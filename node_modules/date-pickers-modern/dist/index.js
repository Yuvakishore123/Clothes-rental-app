'use strict';

var React$4 = require('react');
var require$$0 = require('@babel/runtime/helpers/interopRequireDefault');
var _extends = require('@babel/runtime/helpers/esm/extends');
var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/esm/objectWithoutPropertiesLoose');
require('@babel/runtime/helpers/extends');
var jsxRuntime = require('react/jsx-runtime');
var _assertThisInitialized$w = require('@babel/runtime/helpers/esm/assertThisInitialized');
var _inheritsLoose = require('@babel/runtime/helpers/esm/inheritsLoose');
var ReactDOM = require('react-dom');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React$4);
var ReactDOM__namespace = /*#__PURE__*/_interopNamespaceDefault(ReactDOM);

function toInteger$1(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs$1(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

function _typeof$y(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$y = function _typeof(obj) { return typeof obj; }; } else { _typeof$y = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$y(obj); }
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate$1(argument) {
  requiredArgs$1(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || _typeof$y(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} - the new date with the days added
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */

function addDays$1(dirtyDate, dirtyAmount) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var amount = toInteger$1(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  date.setDate(date.getDate() + amount);
  return date;
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds$1(dirtyDate, dirtyAmount) {
  requiredArgs$1(2, arguments);
  var timestamp = toDate$1(dirtyDate).getTime();
  var amount = toInteger$1(dirtyAmount);
  return new Date(timestamp + amount);
}

/**
 * @name addSeconds
 * @category Second Helpers
 * @summary Add the specified number of seconds to the given date.
 *
 * @description
 * Add the specified number of seconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of seconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the seconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 30 seconds to 10 July 2014 12:45:00:
 * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:45:30
 */

function addSeconds$1(dirtyDate, dirtyAmount) {
  requiredArgs$1(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMilliseconds$1(dirtyDate, amount * 1000);
}

var MILLISECONDS_IN_MINUTE$5 = 60000;
/**
 * @name addMinutes
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the minutes added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */

function addMinutes$1(dirtyDate, dirtyAmount) {
  requiredArgs$1(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMilliseconds$1(dirtyDate, amount * MILLISECONDS_IN_MINUTE$5);
}

var MILLISECONDS_IN_HOUR$4 = 3600000;
/**
 * @name addHours
 * @category Hour Helpers
 * @summary Add the specified number of hours to the given date.
 *
 * @description
 * Add the specified number of hours to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of hours to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the hours added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 2 hours to 10 July 2014 23:00:00:
 * const result = addHours(new Date(2014, 6, 10, 23, 0), 2)
 * //=> Fri Jul 11 2014 01:00:00
 */

function addHours$1(dirtyDate, dirtyAmount) {
  requiredArgs$1(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMilliseconds$1(dirtyDate, amount * MILLISECONDS_IN_HOUR$4);
}

/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the weeks added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * const result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */

function addWeeks$1(dirtyDate, dirtyAmount) {
  requiredArgs$1(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  var days = amount * 7;
  return addDays$1(dirtyDate, days);
}

/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */

function addMonths$1(dirtyDate, dirtyAmount) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var amount = toInteger$1(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 months, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for
  // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
  // want except that dates will wrap around the end of a month, meaning that
  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
  // we'll default to the end of the desired month by adding 1 to the desired
  // month and using a date of 0 to back up one day to the end of the desired
  // month.

  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();

  if (dayOfMonth >= daysInMonth) {
    // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
  } else {
    // Otherwise, we now know that setting the original day-of-month value won't
    // cause an overflow, so set the desired day-of-month. Note that we can't
    // just set the date of `endOfDesiredMonth` because that object may have had
    // its time changed in the unusual case where where a DST transition was on
    // the last day of the month and its local time was in the hour skipped or
    // repeated next to a DST transition.  So we use `date` instead which is
    // guaranteed to still have the original time.
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * const result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */

function addYears$1(dirtyDate, dirtyAmount) {
  requiredArgs$1(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMonths$1(dirtyDate, amount * 12);
}

/**
 * @name differenceInCalendarYears
 * @category Year Helpers
 * @summary Get the number of calendar years between the given dates.
 *
 * @description
 * Get the number of calendar years between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar years
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInCalendarYears(
 *   new Date(2015, 1, 11),
 *   new Date(2013, 11, 31)
 * )
 * //=> 2
 */

function differenceInCalendarYears$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}

/**
 * @name compareAsc
 * @category Common Helpers
 * @summary Compare the two dates and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return 1 if the first date is after the second,
 * -1 if the first date is before the second or 0 if dates are equal.
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Number} the result of the comparison
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989:
 * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> -1
 *
 * @example
 * // Sort the array of dates:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareAsc)
 * //=> [
 * //   Wed Feb 11 1987 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Sun Jul 02 1995 00:00:00
 * // ]
 */

function compareAsc$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1; // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}

/**
 * @name differenceInYears
 * @category Year Helpers
 * @summary Get the number of full years between the given dates.
 *
 * @description
 * Get the number of full years between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full years
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
 * //=> 1
 */

function differenceInYears$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  var sign = compareAsc$1(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarYears$1(dateLeft, dateRight)); // Set both dates to a valid leap year for accurate comparison when dealing
  // with leap days

  dateLeft.setFullYear(1584);
  dateRight.setFullYear(1584); // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
  // If so, result must be decreased by 1 in absolute value

  var isLastYearNotFull = compareAsc$1(dateLeft, dateRight) === -sign;
  var result = sign * (difference - Number(isLastYearNotFull)); // Prevent negative zero

  return result === 0 ? 0 : result;
}

/**
 * @name differenceInCalendarMonths
 * @category Month Helpers
 * @summary Get the number of calendar months between the given dates.
 *
 * @description
 * Get the number of calendar months between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar months
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInCalendarMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 8
 */

function differenceInCalendarMonths$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}

/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */

function endOfDay$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */

function endOfMonth$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name isLastDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the last day of a month?
 *
 * @description
 * Is the given date the last day of a month?
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is the last day of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 28 February 2014 the last day of a month?
 * const result = isLastDayOfMonth(new Date(2014, 1, 28))
 * //=> true
 */

function isLastDayOfMonth(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  return endOfDay$1(date).getTime() === endOfMonth$1(date).getTime();
}

/**
 * @name differenceInMonths
 * @category Month Helpers
 * @summary Get the number of full months between the given dates.
 *
 * @description
 * Get the number of full months between the given dates using trunc as a default rounding method.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full months
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
 * //=> 7
 */

function differenceInMonths$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  var sign = compareAsc$1(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths$1(dateLeft, dateRight));
  var result; // Check for the difference of less than month

  if (difference < 1) {
    result = 0;
  } else {
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      // This will check if the date is end of Feb and assign a higher end of month date
      // to compare it with Jan
      dateLeft.setDate(30);
    }

    dateLeft.setMonth(dateLeft.getMonth() - sign * difference); // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
    // If so, result must be decreased by 1 in absolute value

    var isLastMonthNotFull = compareAsc$1(dateLeft, dateRight) === -sign; // Check for cases of one full calendar month

    if (isLastDayOfMonth(toDate$1(dirtyDateLeft)) && difference === 1 && compareAsc$1(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }

    result = sign * (difference - Number(isLastMonthNotFull));
  } // Prevent negative zero


  return result === 0 ? 0 : result;
}

var roundingMap = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function trunc(value) {
    return value < 0 ? Math.ceil(value) : Math.floor(value);
  } // Math.trunc is not supported by IE

};
var defaultRoundingMethod = 'trunc';
function getRoundingMethod(method) {
  return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
}

/**
 * @name differenceInQuarters
 * @category Quarter Helpers
 * @summary Get the number of quarters between the given dates.
 *
 * @description
 * Get the number of quarters between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of full quarters
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full quarters are between 31 December 2013 and 2 July 2014?
 * const result = differenceInQuarters(new Date(2014, 6, 2), new Date(2013, 11, 31))
 * //=> 2
 */

function differenceInQuarters$1(dateLeft, dateRight, options) {
  requiredArgs$1(2, arguments);
  var diff = differenceInMonths$1(dateLeft, dateRight) / 3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds$1(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

var MILLISECONDS_IN_DAY$3 = 86400000;
/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar days
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */

function differenceInCalendarDays$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var startOfDayLeft = startOfDay$1(dirtyDateLeft);
  var startOfDayRight = startOfDay$1(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds$1(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds$1(startOfDayRight); // Round the number of days to the nearest integer
  // because the number of milliseconds in a day is not constant
  // (e.g. it's different in the day of the daylight saving time clock shift)

  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$3);
}

// for accurate equality comparisons of UTC timestamps that end up
// having the same representation in local time, e.g. one hour before
// DST ends vs. the instant that DST ends.

function compareLocalAsc$1(dateLeft, dateRight) {
  var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1; // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}
/**
 * @name differenceInDays
 * @category Day Helpers
 * @summary Get the number of full days between the given dates.
 *
 * @description
 * Get the number of full day periods between two dates. Fractional days are
 * truncated towards zero.
 *
 * One "full day" is the distance between a local time in one day to the same
 * local time on the next or previous day. A full day can sometimes be less than
 * or more than 24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
 *
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full days according to the local timezone
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 365
 * // How many full days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 0
 * // How many full days are between
 * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 92 days, even in
 * // time zones where DST starts and the
 * // period has only 92*24-1 hours.
 * const result = differenceInDays(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 1)
 * )
//=> 92
 */


function differenceInDays$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  var sign = compareLocalAsc$1(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays$1(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign * difference); // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
  // If so, result must be decreased by 1 in absolute value

  var isLastDayNotFull = Number(compareLocalAsc$1(dateLeft, dateRight) === -sign);
  var result = sign * (difference - isLastDayNotFull); // Prevent negative zero

  return result === 0 ? 0 : result;
}

/**
 * @name differenceInWeeks
 * @category Week Helpers
 * @summary Get the number of full weeks between the given dates.
 *
 * @description
 * Get the number of full weeks between two dates. Fractional weeks are
 * truncated towards zero by default.
 *
 * One "full week" is the distance between a local time in one day to the same
 * local time 7 days earlier or later. A full week can sometimes be less than
 * or more than 7*24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 7*24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
 *
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of full weeks
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
 * //=> 2
 *
 * // How many full weeks are between
 * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 8 weeks (54 days),
 * // even if DST starts and the period has
 * // only 54*24-1 hours.
 * const result = differenceInWeeks(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 6)
 * )
 * //=> 8
 */

function differenceInWeeks$1(dateLeft, dateRight, options) {
  requiredArgs$1(2, arguments);
  var diff = differenceInDays$1(dateLeft, dateRight) / 7;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}

/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInMinute = 60000;
/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInHour = 3600000;
/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInSecond = 1000;

/**
 * @name differenceInMilliseconds
 * @category Millisecond Helpers
 * @summary Get the number of milliseconds between the given dates.
 *
 * @description
 * Get the number of milliseconds between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of milliseconds
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many milliseconds are between
 * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
 * const result = differenceInMilliseconds(
 *   new Date(2014, 6, 2, 12, 30, 21, 700),
 *   new Date(2014, 6, 2, 12, 30, 20, 600)
 * )
 * //=> 1100
 */

function differenceInMilliseconds$1(dateLeft, dateRight) {
  requiredArgs$1(2, arguments);
  return toDate$1(dateLeft).getTime() - toDate$1(dateRight).getTime();
}

/**
 * @name differenceInHours
 * @category Hour Helpers
 * @summary Get the number of hours between the given dates.
 *
 * @description
 * Get the number of hours between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of hours
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?
 * const result = differenceInHours(
 *   new Date(2014, 6, 2, 19, 0),
 *   new Date(2014, 6, 2, 6, 50)
 * )
 * //=> 12
 */

function differenceInHours$1(dateLeft, dateRight, options) {
  requiredArgs$1(2, arguments);
  var diff = differenceInMilliseconds$1(dateLeft, dateRight) / millisecondsInHour;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}

/**
 * @name differenceInMinutes
 * @category Minute Helpers
 * @summary Get the number of minutes between the given dates.
 *
 * @description
 * Get the signed number of full (rounded towards 0) minutes between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of minutes
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
 * const result = differenceInMinutes(
 *   new Date(2014, 6, 2, 12, 20, 0),
 *   new Date(2014, 6, 2, 12, 7, 59)
 * )
 * //=> 12
 *
 * @example
 * // How many minutes are between 10:01:59 and 10:00:00
 * const result = differenceInMinutes(
 *   new Date(2000, 0, 1, 10, 0, 0),
 *   new Date(2000, 0, 1, 10, 1, 59)
 * )
 * //=> -1
 */

function differenceInMinutes$1(dateLeft, dateRight, options) {
  requiredArgs$1(2, arguments);
  var diff = differenceInMilliseconds$1(dateLeft, dateRight) / millisecondsInMinute;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}

/**
 * @name differenceInSeconds
 * @category Second Helpers
 * @summary Get the number of seconds between the given dates.
 *
 * @description
 * Get the number of seconds between the given dates.
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @param {Object} [options] - an object with options.
 * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
 * @returns {Number} the number of seconds
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many seconds are between
 * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
 * const result = differenceInSeconds(
 *   new Date(2014, 6, 2, 12, 30, 20, 0),
 *   new Date(2014, 6, 2, 12, 30, 7, 999)
 * )
 * //=> 12
 */

function differenceInSeconds$1(dateLeft, dateRight, options) {
  requiredArgs$1(2, arguments);
  var diff = differenceInMilliseconds$1(dateLeft, dateRight) / 1000;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}

/**
 * @name eachDayOfInterval
 * @category Interval Helpers
 * @summary Return the array of dates within the specified time interval.
 *
 * @description
 * Return the array of dates within the specified time interval.
 *
 * @param {Interval} interval - the interval. See [Interval]{@link https://date-fns.org/docs/Interval}
 * @param {Object} [options] - an object with options.
 * @param {Number} [options.step=1] - the step to increment by. The value should be more than 1.
 * @returns {Date[]} the array with starts of days from the day of the interval start to the day of the interval end
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.step` must be a number greater than 1
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Each day between 6 October 2014 and 10 October 2014:
 * const result = eachDayOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 9, 10)
 * })
 * //=> [
 * //   Mon Oct 06 2014 00:00:00,
 * //   Tue Oct 07 2014 00:00:00,
 * //   Wed Oct 08 2014 00:00:00,
 * //   Thu Oct 09 2014 00:00:00,
 * //   Fri Oct 10 2014 00:00:00
 * // ]
 */

function eachDayOfInterval$1(dirtyInterval, options) {
  var _options$step;

  requiredArgs$1(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate$1(interval.start);
  var endDate = toDate$1(interval.end);
  var endTime = endDate.getTime(); // Throw an exception if start date is after end date or if any date is `Invalid Date`

  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError('Invalid interval');
  }

  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step)) throw new RangeError('`options.step` must be a number greater than 1');

  while (currentDate.getTime() <= endTime) {
    dates.push(toDate$1(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }

  return dates;
}

var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

/**
 * @name endOfWeek
 * @category Week Helpers
 * @summary Return the end of a week for the given date.
 *
 * @description
 * Return the end of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the end of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The end of a week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 23:59:59.999
 *
 * @example
 * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 23:59:59.999
 */
function endOfWeek$1(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs$1(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate$1(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name endOfYear
 * @category Year Helpers
 * @summary Return the end of a year for the given date.
 *
 * @description
 * Return the end of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a year for 2 September 2014 11:55:00:
 * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 23:59:59.999
 */

function endOfYear$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

function _typeof$x(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$x = function _typeof(obj) { return typeof obj; }; } else { _typeof$x = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$x(obj); }
/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate$1(value) {
  requiredArgs$1(1, arguments);
  return value instanceof Date || _typeof$x(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid$1(dirtyDate) {
  requiredArgs$1(1, arguments);

  if (!isDate$1(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = toDate$1(dirtyDate);
  return !isNaN(Number(date));
}

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds$1(dirtyDate, dirtyAmount) {
  requiredArgs$1(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMilliseconds$1(dirtyDate, -amount);
}

var MILLISECONDS_IN_DAY$2 = 86400000;
function getUTCDayOfYear$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY$2) + 1;
}

function startOfUTCISOWeek$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var weekStartsOn = 1;
  var date = toDate$1(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCISOWeekYear$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek$1(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek$1(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCISOWeekYear$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var year = getUTCISOWeekYear$1(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek$1(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$5 = 604800000;
function getUTCISOWeek$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var diff = startOfUTCISOWeek$1(date).getTime() - startOfUTCISOWeekYear$1(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$5) + 1;
}

function startOfUTCWeek$1(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs$1(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate$1(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCWeekYear$1(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek$1(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek$1(firstWeekOfThisYear, options);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCWeekYear$1(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs$1(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear$1(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek$1(firstWeek, options);
  return date;
}

var MILLISECONDS_IN_WEEK$4 = 604800000;
function getUTCWeek$1(dirtyDate, options) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var diff = startOfUTCWeek$1(date, options).getTime() - startOfUTCWeekYear$1(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$4) + 1;
}

function addLeadingZeros$1(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters$5 = {
  // Year
  y: function y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros$1(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : addLeadingZeros$1(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros$1(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros$1(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros$1(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros$1(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros$1(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros$1(fractionalSeconds, token.length);
  }
};
var lightFormatters$1 = formatters$5;

var dayPeriodEnum$1 = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */
var formatters$3 = {
  // Era
  G: function G(date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function y(date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return lightFormatters$1.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear$1(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros$1(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return addLeadingZeros$1(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear$1(date); // Padding

    return addLeadingZeros$1(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros$1(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return addLeadingZeros$1(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return addLeadingZeros$1(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function M(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return lightFormatters$1.M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return addLeadingZeros$1(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize, options) {
    var week = getUTCWeek$1(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return addLeadingZeros$1(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize) {
    var isoWeek = getUTCISOWeek$1(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return addLeadingZeros$1(isoWeek, token.length);
  },
  // Day of the month
  d: function d(date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return lightFormatters$1.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize) {
    var dayOfYear = getUTCDayOfYear$1(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return addLeadingZeros$1(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return addLeadingZeros$1(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return addLeadingZeros$1(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return addLeadingZeros$1(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function a(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum$1.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum$1.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum$1.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum$1.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum$1.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum$1.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function h(date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return lightFormatters$1.h(date, token);
  },
  // Hour [0-23]
  H: function H(date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return lightFormatters$1.H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros$1(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros$1(hours, token.length);
  },
  // Minute
  m: function m(date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return lightFormatters$1.m(date, token);
  },
  // Second
  s: function s(date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return lightFormatters$1.s(date, token);
  },
  // Fraction of second
  S: function S(date, token) {
    return lightFormatters$1.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone$1(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone$1(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes$1(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone$1(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone$1(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort$1(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone$1(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort$1(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone$1(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return addLeadingZeros$1(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros$1(timestamp, token.length);
  }
};

function formatTimezoneShort$1(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + addLeadingZeros$1(minutes, 2);
}

function formatTimezoneWithOptionalMinutes$1(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + addLeadingZeros$1(Math.abs(offset) / 60, 2);
  }

  return formatTimezone$1(offset, dirtyDelimiter);
}

function formatTimezone$1(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros$1(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros$1(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

var formatters$4 = formatters$3;

var dateLongFormatter$1 = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};

var timeLongFormatter$1 = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};

var dateTimeLongFormatter$1 = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter$1(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter$1(datePattern, formatLong)).replace('{{time}}', timeLongFormatter$1(timePattern, formatLong));
};

var longFormatters$6 = {
  p: timeLongFormatter$1,
  P: dateTimeLongFormatter$1
};
var longFormatters$7 = longFormatters$6;

var protectedDayOfYearTokens$1 = ['D', 'DD'];
var protectedWeekYearTokens$1 = ['YY', 'YYYY'];
function isProtectedDayOfYearToken$1(token) {
  return protectedDayOfYearTokens$1.indexOf(token) !== -1;
}
function isProtectedWeekYearToken$1(token) {
  return protectedWeekYearTokens$1.indexOf(token) !== -1;
}
function throwProtectedError$1(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

var formatDistanceLocale$2 = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance$2 = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale$2[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

var formatDistance$3 = formatDistance$2;

function buildFormatLongFn$1(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats$2 = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats$2 = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats$2 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong$4 = {
  date: buildFormatLongFn$1({
    formats: dateFormats$2,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn$1({
    formats: timeFormats$2,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn$1({
    formats: dateTimeFormats$2,
    defaultWidth: 'full'
  })
};
var formatLong$5 = formatLong$4;

var formatRelativeLocale$2 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative$2 = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale$2[token];
};

var formatRelative$3 = formatRelative$2;

function buildLocalizeFn$1(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

var eraValues$2 = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues$2 = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues$2 = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues$2 = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues$2 = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues$2 = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber$2 = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize$4 = {
  ordinalNumber: ordinalNumber$2,
  era: buildLocalizeFn$1({
    values: eraValues$2,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn$1({
    values: quarterValues$2,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn$1({
    values: monthValues$2,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn$1({
    values: dayValues$2,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn$1({
    values: dayPeriodValues$2,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues$2,
    defaultFormattingWidth: 'wide'
  })
};
var localize$5 = localize$4;

function buildMatchFn$1(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex$1(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey$1(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey$1(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex$1(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

function buildMatchPatternFn$1(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

var matchOrdinalNumberPattern$2 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern$2 = /\d+/i;
var matchEraPatterns$2 = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns$2 = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns$2 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns$2 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns$2 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns$2 = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns$2 = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns$2 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns$2 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns$2 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match$6 = {
  ordinalNumber: buildMatchPatternFn$1({
    matchPattern: matchOrdinalNumberPattern$2,
    parsePattern: parseOrdinalNumberPattern$2,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn$1({
    matchPatterns: matchEraPatterns$2,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns$2,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn$1({
    matchPatterns: matchQuarterPatterns$2,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns$2,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn$1({
    matchPatterns: matchMonthPatterns$2,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns$2,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn$1({
    matchPatterns: matchDayPatterns$2,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns$2,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn$1({
    matchPatterns: matchDayPeriodPatterns$2,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns$2,
    defaultParseWidth: 'any'
  })
};
var match$7 = match$6;

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale$2 = {
  code: 'en-US',
  formatDistance: formatDistance$3,
  formatLong: formatLong$5,
  formatRelative: formatRelative$3,
  localize: localize$5,
  match: match$7,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
var defaultLocale$3 = locale$2;

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp$3 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp$3 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$3 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$3 = /''/g;
var unescapedLatinCharacterRegExp$3 = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format$2(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

  requiredArgs$1(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions = getDefaultOptions();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$3;
  var firstWeekContainsDate = toInteger$1((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var weekStartsOn = toInteger$1((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = toDate$1(dirtyDate);

  if (!isValid$1(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = getTimezoneOffsetInMilliseconds$1(originalDate);
  var utcDate = subMilliseconds$1(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$3).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$7[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }

    return substring;
  }).join('').match(formattingTokensRegExp$3).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString$3(substring);
    }

    var formatter = formatters$4[firstCharacter];

    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(substring)) {
        throwProtectedError$1(substring, dirtyFormatStr, String(dirtyDate));
      }

      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(substring)) {
        throwProtectedError$1(substring, dirtyFormatStr, String(dirtyDate));
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp$3)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString$3(input) {
  var matched = input.match(escapedStringRegExp$3);

  if (!matched) {
    return input;
  }

  return matched[1].replace(doubleQuoteRegExp$3, "'");
}

/**
 * @name getDate
 * @category Day Helpers
 * @summary Get the day of the month of the given date.
 *
 * @description
 * Get the day of the month of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the day of month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the month is 29 February 2012?
 * const result = getDate(new Date(2012, 1, 29))
 * //=> 29
 */

function getDate$2(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}

/**
 * @name getDay
 * @category Weekday Helpers
 * @summary Get the day of the week of the given date.
 *
 * @description
 * Get the day of the week of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {0|1|2|3|4|5|6} the day of week, 0 represents Sunday
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the week is 29 February 2012?
 * const result = getDay(new Date(2012, 1, 29))
 * //=> 3
 */

function getDay$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var day = date.getDay();
  return day;
}

/**
 * @name getDaysInMonth
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the number of days in a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // How many days are in February 2000?
 * const result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */

function getDaysInMonth$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}

/**
 * @name getHours
 * @category Hour Helpers
 * @summary Get the hours of the given date.
 *
 * @description
 * Get the hours of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the hours
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the hours of 29 February 2012 11:45:00:
 * const result = getHours(new Date(2012, 1, 29, 11, 45))
 * //=> 11
 */

function getHours$2(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var hours = date.getHours();
  return hours;
}

/**
 * @name getMinutes
 * @category Minute Helpers
 * @summary Get the minutes of the given date.
 *
 * @description
 * Get the minutes of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the minutes
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the minutes of 29 February 2012 11:45:05:
 * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 45
 */

function getMinutes$2(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}

/**
 * @name getMonth
 * @category Month Helpers
 * @summary Get the month of the given date.
 *
 * @description
 * Get the month of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which month is 29 February 2012?
 * const result = getMonth(new Date(2012, 1, 29))
 * //=> 1
 */

function getMonth$2(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var month = date.getMonth();
  return month;
}

/**
 * @name getSeconds
 * @category Second Helpers
 * @summary Get the seconds of the given date.
 *
 * @description
 * Get the seconds of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the seconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the seconds of 29 February 2012 11:45:05.123:
 * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 5
 */

function getSeconds$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}

/**
 * @name getYear
 * @category Year Helpers
 * @summary Get the year of the given date.
 *
 * @description
 * Get the year of the given date.
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which year is 2 July 2014?
 * const result = getYear(new Date(2014, 6, 2))
 * //=> 2014
 */

function getYear$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  return toDate$1(dirtyDate).getFullYear();
}

/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @param {Date|Number} date - the date that should be after the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is after the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */

function isAfter$1(dirtyDate, dirtyDateToCompare) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var dateToCompare = toDate$1(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}

/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @param {Date|Number} date - the date that should be before the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */

function isBefore$1(dirtyDate, dirtyDateToCompare) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var dateToCompare = toDate$1(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

/**
 * @name isEqual
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Boolean} the dates are equal
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * const result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0),
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */

function isEqual$1(dirtyLeftDate, dirtyRightDate) {
  requiredArgs$1(2, arguments);
  var dateLeft = toDate$1(dirtyLeftDate);
  var dateRight = toDate$1(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}

/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day (and year and month)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */

function isSameDay$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeftStartOfDay = startOfDay$1(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay$1(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

/**
 * @name isSameYear
 * @category Year Helpers
 * @summary Are the given dates in the same year?
 *
 * @description
 * Are the given dates in the same year?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same year
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same year?
 * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 */

function isSameYear$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}

/**
 * @name isSameMonth
 * @category Month Helpers
 * @summary Are the given dates in the same month (and year)?
 *
 * @description
 * Are the given dates in the same month (and year)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same month (and year)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 *
 * @example
 * // Are 2 September 2014 and 25 September 2015 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
 * //=> false
 */

function isSameMonth$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}

/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of an hour
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */

function startOfHour$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  date.setMinutes(0, 0, 0);
  return date;
}

/**
 * @name isSameHour
 * @category Hour Helpers
 * @summary Are the given dates in the same hour (and same day)?
 *
 * @description
 * Are the given dates in the same hour (and same day)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same hour (and same day)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 4 September 06:30:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 6, 30))
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 5 September 06:00:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 5, 6, 0))
 * //=> false
 */

function isSameHour$1(dirtyDateLeft, dirtyDateRight) {
  requiredArgs$1(2, arguments);
  var dateLeftStartOfHour = startOfHour$1(dirtyDateLeft);
  var dateRightStartOfHour = startOfHour$1(dirtyDateRight);
  return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
}

function assign$2(target, object) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }

  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }

  return target;
}

function _typeof$w(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$w = function _typeof(obj) { return typeof obj; }; } else { _typeof$w = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$w(obj); }

function _inherits$v(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$v(subClass, superClass); }

function _setPrototypeOf$v(o, p) { _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$v(o, p); }

function _createSuper$v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$v(); return function _createSuperInternal() { var Super = _getPrototypeOf$v(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$v(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$v(this, result); }; }

function _possibleConstructorReturn$v(self, call) { if (call && (_typeof$w(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$v(self); }

function _assertThisInitialized$v(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$v(o) { _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$v(o); }

function _classCallCheck$w(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$w(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$w(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$w(Constructor.prototype, protoProps); if (staticProps) _defineProperties$w(Constructor, staticProps); return Constructor; }

function _defineProperty$v(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TIMEZONE_UNIT_PRIORITY$1 = 10;
var Setter = /*#__PURE__*/function () {
  function Setter() {
    _classCallCheck$w(this, Setter);

    _defineProperty$v(this, "subPriority", 0);
  }

  _createClass$w(Setter, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);

  return Setter;
}();
var ValueSetter = /*#__PURE__*/function (_Setter) {
  _inherits$v(ValueSetter, _Setter);

  var _super = _createSuper$v(ValueSetter);

  function ValueSetter(value, validateValue, setValue, priority, subPriority) {
    var _this;

    _classCallCheck$w(this, ValueSetter);

    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;

    if (subPriority) {
      _this.subPriority = subPriority;
    }

    return _this;
  }

  _createClass$w(ValueSetter, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);

  return ValueSetter;
}(Setter);
var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
  _inherits$v(DateToSystemTimezoneSetter, _Setter2);

  var _super2 = _createSuper$v(DateToSystemTimezoneSetter);

  function DateToSystemTimezoneSetter() {
    var _this2;

    _classCallCheck$w(this, DateToSystemTimezoneSetter);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));

    _defineProperty$v(_assertThisInitialized$v(_this2), "priority", TIMEZONE_UNIT_PRIORITY$1);

    _defineProperty$v(_assertThisInitialized$v(_this2), "subPriority", -1);

    return _this2;
  }

  _createClass$w(DateToSystemTimezoneSetter, [{
    key: "set",
    value: function set(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }

      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);

  return DateToSystemTimezoneSetter;
}(Setter);

function _classCallCheck$v(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$v(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$v(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$v(Constructor.prototype, protoProps); if (staticProps) _defineProperties$v(Constructor, staticProps); return Constructor; }
var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck$v(this, Parser);
  }

  _createClass$v(Parser, [{
    key: "run",
    value: function run(dateString, token, match, options) {
      var result = this.parse(dateString, token, match, options);

      if (!result) {
        return null;
      }

      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);

  return Parser;
}();

function _typeof$v(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$v = function _typeof(obj) { return typeof obj; }; } else { _typeof$v = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$v(obj); }

function _classCallCheck$u(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$u(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$u(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$u(Constructor.prototype, protoProps); if (staticProps) _defineProperties$u(Constructor, staticProps); return Constructor; }

function _inherits$u(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$u(subClass, superClass); }

function _setPrototypeOf$u(o, p) { _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$u(o, p); }

function _createSuper$u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$u(); return function _createSuperInternal() { var Super = _getPrototypeOf$u(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$u(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$u(this, result); }; }

function _possibleConstructorReturn$u(self, call) { if (call && (_typeof$v(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$u(self); }

function _assertThisInitialized$u(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$u(o) { _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$u(o); }

function _defineProperty$u(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var EraParser = /*#__PURE__*/function (_Parser) {
  _inherits$u(EraParser, _Parser);

  var _super = _createSuper$u(EraParser);

  function EraParser() {
    var _this;

    _classCallCheck$u(this, EraParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$u(_assertThisInitialized$u(_this), "priority", 140);

    _defineProperty$u(_assertThisInitialized$u(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);

    return _this;
  }

  _createClass$u(EraParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
        // A, B

        case 'GGGGG':
          return match.era(dateString, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return match.era(dateString, {
            width: 'wide'
          }) || match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return EraParser;
}(Parser);

var numericPatterns$1 = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

};
var timezonePatterns$1 = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }

  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern$1(pattern, dateString) {
  var matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern$1(pattern, dateString) {
  var matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  } // Input is 'Z'


  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }

  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned$1(dateString) {
  return parseNumericPattern$1(numericPatterns$1.anyDigitsSigned, dateString);
}
function parseNDigits$1(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern$1(numericPatterns$1.singleDigit, dateString);

    case 2:
      return parseNumericPattern$1(numericPatterns$1.twoDigits, dateString);

    case 3:
      return parseNumericPattern$1(numericPatterns$1.threeDigits, dateString);

    case 4:
      return parseNumericPattern$1(numericPatterns$1.fourDigits, dateString);

    default:
      return parseNumericPattern$1(new RegExp('^\\d{1,' + n + '}'), dateString);
  }
}
function parseNDigitsSigned$1(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern$1(numericPatterns$1.singleDigitSigned, dateString);

    case 2:
      return parseNumericPattern$1(numericPatterns$1.twoDigitsSigned, dateString);

    case 3:
      return parseNumericPattern$1(numericPatterns$1.threeDigitsSigned, dateString);

    case 4:
      return parseNumericPattern$1(numericPatterns$1.fourDigitsSigned, dateString);

    default:
      return parseNumericPattern$1(new RegExp('^-?\\d{1,' + n + '}'), dateString);
  }
}
function dayPeriodEnumToHours$1(dayPeriod) {
  switch (dayPeriod) {
    case 'morning':
      return 4;

    case 'evening':
      return 17;

    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;

    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}
function normalizeTwoDigitYear$1(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0; // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC

  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;

  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex$3(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

function _typeof$u(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$u = function _typeof(obj) { return typeof obj; }; } else { _typeof$u = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$u(obj); }

function _classCallCheck$t(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$t(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$t(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$t(Constructor.prototype, protoProps); if (staticProps) _defineProperties$t(Constructor, staticProps); return Constructor; }

function _inherits$t(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$t(subClass, superClass); }

function _setPrototypeOf$t(o, p) { _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$t(o, p); }

function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = _getPrototypeOf$t(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$t(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$t(this, result); }; }

function _possibleConstructorReturn$t(self, call) { if (call && (_typeof$u(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$t(self); }

function _assertThisInitialized$t(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$t(o) { _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$t(o); }

function _defineProperty$t(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
var YearParser = /*#__PURE__*/function (_Parser) {
  _inherits$t(YearParser, _Parser);

  var _super = _createSuper$t(YearParser);

  function YearParser() {
    var _this;

    _classCallCheck$t(this, YearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$t(_assertThisInitialized$t(_this), "priority", 130);

    _defineProperty$t(_assertThisInitialized$t(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$t(YearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };

      switch (token) {
        case 'y':
          return mapValue(parseNDigits$1(4, dateString), valueCallback);

        case 'yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);

        default:
          return mapValue(parseNDigits$1(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      var currentYear = date.getUTCFullYear();

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear$1(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return YearParser;
}(Parser);

function _typeof$t(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$t = function _typeof(obj) { return typeof obj; }; } else { _typeof$t = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$t(obj); }

function _classCallCheck$s(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$s(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$s(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$s(Constructor.prototype, protoProps); if (staticProps) _defineProperties$s(Constructor, staticProps); return Constructor; }

function _inherits$s(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$s(subClass, superClass); }

function _setPrototypeOf$s(o, p) { _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$s(o, p); }

function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf$s(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$s(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$s(this, result); }; }

function _possibleConstructorReturn$s(self, call) { if (call && (_typeof$t(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$s(self); }

function _assertThisInitialized$s(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$s(o) { _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$s(o); }

function _defineProperty$s(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// Local week-numbering year
var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$s(LocalWeekYearParser, _Parser);

  var _super = _createSuper$s(LocalWeekYearParser);

  function LocalWeekYearParser() {
    var _this;

    _classCallCheck$s(this, LocalWeekYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$s(_assertThisInitialized$s(_this), "priority", 130);

    _defineProperty$s(_assertThisInitialized$s(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);

    return _this;
  }

  _createClass$s(LocalWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };

      switch (token) {
        case 'Y':
          return mapValue(parseNDigits$1(4, dateString), valueCallback);

        case 'Yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);

        default:
          return mapValue(parseNDigits$1(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value, options) {
      var currentYear = getUTCWeekYear$1(date, options);

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear$1(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek$1(date, options);
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek$1(date, options);
    }
  }]);

  return LocalWeekYearParser;
}(Parser);

function _typeof$s(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$s = function _typeof(obj) { return typeof obj; }; } else { _typeof$s = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$s(obj); }

function _classCallCheck$r(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$r(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$r(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$r(Constructor.prototype, protoProps); if (staticProps) _defineProperties$r(Constructor, staticProps); return Constructor; }

function _inherits$r(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$r(subClass, superClass); }

function _setPrototypeOf$r(o, p) { _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$r(o, p); }

function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf$r(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$r(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$r(this, result); }; }

function _possibleConstructorReturn$r(self, call) { if (call && (_typeof$s(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$r(self); }

function _assertThisInitialized$r(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$r(o) { _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$r(o); }

function _defineProperty$r(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$r(ISOWeekYearParser, _Parser);

  var _super = _createSuper$r(ISOWeekYearParser);

  function ISOWeekYearParser() {
    var _this;

    _classCallCheck$r(this, ISOWeekYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$r(_assertThisInitialized$r(_this), "priority", 130);

    _defineProperty$r(_assertThisInitialized$r(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$r(ISOWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'R') {
        return parseNDigitsSigned$1(4, dateString);
      }

      return parseNDigitsSigned$1(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek$1(firstWeekOfYear);
    }
  }]);

  return ISOWeekYearParser;
}(Parser);

function _typeof$r(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$r = function _typeof(obj) { return typeof obj; }; } else { _typeof$r = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$r(obj); }

function _classCallCheck$q(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$q(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$q(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$q(Constructor.prototype, protoProps); if (staticProps) _defineProperties$q(Constructor, staticProps); return Constructor; }

function _inherits$q(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$q(subClass, superClass); }

function _setPrototypeOf$q(o, p) { _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$q(o, p); }

function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf$q(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$q(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$q(this, result); }; }

function _possibleConstructorReturn$q(self, call) { if (call && (_typeof$r(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$q(self); }

function _assertThisInitialized$q(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$q(o) { _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$q(o); }

function _defineProperty$q(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$q(ExtendedYearParser, _Parser);

  var _super = _createSuper$q(ExtendedYearParser);

  function ExtendedYearParser() {
    var _this;

    _classCallCheck$q(this, ExtendedYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$q(_assertThisInitialized$q(_this), "priority", 130);

    _defineProperty$q(_assertThisInitialized$q(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$q(ExtendedYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'u') {
        return parseNDigitsSigned$1(4, dateString);
      }

      return parseNDigitsSigned$1(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return ExtendedYearParser;
}(Parser);

function _typeof$q(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$q = function _typeof(obj) { return typeof obj; }; } else { _typeof$q = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$q(obj); }

function _classCallCheck$p(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$p(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$p(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$p(Constructor.prototype, protoProps); if (staticProps) _defineProperties$p(Constructor, staticProps); return Constructor; }

function _inherits$p(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$p(subClass, superClass); }

function _setPrototypeOf$p(o, p) { _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$p(o, p); }

function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf$p(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$p(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$p(this, result); }; }

function _possibleConstructorReturn$p(self, call) { if (call && (_typeof$q(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$p(self); }

function _assertThisInitialized$p(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$p(o) { _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$p(o); }

function _defineProperty$p(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var QuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits$p(QuarterParser, _Parser);

  var _super = _createSuper$p(QuarterParser);

  function QuarterParser() {
    var _this;

    _classCallCheck$p(this, QuarterParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$p(_assertThisInitialized$p(_this), "priority", 120);

    _defineProperty$p(_assertThisInitialized$p(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$p(QuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits$1(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return QuarterParser;
}(Parser);

function _typeof$p(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$p = function _typeof(obj) { return typeof obj; }; } else { _typeof$p = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$p(obj); }

function _classCallCheck$o(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$o(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$o(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$o(Constructor.prototype, protoProps); if (staticProps) _defineProperties$o(Constructor, staticProps); return Constructor; }

function _inherits$o(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$o(subClass, superClass); }

function _setPrototypeOf$o(o, p) { _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$o(o, p); }

function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf$o(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$o(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$o(this, result); }; }

function _possibleConstructorReturn$o(self, call) { if (call && (_typeof$p(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$o(self); }

function _assertThisInitialized$o(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$o(o) { _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$o(o); }

function _defineProperty$o(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits$o(StandAloneQuarterParser, _Parser);

  var _super = _createSuper$o(StandAloneQuarterParser);

  function StandAloneQuarterParser() {
    var _this;

    _classCallCheck$o(this, StandAloneQuarterParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$o(_assertThisInitialized$o(_this), "priority", 120);

    _defineProperty$o(_assertThisInitialized$o(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$o(StandAloneQuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits$1(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneQuarterParser;
}(Parser);

function _typeof$o(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$o = function _typeof(obj) { return typeof obj; }; } else { _typeof$o = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$o(obj); }

function _classCallCheck$n(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$n(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$n(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$n(Constructor.prototype, protoProps); if (staticProps) _defineProperties$n(Constructor, staticProps); return Constructor; }

function _inherits$n(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$n(subClass, superClass); }

function _setPrototypeOf$n(o, p) { _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$n(o, p); }

function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf$n(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$n(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$n(this, result); }; }

function _possibleConstructorReturn$n(self, call) { if (call && (_typeof$o(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$n(self); }

function _assertThisInitialized$n(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$n(o) { _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$n(o); }

function _defineProperty$n(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var MonthParser = /*#__PURE__*/function (_Parser) {
  _inherits$n(MonthParser, _Parser);

  var _super = _createSuper$n(MonthParser);

  function MonthParser() {
    var _this;

    _classCallCheck$n(this, MonthParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$n(_assertThisInitialized$n(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    _defineProperty$n(_assertThisInitialized$n(_this), "priority", 110);

    return _this;
  }

  _createClass$n(MonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return mapValue(parseNumericPattern$1(numericPatterns$1.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'MM':
          return mapValue(parseNDigits$1(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'MMM':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return MonthParser;
}(Parser);

function _typeof$n(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$n = function _typeof(obj) { return typeof obj; }; } else { _typeof$n = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$n(obj); }

function _classCallCheck$m(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$m(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$m(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$m(Constructor.prototype, protoProps); if (staticProps) _defineProperties$m(Constructor, staticProps); return Constructor; }

function _inherits$m(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$m(subClass, superClass); }

function _setPrototypeOf$m(o, p) { _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$m(o, p); }

function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf$m(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$m(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$m(this, result); }; }

function _possibleConstructorReturn$m(self, call) { if (call && (_typeof$n(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$m(self); }

function _assertThisInitialized$m(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$m(o) { _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$m(o); }

function _defineProperty$m(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
  _inherits$m(StandAloneMonthParser, _Parser);

  var _super = _createSuper$m(StandAloneMonthParser);

  function StandAloneMonthParser() {
    var _this;

    _classCallCheck$m(this, StandAloneMonthParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$m(_assertThisInitialized$m(_this), "priority", 110);

    _defineProperty$m(_assertThisInitialized$m(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$m(StandAloneMonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return mapValue(parseNumericPattern$1(numericPatterns$1.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'LL':
          return mapValue(parseNDigits$1(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'LLL':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneMonthParser;
}(Parser);

function setUTCWeek$1(dirtyDate, dirtyWeek, options) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var week = toInteger$1(dirtyWeek);
  var diff = getUTCWeek$1(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

function _typeof$m(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$m = function _typeof(obj) { return typeof obj; }; } else { _typeof$m = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$m(obj); }

function _classCallCheck$l(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$l(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$l(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$l(Constructor.prototype, protoProps); if (staticProps) _defineProperties$l(Constructor, staticProps); return Constructor; }

function _inherits$l(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$l(subClass, superClass); }

function _setPrototypeOf$l(o, p) { _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$l(o, p); }

function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf$l(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$l(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$l(this, result); }; }

function _possibleConstructorReturn$l(self, call) { if (call && (_typeof$m(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$l(self); }

function _assertThisInitialized$l(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$l(o) { _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$l(o); }

function _defineProperty$l(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LocalWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits$l(LocalWeekParser, _Parser);

  var _super = _createSuper$l(LocalWeekParser);

  function LocalWeekParser() {
    var _this;

    _classCallCheck$l(this, LocalWeekParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$l(_assertThisInitialized$l(_this), "priority", 100);

    _defineProperty$l(_assertThisInitialized$l(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);

    return _this;
  }

  _createClass$l(LocalWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'w':
          return parseNumericPattern$1(numericPatterns$1.week, dateString);

        case 'wo':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      return startOfUTCWeek$1(setUTCWeek$1(date, value, options), options);
    }
  }]);

  return LocalWeekParser;
}(Parser);

function setUTCISOWeek$1(dirtyDate, dirtyISOWeek) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var isoWeek = toInteger$1(dirtyISOWeek);
  var diff = getUTCISOWeek$1(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

function _typeof$l(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$l = function _typeof(obj) { return typeof obj; }; } else { _typeof$l = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$l(obj); }

function _classCallCheck$k(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$k(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$k(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$k(Constructor.prototype, protoProps); if (staticProps) _defineProperties$k(Constructor, staticProps); return Constructor; }

function _inherits$k(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$k(subClass, superClass); }

function _setPrototypeOf$k(o, p) { _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$k(o, p); }

function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf$k(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$k(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$k(this, result); }; }

function _possibleConstructorReturn$k(self, call) { if (call && (_typeof$l(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$k(self); }

function _assertThisInitialized$k(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$k(o) { _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$k(o); }

function _defineProperty$k(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits$k(ISOWeekParser, _Parser);

  var _super = _createSuper$k(ISOWeekParser);

  function ISOWeekParser() {
    var _this;

    _classCallCheck$k(this, ISOWeekParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$k(_assertThisInitialized$k(_this), "priority", 100);

    _defineProperty$k(_assertThisInitialized$k(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$k(ISOWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'I':
          return parseNumericPattern$1(numericPatterns$1.week, dateString);

        case 'Io':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      return startOfUTCISOWeek$1(setUTCISOWeek$1(date, value));
    }
  }]);

  return ISOWeekParser;
}(Parser);

function _typeof$k(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$k = function _typeof(obj) { return typeof obj; }; } else { _typeof$k = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$k(obj); }

function _classCallCheck$j(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$j(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$j(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$j(Constructor.prototype, protoProps); if (staticProps) _defineProperties$j(Constructor, staticProps); return Constructor; }

function _inherits$j(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$j(subClass, superClass); }

function _setPrototypeOf$j(o, p) { _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$j(o, p); }

function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf$j(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$j(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$j(this, result); }; }

function _possibleConstructorReturn$j(self, call) { if (call && (_typeof$k(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$j(self); }

function _assertThisInitialized$j(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$j(o) { _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$j(o); }

function _defineProperty$j(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var DAYS_IN_MONTH$1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR$1 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // Day of the month

var DateParser = /*#__PURE__*/function (_Parser) {
  _inherits$j(DateParser, _Parser);

  var _super = _createSuper$j(DateParser);

  function DateParser() {
    var _this;

    _classCallCheck$j(this, DateParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$j(_assertThisInitialized$j(_this), "priority", 90);

    _defineProperty$j(_assertThisInitialized$j(_this), "subPriority", 1);

    _defineProperty$j(_assertThisInitialized$j(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$j(DateParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'd':
          return parseNumericPattern$1(numericPatterns$1.date, dateString);

        case 'do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$3(year);
      var month = date.getUTCMonth();

      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR$1[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH$1[month];
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DateParser;
}(Parser);

function _typeof$j(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$j = function _typeof(obj) { return typeof obj; }; } else { _typeof$j = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$j(obj); }

function _classCallCheck$i(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$i(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$i(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$i(Constructor.prototype, protoProps); if (staticProps) _defineProperties$i(Constructor, staticProps); return Constructor; }

function _inherits$i(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$i(subClass, superClass); }

function _setPrototypeOf$i(o, p) { _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$i(o, p); }

function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf$i(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$i(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$i(this, result); }; }

function _possibleConstructorReturn$i(self, call) { if (call && (_typeof$j(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$i(self); }

function _assertThisInitialized$i(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$i(o) { _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$i(o); }

function _defineProperty$i(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var DayOfYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$i(DayOfYearParser, _Parser);

  var _super = _createSuper$i(DayOfYearParser);

  function DayOfYearParser() {
    var _this;

    _classCallCheck$i(this, DayOfYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$i(_assertThisInitialized$i(_this), "priority", 90);

    _defineProperty$i(_assertThisInitialized$i(_this), "subpriority", 1);

    _defineProperty$i(_assertThisInitialized$i(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$i(DayOfYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern$1(numericPatterns$1.dayOfYear, dateString);

        case 'Do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$3(year);

      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DayOfYearParser;
}(Parser);

function setUTCDay$1(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs$1(2, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate$1(dirtyDate);
  var day = toInteger$1(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function _typeof$i(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$i = function _typeof(obj) { return typeof obj; }; } else { _typeof$i = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$i(obj); }

function _classCallCheck$h(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$h(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$h(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$h(Constructor.prototype, protoProps); if (staticProps) _defineProperties$h(Constructor, staticProps); return Constructor; }

function _inherits$h(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$h(subClass, superClass); }

function _setPrototypeOf$h(o, p) { _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$h(o, p); }

function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf$h(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$h(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$h(this, result); }; }

function _possibleConstructorReturn$h(self, call) { if (call && (_typeof$i(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$h(self); }

function _assertThisInitialized$h(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$h(o) { _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$h(o); }

function _defineProperty$h(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DayParser = /*#__PURE__*/function (_Parser) {
  _inherits$h(DayParser, _Parser);

  var _super = _createSuper$h(DayParser);

  function DayParser() {
    var _this;

    _classCallCheck$h(this, DayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$h(_assertThisInitialized$h(_this), "priority", 90);

    _defineProperty$h(_assertThisInitialized$h(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$h(DayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay$1(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DayParser;
}(Parser);

function _typeof$h(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$h = function _typeof(obj) { return typeof obj; }; } else { _typeof$h = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$h(obj); }

function _classCallCheck$g(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$g(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$g(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$g(Constructor.prototype, protoProps); if (staticProps) _defineProperties$g(Constructor, staticProps); return Constructor; }

function _inherits$g(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$g(subClass, superClass); }

function _setPrototypeOf$g(o, p) { _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$g(o, p); }

function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf$g(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$g(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$g(this, result); }; }

function _possibleConstructorReturn$g(self, call) { if (call && (_typeof$h(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$g(self); }

function _assertThisInitialized$g(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$g(o) { _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$g(o); }

function _defineProperty$g(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits$g(LocalDayParser, _Parser);

  var _super = _createSuper$g(LocalDayParser);

  function LocalDayParser() {
    var _this;

    _classCallCheck$g(this, LocalDayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$g(_assertThisInitialized$g(_this), "priority", 90);

    _defineProperty$g(_assertThisInitialized$g(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);

    return _this;
  }

  _createClass$g(LocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return mapValue(parseNDigits$1(token.length, dateString), valueCallback);
        // 3rd

        case 'eo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'eee':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay$1(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return LocalDayParser;
}(Parser);

function _typeof$g(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$g = function _typeof(obj) { return typeof obj; }; } else { _typeof$g = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$g(obj); }

function _classCallCheck$f(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$f(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$f(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$f(Constructor.prototype, protoProps); if (staticProps) _defineProperties$f(Constructor, staticProps); return Constructor; }

function _inherits$f(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$f(subClass, superClass); }

function _setPrototypeOf$f(o, p) { _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$f(o, p); }

function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf$f(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$f(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$f(this, result); }; }

function _possibleConstructorReturn$f(self, call) { if (call && (_typeof$g(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$f(self); }

function _assertThisInitialized$f(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$f(o) { _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$f(o); }

function _defineProperty$f(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits$f(StandAloneLocalDayParser, _Parser);

  var _super = _createSuper$f(StandAloneLocalDayParser);

  function StandAloneLocalDayParser() {
    var _this;

    _classCallCheck$f(this, StandAloneLocalDayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$f(_assertThisInitialized$f(_this), "priority", 90);

    _defineProperty$f(_assertThisInitialized$f(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);

    return _this;
  }

  _createClass$f(StandAloneLocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return mapValue(parseNDigits$1(token.length, dateString), valueCallback);
        // 3rd

        case 'co':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'ccc':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay$1(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneLocalDayParser;
}(Parser);

function setUTCISODay$1(dirtyDate, dirtyDay) {
  requiredArgs$1(2, arguments);
  var day = toInteger$1(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = toDate$1(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function _typeof$f(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$f = function _typeof(obj) { return typeof obj; }; } else { _typeof$f = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$f(obj); }

function _classCallCheck$e(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$e(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$e(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$e(Constructor.prototype, protoProps); if (staticProps) _defineProperties$e(Constructor, staticProps); return Constructor; }

function _inherits$e(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$e(subClass, superClass); }

function _setPrototypeOf$e(o, p) { _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$e(o, p); }

function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf$e(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$e(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$e(this, result); }; }

function _possibleConstructorReturn$e(self, call) { if (call && (_typeof$f(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$e(self); }

function _assertThisInitialized$e(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$e(o) { _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$e(o); }

function _defineProperty$e(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISODayParser = /*#__PURE__*/function (_Parser) {
  _inherits$e(ISODayParser, _Parser);

  var _super = _createSuper$e(ISODayParser);

  function ISODayParser() {
    var _this;

    _classCallCheck$e(this, ISODayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$e(_assertThisInitialized$e(_this), "priority", 90);

    _defineProperty$e(_assertThisInitialized$e(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$e(ISODayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        if (value === 0) {
          return 7;
        }

        return value;
      };

      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits$1(token.length, dateString);
        // 2nd

        case 'io':
          return match.ordinalNumber(dateString, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return mapValue(match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // T

        case 'iiiii':
          return mapValue(match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tu

        case 'iiiiii':
          return mapValue(match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tuesday

        case 'iiii':
        default:
          return mapValue(match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date = setUTCISODay$1(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return ISODayParser;
}(Parser);

function _typeof$e(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$e = function _typeof(obj) { return typeof obj; }; } else { _typeof$e = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$e(obj); }

function _classCallCheck$d(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$d(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$d(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$d(Constructor.prototype, protoProps); if (staticProps) _defineProperties$d(Constructor, staticProps); return Constructor; }

function _inherits$d(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$d(subClass, superClass); }

function _setPrototypeOf$d(o, p) { _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$d(o, p); }

function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf$d(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$d(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$d(this, result); }; }

function _possibleConstructorReturn$d(self, call) { if (call && (_typeof$e(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$d(self); }

function _assertThisInitialized$d(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$d(o) { _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$d(o); }

function _defineProperty$d(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var AMPMParser = /*#__PURE__*/function (_Parser) {
  _inherits$d(AMPMParser, _Parser);

  var _super = _createSuper$d(AMPMParser);

  function AMPMParser() {
    var _this;

    _classCallCheck$d(this, AMPMParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$d(_assertThisInitialized$d(_this), "priority", 80);

    _defineProperty$d(_assertThisInitialized$d(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass$d(AMPMParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaaa':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours$1(value), 0, 0, 0);
      return date;
    }
  }]);

  return AMPMParser;
}(Parser);

function _typeof$d(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$d = function _typeof(obj) { return typeof obj; }; } else { _typeof$d = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$d(obj); }

function _classCallCheck$c(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$c(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$c(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$c(Constructor.prototype, protoProps); if (staticProps) _defineProperties$c(Constructor, staticProps); return Constructor; }

function _inherits$c(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$c(subClass, superClass); }

function _setPrototypeOf$c(o, p) { _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$c(o, p); }

function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf$c(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$c(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$c(this, result); }; }

function _possibleConstructorReturn$c(self, call) { if (call && (_typeof$d(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$c(self); }

function _assertThisInitialized$c(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$c(o) { _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$c(o); }

function _defineProperty$c(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
  _inherits$c(AMPMMidnightParser, _Parser);

  var _super = _createSuper$c(AMPMMidnightParser);

  function AMPMMidnightParser() {
    var _this;

    _classCallCheck$c(this, AMPMMidnightParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$c(_assertThisInitialized$c(_this), "priority", 80);

    _defineProperty$c(_assertThisInitialized$c(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass$c(AMPMMidnightParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbbb':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours$1(value), 0, 0, 0);
      return date;
    }
  }]);

  return AMPMMidnightParser;
}(Parser);

function _typeof$c(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$c = function _typeof(obj) { return typeof obj; }; } else { _typeof$c = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$c(obj); }

function _classCallCheck$b(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$b(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$b(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$b(Constructor.prototype, protoProps); if (staticProps) _defineProperties$b(Constructor, staticProps); return Constructor; }

function _inherits$b(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$b(subClass, superClass); }

function _setPrototypeOf$b(o, p) { _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$b(o, p); }

function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf$b(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$b(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$b(this, result); }; }

function _possibleConstructorReturn$b(self, call) { if (call && (_typeof$c(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$b(self); }

function _assertThisInitialized$b(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$b(o) { _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$b(o); }

function _defineProperty$b(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DayPeriodParser = /*#__PURE__*/function (_Parser) {
  _inherits$b(DayPeriodParser, _Parser);

  var _super = _createSuper$b(DayPeriodParser);

  function DayPeriodParser() {
    var _this;

    _classCallCheck$b(this, DayPeriodParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$b(_assertThisInitialized$b(_this), "priority", 80);

    _defineProperty$b(_assertThisInitialized$b(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);

    return _this;
  }

  _createClass$b(DayPeriodParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBBB':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours$1(value), 0, 0, 0);
      return date;
    }
  }]);

  return DayPeriodParser;
}(Parser);

function _typeof$b(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$b = function _typeof(obj) { return typeof obj; }; } else { _typeof$b = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$b(obj); }

function _classCallCheck$a(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$a(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$a(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$a(Constructor.prototype, protoProps); if (staticProps) _defineProperties$a(Constructor, staticProps); return Constructor; }

function _inherits$a(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$a(subClass, superClass); }

function _setPrototypeOf$a(o, p) { _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$a(o, p); }

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf$a(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$a(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$a(this, result); }; }

function _possibleConstructorReturn$a(self, call) { if (call && (_typeof$b(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$a(self); }

function _assertThisInitialized$a(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$a(o) { _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$a(o); }

function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
  _inherits$a(Hour1to12Parser, _Parser);

  var _super = _createSuper$a(Hour1to12Parser);

  function Hour1to12Parser() {
    var _this;

    _classCallCheck$a(this, Hour1to12Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$a(_assertThisInitialized$a(_this), "priority", 70);

    _defineProperty$a(_assertThisInitialized$a(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);

    return _this;
  }

  _createClass$a(Hour1to12Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'h':
          return parseNumericPattern$1(numericPatterns$1.hour12h, dateString);

        case 'ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    }
  }]);

  return Hour1to12Parser;
}(Parser);

function _typeof$a(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$a = function _typeof(obj) { return typeof obj; }; } else { _typeof$a = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$a(obj); }

function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$9(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$9(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$9(Constructor.prototype, protoProps); if (staticProps) _defineProperties$9(Constructor, staticProps); return Constructor; }

function _inherits$9(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$9(subClass, superClass); }

function _setPrototypeOf$9(o, p) { _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$9(o, p); }

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf$9(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$9(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$9(this, result); }; }

function _possibleConstructorReturn$9(self, call) { if (call && (_typeof$a(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$9(self); }

function _assertThisInitialized$9(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$9(o) { _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$9(o); }

function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
  _inherits$9(Hour0to23Parser, _Parser);

  var _super = _createSuper$9(Hour0to23Parser);

  function Hour0to23Parser() {
    var _this;

    _classCallCheck$9(this, Hour0to23Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$9(_assertThisInitialized$9(_this), "priority", 70);

    _defineProperty$9(_assertThisInitialized$9(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);

    return _this;
  }

  _createClass$9(Hour0to23Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'H':
          return parseNumericPattern$1(numericPatterns$1.hour23h, dateString);

        case 'Ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);

  return Hour0to23Parser;
}(Parser);

function _typeof$9(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$9 = function _typeof(obj) { return typeof obj; }; } else { _typeof$9 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$9(obj); }

function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$8(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$8(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$8(Constructor.prototype, protoProps); if (staticProps) _defineProperties$8(Constructor, staticProps); return Constructor; }

function _inherits$8(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$8(subClass, superClass); }

function _setPrototypeOf$8(o, p) { _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$8(o, p); }

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf$8(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$8(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$8(this, result); }; }

function _possibleConstructorReturn$8(self, call) { if (call && (_typeof$9(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$8(self); }

function _assertThisInitialized$8(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$8(o) { _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$8(o); }

function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
  _inherits$8(Hour0To11Parser, _Parser);

  var _super = _createSuper$8(Hour0To11Parser);

  function Hour0To11Parser() {
    var _this;

    _classCallCheck$8(this, Hour0To11Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$8(_assertThisInitialized$8(_this), "priority", 70);

    _defineProperty$8(_assertThisInitialized$8(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass$8(Hour0To11Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'K':
          return parseNumericPattern$1(numericPatterns$1.hour11h, dateString);

        case 'Ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    }
  }]);

  return Hour0To11Parser;
}(Parser);

function _typeof$8(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$8 = function _typeof(obj) { return typeof obj; }; } else { _typeof$8 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$8(obj); }

function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }

function _inherits$7(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$7(subClass, superClass); }

function _setPrototypeOf$7(o, p) { _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$7(o, p); }

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf$7(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$7(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$7(this, result); }; }

function _possibleConstructorReturn$7(self, call) { if (call && (_typeof$8(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$7(self); }

function _assertThisInitialized$7(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$7(o) { _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$7(o); }

function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
  _inherits$7(Hour1To24Parser, _Parser);

  var _super = _createSuper$7(Hour1To24Parser);

  function Hour1To24Parser() {
    var _this;

    _classCallCheck$7(this, Hour1To24Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$7(_assertThisInitialized$7(_this), "priority", 70);

    _defineProperty$7(_assertThisInitialized$7(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);

    return _this;
  }

  _createClass$7(Hour1To24Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'k':
          return parseNumericPattern$1(numericPatterns$1.hour24h, dateString);

        case 'ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);

  return Hour1To24Parser;
}(Parser);

function _typeof$7(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$7 = function _typeof(obj) { return typeof obj; }; } else { _typeof$7 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$7(obj); }

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }

function _inherits$6(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$6(subClass, superClass); }

function _setPrototypeOf$6(o, p) { _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$6(o, p); }

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf$6(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$6(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$6(this, result); }; }

function _possibleConstructorReturn$6(self, call) { if (call && (_typeof$7(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$6(self); }

function _assertThisInitialized$6(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$6(o) { _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$6(o); }

function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var MinuteParser = /*#__PURE__*/function (_Parser) {
  _inherits$6(MinuteParser, _Parser);

  var _super = _createSuper$6(MinuteParser);

  function MinuteParser() {
    var _this;

    _classCallCheck$6(this, MinuteParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$6(_assertThisInitialized$6(_this), "priority", 60);

    _defineProperty$6(_assertThisInitialized$6(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass$6(MinuteParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'm':
          return parseNumericPattern$1(numericPatterns$1.minute, dateString);

        case 'mo':
          return match.ordinalNumber(dateString, {
            unit: 'minute'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);

  return MinuteParser;
}(Parser);

function _typeof$6(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$6 = function _typeof(obj) { return typeof obj; }; } else { _typeof$6 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$6(obj); }

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }

function _inherits$5(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$5(subClass, superClass); }

function _setPrototypeOf$5(o, p) { _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$5(o, p); }

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf$5(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$5(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$5(this, result); }; }

function _possibleConstructorReturn$5(self, call) { if (call && (_typeof$6(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$5(self); }

function _assertThisInitialized$5(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$5(o) { _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$5(o); }

function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var SecondParser = /*#__PURE__*/function (_Parser) {
  _inherits$5(SecondParser, _Parser);

  var _super = _createSuper$5(SecondParser);

  function SecondParser() {
    var _this;

    _classCallCheck$5(this, SecondParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$5(_assertThisInitialized$5(_this), "priority", 50);

    _defineProperty$5(_assertThisInitialized$5(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass$5(SecondParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 's':
          return parseNumericPattern$1(numericPatterns$1.second, dateString);

        case 'so':
          return match.ordinalNumber(dateString, {
            unit: 'second'
          });

        default:
          return parseNDigits$1(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);

  return SecondParser;
}(Parser);

function _typeof$5(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$5 = function _typeof(obj) { return typeof obj; }; } else { _typeof$5 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$5(obj); }

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$4(subClass, superClass); }

function _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf$4(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$4(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$4(this, result); }; }

function _possibleConstructorReturn$4(self, call) { if (call && (_typeof$5(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$4(self); }

function _assertThisInitialized$4(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$4(o) { _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$4(o); }

function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
  _inherits$4(FractionOfSecondParser, _Parser);

  var _super = _createSuper$4(FractionOfSecondParser);

  function FractionOfSecondParser() {
    var _this;

    _classCallCheck$4(this, FractionOfSecondParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$4(_assertThisInitialized$4(_this), "priority", 30);

    _defineProperty$4(_assertThisInitialized$4(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass$4(FractionOfSecondParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      var valueCallback = function valueCallback(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };

      return mapValue(parseNDigits$1(token.length, dateString), valueCallback);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);

  return FractionOfSecondParser;
}(Parser);

function _typeof$4(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$4(obj); }

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$3(subClass, superClass); }

function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf$3(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$3(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$3(this, result); }; }

function _possibleConstructorReturn$3(self, call) { if (call && (_typeof$4(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$3(self); }

function _assertThisInitialized$3(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$3(o) { _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$3(o); }

function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
  _inherits$3(ISOTimezoneWithZParser, _Parser);

  var _super = _createSuper$3(ISOTimezoneWithZParser);

  function ISOTimezoneWithZParser() {
    var _this;

    _classCallCheck$3(this, ISOTimezoneWithZParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$3(_assertThisInitialized$3(_this), "priority", 10);

    _defineProperty$3(_assertThisInitialized$3(_this), "incompatibleTokens", ['t', 'T', 'x']);

    return _this;
  }

  _createClass$3(ISOTimezoneWithZParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'X':
          return parseTimezonePattern$1(timezonePatterns$1.basicOptionalMinutes, dateString);

        case 'XX':
          return parseTimezonePattern$1(timezonePatterns$1.basic, dateString);

        case 'XXXX':
          return parseTimezonePattern$1(timezonePatterns$1.basicOptionalSeconds, dateString);

        case 'XXXXX':
          return parseTimezonePattern$1(timezonePatterns$1.extendedOptionalSeconds, dateString);

        case 'XXX':
        default:
          return parseTimezonePattern$1(timezonePatterns$1.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    }
  }]);

  return ISOTimezoneWithZParser;
}(Parser);

function _typeof$3(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$2(subClass, superClass); }

function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf$2(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$2(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$2(this, result); }; }

function _possibleConstructorReturn$2(self, call) { if (call && (_typeof$3(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$2(self); }

function _assertThisInitialized$2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$2(o) { _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$2(o); }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
  _inherits$2(ISOTimezoneParser, _Parser);

  var _super = _createSuper$2(ISOTimezoneParser);

  function ISOTimezoneParser() {
    var _this;

    _classCallCheck$2(this, ISOTimezoneParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$2(_assertThisInitialized$2(_this), "priority", 10);

    _defineProperty$2(_assertThisInitialized$2(_this), "incompatibleTokens", ['t', 'T', 'X']);

    return _this;
  }

  _createClass$2(ISOTimezoneParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'x':
          return parseTimezonePattern$1(timezonePatterns$1.basicOptionalMinutes, dateString);

        case 'xx':
          return parseTimezonePattern$1(timezonePatterns$1.basic, dateString);

        case 'xxxx':
          return parseTimezonePattern$1(timezonePatterns$1.basicOptionalSeconds, dateString);

        case 'xxxxx':
          return parseTimezonePattern$1(timezonePatterns$1.extendedOptionalSeconds, dateString);

        case 'xxx':
        default:
          return parseTimezonePattern$1(timezonePatterns$1.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    }
  }]);

  return ISOTimezoneParser;
}(Parser);

function _typeof$2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$1(subClass, superClass); }

function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf$1(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$1(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$1(this, result); }; }

function _possibleConstructorReturn$1(self, call) { if (call && (_typeof$2(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$1(self); }

function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$1(o) { _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$1(o); }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits$1(TimestampSecondsParser, _Parser);

  var _super = _createSuper$1(TimestampSecondsParser);

  function TimestampSecondsParser() {
    var _this;

    _classCallCheck$1(this, TimestampSecondsParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized$1(_this), "priority", 40);

    _defineProperty$1(_assertThisInitialized$1(_this), "incompatibleTokens", '*');

    return _this;
  }

  _createClass$1(TimestampSecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned$1(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    }
  }]);

  return TimestampSecondsParser;
}(Parser);

function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof$1(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampMillisecondsParser, _Parser);

  var _super = _createSuper(TimestampMillisecondsParser);

  function TimestampMillisecondsParser() {
    var _this;

    _classCallCheck(this, TimestampMillisecondsParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 20);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');

    return _this;
  }

  _createClass(TimestampMillisecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned$1(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);

  return TimestampMillisecondsParser;
}(Parser);

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */

var parsers$2 = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp$2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp$2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$2 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$2 = /''/g;
var notWhitespaceRegExp$1 = /\S/;
var unescapedLatinCharacterRegExp$2 = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse$3(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

  requiredArgs$1(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions = getDefaultOptions();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$3;

  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }

  var firstWeekContainsDate = toInteger$1((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var weekStartsOn = toInteger$1((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (formatString === '') {
    if (dateString === '') {
      return toDate$1(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }

  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale
  }; // If timezone isn't specified, it will be set to the system timezone

  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp$2).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter in longFormatters$7) {
      var longFormatter = longFormatters$7[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }

    return substring;
  }).join('').match(formattingTokensRegExp$2);
  var usedTokens = [];

  var _iterator = _createForOfIteratorHelper(tokens),
      _step;

  try {
    var _loop = function _loop() {
      var token = _step.value;

      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(token)) {
        throwProtectedError$1(token, formatString, dirtyDateString);
      }

      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(token)) {
        throwProtectedError$1(token, formatString, dirtyDateString);
      }

      var firstCharacter = token[0];
      var parser = parsers$2[firstCharacter];

      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;

        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function (usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });

          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }

        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale.match, subFnOptions);

        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }

        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp$2)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        } // Replace two single quote characters with one single quote character


        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString$2(token);
        } // Cut token from string, or, if string doesn't match the token, return Invalid Date


        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_typeof(_ret) === "object") return _ret.v;
    } // Check if the remaining input contains something other than whitespace

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (dateString.length > 0 && notWhitespaceRegExp$1.test(dateString)) {
    return new Date(NaN);
  }

  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate$1(dirtyReferenceDate);

  if (isNaN(date.getTime())) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.


  var utcDate = subMilliseconds$1(date, getTimezoneOffsetInMilliseconds$1(date));
  var flags = {};

  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var setter = _step2.value;

      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }

      var result = setter.set(utcDate, flags, subFnOptions); // Result is tuple (date, flags)

      if (Array.isArray(result)) {
        utcDate = result[0];
        assign$2(flags, result[1]); // Result is date
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return utcDate;
}

function cleanEscapedString$2(input) {
  return input.match(escapedStringRegExp$2)[1].replace(doubleQuoteRegExp$2, "'");
}

/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} dayOfMonth - the day of the month of the new date
 * @returns {Date} the new date with the day of the month set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * const result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */

function setDate$3(dirtyDate, dirtyDayOfMonth) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var dayOfMonth = toInteger$1(dirtyDayOfMonth);
  date.setDate(dayOfMonth);
  return date;
}

/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} hours - the hours of the new date
 * @returns {Date} the new date with the hours set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */

function setHours$1(dirtyDate, dirtyHours) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var hours = toInteger$1(dirtyHours);
  date.setHours(hours);
  return date;
}

/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} minutes - the minutes of the new date
 * @returns {Date} the new date with the minutes set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */

function setMinutes$1(dirtyDate, dirtyMinutes) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var minutes = toInteger$1(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}

/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} month - the month of the new date
 * @returns {Date} the new date with the month set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */

function setMonth$2(dirtyDate, dirtyMonth) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var month = toInteger$1(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth$1(dateWithDesiredMonth); // Set the last day of the new month
  // if the original date was the last day of the longer month

  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}

/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date.
 *
 * @description
 * Set the seconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} seconds - the seconds of the new date
 * @returns {Date} the new date with the seconds set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */

function setSeconds$1(dirtyDate, dirtySeconds) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var seconds = toInteger$1(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}

/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} year - the year of the new date
 * @returns {Date} the new date with the year set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */

function setYear$1(dirtyDate, dirtyYear) {
  requiredArgs$1(2, arguments);
  var date = toDate$1(dirtyDate);
  var year = toInteger$1(dirtyYear); // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date

  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }

  date.setFullYear(year);
  return date;
}

/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfMonth$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfWeek$1(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs$1(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate$1(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */

function startOfYear$1(dirtyDate) {
  requiredArgs$1(1, arguments);
  var cleanDate = toDate$1(dirtyDate);
  var date = new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @param {String} argument - the value to convert
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */

function parseISO$1(argument, options) {
  var _options$additionalDi;

  requiredArgs$1(1, arguments);
  var additionalDigits = toInteger$1((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);

  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2');
  }

  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
    return new Date(NaN);
  }

  var dateStrings = splitDateString$1(argument);
  var date;

  if (dateStrings.date) {
    var parseYearResult = parseYear$1(dateStrings.date, additionalDigits);
    date = parseDate$1(parseYearResult.restDateString, parseYearResult.year);
  }

  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }

  var timestamp = date.getTime();
  var time = 0;
  var offset;

  if (dateStrings.time) {
    time = parseTime$1(dateStrings.time);

    if (isNaN(time)) {
      return new Date(NaN);
    }
  }

  if (dateStrings.timezone) {
    offset = parseTimezone$1(dateStrings.timezone);

    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time); // js parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.

    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }

  return new Date(timestamp + time + offset);
}
var patterns$1 = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex$1 = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex$1 = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex$1 = /^([+-])(\d{2})(?::?(\d{2}))?$/;

function splitDateString$1(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns$1.dateTimeDelimiter);
  var timeString; // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].

  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];

    if (patterns$1.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns$1.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }

  if (timeString) {
    var token = patterns$1.timezone.exec(timeString);

    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear$1(dateString, additionalDigits) {
  var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
  var captures = dateString.match(regex); // Invalid ISO-formatted year

  if (!captures) return {
    year: NaN,
    restDateString: ''
  };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null; // either year or century is null, not both

  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}

function parseDate$1(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);
  var captures = dateString.match(dateRegex$1); // Invalid ISO-formatted string

  if (!captures) return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit$1(captures[1]);
  var month = parseDateUnit$1(captures[2]) - 1;
  var day = parseDateUnit$1(captures[3]);
  var week = parseDateUnit$1(captures[4]);
  var dayOfWeek = parseDateUnit$1(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate$1(year, week, dayOfWeek)) {
      return new Date(NaN);
    }

    return dayOfISOWeekYear$1(year, week, dayOfWeek);
  } else {
    var date = new Date(0);

    if (!validateDate$2(year, month, day) || !validateDayOfYearDate$1(year, dayOfYear)) {
      return new Date(NaN);
    }

    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit$1(value) {
  return value ? parseInt(value) : 1;
}

function parseTime$1(timeString) {
  var captures = timeString.match(timeRegex$1);
  if (!captures) return NaN; // Invalid ISO-formatted time

  var hours = parseTimeUnit$1(captures[1]);
  var minutes = parseTimeUnit$1(captures[2]);
  var seconds = parseTimeUnit$1(captures[3]);

  if (!validateTime$2(hours, minutes, seconds)) {
    return NaN;
  }

  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000;
}

function parseTimeUnit$1(value) {
  return value && parseFloat(value.replace(',', '.')) || 0;
}

function parseTimezone$1(timezoneString) {
  if (timezoneString === 'Z') return 0;
  var captures = timezoneString.match(timezoneRegex$1);
  if (!captures) return 0;
  var sign = captures[1] === '+' ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;

  if (!validateTimezone$1(hours, minutes)) {
    return NaN;
  }

  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}

function dayOfISOWeekYear$1(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
} // Validation functions
// February is null to handle the leap year (using ||)


var daysInMonths$1 = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex$2(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

function validateDate$2(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths$1[month] || (isLeapYearIndex$2(year) ? 29 : 28));
}

function validateDayOfYearDate$1(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex$2(year) ? 366 : 365);
}

function validateWeekDate$1(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime$2(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}

function validateTimezone$1(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

/**
 * @name formatISO
 * @category Common Helpers
 * @summary Format the date according to the ISO 8601 standard (https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a003169814.htm).
 *
 * @description
 * Return the formatted date string in ISO 8601 format. Options may be passed to control the parts and notations of the date.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {'extended'|'basic'} [options.format='extended'] - if 'basic', hide delimiters between date and time values.
 * @param {'complete'|'date'|'time'} [options.representation='complete'] - format date, time with local time zone, or both.
 * @returns {String} the formatted date string (in local time zone)
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.format` must be 'extended' or 'basic'
 * @throws {RangeError} `options.representation` must be 'date', 'time' or 'complete'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601, short format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918T190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, date only:
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, time only (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52Z'
 */

function formatISO$1(date, options) {
  var _options$format, _options$representati;

  requiredArgs$1(1, arguments);
  var originalDate = toDate$1(date);

  if (isNaN(originalDate.getTime())) {
    throw new RangeError('Invalid time value');
  }

  var format = String((_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : 'extended');
  var representation = String((_options$representati = options === null || options === void 0 ? void 0 : options.representation) !== null && _options$representati !== void 0 ? _options$representati : 'complete');

  if (format !== 'extended' && format !== 'basic') {
    throw new RangeError("format must be 'extended' or 'basic'");
  }

  if (representation !== 'date' && representation !== 'time' && representation !== 'complete') {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }

  var result = '';
  var tzOffset = '';
  var dateDelimiter = format === 'extended' ? '-' : '';
  var timeDelimiter = format === 'extended' ? ':' : ''; // Representation is either 'date' or 'complete'

  if (representation !== 'time') {
    var day = addLeadingZeros$1(originalDate.getDate(), 2);
    var month = addLeadingZeros$1(originalDate.getMonth() + 1, 2);
    var year = addLeadingZeros$1(originalDate.getFullYear(), 4); // yyyyMMdd or yyyy-MM-dd.

    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  } // Representation is either 'time' or 'complete'


  if (representation !== 'date') {
    // Add the timezone.
    var offset = originalDate.getTimezoneOffset();

    if (offset !== 0) {
      var absoluteOffset = Math.abs(offset);
      var hourOffset = addLeadingZeros$1(Math.floor(absoluteOffset / 60), 2);
      var minuteOffset = addLeadingZeros$1(absoluteOffset % 60, 2); // If less than 0, the sign is +, because it is ahead of time.

      var sign = offset < 0 ? '+' : '-';
      tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      tzOffset = 'Z';
    }

    var hour = addLeadingZeros$1(originalDate.getHours(), 2);
    var minute = addLeadingZeros$1(originalDate.getMinutes(), 2);
    var second = addLeadingZeros$1(originalDate.getSeconds(), 2); // If there's also date, separate it with time with 'T'

    var separator = result === '' ? '' : 'T'; // Creates a time string consisting of hour, minute, and second, separated by delimiters, if defined.

    var time = [hour, minute, second].join(timeDelimiter); // HHmmss or HH:mm:ss.

    result = "".concat(result).concat(separator).concat(time).concat(tzOffset);
  }

  return result;
}

/**
 * @name isWithinInterval
 * @category Interval Helpers
 * @summary Is the given date within the interval?
 *
 * @description
 * Is the given date within the interval? (Including start and end.)
 *
 * @param {Date|Number} date - the date to check
 * @param {Interval} interval - the interval to check
 * @returns {Boolean} the date is within the interval
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // For the date within the interval:
 * isWithinInterval(new Date(2014, 0, 3), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> true
 *
 * @example
 * // For the date outside of the interval:
 * isWithinInterval(new Date(2014, 0, 10), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> false
 *
 * @example
 * // For date equal to interval start:
 * isWithinInterval(date, { start, end: date }) // => true
 *
 * @example
 * // For date equal to interval end:
 * isWithinInterval(date, { start: date, end }) // => true
 */
function isWithinInterval$1(dirtyDate, interval) {
  requiredArgs$1(2, arguments);
  var time = toDate$1(dirtyDate).getTime();
  var startTime = toDate$1(interval.start).getTime();
  var endTime = toDate$1(interval.end).getTime(); // Throw an exception if start date is after end date or if any date is `Invalid Date`

  if (!(startTime <= endTime)) {
    throw new RangeError('Invalid interval');
  }

  return time >= startTime && time <= endTime;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var longFormattersExports$1 = {};
var longFormatters$5 = {
  get exports(){ return longFormattersExports$1; },
  set exports(v){ longFormattersExports$1 = v; },
};

(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
	  switch (pattern) {
	    case 'P':
	      return formatLong.date({
	        width: 'short'
	      });

	    case 'PP':
	      return formatLong.date({
	        width: 'medium'
	      });

	    case 'PPP':
	      return formatLong.date({
	        width: 'long'
	      });

	    case 'PPPP':
	    default:
	      return formatLong.date({
	        width: 'full'
	      });
	  }
	};

	var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
	  switch (pattern) {
	    case 'p':
	      return formatLong.time({
	        width: 'short'
	      });

	    case 'pp':
	      return formatLong.time({
	        width: 'medium'
	      });

	    case 'ppp':
	      return formatLong.time({
	        width: 'long'
	      });

	    case 'pppp':
	    default:
	      return formatLong.time({
	        width: 'full'
	      });
	  }
	};

	var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
	  var matchResult = pattern.match(/(P+)(p+)?/) || [];
	  var datePattern = matchResult[1];
	  var timePattern = matchResult[2];

	  if (!timePattern) {
	    return dateLongFormatter(pattern, formatLong);
	  }

	  var dateTimeFormat;

	  switch (datePattern) {
	    case 'P':
	      dateTimeFormat = formatLong.dateTime({
	        width: 'short'
	      });
	      break;

	    case 'PP':
	      dateTimeFormat = formatLong.dateTime({
	        width: 'medium'
	      });
	      break;

	    case 'PPP':
	      dateTimeFormat = formatLong.dateTime({
	        width: 'long'
	      });
	      break;

	    case 'PPPP':
	    default:
	      dateTimeFormat = formatLong.dateTime({
	        width: 'full'
	      });
	      break;
	  }

	  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
	};

	var longFormatters = {
	  p: timeLongFormatter,
	  P: dateTimeLongFormatter
	};
	var _default = longFormatters;
	exports.default = _default;
	module.exports = exports.default;
} (longFormatters$5, longFormattersExports$1));

var longFormatters$4 = /*@__PURE__*/getDefaultExportFromCjs(longFormattersExports$1);

var defaultFormats$6 = {
    dayOfMonth: "d",
    fullDate: "PP",
    fullDateWithWeekday: "PPPP",
    fullDateTime: "PP p",
    fullDateTime12h: "PP hh:mm aaa",
    fullDateTime24h: "PP HH:mm",
    fullTime: "p",
    fullTime12h: "hh:mm aaa",
    fullTime24h: "HH:mm",
    hours12h: "hh",
    hours24h: "HH",
    keyboardDate: "P",
    keyboardDateTime: "P p",
    keyboardDateTime12h: "P hh:mm aaa",
    keyboardDateTime24h: "P HH:mm",
    minutes: "mm",
    month: "LLLL",
    monthAndDate: "MMMM d",
    monthAndYear: "LLLL yyyy",
    monthShort: "MMM",
    weekday: "EEEE",
    weekdayShort: "EEE",
    normalDate: "d MMMM",
    normalDateWithWeekday: "EEE, MMM d",
    seconds: "ss",
    shortDate: "MMM d",
    year: "yyyy",
};
var DateFnsUtils = /** @class */ (function () {
    function DateFnsUtils(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, locale = _b.locale, formats = _b.formats;
        this.lib = "date-fns";
        // Note: date-fns input types are more lenient than this adapter, so we need to expose our more
        // strict signature and delegate to the more lenient signature. Otherwise, we have downstream type errors upon usage.
        this.is12HourCycleInCurrentLocale = function () {
            if (_this.locale) {
                return /a/.test(_this.locale.formatLong.time());
            }
            // By default date-fns is using en-US locale with am/pm enabled
            return true;
        };
        this.getFormatHelperText = function (format) {
            // @see https://github.com/date-fns/date-fns/blob/master/src/format/index.js#L31
            var longFormatRegexp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
            var locale = _this.locale || defaultLocale$3;
            return format
                .match(longFormatRegexp)
                .map(function (token) {
                var firstCharacter = token[0];
                if (firstCharacter === "p" || firstCharacter === "P") {
                    var longFormatter = longFormatters$4[firstCharacter];
                    return longFormatter(token, locale.formatLong, {});
                }
                return token;
            })
                .join("")
                .replace(/(aaa|aa|a)/g, "(a|p)m")
                .toLocaleLowerCase();
        };
        this.parseISO = function (isoString) {
            return parseISO$1(isoString);
        };
        this.toISO = function (value) {
            return formatISO$1(value, { format: "extended" });
        };
        this.getCurrentLocaleCode = function () {
            var _a;
            return ((_a = _this.locale) === null || _a === void 0 ? void 0 : _a.code) || "en-US";
        };
        this.addSeconds = function (value, count) {
            return addSeconds$1(value, count);
        };
        this.addMinutes = function (value, count) {
            return addMinutes$1(value, count);
        };
        this.addHours = function (value, count) {
            return addHours$1(value, count);
        };
        this.addDays = function (value, count) {
            return addDays$1(value, count);
        };
        this.addWeeks = function (value, count) {
            return addWeeks$1(value, count);
        };
        this.addMonths = function (value, count) {
            return addMonths$1(value, count);
        };
        this.addYears = function (value, count) {
            return addYears$1(value, count);
        };
        this.isValid = function (value) {
            return isValid$1(_this.date(value));
        };
        this.getDiff = function (value, comparing, unit) {
            switch (unit) {
                case "years":
                    return differenceInYears$1(value, _this.date(comparing));
                case "quarters":
                    return differenceInQuarters$1(value, _this.date(comparing));
                case "months":
                    return differenceInMonths$1(value, _this.date(comparing));
                case "weeks":
                    return differenceInWeeks$1(value, _this.date(comparing));
                case "days":
                    return differenceInDays$1(value, _this.date(comparing));
                case "hours":
                    return differenceInHours$1(value, _this.date(comparing));
                case "minutes":
                    return differenceInMinutes$1(value, _this.date(comparing));
                case "seconds":
                    return differenceInSeconds$1(value, _this.date(comparing));
                default: {
                    return differenceInMilliseconds$1(value, _this.date(comparing));
                }
            }
        };
        this.isAfter = function (value, comparing) {
            return isAfter$1(value, comparing);
        };
        this.isBefore = function (value, comparing) {
            return isBefore$1(value, comparing);
        };
        this.startOfDay = function (value) {
            return startOfDay$1(value);
        };
        this.endOfDay = function (value) {
            return endOfDay$1(value);
        };
        this.getHours = function (value) {
            return getHours$2(value);
        };
        this.setHours = function (value, count) {
            return setHours$1(value, count);
        };
        this.setMinutes = function (value, count) {
            return setMinutes$1(value, count);
        };
        this.getSeconds = function (value) {
            return getSeconds$1(value);
        };
        this.setSeconds = function (value, count) {
            return setSeconds$1(value, count);
        };
        this.isSameDay = function (value, comparing) {
            return isSameDay$1(value, comparing);
        };
        this.isSameMonth = function (value, comparing) {
            return isSameMonth$1(value, comparing);
        };
        this.isSameYear = function (value, comparing) {
            return isSameYear$1(value, comparing);
        };
        this.isSameHour = function (value, comparing) {
            return isSameHour$1(value, comparing);
        };
        this.startOfYear = function (value) {
            return startOfYear$1(value);
        };
        this.endOfYear = function (value) {
            return endOfYear$1(value);
        };
        this.startOfMonth = function (value) {
            return startOfMonth$1(value);
        };
        this.endOfMonth = function (value) {
            return endOfMonth$1(value);
        };
        this.startOfWeek = function (value) {
            return startOfWeek$1(value, { locale: _this.locale });
        };
        this.endOfWeek = function (value) {
            return endOfWeek$1(value, { locale: _this.locale });
        };
        this.getYear = function (value) {
            return getYear$1(value);
        };
        this.setYear = function (value, count) {
            return setYear$1(value, count);
        };
        this.date = function (value) {
            if (typeof value === "undefined") {
                return new Date();
            }
            if (value === null) {
                return null;
            }
            return new Date(value);
        };
        this.toJsDate = function (value) {
            return value;
        };
        this.parse = function (value, formatString) {
            if (value === "") {
                return null;
            }
            return parse$3(value, formatString, new Date(), { locale: _this.locale });
        };
        this.format = function (date, formatKey) {
            return _this.formatByString(date, _this.formats[formatKey]);
        };
        this.formatByString = function (date, formatString) {
            return format$2(date, formatString, { locale: _this.locale });
        };
        this.isEqual = function (date, comparing) {
            if (date === null && comparing === null) {
                return true;
            }
            return isEqual$1(date, comparing);
        };
        this.isNull = function (date) {
            return date === null;
        };
        this.isAfterDay = function (date, value) {
            return isAfter$1(date, endOfDay$1(value));
        };
        this.isBeforeDay = function (date, value) {
            return isBefore$1(date, startOfDay$1(value));
        };
        this.isBeforeYear = function (date, value) {
            return isBefore$1(date, startOfYear$1(value));
        };
        this.isAfterYear = function (date, value) {
            return isAfter$1(date, endOfYear$1(value));
        };
        this.isWithinRange = function (date, _a) {
            var start = _a[0], end = _a[1];
            return isWithinInterval$1(date, { start: start, end: end });
        };
        this.formatNumber = function (numberToFormat) {
            return numberToFormat;
        };
        this.getMinutes = function (date) {
            return getMinutes$2(date);
        };
        this.getDate = function (date) {
            return getDate$2(date);
        };
        this.setDate = function (date, count) {
            return setDate$3(date, count);
        };
        this.getMonth = function (date) {
            return getMonth$2(date);
        };
        this.getDaysInMonth = function (date) {
            return getDaysInMonth$1(date);
        };
        this.setMonth = function (date, count) {
            return setMonth$2(date, count);
        };
        this.getMeridiemText = function (ampm) {
            return ampm === "am" ? "AM" : "PM";
        };
        this.getNextMonth = function (date) {
            return addMonths$1(date, 1);
        };
        this.getPreviousMonth = function (date) {
            return addMonths$1(date, -1);
        };
        this.getMonthArray = function (date) {
            var firstMonth = startOfYear$1(date);
            var monthArray = [firstMonth];
            while (monthArray.length < 12) {
                var prevMonth = monthArray[monthArray.length - 1];
                monthArray.push(_this.getNextMonth(prevMonth));
            }
            return monthArray;
        };
        this.mergeDateAndTime = function (date, time) {
            return _this.setSeconds(_this.setMinutes(_this.setHours(date, _this.getHours(time)), _this.getMinutes(time)), _this.getSeconds(time));
        };
        this.getWeekdays = function () {
            var now = new Date();
            return eachDayOfInterval$1({
                start: startOfWeek$1(now, { locale: _this.locale }),
                end: endOfWeek$1(now, { locale: _this.locale }),
            }).map(function (day) { return _this.formatByString(day, "EEEEEE"); });
        };
        this.getWeekArray = function (date) {
            var start = startOfWeek$1(startOfMonth$1(date), { locale: _this.locale });
            var end = endOfWeek$1(endOfMonth$1(date), { locale: _this.locale });
            var count = 0;
            var current = start;
            var nestedWeeks = [];
            var lastDay = null;
            while (isBefore$1(current, end)) {
                var weekNumber = Math.floor(count / 7);
                nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
                var day = getDay$1(current);
                if (lastDay !== day) {
                    lastDay = day;
                    nestedWeeks[weekNumber].push(current);
                    count += 1;
                }
                current = addDays$1(current, 1);
            }
            return nestedWeeks;
        };
        this.getYearRange = function (start, end) {
            var startDate = startOfYear$1(start);
            var endDate = endOfYear$1(end);
            var years = [];
            var current = startDate;
            while (isBefore$1(current, endDate)) {
                years.push(current);
                current = addYears$1(current, 1);
            }
            return years;
        };
        this.locale = locale;
        this.formats = Object.assign({}, defaultFormats$6, formats);
    }
    return DateFnsUtils;
}());

/**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the local week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * const result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */

function getWeekYear$1(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var year = date.getFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfWeek$1(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfWeek$1(firstWeekOfThisYear, options);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Date} the start of a week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */

function startOfWeekYear$1(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs$1(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getWeekYear$1(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  var date = startOfWeek$1(firstWeek, options);
  return date;
}

var MILLISECONDS_IN_WEEK$3 = 604800000;
/**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * const result = getWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * const result = getWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */

function getWeek$1(dirtyDate, options) {
  requiredArgs$1(1, arguments);
  var date = toDate$1(dirtyDate);
  var diff = startOfWeek$1(date, options).getTime() - startOfWeekYear$1(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$3) + 1;
}

const formatTokenMap$6 = {
    y: 'year',
    yy: 'year',
    yyy: 'year',
    yyyy: 'year',
    M: 'month',
    MM: 'month',
    MMMM: { sectionName: 'month', contentType: 'letter' },
    MMM: { sectionName: 'month', contentType: 'letter' },
    LLL: { sectionName: 'month', contentType: 'letter' },
    LLLL: { sectionName: 'month', contentType: 'letter' },
    d: 'day',
    dd: 'day',
    H: 'hours',
    HH: 'hours',
    h: 'hours',
    hh: 'hours',
    mm: 'minutes',
    ss: 'seconds',
    a: 'meridiem',
    aa: 'meridiem',
    aaa: 'meridiem',
};
class AdapterDateFns extends DateFnsUtils {
    constructor() {
        super(...arguments);
        this.isMUIAdapter = true;
        this.formatTokenMap = formatTokenMap$6;
        this.escapedCharacters = { start: "'", end: "'" };
        this.expandFormat = (format) => {
            const longFormatRegexp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
            // @see https://github.com/date-fns/date-fns/blob/master/src/format/index.js#L31
            return format
                .match(longFormatRegexp)
                .map((token) => {
                const firstCharacter = token[0];
                if (firstCharacter === 'p' || firstCharacter === 'P') {
                    const longFormatter = longFormatters$4[firstCharacter];
                    const locale = this.locale || defaultLocale$3;
                    return longFormatter(token, locale.formatLong, {});
                }
                return token;
            })
                .join('');
        };
        // Redefined here just to show how it can be written using expandFormat
        this.getFormatHelperText = (format) => {
            return this.expandFormat(format)
                .replace(/(aaa|aa|a)/g, '(a|p)m')
                .toLocaleLowerCase();
        };
        this.getWeekNumber = (date) => {
            return getWeek$1(date, { locale: this.locale });
        };
    }
}

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

/**
 * @name addSeconds
 * @category Second Helpers
 * @summary Add the specified number of seconds to the given date.
 *
 * @description
 * Add the specified number of seconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of seconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the seconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 30 seconds to 10 July 2014 12:45:00:
 * var result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:45:30
 */

function addSeconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1000);
}

var MILLISECONDS_IN_MINUTE$4 = 60000;
/**
 * @name addMinutes
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the minutes added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */

function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$4);
}

var MILLISECONDS_IN_HOUR$3 = 3600000;
/**
 * @name addHours
 * @category Hour Helpers
 * @summary Add the specified number of hours to the given date.
 *
 * @description
 * Add the specified number of hours to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of hours to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the hours added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 2 hours to 10 July 2014 23:00:00:
 * var result = addHours(new Date(2014, 6, 10, 23, 0), 2)
 * //=> Fri Jul 11 2014 01:00:00
 */

function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR$3);
}

// source: https://github.com/jalaali/jalaali-js/blob/2c0cfe1a70caf96ef68ac314f7082a6adbe07d0b/index.js

/*
  Jalaali years starting the 33-year rule.
*/
var breaks$1 = [-61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210, 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178];
/*
  Converts a Gregorian date to Jalaali.
*/

function toJalaali$2(gy, gm, gd) {
  if (Object.prototype.toString.call(gy) === '[object Date]') {
    gd = gy.getDate();
    gm = gy.getMonth() + 1;
    gy = gy.getFullYear();
  }

  return d2j$1(g2d$1(gy, gm, gd));
}
/*
  Converts a Jalaali date to Gregorian.
*/


function toGregorian$2(jy, jm, jd) {
  return d2g$1(j2d$1(jy, jm, jd));
}
/*
  Is this a leap year or not?
*/


function isLeapJalaaliYear$1(jy) {
  return jalCalLeap$1(jy) === 0;
}
/*
    This function determines if the Jalaali (Persian) year is
    leap (366-day long) or is the common year (365 days)

    @param jy Jalaali calendar year (-61 to 3177)
    @returns number of years since the last leap year (0 to 4)
 */


function jalCalLeap$1(jy) {
  var bl = breaks$1.length,
      jp = breaks$1[0],
      jm,
      jump,
      leap,
      n,
      i;

  for (i = 1; i < bl; i += 1) {
    jm = breaks$1[i];
    jump = jm - jp;
    if (jy < jm) break;
    jp = jm;
  }

  n = jy - jp;
  if (jump - n < 6) n = n - jump + div$2(jump + 4, 33) * 33;
  leap = mod$2(mod$2(n + 1, 33) - 1, 4);

  if (leap === -1) {
    leap = 4;
  }

  return leap;
}
/*
  This function determines if the Jalaali (Persian) year is
  leap (366-day long) or is the common year (365 days), and
  finds the day in March (Gregorian calendar) of the first
  day of the Jalaali year (jy).

  @param jy Jalaali calendar year (-61 to 3177)
  @param withoutLeap when don't need leap (true or false) default is false
  @return
    leap: number of years since the last leap year (0 to 4)
    gy: Gregorian year of the beginning of Jalaali year
    march: the March day of Farvardin the 1st (1st day of jy)
  @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
  @see: http://www.fourmilab.ch/documents/calendar/
*/


function jalCal$1(jy, withoutLeap) {
  if (isNaN(jy)) {
    if (withoutLeap) return {
      gy: NaN,
      march: NaN
    };
    return {
      leap: NaN,
      gy: NaN,
      march: NaN
    };
  }

  var bl = breaks$1.length,
      gy = jy + 621,
      leapJ = -14,
      jp = breaks$1[0],
      jm,
      jump,
      leap,
      leapG,
      march,
      n,
      i; // Find the limiting years for the Jalaali year jy.

  for (i = 1; i < bl; i += 1) {
    jm = breaks$1[i];
    jump = jm - jp;
    if (jy < jm) break;
    leapJ = leapJ + div$2(jump, 33) * 8 + div$2(mod$2(jump, 33), 4);
    jp = jm;
  }

  n = jy - jp; // Find the number of leap years from AD 621 to the beginning
  // of the current Jalaali year in the Persian calendar.

  leapJ = leapJ + div$2(n, 33) * 8 + div$2(mod$2(n, 33) + 3, 4);
  if (mod$2(jump, 33) === 4 && jump - n === 4) leapJ += 1; // And the same in the Gregorian calendar (until the year gy).

  leapG = div$2(gy, 4) - div$2((div$2(gy, 100) + 1) * 3, 4) - 150; // Determine the Gregorian date of Farvardin the 1st.

  march = 20 + leapJ - leapG; // return with gy and march when we don't need leap

  if (withoutLeap) return {
    gy: gy,
    march: march // Find how many years have passed since the last leap year.

  };
  if (jump - n < 6) n = n - jump + div$2(jump + 4, 33) * 33;
  leap = mod$2(mod$2(n + 1, 33) - 1, 4);

  if (leap === -1) {
    leap = 4;
  }

  return {
    leap: leap,
    gy: gy,
    march: march
  };
}
/*
  Converts a date of the Jalaali calendar to the Julian Day number.

  @param jy Jalaali year (1 to 3100)
  @param jm Jalaali month (1 to 12)
  @param jd Jalaali day (1 to 29/31)
  @return Julian Day number
*/


function j2d$1(jy, jm, jd) {
  var m = mod$2(mod$2(jm, 12) + 12 - 1, 12) + 1;
  var y = div$2(jm - m, 12);
  jm = m;
  var r = jalCal$1(jy + y, true);
  return g2d$1(r.gy, 3, r.march) + (jm - 1) * 31 - div$2(jm, 7) * (jm - 7) + jd - 1;
}
/*
  Converts the Julian Day number to a date in the Jalaali calendar.

  @param jdn Julian Day number
  @return
    jy: Jalaali year (1 to 3100)
    jm: Jalaali month (1 to 12)
    jd: Jalaali day (1 to 29/31)
*/


function d2j$1(jdn) {
  if (isNaN(jdn)) {
    return {
      jy: NaN,
      jm: NaN,
      jd: NaN
    };
  }

  var gy = d2g$1(jdn).gy,
      // Calculate Gregorian year (gy).
  jy = gy - 621,
      r = jalCal$1(jy, false),
      jdn1f = g2d$1(gy, 3, r.march),
      jd,
      jm,
      k; // Find number of days that passed since 1 Farvardin.

  k = jdn - jdn1f;

  if (k >= 0) {
    if (k <= 185) {
      // The first 6 months.
      jm = 1 + div$2(k, 31);
      jd = mod$2(k, 31) + 1;
      return {
        jy: jy,
        jm: jm,
        jd: jd
      };
    } else {
      // The remaining months.
      k -= 186;
    }
  } else {
    // Previous Jalaali year.
    jy -= 1;
    k += 179;
    if (r.leap === 1) k += 1;
  }

  jm = 7 + div$2(k, 30);
  jd = mod$2(k, 30) + 1;
  return {
    jy: jy,
    jm: jm,
    jd: jd
  };
}
/*
  Calculates the Julian Day number from Gregorian or Julian
  calendar dates. This integer number corresponds to the noon of
  the date (i.e. 12 hours of Universal Time).
  The procedure was tested to be good since 1 March, -100100 (of both
  calendars) up to a few million years into the future.

  @param gy Calendar year (years BC numbered 0, -1, -2, ...)
  @param gm Calendar month (1 to 12)
  @param gd Calendar day of the month (1 to 28/29/30/31)
  @return Julian Day number
*/


function g2d$1(gy, gm, gd) {
  var d = div$2((gy + div$2(gm - 8, 6) + 100100) * 1461, 4) + div$2(153 * mod$2(gm + 9, 12) + 2, 5) + gd - 34840408;
  d = d - div$2(div$2(gy + 100100 + div$2(gm - 8, 6), 100) * 3, 4) + 752;
  return d;
}
/*
  Calculates Gregorian and Julian calendar dates from the Julian Day number
  (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
  calendars) to some millions years ahead of the present.

  @param jdn Julian Day number
  @return
    gy: Calendar year (years BC numbered 0, -1, -2, ...)
    gm: Calendar month (1 to 12)
    gd: Calendar day of the month M (1 to 28/29/30/31)
*/


function d2g$1(jdn) {
  if (isNaN(jdn)) {
    return {
      gy: NaN,
      gm: NaN,
      gd: NaN
    };
  }

  var j, i, gd, gm, gy;
  j = 4 * jdn + 139361631;
  j = j + div$2(div$2(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
  i = div$2(mod$2(j, 1461), 4) * 5 + 308;
  gd = div$2(mod$2(i, 153), 5) + 1;
  gm = mod$2(div$2(i, 153), 12) + 1;
  gy = div$2(j, 1461) - 100100 + div$2(8 - gm, 6);
  return {
    gy: gy,
    gm: gm,
    gd: gd
  };
}
/*
  Utility helper functions.
*/


function div$2(a, b) {
  return ~~(a / b);
}

function mod$2(a, b) {
  return a - ~~(a / b) * b;
}

/**
 *
 * @param cleanDate {Date}
 * @returns {number}
 */

function getDate$1(cleanDate) {
  var gd = cleanDate.getDate();
  var gm = cleanDate.getMonth() + 1;
  var gy = cleanDate.getFullYear();
  return toJalaali$2(gy, gm, gd).jd;
}

/**
 *
 * @param cleanDate {Date}
 * @param date
 * @returns {number}
 */

function setDate$2(cleanDate, date) {
  var gd = cleanDate.getDate();
  var gm = cleanDate.getMonth() + 1;
  var gy = cleanDate.getFullYear();
  var j = toJalaali$2(gy, gm, gd);
  var g = toGregorian$2(j.jy, j.jm, date);
  return cleanDate.setFullYear(g.gy, g.gm - 1, g.gd);
}

/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the days added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * var result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */

function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  setDate$2(date, getDate$1(date) + amount);
  return date;
}

/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the weeks added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * var result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */

function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}

/**
 *
 * @param cleanDate {Date}
 * @returns {number}
 */

function getMonth$1(cleanDate) {
  var gd = cleanDate.getDate();
  var gm = cleanDate.getMonth() + 1;
  var gy = cleanDate.getFullYear();
  return toJalaali$2(gy, gm, gd).jm - 1;
}

/**
 *
 * @param cleanDate {Date}
 * @returns {number}
 */

function getFullYear(cleanDate) {
  var gd = cleanDate.getDate();
  var gm = cleanDate.getMonth() + 1;
  var gy = cleanDate.getFullYear();
  return toJalaali$2(gy, gm, gd).jy;
}

/**
 *
 * @param cleanDate {Date}
 * @param args
 * @returns {number}
 */

function setFullYear(cleanDate) {
  var gd = cleanDate.getDate();
  var gm = cleanDate.getMonth() + 1;
  var gy = cleanDate.getFullYear();
  var j = toJalaali$2(gy, gm, gd);

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var year = args[0],
      _args$ = args[1],
      month = _args$ === void 0 ? j.jm - 1 : _args$,
      _args$2 = args[2],
      date = _args$2 === void 0 ? j.jd : _args$2;
  var g = toGregorian$2(year, month + 1, date);
  return cleanDate.setFullYear(g.gy, g.gm - 1, g.gd);
}

/**
 * @name getDaysInMonth
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the number of days in a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // How many days are in February 2000?
 * var result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */

function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = getFullYear(date);
  var monthIndex = getMonth$1(date);
  var lastDayOfMonth = new Date(0);
  setFullYear(lastDayOfMonth, year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return getDate$1(lastDayOfMonth);
}

/**
 *
 * @param cleanDate {Date}
 * @param args
 * @returns {number}
 */

function setMonth$1(cleanDate) {
  var gd = cleanDate.getDate();
  var gm = cleanDate.getMonth() + 1;
  var gy = cleanDate.getFullYear();
  var j = toJalaali$2(gy, gm, gd);

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var month = args[0],
      _args$ = args[1],
      date = _args$ === void 0 ? j.jd : _args$;
  var g = toGregorian$2(j.jy, month + 1, date);
  return cleanDate.setFullYear(g.gy, g.gm - 1, g.gd);
}

/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the months added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * var result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */

function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  var desiredMonth = getMonth$1(date) + amount;
  var dateWithDesiredMonth = new Date(0);
  setFullYear(dateWithDesiredMonth, getFullYear(date), desiredMonth, 1);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth); // Set the last day of the new month
  // if the original date was the last day of the longer month

  setMonth$1(date, desiredMonth, Math.min(daysInMonth, getDate$1(date)));
  return date;
}

/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the years added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * var result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */

function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}

/**
 * @name differenceInCalendarYears
 * @category Year Helpers
 * @summary Get the number of calendar years between the given dates.
 *
 * @description
 * Get the number of calendar years between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar years
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar years are between 31 December 2013 and 11 February 2015?
 * var result = differenceInCalendarYears(
 *   new Date(2015, 1, 11),
 *   new Date(2013, 11, 31)
 * )
 * //=> 2
 */

function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return getFullYear(dateLeft) - getFullYear(dateRight);
}

/**
 * @name compareAsc
 * @category Common Helpers
 * @summary Compare the two dates and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return 1 if the first date is after the second,
 * -1 if the first date is before the second or 0 if dates are equal.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Number} the result of the comparison
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989:
 * var result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> -1
 *
 * @example
 * // Sort the array of dates:
 * var result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareAsc)
 * //=> [
 * //   Wed Feb 11 1987 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Sun Jul 02 1995 00:00:00
 * // ]
 */

function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1; // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}

/**
 * @name differenceInYears
 * @category Year Helpers
 * @summary Get the number of full years between the given dates.
 *
 * @description
 * Get the number of full years between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full years
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full years are between 31 December 2013 and 11 February 2015?
 * var result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
 * //=> 1
 */

function differenceInYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight)); // Set both dates to a valid leap year for accurate comparison when dealing
  // with leap days

  setFullYear(dateLeft, 1399);
  setFullYear(dateRight, 1399); // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
  // If so, result must be decreased by 1 in absolute value

  var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign;
  var result = sign * (difference - isLastYearNotFull); // Prevent negative zero

  return result === 0 ? 0 : result;
}

/**
 * @name differenceInCalendarMonths
 * @category Month Helpers
 * @summary Get the number of calendar months between the given dates.
 *
 * @description
 * Get the number of calendar months between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar months
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar months are between 31 January 2014 and 1 September 2014?
 * var result = differenceInCalendarMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 8
 */

function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = getFullYear(dateLeft) - getFullYear(dateRight);
  var monthDiff = getMonth$1(dateLeft) - getMonth$1(dateRight);
  return yearDiff * 12 + monthDiff;
}

/**
 * @name differenceInMonths
 * @category Month Helpers
 * @summary Get the number of full months between the given dates.
 *
 * @description
 * Get the number of full months between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full months
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full months are between 31 January 2014 and 1 September 2014?
 * var result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
 * //=> 7
 */

function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  setMonth$1(dateLeft, getMonth$1(dateLeft) - sign * difference); // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
  // If so, result must be decreased by 1 in absolute value

  var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign;
  var result = sign * (difference - isLastMonthNotFull); // Prevent negative zero

  return result === 0 ? 0 : result;
}

/**
 * @name differenceInQuarters
 * @category Quarter Helpers
 * @summary Get the number of full quarters between the given dates.
 *
 * @description
 * Get the number of full quarters between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full quarters
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full quarters are between 31 December 2013 and 2 July 2014?
 * var result = differenceInQuarters(new Date(2014, 6, 2), new Date(2013, 11, 31))
 * //=> 2
 */

function differenceInQuarters(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var diff = differenceInMonths(dirtyDateLeft, dirtyDateRight) / 3;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}

var MILLISECONDS_IN_MINUTE$3 = 60000;

function getDateMillisecondsPart(date) {
  return date.getTime() % MILLISECONDS_IN_MINUTE$3;
}
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */


function getTimezoneOffsetInMilliseconds(dirtyDate) {
  var date = new Date(dirtyDate.getTime());
  var baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
  date.setSeconds(0, 0);
  var hasNegativeUTCOffset = baseTimezoneOffset > 0;
  var millisecondsPartOfTimezoneOffset = hasNegativeUTCOffset ? (MILLISECONDS_IN_MINUTE$3 + getDateMillisecondsPart(date)) % MILLISECONDS_IN_MINUTE$3 : getDateMillisecondsPart(date);
  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE$3 + millisecondsPartOfTimezoneOffset;
}

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * var result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

var MILLISECONDS_IN_DAY$1 = 86400000;
/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar days
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * var result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * var result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */

function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight); // Round the number of days to the nearest integer
  // because the number of milliseconds in a day is not constant
  // (e.g. it's different in the day of the daylight saving time clock shift)

  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
}

// for accurate equality comparisons of UTC timestamps that end up
// having the same representation in local time, e.g. one hour before
// DST ends vs. the instant that DST ends.

function compareLocalAsc(dateLeft, dateRight) {
  var diff = getFullYear(dateLeft) - getFullYear(dateRight) || getMonth$1(dateLeft) - getMonth$1(dateRight) || getDate$1(dateLeft) - getDate$1(dateRight) || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1; // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}
/**
 * @name differenceInDays
 * @category Day Helpers
 * @summary Get the number of full days between the given dates.
 *
 * @description
 * Get the number of full day periods between two dates. Fractional days are
 * truncated towards zero.
 *
 * One "full day" is the distance between a local time in one day to the same
 * local time on the next or previous day. A full day can sometimes be less than
 * or more than 24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
 *
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full days according to the local timezone
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * var result = differenceInDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 365
 * // How many full days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * var result = differenceInDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 0
 * // How many full days are between
 * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 51 days, even in
 * // time zones where DST starts and the
 * // period has only 51*24-1 hours.
 * var result = differenceInDays(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 1)
 * )
//=> 51
 */


function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareLocalAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
  setDate$2(dateLeft, getDate$1(dateLeft) - sign * difference); // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
  // If so, result must be decreased by 1 in absolute value

  var isLastDayNotFull = compareLocalAsc(dateLeft, dateRight) === -sign;
  var result = sign * (difference - isLastDayNotFull); // Prevent negative zero

  return result === 0 ? 0 : result;
}

/**
 * @name differenceInWeeks
 * @category Week Helpers
 * @summary Get the number of full weeks between the given dates.
 *
 * @description
 * Get the number of full weeks between two dates. Fractional weeks are
 * truncated towards zero.
 *
 * One "full week" is the distance between a local time in one day to the same
 * local time 7 days earlier or later. A full week can sometimes be less than
 * or more than 7*24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 7*24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
 *
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of full weeks
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many full weeks are between 5 July 2014 and 20 July 2014?
 * var result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
 * //=> 2
 *
 * // How many full weeks are between
 * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 8 weeks (54 days),
 * // even if DST starts and the period has
 * // only 54*24-1 hours.
 * var result = differenceInWeeks(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 6)
 * )
 * //=> 8
 */

function differenceInWeeks(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var diff = differenceInDays(dirtyDateLeft, dirtyDateRight) / 7;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}

/**
 * @name differenceInMilliseconds
 * @category Millisecond Helpers
 * @summary Get the number of milliseconds between the given dates.
 *
 * @description
 * Get the number of milliseconds between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of milliseconds
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many milliseconds are between
 * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
 * var result = differenceInMilliseconds(
 *   new Date(2014, 6, 2, 12, 30, 21, 700),
 *   new Date(2014, 6, 2, 12, 30, 20, 600)
 * )
 * //=> 1100
 */

function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getTime() - dateRight.getTime();
}

var MILLISECONDS_IN_HOUR$2 = 3600000;
/**
 * @name differenceInHours
 * @category Hour Helpers
 * @summary Get the number of hours between the given dates.
 *
 * @description
 * Get the number of hours between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of hours
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?
 * var result = differenceInHours(
 *   new Date(2014, 6, 2, 19, 0),
 *   new Date(2014, 6, 2, 6, 50)
 * )
 * //=> 12
 */

function differenceInHours(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / MILLISECONDS_IN_HOUR$2;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}

var MILLISECONDS_IN_MINUTE$2 = 60000;
/**
 * @name differenceInMinutes
 * @category Minute Helpers
 * @summary Get the number of minutes between the given dates.
 *
 * @description
 * Get the signed number of full (rounded towards 0) minutes between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of minutes
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
 * var result = differenceInMinutes(
 *   new Date(2014, 6, 2, 12, 20, 0),
 *   new Date(2014, 6, 2, 12, 7, 59)
 * )
 * //=> 12
 *
 * @example
 * // How many minutes are from 10:01:59 to 10:00:00
 * var result = differenceInMinutes(
 *   new Date(2000, 0, 1, 10, 0, 0),
 *   new Date(2000, 0, 1, 10, 1, 59)
 * )
 * //=> -1
 */

function differenceInMinutes(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / MILLISECONDS_IN_MINUTE$2;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}

/**
 * @name differenceInSeconds
 * @category Second Helpers
 * @summary Get the number of seconds between the given dates.
 *
 * @description
 * Get the number of seconds between the given dates.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the later date
 * @param {Date|Number} dateRight - the earlier date
 * @returns {Number} the number of seconds
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // How many seconds are between
 * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
 * var result = differenceInSeconds(
 *   new Date(2014, 6, 2, 12, 30, 20, 0),
 *   new Date(2014, 6, 2, 12, 30, 7, 999)
 * )
 * //=> 12
 */

function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 1000;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}

/**
 * @name eachDayOfInterval
 * @category Interval Helpers
 * @summary Return the array of dates within the specified time interval.
 *
 * @description
 * Return the array of dates within the specified time interval.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The function was renamed from `eachDay` to `eachDayOfInterval`.
 *   This change was made to mirror the use of the word "interval" in standard ISO 8601:2004 terminology:
 *
 *   ```
 *   2.1.3
 *   time interval
 *   part of the time axis limited by two instants
 *   ```
 *
 *   Also, this function now accepts an object with `start` and `end` properties
 *   instead of two arguments as an interval.
 *   This function now throws `RangeError` if the start of the interval is after its end
 *   or if any date in the interval is `Invalid Date`.
 *
 *   ```javascript
 *   // Before v2.0.0
 *
 *   eachDay(new Date(2014, 0, 10), new Date(2014, 0, 20))
 *
 *   // v2.0.0 onward
 *
 *   eachDayOfInterval(
 *     { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) }
 *   )
 *   ```
 *
 * @param {Interval} interval - the interval. See [Interval]{@link docs/types/Interval}
 * @param {Object} [options] - an object with options.
 * @param {Number} [options.step=1] - the step to increment by. The value should be more than 1.
 * @returns {Date[]} the array with starts of days from the day of the interval start to the day of the interval end
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.step` must be a number greater than 1
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // Each day between 6 October 2014 and 10 October 2014:
 * var result = eachDayOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 9, 10)
 * })
 * //=> [
 * //   Mon Oct 06 2014 00:00:00,
 * //   Tue Oct 07 2014 00:00:00,
 * //   Wed Oct 08 2014 00:00:00,
 * //   Thu Oct 09 2014 00:00:00,
 * //   Fri Oct 10 2014 00:00:00
 * // ]
 */

function eachDayOfInterval(dirtyInterval, options) {
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime(); // Throw an exception if start date is after end date or if any date is `Invalid Date`

  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError('Invalid interval');
  }

  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  var step = options && 'step' in options ? Number(options.step) : 1;
  if (step < 1 || isNaN(step)) throw new RangeError('`options.step` must be a number greater than 1');

  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    setDate$2(currentDate, getDate$1(currentDate) + step);
    currentDate.setHours(0, 0, 0, 0);
  }

  return dates;
}

/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * var result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */

function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name endOfWeek
 * @category Week Helpers
 * @summary Return the end of a week for the given date.
 *
 * @description
 * Return the end of a week for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the end of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The end of a week for 2 September 2014 11:55:00:
 * var result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 23:59:59.999
 *
 * @example
 * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
 * var result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 23:59:59.999
 */

function endOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 6 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  setDate$2(date, getDate$1(date) + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name endOfYear
 * @category Year Helpers
 * @summary Return the end of a year for the given date.
 *
 * @description
 * Return the end of a year for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a year for 2 September 2014 11:55:00:
 * var result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 23:59:59.999
 */

function endOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = getFullYear(date);
  setFullYear(date, year + 1, 0, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Now `isValid` doesn't throw an exception
 *   if the first argument is not an instance of Date.
 *   Instead, argument is converted beforehand using `toDate`.
 *
 *   Examples:
 *
 *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
 *   |---------------------------|---------------|---------------|
 *   | `new Date()`              | `true`        | `true`        |
 *   | `new Date('2016-01-01')`  | `true`        | `true`        |
 *   | `new Date('')`            | `false`       | `false`       |
 *   | `new Date(1488370835081)` | `true`        | `true`        |
 *   | `new Date(NaN)`           | `false`       | `false`       |
 *   | `'2016-01-01'`            | `TypeError`   | `false`       |
 *   | `''`                      | `TypeError`   | `false`       |
 *   | `1488370835081`           | `TypeError`   | `true`        |
 *   | `NaN`                     | `TypeError`   | `false`       |
 *
 *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
 *   that try to coerce arguments to the expected type
 *   (which is also the case with other *date-fns* functions).
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * var result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * var result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * var result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return !isNaN(date);
}

var formatDistanceLocale$1 = {
  lessThanXSeconds: {
    one: '   ',
    other: '  {{count}} '
  },
  xSeconds: {
    one: '1 ',
    other: '{{count}} '
  },
  halfAMinute: ' ',
  lessThanXMinutes: {
    one: '   ',
    other: '  {{count}} '
  },
  xMinutes: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXHours: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xHours: {
    one: '1 ',
    other: '{{count}} '
  },
  xDays: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXMonths: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xMonths: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xYears: {
    one: '1 ',
    other: '{{count}} '
  },
  overXYears: {
    one: '  1 ',
    other: '  {{count}} '
  },
  almostXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  }
};
function formatDistance$1(token, count, options) {
  options = options || {};
  var result;

  if (typeof formatDistanceLocale$1[token] === 'string') {
    result = formatDistanceLocale$1[token];
  } else if (count === 1) {
    result = formatDistanceLocale$1[token].one;
  } else {
    result = formatDistanceLocale$1[token].other.replace('{{count}}', count);
  }

  if (options.addSuffix) {
    if (options.comparison > 0) {
      return ' ' + result;
    } else {
      return result + ' ';
    }
  }

  return result;
}

function buildFormatLongFn(args) {
  return function (dirtyOptions) {
    var options = dirtyOptions || {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats$1 = {
  full: 'EEEE do MMMM y',
  long: 'do MMMM y',
  medium: 'd MMM y',
  short: 'yyyy/MM/dd'
};
var timeFormats$1 = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats$1 = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong$2 = {
  date: buildFormatLongFn({
    formats: dateFormats$1,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1,
    defaultWidth: 'full'
  })
};
var formatLong$3 = formatLong$2;

var formatRelativeLocale$1 = {
  lastWeek: "eeee ' ' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: 'P'
};
function formatRelative$1(token, _date, _baseDate, _options) {
  return formatRelativeLocale$1[token];
}

function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}

var eraValues$1 = {
  narrow: ['', ''],
  abbreviated: ['..', '..'],
  wide: ['  ', '  ']
};
var quarterValues$1 = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['1', '2', '3', '4'],
  wide: [' 1', ' 2', ' 3', ' 4'] // Note: in English, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.

};
var monthValues$1 = {
  narrow: ['', '', '', '', '', '', '', '', '', '', '', ''],
  abbreviated: ['', '', '', '', '', '', '', '', '', '', '', ''],
  wide: ['', '', '', '', '', '', '', '', '', '', '', '']
};
var dayValues$1 = {
  narrow: ['', '', '', '', '', '', ''],
  short: ['1', '2', '3', '4', '5', '', ''],
  abbreviated: ['', '', '', '', '', '', ''],
  wide: ['', '', '', '', '', '', '']
};
var dayPeriodValues$1 = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '..',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '..',
    pm: '..',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};
var formattingDayPeriodValues$1 = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '..',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '..',
    pm: '..',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};

function ordinalNumber$1(dirtyNumber) {
  var number = Number(dirtyNumber);
  return number + '-';
}

var localize$2 = {
  ordinalNumber: ordinalNumber$1,
  era: buildLocalizeFn({
    values: eraValues$1,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues$1,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues$1,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues$1,
    defaultFormattingWidth: 'wide'
  })
};
var localize$3 = localize$2;

function buildMatchPatternFn(args) {
  return function (dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options = dirtyOptions || {};
    var matchResult = string.match(args.matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);

    if (!parseResult) {
      return null;
    }

    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    return {
      value: value,
      rest: string.slice(matchedString.length)
    };
  };
}

function buildMatchFn(args) {
  return function (dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options = dirtyOptions || {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var value;

    if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {
      value = findIndex(parsePatterns, function (pattern) {
        return pattern.test(matchedString);
      });
    } else {
      value = findKey(parsePatterns, function (pattern) {
        return pattern.test(matchedString);
      });
    }

    value = args.valueCallback ? args.valueCallback(value) : value;
    value = options.valueCallback ? options.valueCallback(value) : value;
    return {
      value: value,
      rest: string.slice(matchedString.length)
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
}

var matchOrdinalNumberPattern$1 = /^(\d+)(-?)?/i;
var parseOrdinalNumberPattern$1 = /\d+/i;
var matchEraPatterns$1 = {
  narrow: /^(|)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?|\.?)/i,
  wide: /^(  | |  )/i
};
var parseEraPatterns$1 = {
  any: [/^/i, /^/i]
};
var matchQuarterPatterns$1 = {
  narrow: /^[1234]/i,
  abbreviated: /^(|Q|)[1234]/i,
  wide: /^(|quarter|) [1234](-|)?/i
};
var parseQuarterPatterns$1 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns$1 = {
  narrow: /^(|||||||||||)/i,
  abbreviated: /^(|||||||||||)/i,
  wide: /^(|||||||||||)/i
};
var parseMonthPatterns$1 = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]
};
var matchDayPatterns$1 = {
  narrow: /^[]/i,
  short: /^(||1|2|3|4|5)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
var parseDayPatterns$1 = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^(|1|)/i, /^(|2|)/i, /^(|3|)/i, /^(|4|)/i, /^(|5|)/i, /^(|)/i, /^(|)/i]
};
var matchDayPeriodPatterns$1 = {
  narrow: /^(|||||..||)/i,
  abbreviated: /^(..|..||||||)/i,
  wide: /^(||||||)/i
};
var parseDayPeriodPatterns$1 = {
  any: {
    am: /^(|..|)/i,
    pm: /^(|..|)/i,
    midnight: /^(|)/i,
    noon: /^(|)/i,
    morning: /^(|)/i,
    afternoon: /^(|..|)/i,
    evening: /^(|)/i,
    night: /^(|)/i
  }
};
var match$4 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1,
    parsePattern: parseOrdinalNumberPattern$1,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns$1,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns$1,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns$1,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns$1,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns$1,
    defaultParseWidth: 'any'
  })
};
var match$5 = match$4;

/**
 * @type {Locale}
 * @category Locales
 * @summary Persian/Farsi locale (Iran).
 * @language Persian
 * @iso-639-2 ira
 * @author Seyyed Morteza Moosavi [@smmoosavi]{@link https://github.com/smmoosavi}
 */

var locale$1 = {
  code: 'fa-jalali-IR',
  formatDistance: formatDistance$1,
  formatLong: formatLong$3,
  formatRelative: formatRelative$1,
  localize: localize$3,
  match: match$5,
  options: {
    weekStartsOn: 6
    /* Sat */
    ,
    firstWeekContainsDate: 1
  }
};
var defaultLocale$2 = locale$1;

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/**
 *
 * @param cleanDate {Date}
 * @returns {number}
 */

function getUTCMonth(cleanDate) {
  var gd = cleanDate.getUTCDate();
  var gm = cleanDate.getUTCMonth() + 1;
  var gy = cleanDate.getUTCFullYear();
  return toJalaali$2(gy, gm, gd).jm - 1;
}

/**
 *
 * @param cleanDate {Date}
 * @returns {number}
 */

function getUTCDate(cleanDate) {
  var gd = cleanDate.getUTCDate();
  var gm = cleanDate.getUTCMonth() + 1;
  var gy = cleanDate.getUTCFullYear();
  return toJalaali$2(gy, gm, gd).jd;
}

/**
 *
 * @param cleanDate {Date}
 * @returns {number}
 */

function getUTCFullYear(cleanDate) {
  var gd = cleanDate.getUTCDate();
  var gm = cleanDate.getUTCMonth() + 1;
  var gy = cleanDate.getUTCFullYear();
  return toJalaali$2(gy, gm, gd).jy;
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters$2 = {
  // Year
  y: function (date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = getUTCFullYear(date); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function (date, token) {
    var month = getUTCMonth(date);
    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function (date, token) {
    return addLeadingZeros(getUTCDate(date), token.length);
  },
  // AM or PM
  a: function (date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
      case 'aaa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function (date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function (date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function (date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function (date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function (date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var lightFormatters = formatters$2;

/**
 *
 * @param cleanDate {Date}
 * @param args
 * @returns {number}
 */

function setUTCMonth(cleanDate) {
  var gd = cleanDate.getUTCDate();
  var gm = cleanDate.getUTCMonth() + 1;
  var gy = cleanDate.getUTCFullYear();
  var j = toJalaali$2(gy, gm, gd);

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var month = args[0],
      _args$ = args[1],
      date = _args$ === void 0 ? j.jd : _args$;
  var g = toGregorian$2(j.jy, month + 1, date);
  return cleanDate.setUTCFullYear(g.gy, g.gm - 1, g.gd);
}

var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  setUTCMonth(date, 0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$2 = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
}

/**
 *
 * @param cleanDate {Date}
 * @param date
 * @returns {number}
 */

function setUTCDate(cleanDate, date) {
  var gd = cleanDate.getUTCDate();
  var gm = cleanDate.getUTCMonth() + 1;
  var gy = cleanDate.getUTCFullYear();
  var j = toJalaali$2(gy, gm, gd);
  var g = toGregorian$2(j.jy, j.jm, date);
  return cleanDate.setUTCFullYear(g.gy, g.gm - 1, g.gd);
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 6 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  setUTCDate(date, getUTCDate(date) - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

/**
 *
 * @param cleanDate {Date}
 * @param args
 * @returns {number}
 */

function setUTCFullYear(cleanDate) {
  var gd = cleanDate.getUTCDate();
  var gm = cleanDate.getUTCMonth() + 1;
  var gy = cleanDate.getUTCFullYear();
  var j = toJalaali$2(gy, gm, gd);

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var year = args[0],
      _args$ = args[1],
      month = _args$ === void 0 ? j.jm : _args$,
      _args$2 = args[2],
      date = _args$2 === void 0 ? j.jd : _args$2;
  var g = toGregorian$2(year, month + 1, date);
  return cleanDate.setUTCFullYear(g.gy, g.gm - 1, g.gd);
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate, dirtyOptions);
  var year = getUTCFullYear(date);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  setUTCFullYear(firstWeekOfNextYear, year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  setUTCFullYear(firstWeekOfThisYear, year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  setUTCFullYear(firstWeek, year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* | Milliseconds in day            |
   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
   * |  d  | Day of month                   |  D  | Day of year                    |
   * |  e  | Local day of week              |  E  | Day of week                    |
   * |  f  |                                |  F* | Day of week in month           |
   * |  g* | Modified Julian day            |  G  | Era                            |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  i! | ISO day of week                |  I! | ISO week of year               |
   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
   * |  l* | (deprecated)                   |  L  | Stand-alone month              |
   * |  m  | Minute                         |  M  | Month                          |
   * |  n  |                                |  N  |                                |
   * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
   * |  p! | Long localized time            |  P! | Long localized date            |
   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
   * |  u  | Extended year                  |  U* | Cyclic year                    |
   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
   * |  w  | Local week of year             |  W* | Week of month                  |
   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
   * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   *
   * Letters marked by ! are non-standard, but implemented by date-fns:
   * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
   *   i.e. 7 for Sunday, 1 for Monday, etc.
   * - `I` is ISO week of year, as opposed to `w` which is local week of year.
   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
   *   `R` is supposed to be used in conjunction with `I` and `i`
   *   for universal ISO week-numbering date, whereas
   *   `Y` is supposed to be used in conjunction with `w` and `e`
   *   for week-numbering date specific to the locale.
   * - `P` is long localized date format
   * - `p` is long localized time format
   */

};
var formatters = {
  // Era
  G: function (date, token, localize) {
    var era = getUTCFullYear(date) > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = getUTCFullYear(date); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function (date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function (date, token) {
    var isoWeekYear = getUTCISOWeekYear(date); // Padding

    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    var year = getUTCFullYear(date);
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function (date, token, localize) {
    var quarter = Math.ceil((getUTCMonth(date) + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function (date, token, localize) {
    var quarter = Math.ceil((getUTCMonth(date) + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function (date, token, localize) {
    var month = getUTCMonth(date);

    switch (token) {
      case 'M':
      case 'MM':
        return lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function (date, token, localize) {
    var month = getUTCMonth(date);

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function (date, token, localize, options) {
    var week = getUTCWeek(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function (date, token, localize) {
    var isoWeek = getUTCISOWeek(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function (date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(getUTCDate(date), {
        unit: 'date'
      });
    }

    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function (date, token, localize) {
    var dayOfYear = getUTCDayOfYear(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function (date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function (date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function (date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return lightFormatters.m(date, token);
  },
  // Second
  s: function (date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function (date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

var formatters$1 = formatters;

function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
}

function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
}

function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/);
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
}

var longFormatters$2 = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$3 = longFormatters$2;

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token) {
  if (token === 'YYYY') {
    throw new RangeError('Use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr');
  } else if (token === 'YY') {
    throw new RangeError('Use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr');
  } else if (token === 'D') {
    throw new RangeError('Use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr');
  } else if (token === 'DD') {
    throw new RangeError('Use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr');
  }
}

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Su            | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
 * | AM, PM                          | a..aaa  | AM, PM                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 0001, ..., 999               |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 05/29/1453                        | 7     |
 * |                                 | PP      | May 29, 1453                      | 7     |
 * |                                 | PPP     | May 29th, 1453                    | 7     |
 * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |
 * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 9. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The second argument is now required for the sake of explicitness.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   format(new Date(2016, 0, 1))
 *
 *   // v2.0.0 onward
 *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
 *   ```
 *
 * - New format string API for `format` function
 *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
 *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
 *
 * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format$1(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale = options.locale || defaultLocale$2;
  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 6 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = toDate(dirtyDate);

  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$3[firstCharacter];
      return longFormatter(substring, locale.formatLong, formatterOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp$1).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }

    var formatter = formatters$1[firstCharacter];

    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring);
      }

      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring);
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString$1(input) {
  return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
}

/**
 * @name formatISO
 * @category Common Helpers
 * @summary Format the date according to the ISO 8601 standard (http://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a003169814.htm).
 *
 * @description
 * Return the formatted date string in ISO 8601 format. Options may be passed to control the parts and notations of the date.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {'extended'|'basic'} [options.format='extended'] - if 'basic', hide delimiters between date and time values.
 * @param {'complete'|'date'|'time'} [options.representation='complete'] - format date, time with time zone, or both.
 * @returns {String} the formatted date string
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.format` must be 'extended' or 'basic'
 * @throws {RangeError} `options.represenation` must be 'date', 'time' or 'complete'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format (UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601, short format (UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918T190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, date only:
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, time only (UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52Z'
 */

function formatISO(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
  }

  var originalDate = toDate(dirtyDate);

  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value');
  }

  var options = dirtyOptions || {};
  var format = options.format == null ? 'extended' : String(options.format);
  var representation = options.representation == null ? 'complete' : String(options.representation);

  if (format !== 'extended' && format !== 'basic') {
    throw new RangeError("format must be 'extended' or 'basic'");
  }

  if (representation !== 'date' && representation !== 'time' && representation !== 'complete') {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }

  var result = '';
  var tzOffset = '';
  var dateDelimiter = format === 'extended' ? '-' : '';
  var timeDelimiter = format === 'extended' ? ':' : ''; // Representation is either 'date' or 'complete'

  if (representation !== 'time') {
    var day = addLeadingZeros(originalDate.getDate(), 2);
    var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
    var year = addLeadingZeros(originalDate.getFullYear(), 4); // yyyyMMdd or yyyy-MM-dd.

    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  } // Representation is either 'time' or 'complete'


  if (representation !== 'date') {
    // Add the timezone.
    var offset = originalDate.getTimezoneOffset();

    if (offset !== 0) {
      var absoluteOffset = Math.abs(offset);
      var hourOffset = addLeadingZeros(Math.floor(absoluteOffset / 60), 2);
      var minuteOffset = addLeadingZeros(absoluteOffset % 60, 2); // If less than 0, the sign is +, because it is ahead of time.

      var sign = offset < 0 ? '+' : '-';
      tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      tzOffset = 'Z';
    }

    var hour = addLeadingZeros(originalDate.getHours(), 2);
    var minute = addLeadingZeros(originalDate.getMinutes(), 2);
    var second = addLeadingZeros(originalDate.getSeconds(), 2); // If there's also date, separate it with time with 'T'

    var separator = result === '' ? '' : 'T'; // Creates a time string consisting of hour, minute, and second, separated by delimiters, if defined.

    var time = [hour, minute, second].join(timeDelimiter); // HHmmss or HH:mm:ss.

    result = "".concat(result).concat(separator).concat(time).concat(tzOffset);
  }

  return result;
}

/**
 * @name getHours
 * @category Hour Helpers
 * @summary Get the hours of the given date.
 *
 * @description
 * Get the hours of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the hours
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the hours of 29 February 2012 11:45:00:
 * var result = getHours(new Date(2012, 1, 29, 11, 45))
 * //=> 11
 */

function getHours$1(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}

/**
 * @name getSeconds
 * @category Second Helpers
 * @summary Get the seconds of the given date.
 *
 * @description
 * Get the seconds of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the seconds
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the seconds of 29 February 2012 11:45:05.123:
 * var result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 5
 */

function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}

/**
 * @name getYear
 * @category Year Helpers
 * @summary Get the year of the given date.
 *
 * @description
 * Get the year of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which year is 2 July 2014?
 * var result = getYear(new Date(2014, 6, 2))
 * //=> 2014
 */

function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = getFullYear(date);
  return year;
}

/**
 * @name getMonth
 * @category Month Helpers
 * @summary Get the month of the given date.
 *
 * @description
 * Get the month of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which month is 29 February 2012?
 * var result = getMonth(new Date(2012, 1, 29))
 * //=> 1
 */

function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = getMonth$1(date);
  return month;
}

/**
 * @name getDate
 * @category Day Helpers
 * @summary Get the day of the month of the given date.
 *
 * @description
 * Get the day of the month of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the day of month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the month is 29 February 2012?
 * var result = getDate(new Date(2012, 1, 29))
 * //=> 29
 */

function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = getDate$1(date);
  return dayOfMonth;
}

/**
 * @name getDay
 * @category Weekday Helpers
 * @summary Get the day of the week of the given date.
 *
 * @description
 * Get the day of the week of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {0|1|2|3|4|5|6} the day of week
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Which day of the week is 29 February 2012?
 * var result = getDay(new Date(2012, 1, 29))
 * //=> 3
 */

function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}

/**
 * @name getMinutes
 * @category Minute Helpers
 * @summary Get the minutes of the given date.
 *
 * @description
 * Get the minutes of the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @returns {Number} the minutes
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Get the minutes of 29 February 2012 11:45:05:
 * var result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 45
 */

function getMinutes$1(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}

/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date that should be after the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is after the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */

function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}

/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date that should be before the other one to return true
 * @param {Date|Number} dateToCompare - the date to compare with
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */

function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

/**
 * @name isEqual
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Boolean} the dates are equal
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * var result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0),
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */

function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}

/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day?
 *
 * @description
 * Are the given dates in the same day?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * var result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 */

function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

/**
 * @name isSameYear
 * @category Year Helpers
 * @summary Are the given dates in the same year?
 *
 * @description
 * Are the given dates in the same year?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same year
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same year?
 * var result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 */

function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return getFullYear(dateLeft) === getFullYear(dateRight);
}

/**
 * @name isSameMonth
 * @category Month Helpers
 * @summary Are the given dates in the same month?
 *
 * @description
 * Are the given dates in the same month?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same month
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same month?
 * var result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 */

function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return getFullYear(dateLeft) === getFullYear(dateRight) && getMonth$1(dateLeft) === getMonth$1(dateRight);
}

/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of an hour
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * var result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */

function startOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMinutes(0, 0, 0);
  return date;
}

/**
 * @name isSameHour
 * @category Hour Helpers
 * @summary Are the given dates in the same hour?
 *
 * @description
 * Are the given dates in the same hour?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same hour
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 4 September 06:30:00 in the same hour?
 * var result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 6, 30))
 * //=> true
 */

function isSameHour(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfHour = startOfHour(dirtyDateLeft);
  var dateRightStartOfHour = startOfHour(dirtyDateRight);
  return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
}

function assign$1(target, dirtyObject) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }

  dirtyObject = dirtyObject || {};

  for (var property in dirtyObject) {
    if (dirtyObject.hasOwnProperty(property)) {
      target[property] = dirtyObject[property];
    }
  }

  return target;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  requiredArgs(2, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 6 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var delta = 7 - weekStartsOn;
  var diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  setUTCDate(date, getUTCDate(date) + diff);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  setUTCDate(date, getUTCDate(date) - diff * 7);
  return date;
}

/**
 *
 * @param year {number}
 * @returns {boolean}
 */

function isLeapYear$2(year) {
  return isLeapJalaaliYear$1(year);
}

/**
 * @name isLeapYear
 * @category Year Helpers
 * @summary Is the given date in the leap year?
 *
 * @description
 * Is the given date in the leap year?
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is in the leap year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Is 1 September 2012 in the leap year?
 * var result = isLeapYear(new Date(2012, 8, 1))
 * //=> true
 */

function isLeapYear$1(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = getFullYear(date);
  return isLeapYear$2(year);
}

/**
 *
 * @param args
 * @returns {Date}
 */

function newDate() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length > 1) {
    var year = args[0],
        month = args[1],
        _args$ = args[2],
        day = _args$ === void 0 ? 1 : _args$,
        rest = args.slice(3);
    var g = toGregorian$2(year, month + 1, day);
    return new Date(...[g.gy, g.gm - 1, g.gd, ...rest]);
  }

  return new Date(...args);
}

var MILLISECONDS_IN_HOUR$1 = 3600000;
var MILLISECONDS_IN_MINUTE$1 = 60000;
var MILLISECONDS_IN_SECOND = 1000;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);

  if (!matchResult) {
    return null;
  }

  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}

function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);

  if (!matchResult) {
    return null;
  } // Input is 'Z'


  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }

  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$1 + seconds * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}

function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}

function parseNDigits(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);

    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), string, valueCallback);
  }
}

function parseNDigitsSigned(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);

    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), string, valueCallback);
  }
}

function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case 'morning':
      return 4;

    case 'evening':
      return 17;

    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;

    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}

function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0; // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC

  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;

  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}

var DAYS_IN_MONTH = [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 30]; // User for validation

function isLeapYearIndex$1(year) {
  return isLeapYear$1(newDate(year, 0));
}
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */


var parsers = {
  // Era
  G: {
    priority: 140,
    parse: function (string, token, match, _options) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
        // A, B

        case 'GGGGG':
          return match.era(string, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return match.era(string, {
            width: 'wide'
          }) || match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
      }
    },
    set: function (date, flags, value, _options) {
      flags.era = value;
      setUTCFullYear(date, value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['R', 'u', 't', 'T']
  },
  // Year
  y: {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    priority: 130,
    parse: function (string, token, match, _options) {
      var valueCallback = function (year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };

      switch (token) {
        case 'y':
          return parseNDigits(4, string, valueCallback);

        case 'yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });

        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function (_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function (date, flags, value, _options) {
      var currentYear = getUTCFullYear(date);

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        setUTCFullYear(date, normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      setUTCFullYear(date, year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  // Local week-numbering year
  Y: {
    priority: 130,
    parse: function (string, token, match, _options) {
      var valueCallback = function (year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };

      switch (token) {
        case 'Y':
          return parseNDigits(4, string, valueCallback);

        case 'Yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });

        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function (_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function (date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        setUTCFullYear(date, normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      setUTCFullYear(date, year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  // ISO week-numbering year
  R: {
    priority: 130,
    parse: function (string, token, _match, _options) {
      if (token === 'R') {
        return parseNDigitsSigned(4, string);
      }

      return parseNDigitsSigned(token.length, string);
    },
    set: function (_date, _flags, value, _options) {
      var firstWeekOfYear = new Date(0);
      setUTCFullYear(firstWeekOfYear, value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    },
    incompatibleTokens: ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  // Extended year
  u: {
    priority: 130,
    parse: function (string, token, _match, _options) {
      if (token === 'u') {
        return parseNDigitsSigned(4, string);
      }

      return parseNDigitsSigned(token.length, string);
    },
    set: function (date, _flags, value, _options) {
      setUTCFullYear(date, value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  // Quarter
  Q: {
    priority: 120,
    parse: function (string, token, match, _options) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits(token.length, string);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function (date, _flags, value, _options) {
      setUTCMonth(date, (value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Stand-alone quarter
  q: {
    priority: 120,
    parse: function (string, token, match, _options) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits(token.length, string);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function (date, _flags, value, _options) {
      setUTCMonth(date, (value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Month
  M: {
    priority: 110,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        // 01, 02, ..., 12

        case 'MM':
          return parseNDigits(2, string, valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        // Jan, Feb, ..., Dec

        case 'MMM':
          return match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      setUTCMonth(date, value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Stand-alone month
  L: {
    priority: 110,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        // 01, 02, ..., 12

        case 'LL':
          return parseNDigits(2, string, valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        // Jan, Feb, ..., Dec

        case 'LLL':
          return match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      setUTCMonth(date, value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Local week of year
  w: {
    priority: 100,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, string);

        case 'wo':
          return match.ordinalNumber(string, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function (date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  // ISO week of year
  I: {
    priority: 100,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, string);

        case 'Io':
          return match.ordinalNumber(string, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function (date, _flags, value, options) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  // Day of the month
  d: {
    priority: 90,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, string);

        case 'do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (date, value, _options) {
      var year = getUTCFullYear(date);
      var isLeapYear = isLeapYearIndex$1(year);
      var month = getUTCMonth(date);

      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    },
    set: function (date, _flags, value, _options) {
      setUTCDate(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Day of year
  D: {
    priority: 90,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, string);

        case 'Do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (date, value, _options) {
      var year = getUTCFullYear(date);
      var isLeapYear = isLeapYearIndex$1(year);

      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function (date, _flags, value, _options) {
      setUTCMonth(date, 0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']
  },
  // Day of week
  E: {
    priority: 90,
    parse: function (string, token, match, _options) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['D', 'i', 'e', 'c', 't', 'T']
  },
  // Local day of week
  e: {
    priority: 90,
    parse: function (string, token, match, options) {
      var valueCallback = function (value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6
        /* move sun -> sat */
        + 1) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return parseNDigits(token.length, string, valueCallback);
        // 3rd

        case 'eo':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        // Tue

        case 'eee':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']
  },
  // Stand-alone local day of week
  c: {
    priority: 90,
    parse: function (string, token, match, options) {
      var valueCallback = function (value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6
        /* move sun -> sat */
        + 1) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return parseNDigits(token.length, string, valueCallback);
        // 3rd

        case 'co':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        // Tue

        case 'ccc':
          return match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']
  },
  // ISO day of week
  i: {
    priority: 90,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        if (value === 0) {
          return 7;
        }

        return value;
      };

      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits(token.length, string);
        // 2nd

        case 'io':
          return match.ordinalNumber(string, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // T

        case 'iiiii':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // Tu

        case 'iiiiii':
          return match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // Tuesday

        case 'iiii':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 7;
    },
    set: function (date, _flags, value, options) {
      date = setUTCISODay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']
  },
  // AM or PM
  a: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaaa':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['b', 'B', 'H', 'K', 'k', 't', 'T']
  },
  // AM, PM, midnight
  b: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbbb':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'B', 'H', 'K', 'k', 't', 'T']
  },
  // in the morning, in the afternoon, in the evening, at night
  B: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBBB':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 't', 'T']
  },
  // Hour [1-12]
  h: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, string);

        case 'ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 12;
    },
    set: function (date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    },
    incompatibleTokens: ['H', 'K', 'k', 't', 'T']
  },
  // Hour [0-23]
  H: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, string);

        case 'Ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 23;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'K', 'k', 't', 'T']
  },
  // Hour [0-11]
  K: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, string);

        case 'Ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'H', 'k', 't', 'T']
  },
  // Hour [1-24]
  k: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, string);

        case 'ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 24;
    },
    set: function (date, _flags, value, _options) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'H', 'K', 't', 'T']
  },
  // Minute
  m: {
    priority: 60,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, string);

        case 'mo':
          return match.ordinalNumber(string, {
            unit: 'minute'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Second
  s: {
    priority: 50,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, string);

        case 'so':
          return match.ordinalNumber(string, {
            unit: 'second'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCSeconds(value, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Fraction of second
  S: {
    priority: 30,
    parse: function (string, token, _match, _options) {
      var valueCallback = function (value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };

      return parseNDigits(token.length, string, valueCallback);
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMilliseconds(value);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Timezone (ISO-8601. +00:00 is `'Z'`)
  X: {
    priority: 10,
    parse: function (string, token, _match, _options) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, string);

        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function (date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'x']
  },
  // Timezone (ISO-8601)
  x: {
    priority: 10,
    parse: function (string, token, _match, _options) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, string);

        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function (date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'X']
  },
  // Seconds timestamp
  t: {
    priority: 40,
    parse: function (string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function (_date, _flags, value, _options) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  },
  // Milliseconds timestamp
  T: {
    priority: 20,
    parse: function (string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function (_date, _flags, value, _options) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  }
};
var parsers$1 = parsers;

var TIMEZONE_UNIT_PRIORITY = 10; // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 0001, ..., 999               |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Old `parse` was renamed to `toDate`.
 *   Now `parse` is a new function which parses a string using a provided format.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   parse('2016-01-01')
 *
 *   // v2.0.0 onward
 *   toDate('2016-01-01')
 *   parse('2016-01-01', 'yyyy-MM-dd', new Date())
 *   ```
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse$2(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options = dirtyOptions || {};
  var locale = options.locale || defaultLocale$2;

  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }

  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 6 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }

  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale // If timezone isn't specified, it will be set to the system timezone

  };
  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i;
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$3[firstCharacter];
      return longFormatter(substring, locale.formatLong, subFnOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];

  for (i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
      throwProtectedError(token);
    }

    if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      throwProtectedError(token);
    }

    var firstCharacter = token[0];
    var parser = parsers$1[firstCharacter];

    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;

      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = void 0;

        for (var _i = 0; _i < usedTokens.length; _i++) {
          var usedToken = usedTokens[_i].token;

          if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
            incompatibleToken = usedTokens[_i];
            break;
          }
        }

        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === '*' && usedTokens.length) {
        throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
      }

      usedTokens.push({
        token: firstCharacter,
        fullToken: token
      });
      var parseResult = parser.parse(dateString, token, locale.match, subFnOptions);

      if (!parseResult) {
        return new Date(NaN);
      }

      setters.push({
        priority: parser.priority,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
      } // Replace two single quote characters with one single quote character


      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      } // Cut token from string, or, if string doesn't match the token, return Invalid Date


      if (dateString.indexOf(token) === 0) {
        dateString = dateString.slice(token.length);
      } else {
        return new Date(NaN);
      }
    }
  } // Check if the remaining input contains something other than whitespace


  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }

  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).reverse();
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);

  if (isNaN(date)) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37


  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};

  for (i = 0; i < uniquePrioritySetters.length; i++) {
    var setter = uniquePrioritySetters[i];

    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return new Date(NaN);
    }

    var result = setter.set(utcDate, flags, setter.value, subFnOptions); // Result is tuple (date, flags)

    if (result[0]) {
      utcDate = result[0];
      assign$1(flags, result[1]); // Result is date
    } else {
      utcDate = result;
    }
  }

  return utcDate;
}

function dateToSystemTimezone(date, flags) {
  if (flags.timestampIsSet) {
    return date;
  }

  var convertedDate = new Date(0);
  setFullYear(convertedDate, getUTCFullYear(date), getUTCMonth(date), getUTCDate(date));
  convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
  return convertedDate;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The previous `parse` implementation was renamed to `parseISO`.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   parse('2016-01-01')
 *
 *   // v2.0.0 onward
 *   parseISO('2016-01-01')
 *   ```
 *
 * - `parseISO` now validates separate date and time values in ISO-8601 strings
 *   and returns `Invalid Date` if the date is invalid.
 *
 *   ```javascript
 *   parseISO('2018-13-32')
 *   //=> Invalid Date
 *   ```
 *
 * - `parseISO` now doesn't fall back to `new Date` constructor
 *   if it fails to parse a string argument. Instead, it returns `Invalid Date`.
 *
 * @param {String} argument - the value to convert
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * var result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * var result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */

function parseISO(argument, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options.additionalDigits);

  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2');
  }

  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
    return new Date(NaN);
  }

  var dateStrings = splitDateString(argument);
  var date;

  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (isNaN(date) || !date) {
    return new Date(NaN);
  }

  var timestamp = date.getTime();
  var time = 0;
  var offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);

    if (isNaN(time) || time === null) {
      return new Date(NaN);
    }
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);

    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time); // js parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.

    var result = new Date(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate(), dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    result.setFullYear(dirtyDate.getUTCFullYear());
    return result;
  }

  return new Date(timestamp + time + offset);
}

function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;

  if (/:/.test(array[0])) {
    dateStrings.date = null;
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];

    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }

  if (timeString) {
    var token = patterns.timezone.exec(timeString);

    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
  var captures = dateString.match(regex); // Invalid ISO-formatted year

  if (!captures) return {
    year: null
  };
  var year = captures[1] && parseInt(captures[1]);
  var century = captures[2] && parseInt(captures[2]);
  return {
    year: century == null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return null;
  var captures = dateString.match(dateRegex); // Invalid ISO-formatted string

  if (!captures) return null;
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }

    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);

    if (!validateDate$1(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }

    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures) return null; // Invalid ISO-formatted time

  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);

  if (!validateTime$1(hours, minutes, seconds)) {
    return NaN;
  }

  return hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
}

function parseTimeUnit(value) {
  return value && parseFloat(value.replace(',', '.')) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === 'Z') return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  var sign = captures[1] === '+' ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE);
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
} // Validation functions
// February is null to handle the leap year (using ||)


var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100;
}

function validateDate$1(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime$1(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} dayOfMonth - the day of the month of the new date
 * @returns {Date} the new date with the day of the month set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * var result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */

function setDate$1(dirtyDate, dirtyDayOfMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = toInteger(dirtyDayOfMonth);
  setDate$2(date, dayOfMonth);
  return date;
}

/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} hours - the hours of the new date
 * @returns {Date} the new date with the hours set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * var result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */

function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}

/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} minutes - the minutes of the new date
 * @returns {Date} the new date with the minutes set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * var result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */

function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}

/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} month - the month of the new date
 * @returns {Date} the new date with the month set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set February to 1 September 2014:
 * var result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */

function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = getFullYear(date);
  var day = getDate$1(date);
  var dateWithDesiredMonth = new Date(0);
  setFullYear(dateWithDesiredMonth, year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth); // Set the last day of the new month
  // if the original date was the last day of the longer month

  setMonth$1(date, month, Math.min(day, daysInMonth));
  return date;
}

/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date.
 *
 * @description
 * Set the seconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} seconds - the seconds of the new date
 * @returns {Date} the new date with the seconds set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * var result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */

function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}

/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} year - the year of the new date
 * @returns {Date} the new date with the year set
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * var result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */

function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear); // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date

  if (isNaN(date)) {
    return new Date(NaN);
  }

  setFullYear(date, year);
  return date;
}

/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * var result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  setDate$2(date, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * var result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */

function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = getMonth$1(date);
  setFullYear(date, getFullYear(date), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * var result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * var result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 6 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  setDate$2(date, getDate$1(date) - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a year
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * var result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */

function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = new Date(0);
  setFullYear(date, getFullYear(cleanDate), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

/**
 * @name isWithinInterval
 * @category Interval Helpers
 * @summary Is the given date within the interval?
 *
 * @description
 * Is the given date within the interval? (Including start and end.)
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The function was renamed from `isWithinRange` to `isWithinInterval`.
 *   This change was made to mirror the use of the word "interval" in standard ISO 8601:2004 terminology:
 *
 *   ```
 *   2.1.3
 *   time interval
 *   part of the time axis limited by two instants
 *   ```
 *
 *   Also, this function now accepts an object with `start` and `end` properties
 *   instead of two arguments as an interval.
 *   This function now throws `RangeError` if the start of the interval is after its end
 *   or if any date in the interval is `Invalid Date`.
 *
 *   ```javascript
 *   // Before v2.0.0
 *
 *   isWithinRange(
 *     new Date(2014, 0, 3),
 *     new Date(2014, 0, 1), new Date(2014, 0, 7)
 *   )
 *
 *   // v2.0.0 onward
 *
 *   isWithinInterval(
 *     new Date(2014, 0, 3),
 *     { start: new Date(2014, 0, 1), end: new Date(2014, 0, 7) }
 *   )
 *   ```
 *
 * @param {Date|Number} date - the date to check
 * @param {Interval} interval - the interval to check
 * @returns {Boolean} the date is within the interval
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} The start of an interval cannot be after its end
 * @throws {RangeError} Date in interval cannot be `Invalid Date`
 *
 * @example
 * // For the date within the interval:
 * isWithinInterval(new Date(2014, 0, 3), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> true
 *
 * @example
 * // For the date outside of the interval:
 * isWithinInterval(new Date(2014, 0, 10), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> false
 *
 * @example
 * // For date equal to interval start:
 * isWithinInterval(date, { start, end: date }) // => true
 *
 * @example
 * // For date equal to interval end:
 * isWithinInterval(date, { start: date, end }) // => true
 */

function isWithinInterval(dirtyDate, dirtyInterval) {
  requiredArgs(2, arguments);
  var interval = dirtyInterval || {};
  var time = toDate(dirtyDate).getTime();
  var startTime = toDate(interval.start).getTime();
  var endTime = toDate(interval.end).getTime(); // Throw an exception if start date is after end date or if any date is `Invalid Date`

  if (!(startTime <= endTime)) {
    throw new RangeError('Invalid interval');
  }

  return time >= startTime && time <= endTime;
}

var longFormattersExports = {};
var longFormatters$1 = {
  get exports(){ return longFormattersExports; },
  set exports(v){ longFormattersExports = v; },
};

(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	function dateLongFormatter(pattern, formatLong) {
	  switch (pattern) {
	    case 'P':
	      return formatLong.date({
	        width: 'short'
	      });

	    case 'PP':
	      return formatLong.date({
	        width: 'medium'
	      });

	    case 'PPP':
	      return formatLong.date({
	        width: 'long'
	      });

	    case 'PPPP':
	    default:
	      return formatLong.date({
	        width: 'full'
	      });
	  }
	}

	function timeLongFormatter(pattern, formatLong) {
	  switch (pattern) {
	    case 'p':
	      return formatLong.time({
	        width: 'short'
	      });

	    case 'pp':
	      return formatLong.time({
	        width: 'medium'
	      });

	    case 'ppp':
	      return formatLong.time({
	        width: 'long'
	      });

	    case 'pppp':
	    default:
	      return formatLong.time({
	        width: 'full'
	      });
	  }
	}

	function dateTimeLongFormatter(pattern, formatLong) {
	  var matchResult = pattern.match(/(P+)(p+)?/);
	  var datePattern = matchResult[1];
	  var timePattern = matchResult[2];

	  if (!timePattern) {
	    return dateLongFormatter(pattern, formatLong);
	  }

	  var dateTimeFormat;

	  switch (datePattern) {
	    case 'P':
	      dateTimeFormat = formatLong.dateTime({
	        width: 'short'
	      });
	      break;

	    case 'PP':
	      dateTimeFormat = formatLong.dateTime({
	        width: 'medium'
	      });
	      break;

	    case 'PPP':
	      dateTimeFormat = formatLong.dateTime({
	        width: 'long'
	      });
	      break;

	    case 'PPPP':
	    default:
	      dateTimeFormat = formatLong.dateTime({
	        width: 'full'
	      });
	      break;
	  }

	  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
	}

	var longFormatters = {
	  p: timeLongFormatter,
	  P: dateTimeLongFormatter
	};
	var _default = longFormatters;
	exports.default = _default;
	module.exports = exports.default;
} (longFormatters$1, longFormattersExports));

var longFormatters = /*@__PURE__*/getDefaultExportFromCjs(longFormattersExports);

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: '   ',
    other: '  {{count}} '
  },
  xSeconds: {
    one: '1 ',
    other: '{{count}} '
  },
  halfAMinute: ' ',
  lessThanXMinutes: {
    one: '   ',
    other: '  {{count}} '
  },
  xMinutes: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXHours: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xHours: {
    one: '1 ',
    other: '{{count}} '
  },
  xDays: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXMonths: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xMonths: {
    one: '1 ',
    other: '{{count}} '
  },
  aboutXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  },
  xYears: {
    one: '1 ',
    other: '{{count}} '
  },
  overXYears: {
    one: '  1 ',
    other: '  {{count}} '
  },
  almostXYears: {
    one: ' 1 ',
    other: ' {{count}} '
  }
};
function formatDistance(token, count, options) {
  options = options || {};
  var result;

  if (typeof formatDistanceLocale[token] === 'string') {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace('{{count}}', count);
  }

  if (options.addSuffix) {
    if (options.comparison > 0) {
      return ' ' + result;
    } else {
      return result + ' ';
    }
  }

  return result;
}

var dateFormats = {
  full: 'EEEE do MMMM y',
  long: 'do MMMM y',
  medium: 'd MMM y',
  short: 'yyyy/MM/dd'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} '' {{time}}",
  long: "{{date}} '' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
var formatLong$1 = formatLong;

var formatRelativeLocale = {
  lastWeek: "eeee ' ' p",
  yesterday: "' ' p",
  today: "' ' p",
  tomorrow: "' ' p",
  nextWeek: "eeee '' p",
  other: 'P'
};
function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
}

var eraValues = {
  narrow: ['', ''],
  abbreviated: ['..', '..'],
  wide: ['  ', '  ']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['1', '2', '3', '4'],
  wide: [' 1', ' 2', ' 3', ' 4'] // Note: in English, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.

};
var monthValues = {
  narrow: ['', '', '', '', '', '', '', '', '', '', '', ''],
  abbreviated: ['', '', '', '', '', '', '', '', '', '', '', ''],
  wide: ['', '', '', '', '', '', '', '', '', '', '', '']
};
var dayValues = {
  narrow: ['', '', '', '', '', '', ''],
  short: ['1', '2', '3', '4', '5', '', ''],
  abbreviated: ['', '', '', '', '', '', ''],
  wide: ['', '', '', '', '', '', '']
};
var dayPeriodValues = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '..',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '..',
    pm: '..',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '..',
    evening: '',
    night: ''
  },
  abbreviated: {
    am: '..',
    pm: '..',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  },
  wide: {
    am: '',
    pm: '',
    midnight: '',
    noon: '',
    morning: '',
    afternoon: '',
    evening: '',
    night: ''
  }
};

function ordinalNumber(dirtyNumber) {
  return String(dirtyNumber);
}

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
var localize$1 = localize;

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(|)/i,
  abbreviated: /^(\.?\s?\.?|\.?\s?\.?\s?\.?|\.?\s?|\.?\s?\.?)/i,
  wide: /^(  |   || |  )/i
};
var parseEraPatterns = {
  any: [/^/i, /^/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234]/i,
  wide: /^ [1234]/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[]/i,
  abbreviated: /^(|||||||||||||||||||||||||)/i,
  wide: /^(|||||||||||||||||||||||||||)/i
};
var parseMonthPatterns = {
  narrow: [/^(|)/i, /^/i, /^/i, /^(|)/i, /^/i, /^(|)/i, /^(|)/i, /^(|)/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^/i, /^/i, /^/i, /^/i, /^(|)/i, /^(|)/i, /^(|)/i, /^(|)/i, /^/i, /^(|)/i, /^/i, /^/i]
};
var matchDayPatterns = {
  narrow: /^[]/i,
  short: /^(||1|2|3|4|5)/i,
  abbreviated: /^(||||||)/i,
  wide: /^(||||||)/i
};
var parseDayPatterns = {
  narrow: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
  any: [/^(|1|)/i, /^(|2|)/i, /^(|3|)/i, /^(|4|)/i, /^(|5|)/i, /^(|)/i, /^(|)/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(|||||..||)/i,
  abbreviated: /^(..|..||||||)/i,
  wide: /^(||||||)/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^(|..|)/i,
    pm: /^(|..|)/i,
    midnight: /^(|)/i,
    noon: /^(|)/i,
    morning: /(|)/i,
    afternoon: /(|..|)/i,
    evening: /(|)/i,
    night: /(|)/i
  }
};
var match$2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
var match$3 = match$2;

/**
 * @type {Locale}
 * @category Locales
 * @summary Persian/Farsi locale (Iran).
 * @language Persian
 * @iso-639-2 ira
 * @author Morteza Ziyae [@mort3za]{@link https://github.com/mort3za}
 */

var locale = {
  code: 'fa-IR',
  formatDistance: formatDistance,
  formatLong: formatLong$1,
  formatRelative: formatRelative,
  localize: localize$1,
  match: match$3,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
var defaultLocale$1 = locale;

var defaultFormats$5 = {
    dayOfMonth: "d",
    fullDate: "PPP",
    fullDateWithWeekday: "PPPP",
    fullDateTime: "PPP p",
    fullDateTime12h: "PPP hh:mm aaa",
    fullDateTime24h: "PPP HH:mm",
    fullTime: "p",
    fullTime12h: "hh:mm aaa",
    fullTime24h: "HH:mm",
    hours12h: "hh",
    hours24h: "HH",
    keyboardDate: "P",
    keyboardDateTime: "P p",
    keyboardDateTime12h: "P hh:mm aaa",
    keyboardDateTime24h: "P HH:mm",
    minutes: "mm",
    month: "LLLL",
    monthAndDate: "d MMMM",
    monthAndYear: "LLLL yyyy",
    monthShort: "MMM",
    weekday: "EEEE",
    weekdayShort: "EEE",
    normalDate: "d MMMM",
    normalDateWithWeekday: "EEE, d MMMM",
    seconds: "ss",
    shortDate: "d MMM",
    year: "yyyy",
};
var symbolMap$3 = {
    1: "",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: "",
    0: "",
};
var DateFnsJalaliUtils = /** @class */ (function () {
    function DateFnsJalaliUtils(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, locale = _b.locale, formats = _b.formats;
        this.lib = "date-fns-jalali";
        // Note: date-fns input types are more lenient than this adapter, so we need to expose our more
        // strict signature and delegate to the more lenient signature. Otherwise, we have downstream type errors upon usage.
        this.is12HourCycleInCurrentLocale = function () {
            if (_this.locale) {
                return /a/.test(_this.locale.formatLong.time());
            }
            // By default date-fns-jalali is using fa-IR locale with am/pm enabled
            return true;
        };
        this.getFormatHelperText = function (format) {
            // @see https://github.com/date-fns/date-fns/blob/master/src/format/index.js#L31
            var longFormatRegexp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
            var locale = _this.locale || defaultLocale$1;
            return format
                .match(longFormatRegexp)
                .map(function (token) {
                var firstCharacter = token[0];
                if (firstCharacter === "p" || firstCharacter === "P") {
                    var longFormatter = longFormatters[firstCharacter];
                    return longFormatter(token, locale.formatLong, {});
                }
                return token;
            })
                .join("")
                .replace(/(aaa|aa|a)/g, "(a|p)m")
                .toLocaleLowerCase();
        };
        this.getCurrentLocaleCode = function () {
            var _a;
            return ((_a = _this.locale) === null || _a === void 0 ? void 0 : _a.code) || "fa-IR";
        };
        this.addSeconds = function (value, count) {
            return addSeconds(value, count);
        };
        this.addMinutes = function (value, count) {
            return addMinutes(value, count);
        };
        this.addHours = function (value, count) {
            return addHours(value, count);
        };
        this.addDays = function (value, count) {
            return addDays(value, count);
        };
        this.addWeeks = function (value, count) {
            return addWeeks(value, count);
        };
        this.addMonths = function (value, count) {
            return addMonths(value, count);
        };
        this.addYears = function (value, count) {
            return addYears(value, count);
        };
        this.isValid = function (value) {
            return isValid(_this.date(value));
        };
        this.getDiff = function (value, comparing, unit) {
            switch (unit) {
                case "years":
                    return differenceInYears(value, _this.date(comparing));
                case "quarters":
                    return differenceInQuarters(value, _this.date(comparing));
                case "months":
                    return differenceInMonths(value, _this.date(comparing));
                case "weeks":
                    return differenceInWeeks(value, _this.date(comparing));
                case "days":
                    return differenceInDays(value, _this.date(comparing));
                case "hours":
                    return differenceInHours(value, _this.date(comparing));
                case "minutes":
                    return differenceInMinutes(value, _this.date(comparing));
                case "seconds":
                    return differenceInSeconds(value, _this.date(comparing));
                default: {
                    return differenceInMilliseconds(value, _this.date(comparing));
                }
            }
        };
        this.isAfter = function (value, comparing) {
            return isAfter(value, comparing);
        };
        this.isBefore = function (value, comparing) {
            return isBefore(value, comparing);
        };
        this.startOfDay = function (value) {
            return startOfDay(value);
        };
        this.endOfDay = function (value) {
            return endOfDay(value);
        };
        this.getHours = function (value) {
            return getHours$1(value);
        };
        this.setHours = function (value, count) {
            return setHours(value, count);
        };
        this.setMinutes = function (value, count) {
            return setMinutes(value, count);
        };
        this.getSeconds = function (value) {
            return getSeconds(value);
        };
        this.setSeconds = function (value, count) {
            return setSeconds(value, count);
        };
        this.isSameDay = function (value, comparing) {
            return isSameDay(value, comparing);
        };
        this.isSameMonth = function (value, comparing) {
            return isSameMonth(value, comparing);
        };
        this.isSameYear = function (value, comparing) {
            return isSameYear(value, comparing);
        };
        this.isSameHour = function (value, comparing) {
            return isSameHour(value, comparing);
        };
        this.startOfYear = function (value) {
            return startOfYear(value);
        };
        this.endOfYear = function (value) {
            return endOfYear(value);
        };
        this.startOfMonth = function (value) {
            return startOfMonth(value);
        };
        this.endOfMonth = function (value) {
            return endOfMonth(value);
        };
        this.startOfWeek = function (value) {
            return startOfWeek(value, { locale: _this.locale });
        };
        this.endOfWeek = function (value) {
            return endOfWeek(value, { locale: _this.locale });
        };
        this.getYear = function (value) {
            return getYear(value);
        };
        this.setYear = function (value, count) {
            return setYear(value, count);
        };
        this.getDate = function (value) {
            return getDate(value);
        };
        this.setDate = function (value, count) {
            return setDate$1(value, count);
        };
        this.date = function (value) {
            if (typeof value === "undefined") {
                return new Date();
            }
            if (value === null) {
                return null;
            }
            return new Date(value);
        };
        this.toJsDate = function (value) {
            return value;
        };
        this.parseISO = function (isoString) {
            return parseISO(isoString);
        };
        this.toISO = function (value) {
            return formatISO(value, { format: "extended" });
        };
        this.parse = function (value, formatString) {
            if (value === "") {
                return null;
            }
            return parse$2(value, formatString, new Date(), { locale: _this.locale });
        };
        this.format = function (date, formatKey) {
            return _this.formatByString(date, _this.formats[formatKey]);
        };
        this.formatByString = function (date, formatString) {
            return format$1(date, formatString, { locale: _this.locale });
        };
        this.isEqual = function (date, comparing) {
            if (date === null && comparing === null) {
                return true;
            }
            return isEqual(date, comparing);
        };
        this.isNull = function (date) {
            return date === null;
        };
        this.isAfterDay = function (date, value) {
            return isAfter(date, endOfDay(value));
        };
        this.isBeforeDay = function (date, value) {
            return isBefore(date, startOfDay(value));
        };
        this.isBeforeYear = function (date, value) {
            return isBefore(date, startOfYear(value));
        };
        this.isAfterYear = function (date, value) {
            return isAfter(date, endOfYear(value));
        };
        this.isWithinRange = function (date, _a) {
            var start = _a[0], end = _a[1];
            return isWithinInterval(date, { start: start, end: end });
        };
        this.formatNumber = function (numberToFormat) {
            return numberToFormat.replace(/\d/g, function (match) { return symbolMap$3[match]; }).replace(/,/g, "");
        };
        this.getMinutes = function (date) {
            return getMinutes$1(date);
        };
        this.getMonth = function (date) {
            return getMonth(date);
        };
        this.getDaysInMonth = function (date) {
            return getDaysInMonth(date);
        };
        this.setMonth = function (date, count) {
            return setMonth(date, count);
        };
        this.getMeridiemText = function (ampm) {
            if (ampm === "am") {
                return "..";
            }
            return "..";
        };
        this.getNextMonth = function (date) {
            return addMonths(date, 1);
        };
        this.getPreviousMonth = function (date) {
            return addMonths(date, -1);
        };
        this.getMonthArray = function (date) {
            var firstMonth = startOfYear(date);
            var monthArray = [firstMonth];
            while (monthArray.length < 12) {
                var prevMonth = monthArray[monthArray.length - 1];
                monthArray.push(_this.getNextMonth(prevMonth));
            }
            return monthArray;
        };
        this.mergeDateAndTime = function (date, time) {
            return _this.setSeconds(_this.setMinutes(_this.setHours(date, _this.getHours(time)), _this.getMinutes(time)), _this.getSeconds(time));
        };
        this.getWeekdays = function () {
            var now = new Date();
            return eachDayOfInterval({
                start: startOfWeek(now, { locale: _this.locale }),
                end: endOfWeek(now, { locale: _this.locale }),
            }).map(function (day) { return _this.formatByString(day, "EEEEEE"); });
        };
        this.getWeekArray = function (date) {
            var start = startOfWeek(startOfMonth(date), { locale: _this.locale });
            var end = endOfWeek(endOfMonth(date), { locale: _this.locale });
            var count = 0;
            var current = start;
            var nestedWeeks = [];
            var lastDay = null;
            while (isBefore(current, end)) {
                var weekNumber = Math.floor(count / 7);
                nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
                var day = getDay(current);
                if (lastDay !== day) {
                    lastDay = day;
                    nestedWeeks[weekNumber].push(current);
                    count += 1;
                }
                current = addDays(current, 1);
            }
            return nestedWeeks;
        };
        this.getYearRange = function (start, end) {
            var startDate = startOfYear(start);
            var endDate = endOfYear(end);
            var years = [];
            var current = startDate;
            while (isBefore(current, endDate)) {
                years.push(current);
                current = addYears(current, 1);
            }
            return years;
        };
        this.locale = locale;
        this.formats = Object.assign({}, defaultFormats$5, formats);
    }
    return DateFnsJalaliUtils;
}());

/**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the local week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * var result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * var result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * var result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */

function getWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = getFullYear(date);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  setFullYear(firstWeekOfNextYear, year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  setFullYear(firstWeekOfThisYear, year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfWeek(firstWeekOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Date} the start of a week-numbering year
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * var result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * var result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */

function startOfWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  setFullYear(firstWeek, year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  var date = startOfWeek(firstWeek, dirtyOptions);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000;
/**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the given date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @returns {Number} the week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * var result = getISOWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * var result = getISOWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */

function getWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfWeek(date, options).getTime() - startOfWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

const formatTokenMap$5 = {
    y: 'year',
    yy: 'year',
    yyy: 'year',
    yyyy: 'year',
    M: 'month',
    MM: 'month',
    MMMM: { sectionName: 'month', contentType: 'letter' },
    MMM: { sectionName: 'month', contentType: 'letter' },
    LLL: { sectionName: 'month', contentType: 'letter' },
    LLLL: { sectionName: 'month', contentType: 'letter' },
    d: 'day',
    dd: 'day',
    H: 'hours',
    HH: 'hours',
    h: 'hours',
    hh: 'hours',
    mm: 'minutes',
    ss: 'seconds',
    a: 'meridiem',
    aa: 'meridiem',
    aaa: 'meridiem',
};
class AdapterDateFnsJalali extends DateFnsJalaliUtils {
    constructor() {
        super(...arguments);
        this.isMUIAdapter = true;
        this.formatTokenMap = formatTokenMap$5;
        this.escapedCharacters = { start: "'", end: "'" };
        this.expandFormat = (format) => {
            var _a;
            // @see https://github.com/date-fns/date-fns/blob/master/src/format/index.js#L31
            const longFormatRegexp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
            const locale = (_a = this.locale) !== null && _a !== void 0 ? _a : defaultLocale$1;
            return format
                .match(longFormatRegexp)
                .map((token) => {
                const firstCharacter = token[0];
                if (firstCharacter === 'p' || firstCharacter === 'P') {
                    const longFormatter = longFormatters[firstCharacter];
                    return longFormatter(token, locale.formatLong, {});
                }
                return token;
            })
                .join('');
        };
        // Redefined here just to show how it can be written using expandFormat
        this.getFormatHelperText = (format) => {
            return this.expandFormat(format)
                .replace(/(aaa|aa|a)/g, '(a|p)m')
                .toLocaleLowerCase();
        };
        this.getWeekNumber = (date) => {
            return getWeek(date, { locale: this.locale });
        };
    }
}

var weekOfYearExports = {};
var weekOfYear = {
  get exports(){ return weekOfYearExports; },
  set exports(v){ weekOfYearExports = v; },
};

(function (module, exports) {
	!function(e,t){module.exports=t();}(commonjsGlobal,(function(){var e="week",t="year";return function(i,n,r){var f=n.prototype;f.week=function(i){if(void 0===i&&(i=null),null!==i)return this.add(7*(i-this.week()),"day");var n=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var f=r(this).startOf(t).add(1,t).date(n),s=r(this).endOf(e);if(f.isBefore(s))return 1}var a=r(this).startOf(t).date(n).startOf(e).subtract(1,"millisecond"),o=this.diff(a,e,!0);return o<0?r(this).startOf("week").week():Math.ceil(o)},f.weeks=function(e){return void 0===e&&(e=null),this.week(e)};}}));
} (weekOfYear));

var dayjs_minExports = {};
var dayjs_min = {
  get exports(){ return dayjs_minExports; },
  set exports(v){ dayjs_minExports = v; },
};

(function (module, exports) {
	!function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return "["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else {var a=e.name;D[a]=e,i=a;}return !r&&i&&(g=i),i||!r&&g},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=v;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t);}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return O},m.isValid=function(){return !(this.$d.toString()===l)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),l=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(h){case c:return r?l(1,0):l(31,11);case f:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),l=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,l=this;r=Number(r);var $=O.p(h),y=function(t){var e=w(l);return O.w(e.date(e.date()+Math.round(t*r)),l)};if($===f)return this.set(f,this.$M+r);if($===c)return this.set(c,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},$={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||$[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,v=this-M,g=O.m(this,M);return g=($={},$[c]=g/12,$[f]=g,$[h]=g/3,$[o]=(v-m)/6048e5,$[a]=(v-m)/864e5,$[u]=v/n,$[s]=v/e,$[i]=v/t,$)[y]||v,l?g:O.a(g)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[g],w.Ls=D,w.p={},w}));
} (dayjs_min));

var defaultDayjs = dayjs_minExports;

var customParseFormatExports = {};
var customParseFormat = {
  get exports(){ return customParseFormatExports; },
  set exports(v){ customParseFormatExports = v; },
};

(function (module, exports) {
	!function(e,t){module.exports=t();}(commonjsGlobal,(function(){var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},t=/(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\d\d/,r=/\d\d?/,i=/\d*[^-_:/,()\s\d]+/,o={},s=function(e){return (e=+e)+(e>68?1900:2e3)};var a=function(e){return function(t){this[e]=+t;}},f=[/[+-]\d\d:?(\d\d)?|Z/,function(e){(this.zone||(this.zone={})).offset=function(e){if(!e)return 0;if("Z"===e)return 0;var t=e.match(/([+-]|\d\d)/g),n=60*t[1]+(+t[2]||0);return 0===n?0:"+"===t[0]?-n:n}(e);}],h=function(e){var t=o[e];return t&&(t.indexOf?t:t.s.concat(t.f))},u=function(e,t){var n,r=o.meridiem;if(r){for(var i=1;i<=24;i+=1)if(e.indexOf(r(i,0,t))>-1){n=i>12;break}}else n=e===(t?"pm":"PM");return n},d={A:[i,function(e){this.afternoon=u(e,!1);}],a:[i,function(e){this.afternoon=u(e,!0);}],S:[/\d/,function(e){this.milliseconds=100*+e;}],SS:[n,function(e){this.milliseconds=10*+e;}],SSS:[/\d{3}/,function(e){this.milliseconds=+e;}],s:[r,a("seconds")],ss:[r,a("seconds")],m:[r,a("minutes")],mm:[r,a("minutes")],H:[r,a("hours")],h:[r,a("hours")],HH:[r,a("hours")],hh:[r,a("hours")],D:[r,a("day")],DD:[n,a("day")],Do:[i,function(e){var t=o.ordinal,n=e.match(/\d+/);if(this.day=n[0],t)for(var r=1;r<=31;r+=1)t(r).replace(/\[|\]/g,"")===e&&(this.day=r);}],M:[r,a("month")],MM:[n,a("month")],MMM:[i,function(e){var t=h("months"),n=(h("monthsShort")||t.map((function(e){return e.slice(0,3)}))).indexOf(e)+1;if(n<1)throw new Error;this.month=n%12||n;}],MMMM:[i,function(e){var t=h("months").indexOf(e)+1;if(t<1)throw new Error;this.month=t%12||t;}],Y:[/[+-]?\d+/,a("year")],YY:[n,function(e){this.year=s(e);}],YYYY:[/\d{4}/,a("year")],Z:f,ZZ:f};function c(n){var r,i;r=n,i=o&&o.formats;for(var s=(n=r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var o=r&&r.toUpperCase();return n||i[r]||e[r]||i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))).match(t),a=s.length,f=0;f<a;f+=1){var h=s[f],u=d[h],c=u&&u[0],l=u&&u[1];s[f]=l?{regex:c,parser:l}:h.replace(/^\[|\]$/g,"");}return function(e){for(var t={},n=0,r=0;n<a;n+=1){var i=s[n];if("string"==typeof i)r+=i.length;else {var o=i.regex,f=i.parser,h=e.slice(r),u=o.exec(h)[0];f.call(t,u),e=e.replace(u,"");}}return function(e){var t=e.afternoon;if(void 0!==t){var n=e.hours;t?n<12&&(e.hours+=12):12===n&&(e.hours=0),delete e.afternoon;}}(t),t}}return function(e,t,n){n.p.customParseFormat=!0,e&&e.parseTwoDigitYear&&(s=e.parseTwoDigitYear);var r=t.prototype,i=r.parse;r.parse=function(e){var t=e.date,r=e.utc,s=e.args;this.$u=r;var a=s[1];if("string"==typeof a){var f=!0===s[2],h=!0===s[3],u=f||h,d=s[2];h&&(d=s[2]),o=this.$locale(),!f&&d&&(o=n.Ls[d]),this.$d=function(e,t,n){try{if(["x","X"].indexOf(t)>-1)return new Date(("X"===t?1e3:1)*e);var r=c(t)(e),i=r.year,o=r.month,s=r.day,a=r.hours,f=r.minutes,h=r.seconds,u=r.milliseconds,d=r.zone,l=new Date,m=s||(i||o?1:l.getDate()),M=i||l.getFullYear(),Y=0;i&&!o||(Y=o>0?o-1:l.getMonth());var p=a||0,v=f||0,D=h||0,g=u||0;return d?new Date(Date.UTC(M,Y,m,p,v,D,g+60*d.offset*1e3)):n?new Date(Date.UTC(M,Y,m,p,v,D,g)):new Date(M,Y,m,p,v,D,g)}catch(e){return new Date("")}}(t,a,r),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),u&&t!=this.format(a)&&(this.$d=new Date("")),o={};}else if(a instanceof Array)for(var l=a.length,m=1;m<=l;m+=1){s[1]=a[m-1];var M=n.apply(this,s);if(M.isValid()){this.$d=M.$d,this.$L=M.$L,this.init();break}m===l&&(this.$d=new Date(""));}else i.call(this,e);};}}));
} (customParseFormat));

var customParseFormatPlugin = customParseFormatExports;

var localizedFormatExports = {};
var localizedFormat = {
  get exports(){ return localizedFormatExports; },
  set exports(v){ localizedFormatExports = v; },
};

(function (module, exports) {
	!function(e,t){module.exports=t();}(commonjsGlobal,(function(){var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,o,n){var r=o.prototype,i=r.format;n.en.formats=e,r.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var o=this.$locale().formats,n=function(t,o){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var i=r&&r.toUpperCase();return n||o[r]||e[r]||o[i].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,o){return t||o.slice(1)}))}))}(t,void 0===o?{}:o);return i.call(this,n)};}}));
} (localizedFormat));

var localizedFormatPlugin = localizedFormatExports;

var isBetweenExports = {};
var isBetween = {
  get exports(){ return isBetweenExports; },
  set exports(v){ isBetweenExports = v; },
};

(function (module, exports) {
	!function(e,i){module.exports=i();}(commonjsGlobal,(function(){return function(e,i,t){i.prototype.isBetween=function(e,i,s,f){var n=t(e),o=t(i),r="("===(f=f||"()")[0],u=")"===f[1];return (r?this.isAfter(n,s):!this.isBefore(n,s))&&(u?this.isBefore(o,s):!this.isAfter(o,s))||(r?this.isBefore(n,s):!this.isAfter(n,s))&&(u?this.isAfter(o,s):!this.isBefore(o,s))};}}));
} (isBetween));

var isBetweenPlugin = isBetweenExports;

defaultDayjs.extend(customParseFormatPlugin);
defaultDayjs.extend(localizedFormatPlugin);
defaultDayjs.extend(isBetweenPlugin);
var withLocale = function (dayjs, locale) { return (!locale ? dayjs : function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return dayjs.apply(void 0, args).locale(locale);
}); };
var defaultFormats$4 = {
    normalDateWithWeekday: "ddd, MMM D",
    normalDate: "D MMMM",
    shortDate: "MMM D",
    monthAndDate: "MMMM D",
    dayOfMonth: "D",
    year: "YYYY",
    month: "MMMM",
    monthShort: "MMM",
    monthAndYear: "MMMM YYYY",
    weekday: "dddd",
    weekdayShort: "ddd",
    minutes: "mm",
    hours12h: "hh",
    hours24h: "HH",
    seconds: "ss",
    fullTime: "LT",
    fullTime12h: "hh:mm A",
    fullTime24h: "HH:mm",
    fullDate: "ll",
    fullDateWithWeekday: "dddd, LL",
    fullDateTime: "lll",
    fullDateTime12h: "ll hh:mm A",
    fullDateTime24h: "ll HH:mm",
    keyboardDate: "L",
    keyboardDateTime: "L LT",
    keyboardDateTime12h: "L hh:mm A",
    keyboardDateTime24h: "L HH:mm",
};
var DayjsUtils = /** @class */ (function () {
    function DayjsUtils(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, locale = _b.locale, formats = _b.formats, instance = _b.instance;
        this.lib = "dayjs";
        this.is12HourCycleInCurrentLocale = function () {
            var _a, _b;
            /* istanbul ignore next */
            return /A|a/.test((_b = (_a = _this.rawDayJsInstance.Ls[_this.locale || "en"]) === null || _a === void 0 ? void 0 : _a.formats) === null || _b === void 0 ? void 0 : _b.LT);
        };
        this.getCurrentLocaleCode = function () {
            return _this.locale || "en";
        };
        this.getFormatHelperText = function (format) {
            // @see https://github.com/iamkun/dayjs/blob/dev/src/plugin/localizedFormat/index.js
            var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?)|./g;
            return format
                .match(localFormattingTokens)
                .map(function (token) {
                var _a, _b;
                var firstCharacter = token[0];
                if (firstCharacter === "L") {
                    /* istanbul ignore next */
                    return (_b = (_a = _this.rawDayJsInstance.Ls[_this.locale || "en"]) === null || _a === void 0 ? void 0 : _a.formats[token]) !== null && _b !== void 0 ? _b : token;
                }
                return token;
            })
                .join("")
                .replace(/a/gi, "(a|p)m")
                .toLocaleLowerCase();
        };
        this.parseISO = function (isoString) {
            return _this.dayjs(isoString);
        };
        this.toISO = function (value) {
            return value.toISOString();
        };
        this.parse = function (value, format) {
            if (value === "") {
                return null;
            }
            return _this.dayjs(value, format, _this.locale, true);
        };
        this.date = function (value) {
            if (value === null) {
                return null;
            }
            return _this.dayjs(value);
        };
        this.toJsDate = function (value) {
            return value.toDate();
        };
        this.isValid = function (value) {
            return _this.dayjs(value).isValid();
        };
        this.isNull = function (date) {
            return date === null;
        };
        this.getDiff = function (date, comparing, units) {
            return date.diff(comparing, units);
        };
        this.isAfter = function (date, value) {
            return date.isAfter(value);
        };
        this.isBefore = function (date, value) {
            return date.isBefore(value);
        };
        this.isAfterDay = function (date, value) {
            return date.isAfter(value, "day");
        };
        this.isBeforeDay = function (date, value) {
            return date.isBefore(value, "day");
        };
        this.isBeforeYear = function (date, value) {
            return date.isBefore(value, "year");
        };
        this.isAfterYear = function (date, value) {
            return date.isAfter(value, "year");
        };
        this.startOfDay = function (date) {
            return date.startOf("day");
        };
        this.endOfDay = function (date) {
            return date.endOf("day");
        };
        this.format = function (date, formatKey) {
            return _this.formatByString(date, _this.formats[formatKey]);
        };
        this.formatByString = function (date, formatString) {
            return _this.dayjs(date).format(formatString);
        };
        this.formatNumber = function (numberToFormat) {
            return numberToFormat;
        };
        this.getHours = function (date) {
            return date.hour();
        };
        this.addSeconds = function (date, count) {
            return count < 0
                ? date.subtract(Math.abs(count), "second")
                : date.add(count, "second");
        };
        this.addMinutes = function (date, count) {
            return count < 0
                ? date.subtract(Math.abs(count), "minute")
                : date.add(count, "minute");
        };
        this.addHours = function (date, count) {
            return count < 0
                ? date.subtract(Math.abs(count), "hour")
                : date.add(count, "hour");
        };
        this.addDays = function (date, count) {
            return count < 0
                ? date.subtract(Math.abs(count), "day")
                : date.add(count, "day");
        };
        this.addWeeks = function (date, count) {
            return count < 0
                ? date.subtract(Math.abs(count), "week")
                : date.add(count, "week");
        };
        this.addMonths = function (date, count) {
            return count < 0
                ? date.subtract(Math.abs(count), "month")
                : date.add(count, "month");
        };
        this.addYears = function (date, count) {
            return count < 0
                ? date.subtract(Math.abs(count), "year")
                : date.add(count, "year");
        };
        this.setMonth = function (date, count) {
            return date.set("month", count);
        };
        this.setHours = function (date, count) {
            return date.set("hour", count);
        };
        this.getMinutes = function (date) {
            return date.minute();
        };
        this.setMinutes = function (date, count) {
            return date.set("minute", count);
        };
        this.getSeconds = function (date) {
            return date.second();
        };
        this.setSeconds = function (date, count) {
            return date.set("second", count);
        };
        this.getMonth = function (date) {
            return date.month();
        };
        this.getDate = function (date) {
            return date.date();
        };
        this.setDate = function (date, count) {
            return date.set("date", count);
        };
        this.getDaysInMonth = function (date) {
            return date.daysInMonth();
        };
        this.isSameDay = function (date, comparing) {
            return date.isSame(comparing, "day");
        };
        this.isSameMonth = function (date, comparing) {
            return date.isSame(comparing, "month");
        };
        this.isSameYear = function (date, comparing) {
            return date.isSame(comparing, "year");
        };
        this.isSameHour = function (date, comparing) {
            return date.isSame(comparing, "hour");
        };
        this.getMeridiemText = function (ampm) {
            return ampm === "am" ? "AM" : "PM";
        };
        this.startOfYear = function (date) {
            return date.startOf("year");
        };
        this.endOfYear = function (date) {
            return date.endOf("year");
        };
        this.startOfMonth = function (date) {
            return date.startOf("month");
        };
        this.endOfMonth = function (date) {
            return date.endOf("month");
        };
        this.startOfWeek = function (date) {
            return date.startOf("week");
        };
        this.endOfWeek = function (date) {
            return date.endOf("week");
        };
        this.getNextMonth = function (date) {
            return date.add(1, "month");
        };
        this.getPreviousMonth = function (date) {
            return date.subtract(1, "month");
        };
        this.getMonthArray = function (date) {
            var firstMonth = date.startOf("year");
            var monthArray = [firstMonth];
            while (monthArray.length < 12) {
                var prevMonth = monthArray[monthArray.length - 1];
                monthArray.push(_this.getNextMonth(prevMonth));
            }
            return monthArray;
        };
        this.getYear = function (date) {
            return date.year();
        };
        this.setYear = function (date, year) {
            return date.set("year", year);
        };
        this.mergeDateAndTime = function (date, time) {
            return date.hour(time.hour()).minute(time.minute()).second(time.second());
        };
        this.getWeekdays = function () {
            var start = _this.dayjs().startOf("week");
            return [0, 1, 2, 3, 4, 5, 6].map(function (diff) {
                return _this.formatByString(start.add(diff, "day"), "dd");
            });
        };
        this.isEqual = function (value, comparing) {
            if (value === null && comparing === null) {
                return true;
            }
            return _this.dayjs(value).isSame(comparing);
        };
        this.getWeekArray = function (date) {
            var start = _this.dayjs(date).startOf("month").startOf("week");
            var end = _this.dayjs(date).endOf("month").endOf("week");
            var count = 0;
            var current = start;
            var nestedWeeks = [];
            while (current.isBefore(end)) {
                var weekNumber = Math.floor(count / 7);
                nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
                nestedWeeks[weekNumber].push(current);
                current = current.add(1, "day");
                count += 1;
            }
            return nestedWeeks;
        };
        this.getYearRange = function (start, end) {
            var startDate = _this.dayjs(start).startOf("year");
            var endDate = _this.dayjs(end).endOf("year");
            var years = [];
            var current = startDate;
            while (current.isBefore(endDate)) {
                years.push(current);
                current = current.add(1, "year");
            }
            return years;
        };
        this.isWithinRange = function (date, _a) {
            var start = _a[0], end = _a[1];
            return date.isBetween(start, end, null, "[]");
        };
        this.rawDayJsInstance = instance || defaultDayjs;
        this.dayjs = withLocale(this.rawDayJsInstance, locale);
        this.locale = locale;
        this.formats = Object.assign({}, defaultFormats$4, formats);
    }
    return DayjsUtils;
}());

const buildWarning = (message, gravity = 'warning') => {
    let alreadyWarned = false;
    const cleanMessage = Array.isArray(message) ? message.join('\n') : message;
    return () => {
        if (!alreadyWarned) {
            alreadyWarned = true;
            if (gravity === 'error') {
                console.error(cleanMessage);
            }
            else {
                console.warn(cleanMessage);
            }
        }
    };
};

const localeNotFoundWarning = buildWarning([
    'Your locale has not been found.',
    'Either the locale key is not a supported one. Locales supported by dayjs are available here: https://github.com/iamkun/dayjs/tree/dev/src/locale',
    "Or you forget to import the locale with `require('dayjs/locale/{localeUsed}')`",
    'fallback on English locale',
]);
const formatTokenMap$4 = {
    YY: 'year',
    YYYY: 'year',
    M: 'month',
    MM: 'month',
    MMM: { sectionName: 'month', contentType: 'letter' },
    MMMM: { sectionName: 'month', contentType: 'letter' },
    D: 'day',
    DD: 'day',
    H: 'hours',
    HH: 'hours',
    h: 'hours',
    hh: 'hours',
    m: 'minutes',
    mm: 'minutes',
    s: 'seconds',
    ss: 'seconds',
    A: 'meridiem',
    a: 'meridiem',
};
class AdapterDayjs extends DayjsUtils {
    constructor(options) {
        super(options);
        this.isMUIAdapter = true;
        this.formatTokenMap = formatTokenMap$4;
        this.escapedCharacters = { start: '[', end: ']' };
        /**
         * The current getFormatHelperText method uses an outdated format parsing logic.
         * We should use this one in the future to support all localized formats.
         */
        this.expandFormat = (format) => {
            const localeObject = this.rawDayJsInstance.Ls[this.locale || 'en'];
            if (localeObject === undefined) {
                localeNotFoundWarning();
            }
            const localeFormats = localeObject === undefined ? this.rawDayJsInstance.Ls.en.formats : localeObject.formats;
            // @see https://github.com/iamkun/dayjs/blob/dev/src/plugin/localizedFormat/index.js
            const t = (formatBis) => formatBis.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (_, a, b) => a || b.slice(1));
            return format.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (_, a, b) => {
                const B = b && b.toUpperCase();
                return (a ||
                    localeFormats[b] ||
                    t(localeFormats[B]));
            });
        };
        // Redefined here just to show how it can be written using expandFormat
        this.getFormatHelperText = (format) => {
            return this.expandFormat(format).replace(/a/gi, '(a|p)m').toLocaleLowerCase();
        };
        this.getWeekNumber = (date) => {
            return date.week();
        };
        this.rawDayJsInstance.extend(weekOfYearExports);
    }
}

// these aren't really private, but nor are they really useful to document

/**
 * @private
 */
class LuxonError extends Error {}

/**
 * @private
 */
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}

/**
 * @private
 */
class ConflictingSpecificationError extends LuxonError {}

/**
 * @private
 */
class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}

/**
 * @private
 */
class InvalidArgumentError extends LuxonError {}

/**
 * @private
 */
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}

/**
 * @private
 */

const n = "numeric",
  s = "short",
  l = "long";

const DATE_SHORT = {
  year: n,
  month: n,
  day: n,
};

const DATE_MED = {
  year: n,
  month: s,
  day: n,
};

const DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
};

const DATE_FULL = {
  year: n,
  month: l,
  day: n,
};

const DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
};

const TIME_SIMPLE = {
  hour: n,
  minute: n,
};

const TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
};

const TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s,
};

const TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l,
};

const TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23",
};

const TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
};

const TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s,
};

const TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l,
};

const DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
};

const DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n,
};

const DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
};

const DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n,
};

const DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n,
};

const DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s,
};

const DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s,
};

const DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l,
};

const DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l,
};

/**
 * @interface
 */
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }

  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }

  get ianaName() {
    return this.name;
  }

  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }

  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}

let singleton$1 = null;

/**
 * Represents the local zone for this JavaScript environment.
 * @implements {Zone}
 */
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }

  /** @override **/
  get type() {
    return "system";
  }

  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }

  /** @override **/
  get isValid() {
    return true;
  }
}

let dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short",
    });
  }
  return dtfCache[zone];
}

const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6,
};

function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""),
    parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted),
    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}

function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];

    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}

let ianaZoneCache = {};
/**
 * A zone identified by an IANA identifier, like America/New_York
 * @implements {Zone}
 */
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }

  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }

  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s) {
    return this.isValidZone(s);
  }

  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }

  constructor(name) {
    super();
    /** @private **/
    this.zoneName = name;
    /** @private **/
    this.valid = IANAZone.isValidZone(name);
  }

  /** @override **/
  get type() {
    return "iana";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }

  /** @override **/
  offset(ts) {
    const date = new Date(ts);

    if (isNaN(date)) return NaN;

    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts
      ? partsOffset(dtf, date)
      : hackyOffset(dtf, date);

    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }

    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat
    const adjustedHour = hour === 24 ? 0 : hour;

    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0,
    });

    let asTS = +date;
    const over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }

  /** @override **/
  get isValid() {
    return this.valid;
  }
}

// todo - remap caching

let intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}

let intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}

let intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}

let intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}

let sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}

function parseLocaleString(localeStr) {
  // I really want to avoid writing a BCP 47 parser
  // see, e.g. https://github.com/wooorm/bcp-47
  // Instead, we'll do this:

  // a) if the string has no -u extensions, just leave it alone
  // b) if it does, use Intl to resolve everything
  // c) if Intl fails, try again without the -u

  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    const smaller = localeStr.substring(0, uIndex);
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e) {
      options = getCachedDTF(smaller).resolvedOptions();
    }

    const { numberingSystem, calendar } = options;
    // return the smaller one so that we can append the calendar and numbering overrides to it
    return [smaller, numberingSystem, calendar];
  }
}

function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    localeStr += "-u";

    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }

    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}

function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }
  return ms;
}

function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}

function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  const mode = loc.listingMode(defaultOK);

  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}

function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return (
      loc.numberingSystem === "latn" ||
      !loc.locale ||
      loc.locale.startsWith("en") ||
      new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn"
    );
  }
}

/**
 * @private
 */

class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;

    const { padTo, floor, ...otherOpts } = opts;

    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }

  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
}

/**
 * @private
 */

class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;

    let z;
    if (dt.zone.isUniversal) {
      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.
      // That is why fixed-offset TZ is set to that unless it is:
      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.
      // 2. Unsupported by the browser:
      //    - some do not support Etc/
      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.
        // So we have to make do. Two cases:
        // 1. The format options tell us to show the zone. We can't do that, so the best
        // we can do is format the date in UTC.
        // 2. The format options don't tell us to show the zone. Then we can adjust them
        // the time and tell the formatter to show it to us in UTC, so that the time is right
        // and the bad zone doesn't show up.
        z = "UTC";
        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);
        }
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }

    const intlOpts = { ...this.opts };
    if (z) {
      intlOpts.timeZone = z;
    }
    this.dtf = getCachedDTF(intl, intlOpts);
  }

  format() {
    return this.dtf.format(this.dt.toJSDate());
  }

  formatToParts() {
    return this.dtf.formatToParts(this.dt.toJSDate());
  }

  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}

/**
 * @private
 */
class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }

  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }

  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}

/**
 * @private
 */

class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }

  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }

  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }

  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }

  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);

    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);

    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};

    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }

  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }

    return this.fastNumbersCached;
  }

  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness =
      (this.numberingSystem === null || this.numberingSystem === "latn") &&
      (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }

  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  }

  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }

  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }

  months(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length },
        formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }

  weekdays(length, format = false, defaultOK = true) {
    return listStuff(this, length, defaultOK, weekdays, () => {
      const intl = format
          ? { weekday: length, year: "numeric", month: "long", day: "numeric" }
          : { weekday: length },
        formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>
          this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }

  meridiems(defaultOK = true) {
    return listStuff(
      this,
      undefined,
      defaultOK,
      () => meridiems,
      () => {
        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
        // for AM and PM. This is probably wrong, but it's makes parsing way easier.
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }

        return this.meridiemCache;
      }
    );
  }

  eras(length, defaultOK = true) {
    return listStuff(this, length, defaultOK, eras, () => {
      const intl = { era: length };

      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) =>
          this.extract(dt, intl, "era")
        );
      }

      return this.eraCache[length];
    });
  }

  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts),
      results = df.formatToParts(),
      matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }

  numberFormatter(opts = {}) {
    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }

  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }

  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }

  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }

  isEnglish() {
    return (
      this.locale === "en" ||
      this.locale.toLowerCase() === "en-us" ||
      new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")
    );
  }

  equals(other) {
    return (
      this.locale === other.locale &&
      this.numberingSystem === other.numberingSystem &&
      this.outputCalendar === other.outputCalendar
    );
  }
}

let singleton = null;

/**
 * A zone with a fixed offset (meaning no DST)
 * @implements {Zone}
 */
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }

  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }

  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s) {
    if (s) {
      const r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }

  constructor(offset) {
    super();
    /** @private **/
    this.fixed = offset;
  }

  /** @override **/
  get type() {
    return "fixed";
  }

  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }

  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }

  /** @override **/
  offsetName() {
    return this.name;
  }

  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }

  /** @override **/
  get isUniversal() {
    return true;
  }

  /** @override **/
  offset() {
    return this.fixed;
  }

  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }

  /** @override **/
  get isValid() {
    return true;
  }
}

/**
 * A zone that failed to parse. You should never need to instantiate this.
 * @implements {Zone}
 */
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    /**  @private */
    this.zoneName = zoneName;
  }

  /** @override **/
  get type() {
    return "invalid";
  }

  /** @override **/
  get name() {
    return this.zoneName;
  }

  /** @override **/
  get isUniversal() {
    return false;
  }

  /** @override **/
  offsetName() {
    return null;
  }

  /** @override **/
  formatOffset() {
    return "";
  }

  /** @override **/
  offset() {
    return NaN;
  }

  /** @override **/
  equals() {
    return false;
  }

  /** @override **/
  get isValid() {
    return false;
  }
}

/**
 * @private
 */

function normalizeZone(input, defaultZone) {
  if (isUndefined(input) || input === null) {
    return defaultZone;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default") return defaultZone;
    else if (lowered === "local" || lowered === "system") return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
    else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    // This is dumb, but the instanceof check above doesn't seem to really work
    // so we're duck checking it
    return input;
  } else {
    return new InvalidZone(input);
  }
}

let now = () => Date.now(),
  defaultZone = "system",
  defaultLocale = null,
  defaultNumberingSystem = null,
  defaultOutputCalendar = null,
  twoDigitCutoffYear = 60,
  throwOnInvalid;

/**
 * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
 */
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }

  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n) {
    now = n;
  }

  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }

  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }

  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }

  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }

  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }

  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }

  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }

  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }

  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }

  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpretted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpretted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpretted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }

  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }

  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }

  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
}

/*
  This is just a junk drawer, containing anything used across multiple classes.
  Because Luxon is small(ish), this should stay small and we won't worry about splitting
  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
*/

/**
 * @private
 */

// TYPES

function isUndefined(o) {
  return typeof o === "undefined";
}

function isNumber(o) {
  return typeof o === "number";
}

function isInteger$1(o) {
  return typeof o === "number" && o % 1 === 0;
}

function isString(o) {
  return typeof o === "string";
}

function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}

// CAPABILITIES

function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}

// OBJECTS AND ARRAYS

function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}

function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return undefined;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}

function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}

function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// NUMBERS AND STRINGS

function integerBetween(thing, bottom, top) {
  return isInteger$1(thing) && thing >= bottom && thing <= top;
}

// x % n but takes the sign of n instead of x
function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}

function padStart(input, n = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n, "0");
  } else {
    padded = ("" + input).padStart(n, "0");
  }
  return padded;
}

function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseInt(string, 10);
  }
}

function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseFloat(string);
  }
}

function parseMillis(fraction) {
  // Return undefined (instead of 0) in these cases, where fraction is not set
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return undefined;
  } else {
    const f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}

function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits,
    rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}

// DATE BASICS

function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}

function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1,
    modYear = year + (month - modMonth) / 12;

  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}

// covert a calendar object to a local timestamp (epoch, but with the offset baked in)
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );

  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  return +d;
}

function weeksInWeekYear(weekYear) {
  const p1 =
      (weekYear +
        Math.floor(weekYear / 4) -
        Math.floor(weekYear / 100) +
        Math.floor(weekYear / 400)) %
      7,
    last = weekYear - 1,
    p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}

function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
}

// PARSING

function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts),
    intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
    };

  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }

  const modified = { timeZoneName: offsetFormat, ...intlOpts };

  const parsed = new Intl.DateTimeFormat(locale, modified)
    .formatToParts(date)
    .find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}

// signedOffset('-5', '30') -> -330
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);

  // don't || this because we want to preserve -0
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }

  const offMin = parseInt(offMinuteStr, 10) || 0,
    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}

// COERCION

function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}

function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty$1(obj, u)) {
      const v = obj[u];
      if (v === undefined || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}

function formatOffset(offset, format) {
  const hours = Math.trunc(Math.abs(offset / 60)),
    minutes = Math.trunc(Math.abs(offset % 60)),
    sign = offset >= 0 ? "+" : "-";

  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}

function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

/**
 * @private
 */

const monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
];

const monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];

const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];

function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}

const weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday",
];

const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];

function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}

const meridiems = ["AM", "PM"];

const erasLong = ["Before Christ", "Anno Domini"];

const erasShort = ["BC", "AD"];

const erasNarrow = ["B", "A"];

function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}

function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}

function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}

function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}

function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}

function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."],
  };

  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;

  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
    }
  }

  const isInPast = Object.is(count, -0) || count < 0,
    fmtValue = Math.abs(count),
    singular = fmtValue === 1,
    lilUnits = units[unit],
    fmtUnit = narrow
      ? singular
        ? lilUnits[1]
        : lilUnits[2] || lilUnits[1]
      : singular
      ? units[unit][0]
      : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

function stringifyTokens(splits, tokenToString) {
  let s = "";
  for (const token of splits) {
    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }
  return s;
}

const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS,
};

/**
 * @private
 */

class Formatter {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }

  static parseFormat(fmt) {
    let current = null,
      currentFull = "",
      bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: false, val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }

    if (currentFull.length > 0) {
      splits.push({ literal: bracketed, val: currentFull });
    }

    return splits;
  }

  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }

  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }

  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }

  formatDateTime(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }

  formatDateTimeParts(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.formatToParts();
  }

  resolvedOptions(dt, opts = {}) {
    const df = this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.resolvedOptions();
  }

  num(n, p = 0) {
    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }

    const opts = { ...this.opts };

    if (p > 0) {
      opts.padTo = p;
    }

    return this.loc.numberFormatter(opts).format(n);
  }

  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en",
      useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
      string = (opts, extract) => this.loc.extract(dt, opts, extract),
      formatOffset = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }

        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      },
      meridiem = () =>
        knownEnglish
          ? meridiemForDateTime(dt)
          : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"),
      month = (length, standalone) =>
        knownEnglish
          ? monthForDateTime(dt, length)
          : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"),
      weekday = (length, standalone) =>
        knownEnglish
          ? weekdayForDateTime(dt, length)
          : string(
              standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
              "weekday"
            ),
      maybeMacro = (token) => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      },
      era = (length) =>
        knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"),
      tokenToString = (token) => {
        // Where possible: http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles
        switch (token) {
          // ms
          case "S":
            return this.num(dt.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this.num(dt.millisecond, 3);
          // seconds
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          // fractional seconds
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          // minutes
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          // hours
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          // offset
          case "Z":
            // like +6
            return formatOffset({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            // like +06:00
            return formatOffset({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            // like +0600
            return formatOffset({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            // like EST
            return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
          case "ZZZZZ":
            // like Eastern Standard Time
            return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
          // zone
          case "z":
            // like America/New_York
            return dt.zoneName;
          // meridiems
          case "a":
            return meridiem();
          // dates
          case "d":
            return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
          // weekdays - standalone
          case "c":
            // like 1
            return this.num(dt.weekday);
          case "ccc":
            // like 'Tues'
            return weekday("short", true);
          case "cccc":
            // like 'Tuesday'
            return weekday("long", true);
          case "ccccc":
            // like 'T'
            return weekday("narrow", true);
          // weekdays - format
          case "E":
            // like 1
            return this.num(dt.weekday);
          case "EEE":
            // like 'Tues'
            return weekday("short", false);
          case "EEEE":
            // like 'Tuesday'
            return weekday("long", false);
          case "EEEEE":
            // like 'T'
            return weekday("narrow", false);
          // months - standalone
          case "L":
            // like 1
            return useDateTimeFormatter
              ? string({ month: "numeric", day: "numeric" }, "month")
              : this.num(dt.month);
          case "LL":
            // like 01, doesn't seem to work
            return useDateTimeFormatter
              ? string({ month: "2-digit", day: "numeric" }, "month")
              : this.num(dt.month, 2);
          case "LLL":
            // like Jan
            return month("short", true);
          case "LLLL":
            // like January
            return month("long", true);
          case "LLLLL":
            // like J
            return month("narrow", true);
          // months - format
          case "M":
            // like 1
            return useDateTimeFormatter
              ? string({ month: "numeric" }, "month")
              : this.num(dt.month);
          case "MM":
            // like 01
            return useDateTimeFormatter
              ? string({ month: "2-digit" }, "month")
              : this.num(dt.month, 2);
          case "MMM":
            // like Jan
            return month("short", false);
          case "MMMM":
            // like January
            return month("long", false);
          case "MMMMM":
            // like J
            return month("narrow", false);
          // years
          case "y":
            // like 2014
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
          case "yy":
            // like 14
            return useDateTimeFormatter
              ? string({ year: "2-digit" }, "year")
              : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            // like 0012
            return useDateTimeFormatter
              ? string({ year: "numeric" }, "year")
              : this.num(dt.year, 4);
          case "yyyyyy":
            // like 000012
            return useDateTimeFormatter
              ? string({ year: "numeric" }, "year")
              : this.num(dt.year, 6);
          // eras
          case "G":
            // like AD
            return era("short");
          case "GG":
            // like Anno Domini
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            // like 1
            return this.num(dt.quarter);
          case "qq":
            // like 01
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };

    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }

  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      tokenToString = (lildur) => (token) => {
        const mapped = tokenToField(token);
        if (mapped) {
          return this.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      },
      tokens = Formatter.parseFormat(fmt),
      realTokens = tokens.reduce(
        (found, { literal, val }) => (literal ? found : found.concat(val)),
        []
      ),
      collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}

class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }

  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}

/*
 * This file handles parsing for well-specified formats. Here's how it works:
 * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
 * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
 * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
 * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
 * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
 * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
 */

const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}

function combineExtractors(...extractors) {
  return (m) =>
    extractors
      .reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      )
      .slice(0, 2);
}

function parse$1(s, ...patterns) {
  if (s == null) {
    return [null, null];
  }

  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}

function simpleParse(...keys) {
  return (match, cursor) => {
    const ret = {};
    let i;

    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}

// ISO and SQL parsing
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
const isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
const isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
const isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const isoOrdinalRegex = /(\d{4})-?(\d{3})/;
const extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
const extractISOOrdinalData = simpleParse("year", "ordinal");
const sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/; // dumbed-down version of the ISO one
const sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
const sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);

function int(match, pos, fallback) {
  const m = match[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}

function extractISOYmd(match, cursor) {
  const item = {
    year: int(match, cursor),
    month: int(match, cursor + 1, 1),
    day: int(match, cursor + 2, 1),
  };

  return [item, null, cursor + 3];
}

function extractISOTime(match, cursor) {
  const item = {
    hours: int(match, cursor, 0),
    minutes: int(match, cursor + 1, 0),
    seconds: int(match, cursor + 2, 0),
    milliseconds: parseMillis(match[cursor + 3]),
  };

  return [item, null, cursor + 4];
}

function extractISOOffset(match, cursor) {
  const local = !match[cursor] && !match[cursor + 1],
    fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
    zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}

function extractIANAZone(match, cursor) {
  const zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
  return [{}, zone, cursor + 1];
}

// ISO time parsing

const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);

// ISO duration parsing

const isoDuration =
  /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;

function extractISODuration(match) {
  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =
    match;

  const hasNegativePrefix = s[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";

  const maybeNegate = (num, force = false) =>
    num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;

  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds),
    },
  ];
}

// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
// and not just that we're in -240 *right now*. But since I don't think these are used that often
// I'm just going to ignore that
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60,
};

function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr),
  };

  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday =
      weekdayStr.length > 3
        ? weekdaysLong.indexOf(weekdayStr) + 1
        : weekdaysShort.indexOf(weekdayStr) + 1;
  }

  return result;
}

// RFC 2822/5322
const rfc2822 =
  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

function extractRFC2822(match) {
  const [
      ,
      weekdayStr,
      dayStr,
      monthStr,
      yearStr,
      hourStr,
      minuteStr,
      secondStr,
      obsOffset,
      milOffset,
      offHourStr,
      offMinuteStr,
    ] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);

  let offset;
  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = signedOffset(offHourStr, offMinuteStr);
  }

  return [result, new FixedOffsetZone(offset)];
}

function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s
    .replace(/\([^)]*\)|[\n\t]/g, " ")
    .replace(/(\s\s+)/g, " ")
    .trim();
}

// http date

const rfc1123 =
    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
  rfc850 =
    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
  ascii =
    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

function extractRFC1123Or850(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

function extractASCII(match) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,
    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);

const extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
const extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);

/*
 * @private
 */

function parseISODate(s) {
  return parse$1(
    s,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}

function parseRFC2822Date(s) {
  return parse$1(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
}

function parseHTTPDate(s) {
  return parse$1(
    s,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}

function parseISODuration(s) {
  return parse$1(s, [isoDuration, extractISODuration]);
}

const extractISOTimeOnly = combineExtractors(extractISOTime);

function parseISOTimeOnly(s) {
  return parse$1(s, [isoTimeOnly, extractISOTimeOnly]);
}

const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);

const extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);

function parseSQL(s) {
  return parse$1(
    s,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

const INVALID$2 = "Invalid Duration";

// unit conversion constants
const lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000,
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000,
    },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },
    minutes: { seconds: 60, milliseconds: 60 * 1000 },
    seconds: { milliseconds: 1000 },
  },
  casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000,
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000,
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000,
    },

    ...lowOrderMatrix,
  },
  daysInYearAccurate = 146097.0 / 400,
  daysInMonthAccurate = 146097.0 / 4800,
  accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: (daysInYearAccurate * 24) / 4,
      minutes: (daysInYearAccurate * 24 * 60) / 4,
      seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,
      milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,
    },
    ...lowOrderMatrix,
  };

// units ordered by size
const orderedUnits$1 = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds",
];

const reverseUnits = orderedUnits$1.slice(0).reverse();

// clone really means "create another instance just like this one, but with these changes"
function clone$1(dur, alts, clear = false) {
  // deep merge for vals
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...(alts.values || {}) },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix,
  };
  return new Duration(conf);
}

function antiTrunc(n) {
  return n < 0 ? Math.floor(n) : Math.ceil(n);
}

// NB: mutates parameters
function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  const conv = matrix[toUnit][fromUnit],
    raw = fromMap[fromUnit] / conv,
    sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
    // ok, so this is wild, but see the matrix in the tests
    added =
      !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
}

// NB: mutates parameters
function normalizeValues(matrix, vals) {
  reverseUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}

// Remove all properties with a value of 0 from an object
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}

/**
 * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.
 *
 * Here is a brief overview of commonly used methods and getters in Duration:
 *
 * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
 * * **Unit values** See the {@link Duration#years}, {@link Duration#months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.
 * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.
 * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.
 * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}
 *
 * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
 */
class Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;

    if (config.matrix) {
      matrix = config.matrix;
    }

    /**
     * @access private
     */
    this.values = config.values;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.matrix = matrix;
    /**
     * @access private
     */
    this.isLuxonDuration = true;
  }

  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }

  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${
          obj === null ? "null" : typeof obj
        }`
      );
    }

    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix,
    });
  }

  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }

  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }

  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }

    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }

  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds",
    }[unit ? unit.toLowerCase() : unit];

    if (!normalized) throw new InvalidUnitError(unit);

    return normalized;
  }

  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return (o && o.isLuxonDuration) || false;
  }

  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false,
    };
    return this.isValid
      ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt)
      : INVALID$2;
  }

  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
   * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    const l = orderedUnits$1
      .map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc
          .numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) })
          .format(val);
      })
      .filter((n) => n);

    return this.loc
      .listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts })
      .format(l);
  }

  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) return null;

    let s = "P";
    if (this.years !== 0) s += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s += this.weeks + "W";
    if (this.days !== 0) s += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s += "T";
    if (this.hours !== 0) s += this.hours + "H";
    if (this.minutes !== 0) s += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      // this will handle "floating point madness" by removing extra decimal places
      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
      s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
    if (s === "P") s += "T0S";
    return s;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;

    const millis = this.toMillis();
    if (millis < 0 || millis >= 86400000) return null;

    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
    };

    const value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");

    let fmt = opts.format === "basic" ? "hhmm" : "hh:mm";

    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";
      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }

    let str = value.toFormat(fmt);

    if (opts.includePrefix) {
      str = "T" + str;
    }

    return str;
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }

  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.as("milliseconds");
  }

  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) return this;

    const dur = Duration.fromDurationLike(duration),
      result = {};

    for (const k of orderedUnits$1) {
      if (hasOwnProperty$1(dur.values, k) || hasOwnProperty$1(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }

    return clone$1(this, { values: result }, true);
  }

  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) return this;

    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }

  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid) return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone$1(this, { values: result }, true);
  }

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }

  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) return this;

    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone$1(this, { values: mixed });
  }

  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone$1(this, opts);
  }

  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }

  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$1(this, { values: vals }, true);
  }

  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$1(this, { values: vals }, true);
  }

  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;

    if (units.length === 0) {
      return this;
    }

    units = units.map((u) => Duration.normalizeUnit(u));

    const built = {},
      accumulated = {},
      vals = this.toObject();
    let lastUnit;

    for (const k of orderedUnits$1) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;

        let own = 0;

        // anything we haven't boiled down yet should get boiled to this unit
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }

        // plus anything that's already in this unit
        if (isNumber(vals[k])) {
          own += vals[k];
        }

        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1000 - i * 1000) / 1000;

        // plus anything further down the chain that should be rolled up in to this
        for (const down in vals) {
          if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        }
        // otherwise, keep it in the wings to boil it later
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }

    // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] +=
          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }

    return clone$1(this, { values: built }, true).normalize();
  }

  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }

  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone$1(this, { values: negated }, true);
  }

  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }

  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }

  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }

  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }

  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }

  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }

  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }

  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }

  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }

  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    if (!this.loc.equals(other.loc)) {
      return false;
    }

    function eq(v1, v2) {
      // Consider 0 and undefined as equal
      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;
      return v1 === v2;
    }

    for (const u of orderedUnits$1) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}

const INVALID$1 = "Invalid Interval";

// checks if the start is equal to or before the end
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}

/**
 * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
 *
 * Here is a brief overview of the most commonly used methods and getters in Interval:
 *
 * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.
 * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.
 * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.
 * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval.merge}, {@link Interval.xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.
 * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}
 * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.
 */
class Interval {
  /**
   * @private
   */
  constructor(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */
    this.e = config.end;
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.isLuxonInterval = true;
  }

  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }

    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }

  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start),
      builtEnd = friendlyDateTime(end);

    const validateError = validateStartEnd(builtStart, builtEnd);

    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd,
      });
    } else {
      return validateError;
    }
  }

  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }

  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration),
      dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }

  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s, e] = (text || "").split("/", 2);
    if (s && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s, opts);
        startIsValid = start.isValid;
      } catch (e) {
        startIsValid = false;
      }

      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e) {
        endIsValid = false;
      }

      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }

      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }

  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return (o && o.isLuxonInterval) || false;
  }

  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }

  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }

  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }

  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }

  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  count(unit = "milliseconds") {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit),
      end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }

  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }

  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }

  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }

  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }

  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }

  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }

  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes
        .map(friendlyDateTime)
        .filter((d) => this.contains(d))
        .sort(),
      results = [];
    let { s } = this,
      i = 0;

    while (s < this.e) {
      const added = sorted[i] || this.e,
        next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }

    return results;
  }

  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);

    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }

    let { s } = this,
      idx = 1,
      next;

    const results = [];
    while (s < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      idx += 1;
    }

    return results;
  }

  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }

  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }

  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }

  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }

  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }

  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    return this.s.equals(other.s) && this.e.equals(other.e);
  }

  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s = this.s > other.s ? this.s : other.s,
      e = this.e < other.e ? this.e : other.e;

    if (s >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  }

  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s = this.s < other.s ? this.s : other.s,
      e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  }

  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals
      .sort((a, b) => a.s - b.s)
      .reduce(
        ([sofar, current], item) => {
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        },
        [[], null]
      );
    if (final) {
      found.push(final);
    }
    return found;
  }

  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null,
      currentCount = 0;
    const results = [],
      ends = intervals.map((i) => [
        { time: i.s, type: "s" },
        { time: i.e, type: "e" },
      ]),
      flattened = Array.prototype.concat(...ends),
      arr = flattened.sort((a, b) => a.time - b.time);

    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;

      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }

        start = null;
      }
    }

    return Interval.merge(results);
  }

  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals))
      .map((i) => this.intersection(i))
      .filter((i) => i && !i.isEmpty());
  }

  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID$1;
    return `[${this.s.toISO()}  ${this.e.toISO()})`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }

  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }

  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime#toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  '  '] - a separator to place between the start and end representations
   * @return {string}
   */
  toFormat(dateFormat, { separator = "  " } = {}) {
    if (!this.isValid) return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }

  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }

  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}

/**
 * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
 */
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });

    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }

  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }

  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }

  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}
  ) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }

  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}
  ) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }

  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }

  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(
    length = "long",
    { locale = null, numberingSystem = null, locObj = null } = {}
  ) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }

  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }

  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }

  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { relative: false }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative() };
  }
}

function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(),
    ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}

function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - (days % 7)) / 7;
      },
    ],
    ["days", dayDiff],
  ];

  const results = {};
  let lowestOrder, highWater;

  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;

      let delta = differ(cursor, later);
      highWater = cursor.plus({ [unit]: delta });

      if (highWater > later) {
        cursor = cursor.plus({ [unit]: delta - 1 });
        delta -= 1;
      } else {
        cursor = highWater;
      }

      results[unit] = delta;
    }
  }

  return [cursor, results, highWater, lowestOrder];
}

function diff (earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);

  const remainingMillis = later - cursor;

  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );

  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }

    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }

  const duration = Duration.fromObject(results, opts);

  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts)
      .shiftTo(...lowerOrderUnits)
      .plus(duration);
  } else {
    return duration;
  }
}

const numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[|||||||||]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d",
};

const numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881],
};

const hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");

function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);

      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}

function digitRegex({ numberingSystem }, append = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
}

const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";

function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s]) => post(parseDigits(s)) };
}

const NBSP = String.fromCharCode(160);
const spaceOrNBSP = `[ ${NBSP}]`;
const spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");

function fixListRegex(s) {
  // make dots optional and also make them literal
  // make space and non breakable space characters interchangeable
  return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}

function stripInsensitivities(s) {
  return s
    .replace(/\./g, "") // ignore dots that were made optional
    .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
    .toLowerCase();
}

function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s]) =>
        strings.findIndex((i) => stripInsensitivities(s) === stripInsensitivities(i)) + startIndex,
    };
  }
}

function offset$2(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}

function simple(regex) {
  return { regex, deser: ([s]) => s };
}

function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}

function unitForToken(token, loc) {
  const one = digitRegex(loc),
    two = digitRegex(loc, "{2}"),
    three = digitRegex(loc, "{3}"),
    four = digitRegex(loc, "{4}"),
    six = digitRegex(loc, "{6}"),
    oneOrTwo = digitRegex(loc, "{1,2}"),
    oneToThree = digitRegex(loc, "{1,3}"),
    oneToSix = digitRegex(loc, "{1,6}"),
    oneToNine = digitRegex(loc, "{1,9}"),
    twoToFour = digitRegex(loc, "{2,4}"),
    fourToSix = digitRegex(loc, "{4,6}"),
    literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s]) => s, literal: true }),
    unitate = (t) => {
      if (token.literal) {
        return literal(t);
      }
      switch (t.val) {
        // era
        case "G":
          return oneOf(loc.eras("short", false), 0);
        case "GG":
          return oneOf(loc.eras("long", false), 0);
        // years
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        // months
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true, false), 1);
        case "MMMM":
          return oneOf(loc.months("long", true, false), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false, false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false, false), 1);
        // dates
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        // ordinals
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        // time
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        // meridiem
        case "a":
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        // weekNumber (W)
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        // weekdays
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false, false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false, false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true, false), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true, false), 1);
        // offset/zone
        case "Z":
        case "ZZ":
          return offset$2(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset$2(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don't have any way to figure out what they are
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        default:
          return literal(t);
      }
    };

  const unit = unitate(token) || {
    invalidReason: MISSING_FTP,
  };

  unit.token = token;

  return unit;
}

const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy",
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM",
  },
  day: {
    numeric: "d",
    "2-digit": "dd",
  },
  weekday: {
    short: "EEE",
    long: "EEEE",
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh",
  },
  minute: {
    numeric: "m",
    "2-digit": "mm",
  },
  second: {
    numeric: "s",
    "2-digit": "ss",
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ",
  },
};

function tokenForPart(part, locale, formatOpts) {
  const { type, value } = part;

  if (type === "literal") {
    return {
      literal: true,
      val: value,
    };
  }

  const style = formatOpts[type];

  let val = partTypeStyleToTokenVal[type];
  if (typeof val === "object") {
    val = val[style];
  }

  if (val) {
    return {
      literal: false,
      val,
    };
  }

  return undefined;
}

function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}

function match$1(input, regex, handlers) {
  const matches = input.match(regex);

  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty$1(handlers, i)) {
        const h = handlers[i],
          groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}

function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };

  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }

  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }

  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }

  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }

  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }

  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }

  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }

    return r;
  }, {});

  return [vals, zone, specificOffset];
}

let dummyDateTimeCache = null;

function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }

  return dummyDateTimeCache;
}

function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }

  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);

  if (tokens == null || tokens.includes(undefined)) {
    return token;
  }

  return tokens;
}

function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}

/**
 * @private
 */

function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
    units = tokens.map((t) => unitForToken(t, locale)),
    disqualifyingUnit = units.find((t) => t.invalidReason);

  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units),
      regex = RegExp(regexString, "i"),
      [rawMatches, matches] = match$1(input, regex, handlers),
      [result, zone, specificOffset] = matches
        ? dateTimeFromMatches(matches)
        : [null, null, undefined];
    if (hasOwnProperty$1(matches, "a") && hasOwnProperty$1(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}

function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}

function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }

  const formatter = Formatter.create(locale, formatOpts);
  const parts = formatter.formatDateTimeParts(getDummyDateTime());
  return parts.map((p) => tokenForPart(p, locale, formatOpts));
}

const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}

function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));

  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }

  const js = d.getUTCDay();

  return js === 0 ? 7 : js;
}

function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}

function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder,
    month0 = table.findIndex((i) => i < ordinal),
    day = ordinal - table[month0];
  return { month: month0 + 1, day };
}

/**
 * @private
 */

function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj,
    ordinal = computeOrdinal(year, month, day),
    weekday = dayOfWeek(year, month, day);

  let weekNumber = Math.floor((ordinal - weekday + 10) / 7),
    weekYear;

  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }

  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}

function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData,
    weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
    yearInDays = daysInYear(weekYear);

  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
    year;

  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }

  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}

function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}

function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}

function hasInvalidWeekData(obj) {
  const validYear = isInteger$1(obj.weekYear),
    validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
    validWeekday = integerBetween(obj.weekday, 1, 7);

  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}

function hasInvalidOrdinalData(obj) {
  const validYear = isInteger$1(obj.year),
    validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}

function hasInvalidGregorianData(obj) {
  const validYear = isInteger$1(obj.year),
    validMonth = integerBetween(obj.month, 1, 12),
    validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}

function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour =
      integerBetween(hour, 0, 23) ||
      (hour === 24 && minute === 0 && second === 0 && millisecond === 0),
    validMinute = integerBetween(minute, 0, 59),
    validSecond = integerBetween(second, 0, 59),
    validMillisecond = integerBetween(millisecond, 0, 999);

  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

const INVALID = "Invalid DateTime";
const MAX_DATE = 8.64e15;

function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}

// we cache week data on the DT object and this intermediates the cache
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}

// clone really means, "make a new object with these modifications". all "setters" really use this
// to create a new object while only changing some of the properties
function clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid,
  };
  return new DateTime({ ...current, ...alts, old: current });
}

// find the right offset a given local time. The o input is our guess, which determines which
// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)
function fixOffset(localTS, o, tz) {
  // Our UTC time is just a guess because our offset is just a guess
  let utcGuess = localTS - o * 60 * 1000;

  // Test whether the zone matches the offset for this ts
  const o2 = tz.offset(utcGuess);

  // If so, offset didn't change and we're done
  if (o === o2) {
    return [utcGuess, o];
  }

  // If not, change the ts by the difference in the offset
  utcGuess -= (o2 - o) * 60 * 1000;

  // If that gives us the local time we want, we're done
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }

  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time
  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
}

// convert an epoch timestamp into a calendar object with the given offset
function tsToObj(ts, offset) {
  ts += offset * 60 * 1000;

  const d = new Date(ts);

  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds(),
  };
}

// convert a calendar object to a epoch timestamp
function objToTS(obj, offset, zone) {
  return fixOffset(objToLocalTS(obj), offset, zone);
}

// create a new DT instance by adding a duration, adjusting for DSTs
function adjustTime(inst, dur) {
  const oPre = inst.o,
    year = inst.c.year + Math.trunc(dur.years),
    month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
    c = {
      ...inst.c,
      year,
      month,
      day:
        Math.min(inst.c.day, daysInMonth(year, month)) +
        Math.trunc(dur.days) +
        Math.trunc(dur.weeks) * 7,
    },
    millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds,
    }).as("milliseconds"),
    localTS = objToLocalTS(c);

  let [ts, o] = fixOffset(localTS, oPre, inst.zone);

  if (millisToAdd !== 0) {
    ts += millisToAdd;
    // that could have changed the offset by going over a DST, but we want to keep the ts the same
    o = inst.zone.offset(ts);
  }

  return { ts, o };
}

// helper useful in turning the results of parsing into real dates
// by handling the zone options
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0) {
    const interpretationZone = parsedZone || zone,
      inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset,
      });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}

// if you want to output a technical format (e.g. RFC 2822), this helper
// helps handle the details
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid
    ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true,
      }).formatDateTimeFromString(dt, format)
    : null;
}

function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0) c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);

  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}

function toISOTime(
  o,
  extended,
  suppressSeconds,
  suppressMilliseconds,
  includeOffset,
  extendedZone
) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }

  if (o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);

    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }

  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }

  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}

// defaults for unspecified units in the supported calendars
const defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  },
  defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  },
  defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  };

// Units in the supported calendars, sorted by bigness
const orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
  orderedWeekUnits = [
    "weekYear",
    "weekNumber",
    "weekday",
    "hour",
    "minute",
    "second",
    "millisecond",
  ],
  orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

// standardize case and plurality in units
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal",
  }[unit.toLowerCase()];

  if (!normalized) throw new InvalidUnitError(unit);

  return normalized;
}

// this is a dumbed down version of fromObject() that runs about 60% faster
// but doesn't do any validation, makes a bunch of assumptions about what units
// are present, and so on.
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone),
    loc = Locale.fromObject(opts),
    tsNow = Settings.now();

  let ts, o;

  // assume we have the higher-order units
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }

    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }

    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }

  return new DateTime({ ts, zone, loc, o });
}

function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round,
    format = (c, unit) => {
      c = roundTo(c, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    },
    differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };

  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }

  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}

function lastOpts(argList) {
  let opts = {},
    args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}

/**
 * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
 *
 * A DateTime comprises of:
 * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
 * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
 * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
 *
 * Here is a brief overview of the most commonly used functionality it provides:
 *
 * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.
 * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},
 * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.
 * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.
 * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.
 * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.
 * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.
 *
 * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
 */
class DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;

    let invalid =
      config.invalid ||
      (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) ||
      (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;

    let c = null,
      o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);

      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }

    /**
     * @access private
     */
    this._zone = zone;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.invalid = invalid;
    /**
     * @access private
     */
    this.weekData = null;
    /**
     * @access private
     */
    this.c = c;
    /**
     * @access private
     */
    this.o = o;
    /**
     * @access private
     */
    this.isLuxonDateTime = true;
  }

  // CONSTRUCT

  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }

  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }

  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments),
      [year, month, day, hour, minute, second, millisecond] = args;

    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }

  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }

    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options),
    });
  }

  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options),
      });
    }
  }

  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options),
      });
    }
  }

  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    const tsNow = Settings.now(),
      offsetProvis = !isUndefined(opts.specificOffset)
        ? opts.specificOffset
        : zoneToUse.offset(tsNow),
      normalized = normalizeObject(obj, normalizeUnit),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber,
      loc = Locale.fromObject(opts);

    // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }

    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);

    // configure ourselves to deal with gregorian dates or week stuff
    let units,
      defaultValues,
      objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }

    // set default values for missing stuff
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }

    // make sure the values we have are in range
    const higherOrderInvalid = useWeekData
        ? hasInvalidWeekData(normalized)
        : containsOrdinal
        ? hasInvalidOrdinalData(normalized)
        : hasInvalidGregorianData(normalized),
      invalid = higherOrderInvalid || hasInvalidTimeData(normalized);

    if (invalid) {
      return DateTime.invalid(invalid);
    }

    // compute the actual time
    const gregorian = useWeekData
        ? weekToGregorian(normalized)
        : containsOrdinal
        ? ordinalToGregorian(normalized)
        : normalized,
      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),
      inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc,
      });

    // gregorian data + weekday serves only to validate
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }

    return inst;
  }

  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }

  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }

  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }

  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }

    const { locale = null, numberingSystem = null } = opts,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true,
      }),
      [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }

  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }

  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }

  /**
   * Create an invalid DateTime.
   * @param {DateTime} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }

    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }

  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return (o && o.isLuxonDateTime) || false;
  }

  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => (t ? t.val : null)).join("");
  }

  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }

  // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }

  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }

  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }

  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }

  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }

  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }

  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }

  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }

  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }

  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }

  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }

  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }

  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }

  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }

  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }

  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }

  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }

  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }

  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }

  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }

  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }

  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }

  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }

  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }

  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }

  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }

  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale,
      });
    } else {
      return null;
    }
  }

  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale,
      });
    } else {
      return null;
    }
  }

  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }

  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return (
        this.offset > this.set({ month: 1, day: 1 }).offset ||
        this.offset > this.set({ month: 5 }).offset
      );
    }
  }

  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }

  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }

  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }

  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }

  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }

  // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset), opts);
  }

  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }

  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone(this, { ts: newTS, zone });
    }
  }

  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone(this, { loc });
  }

  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }

  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid) return this;

    const normalized = normalizeObject(values, normalizeUnit),
      settingWeekStuff =
        !isUndefined(normalized.weekYear) ||
        !isUndefined(normalized.weekNumber) ||
        !isUndefined(normalized.weekday),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber;

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }

    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };

      // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }

    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone(this, { ts, o });
  }

  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration);
    return clone(this, adjustTime(this, dur));
  }

  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone(this, adjustTime(this, dur));
  }

  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit) {
    if (!this.isValid) return this;
    const o = {},
      normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through
      case "quarters":
      case "months":
        o.day = 1;
      // falls through
      case "weeks":
      case "days":
        o.hour = 0;
      // falls through
      case "hours":
        o.minute = 0;
      // falls through
      case "minutes":
        o.second = 0;
      // falls through
      case "seconds":
        o.millisecond = 0;
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }

    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }

    return this.set(o);
  }

  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit) {
    return this.isValid
      ? this.plus({ [unit]: 1 })
          .startOf(unit)
          .minus(1)
      : this;
  }

  // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid
      ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)
      : INVALID;
  }

  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid
      ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this)
      : INVALID;
  }

  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid
      ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this)
      : [];
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false,
  } = {}) {
    if (!this.isValid) {
      return null;
    }

    const ext = format === "extended";

    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }

    return toISODate(this, format === "extended");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended",
  } = {}) {
    if (!this.isValid) {
      return null;
    }

    let c = includePrefix ? "T" : "";
    return (
      c +
      toISOTime(
        this,
        format === "extended",
        suppressSeconds,
        suppressMilliseconds,
        includeOffset,
        extendedZone
      )
    );
  }

  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";

    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }

    return toTechFormat(this, fmt, true);
  }

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }

    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }

  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }

  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }

  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }

  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }

  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1000) : NaN;
  }

  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }

  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }

  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};

    const base = { ...this.c };

    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }

  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }

  // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }

    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };

    const units = maybeArray(unit).map(Duration.normalizeUnit),
      otherIsLater = otherDateTime.valueOf() > this.valueOf(),
      earlier = otherIsLater ? this : otherDateTime,
      later = otherIsLater ? otherDateTime : this,
      diffed = diff(earlier, later, units, durOpts);

    return otherIsLater ? diffed.negate() : diffed;
  }

  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }

  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }

  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;

    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }

  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return (
      this.isValid &&
      other.isValid &&
      this.valueOf() === other.valueOf() &&
      this.zone.equals(other.zone) &&
      this.loc.equals(other.loc)
    );
  }

  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }),
      padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = undefined;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit,
    });
  }

  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;

    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true,
    });
  }

  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }

  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }

  // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options,
      localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true,
      });
    return explainFromTokens(localeToUse, text, fmt);
  }

  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }

  // FORMAT PRESETS

  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }

  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }

  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}

/**
 * @private
 */
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

var defaultFormats$3 = {
    dayOfMonth: "d",
    fullDate: "DD",
    fullDateWithWeekday: "DDDD",
    fullDateTime: "ff",
    fullDateTime12h: "DD, hh:mm a",
    fullDateTime24h: "DD, T",
    fullTime: "t",
    fullTime12h: "hh:mm a",
    fullTime24h: "HH:mm",
    hours12h: "hh",
    hours24h: "HH",
    keyboardDate: "D",
    keyboardDateTime: "D t",
    keyboardDateTime12h: "D hh:mm a",
    keyboardDateTime24h: "D T",
    minutes: "mm",
    seconds: "ss",
    month: "LLLL",
    monthAndDate: "MMMM d",
    monthAndYear: "LLLL yyyy",
    monthShort: "MMM",
    weekday: "cccc",
    weekdayShort: "ccc",
    normalDate: "d MMMM",
    normalDateWithWeekday: "EEE, MMM d",
    shortDate: "MMM d",
    year: "yyyy",
};
var LuxonUtils = /** @class */ (function () {
    function LuxonUtils(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, locale = _b.locale, formats = _b.formats;
        this.lib = "luxon";
        this.date = function (value) {
            if (typeof value === "undefined") {
                return DateTime.local();
            }
            if (value === null) {
                return null;
            }
            if (typeof value === "string") {
                return DateTime.fromJSDate(new Date(value), { locale: _this.locale });
            }
            if (value instanceof DateTime) {
                return value;
            }
            return DateTime.fromJSDate(value, { locale: _this.locale });
        };
        this.toJsDate = function (value) {
            return value.toJSDate();
        };
        this.parseISO = function (isoString) {
            return DateTime.fromISO(isoString);
        };
        this.toISO = function (value) {
            return value.toISO({ format: "extended" });
        };
        this.parse = function (value, formatString) {
            if (value === "") {
                return null;
            }
            return DateTime.fromFormat(value, formatString, { locale: _this.locale });
        };
        /* istanbul ignore next */
        this.is12HourCycleInCurrentLocale = function () {
            var _a, _b;
            if (typeof Intl === "undefined" || typeof Intl.DateTimeFormat === "undefined") {
                return true; // Luxon defaults to en-US if Intl not found
            }
            return Boolean((_b = (_a = new Intl.DateTimeFormat(_this.locale, { hour: "numeric" })) === null || _a === void 0 ? void 0 : _a.resolvedOptions()) === null || _b === void 0 ? void 0 : _b.hour12);
        };
        this.getFormatHelperText = function (format) {
            // Unfortunately there is no way for luxon to retrieve readable formats from localized format
            return "";
        };
        /* istanbul ignore next */
        this.getCurrentLocaleCode = function () {
            return _this.locale || Settings.defaultLocale;
        };
        this.addSeconds = function (date, count) {
            return date.plus({ seconds: count });
        };
        this.addMinutes = function (date, count) {
            return date.plus({ minutes: count });
        };
        this.addHours = function (date, count) {
            return date.plus({ hours: count });
        };
        this.addDays = function (date, count) {
            return date.plus({ days: count });
        };
        this.addWeeks = function (date, count) {
            return date.plus({ weeks: count });
        };
        this.addMonths = function (date, count) {
            return date.plus({ months: count });
        };
        this.addYears = function (date, count) {
            return date.plus({ years: count });
        };
        this.isValid = function (value) {
            if (value instanceof DateTime) {
                return value.isValid;
            }
            if (value === null) {
                return false;
            }
            return _this.date(value).isValid;
        };
        this.isEqual = function (value, comparing) {
            if (value === null && comparing === null) {
                return true;
            }
            // make sure that null will not be passed to this.date
            if (value === null || comparing === null) {
                return false;
            }
            return _this.date(value).equals(_this.date(comparing));
        };
        this.isSameDay = function (date, comparing) {
            return date.hasSame(comparing, "day");
        };
        this.isSameMonth = function (date, comparing) {
            return date.hasSame(comparing, "month");
        };
        this.isSameYear = function (date, comparing) {
            return date.hasSame(comparing, "year");
        };
        this.isSameHour = function (date, comparing) {
            return date.hasSame(comparing, "hour");
        };
        this.isAfter = function (value, comparing) {
            return value > comparing;
        };
        this.isBefore = function (value, comparing) {
            return value < comparing;
        };
        this.isBeforeDay = function (value, comparing) {
            var diff = value.diff(comparing.startOf("day"), "days").toObject();
            return diff.days < 0;
        };
        this.isAfterDay = function (value, comparing) {
            var diff = value.diff(comparing.endOf("day"), "days").toObject();
            return diff.days > 0;
        };
        this.isBeforeYear = function (value, comparing) {
            var diff = value.diff(comparing.startOf("year"), "years").toObject();
            return diff.years < 0;
        };
        this.isAfterYear = function (value, comparing) {
            var diff = value.diff(comparing.endOf("year"), "years").toObject();
            return diff.years > 0;
        };
        this.getDiff = function (value, comparing, unit) {
            if (typeof comparing === "string") {
                comparing = DateTime.fromJSDate(new Date(comparing));
            }
            if (unit) {
                return Math.floor(value.diff(comparing).as(unit));
            }
            return value.diff(comparing).as("millisecond");
        };
        this.startOfDay = function (value) {
            return value.startOf("day");
        };
        this.endOfDay = function (value) {
            return value.endOf("day");
        };
        this.format = function (date, formatKey) {
            return _this.formatByString(date, _this.formats[formatKey]);
        };
        this.formatByString = function (date, format) {
            return date.setLocale(_this.locale).toFormat(format);
        };
        this.formatNumber = function (numberToFormat) {
            return numberToFormat;
        };
        this.getHours = function (value) {
            return value.get("hour");
        };
        this.setHours = function (value, count) {
            return value.set({ hour: count });
        };
        this.getMinutes = function (value) {
            return value.get("minute");
        };
        this.setMinutes = function (value, count) {
            return value.set({ minute: count });
        };
        this.getSeconds = function (value) {
            return value.get("second");
        };
        this.setSeconds = function (value, count) {
            return value.set({ second: count });
        };
        this.getMonth = function (value) {
            // See https://github.com/moment/luxon/blob/master/docs/moment.md#major-functional-differences
            return value.get("month") - 1;
        };
        this.getDaysInMonth = function (value) {
            return value.daysInMonth;
        };
        this.setMonth = function (value, count) {
            return value.set({ month: count + 1 });
        };
        this.getYear = function (value) {
            return value.get("year");
        };
        this.setYear = function (value, year) {
            return value.set({ year: year });
        };
        this.getDate = function (value) {
            return value.get("day");
        };
        this.setDate = function (value, day) {
            return value.set({ day: day });
        };
        this.mergeDateAndTime = function (date, time) {
            return date.set({
                second: time.second,
                hour: time.hour,
                minute: time.minute,
            });
        };
        this.startOfYear = function (value) {
            return value.startOf("year");
        };
        this.endOfYear = function (value) {
            return value.endOf("year");
        };
        this.startOfMonth = function (value) {
            return value.startOf("month");
        };
        this.endOfMonth = function (value) {
            return value.endOf("month");
        };
        this.startOfWeek = function (value) {
            return value.startOf("week");
        };
        this.endOfWeek = function (value) {
            return value.endOf("week");
        };
        this.getNextMonth = function (value) {
            return value.plus({ months: 1 });
        };
        this.getPreviousMonth = function (value) {
            return value.minus({ months: 1 });
        };
        this.getMonthArray = function (date) {
            var firstMonth = _this.date(date).startOf("year");
            var monthArray = [firstMonth];
            while (monthArray.length < 12) {
                var prevMonth = monthArray[monthArray.length - 1];
                monthArray.push(_this.getNextMonth(prevMonth));
            }
            return monthArray;
        };
        this.getWeekdays = function () {
            return Info.weekdaysFormat("narrow", { locale: _this.locale });
        };
        this.getWeekArray = function (date) {
            var days = date
                .endOf("month")
                .endOf("week")
                .diff(date.startOf("month").startOf("week"), "days")
                .toObject().days;
            var weeks = [];
            new Array(Math.round(days))
                .fill(0)
                .map(function (_, i) { return i; })
                .map(function (day) { return date.startOf("month").startOf("week").plus({ days: day }); })
                .forEach(function (v, i) {
                if (i === 0 || (i % 7 === 0 && i > 6)) {
                    weeks.push([v]);
                    return;
                }
                weeks[weeks.length - 1].push(v);
            });
            return weeks;
        };
        this.getYearRange = function (start, end) {
            var startDate = _this.date(start).startOf("year");
            var endDate = _this.date(end).endOf("year");
            var current = startDate;
            var years = [];
            while (current < endDate) {
                years.push(current);
                current = current.plus({ year: 1 });
            }
            return years;
        };
        this.getMeridiemText = function (ampm) {
            return Info.meridiems({ locale: _this.locale }).find(function (v) { return v.toLowerCase() === ampm.toLowerCase(); });
        };
        this.isNull = function (date) {
            return date === null;
        };
        this.isWithinRange = function (date, _a) {
            var start = _a[0], end = _a[1];
            return (date.equals(start) ||
                date.equals(end) ||
                (_this.isAfter(date, start) && _this.isBefore(date, end)));
        };
        this.locale = locale || "en-US";
        this.formats = Object.assign({}, defaultFormats$3, formats);
    }
    return LuxonUtils;
}());

/* eslint-disable class-methods-use-this */
const formatTokenMap$3 = {
    s: 'seconds',
    ss: 'seconds',
    m: 'minutes',
    mm: 'minutes',
    H: 'hours',
    HH: 'hours',
    h: 'hours',
    hh: 'hours',
    a: 'meridiem',
    d: 'day',
    dd: 'day',
    L: 'month',
    LL: 'month',
    LLL: { sectionName: 'month', contentType: 'letter' },
    LLLL: { sectionName: 'month', contentType: 'letter' },
    LLLLL: { sectionName: 'month', contentType: 'letter' },
    M: 'month',
    MM: 'month',
    MMM: { sectionName: 'month', contentType: 'letter' },
    MMMM: { sectionName: 'month', contentType: 'letter' },
    MMMMM: { sectionName: 'month', contentType: 'letter' },
    y: 'year',
    yy: 'year',
    yyyy: 'year',
};
class AdapterLuxon extends LuxonUtils {
    constructor() {
        super(...arguments);
        this.isMUIAdapter = true;
        this.formatTokenMap = formatTokenMap$3;
        this.escapedCharacters = { start: "'", end: "'" };
        this.expandFormat = (format) => {
            if (!DateTime.expandFormat) {
                throw Error('Your luxon version does not support `expandFormat`. Consider upgrading it to v3.0.2');
            }
            // The returned format can contain `yyyyy` which means year between 4 and 6 digits.
            // This value is supported by luxon parser but not luxon formatter.
            // To avoid conflicts, we replace it by 4 digits which is enough for most use-cases.
            return DateTime.expandFormat(format, { locale: this.locale }).replace('yyyyy', 'yyyy');
        };
        // Redefined here just to show how it can be written using expandFormat
        this.getFormatHelperText = (format) => {
            return this.expandFormat(format).replace(/(a)/g, '(a|p)m').toLocaleLowerCase();
        };
        this.getWeekNumber = (date) => {
            return date.weekNumber;
        };
    }
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var momentExports$1 = {};
var moment$1 = {
  get exports(){ return momentExports$1; },
  set exports(v){ momentExports$1 = v; },
};

var hasRequiredMoment;

function requireMoment () {
	if (hasRequiredMoment) return momentExports$1;
	hasRequiredMoment = 1;
	(function (module, exports) {
(function (global, factory) {
		    module.exports = factory() ;
		}(commonjsGlobal, (function () {
		    var hookCallback;

		    function hooks() {
		        return hookCallback.apply(null, arguments);
		    }

		    // This is done to register the method called with moment()
		    // without creating circular dependencies.
		    function setHookCallback(callback) {
		        hookCallback = callback;
		    }

		    function isArray(input) {
		        return (
		            input instanceof Array ||
		            Object.prototype.toString.call(input) === '[object Array]'
		        );
		    }

		    function isObject(input) {
		        // IE8 will treat undefined and null as object if it wasn't for
		        // input != null
		        return (
		            input != null &&
		            Object.prototype.toString.call(input) === '[object Object]'
		        );
		    }

		    function hasOwnProp(a, b) {
		        return Object.prototype.hasOwnProperty.call(a, b);
		    }

		    function isObjectEmpty(obj) {
		        if (Object.getOwnPropertyNames) {
		            return Object.getOwnPropertyNames(obj).length === 0;
		        } else {
		            var k;
		            for (k in obj) {
		                if (hasOwnProp(obj, k)) {
		                    return false;
		                }
		            }
		            return true;
		        }
		    }

		    function isUndefined(input) {
		        return input === void 0;
		    }

		    function isNumber(input) {
		        return (
		            typeof input === 'number' ||
		            Object.prototype.toString.call(input) === '[object Number]'
		        );
		    }

		    function isDate(input) {
		        return (
		            input instanceof Date ||
		            Object.prototype.toString.call(input) === '[object Date]'
		        );
		    }

		    function map(arr, fn) {
		        var res = [],
		            i,
		            arrLen = arr.length;
		        for (i = 0; i < arrLen; ++i) {
		            res.push(fn(arr[i], i));
		        }
		        return res;
		    }

		    function extend(a, b) {
		        for (var i in b) {
		            if (hasOwnProp(b, i)) {
		                a[i] = b[i];
		            }
		        }

		        if (hasOwnProp(b, 'toString')) {
		            a.toString = b.toString;
		        }

		        if (hasOwnProp(b, 'valueOf')) {
		            a.valueOf = b.valueOf;
		        }

		        return a;
		    }

		    function createUTC(input, format, locale, strict) {
		        return createLocalOrUTC(input, format, locale, strict, true).utc();
		    }

		    function defaultParsingFlags() {
		        // We need to deep clone this object.
		        return {
		            empty: false,
		            unusedTokens: [],
		            unusedInput: [],
		            overflow: -2,
		            charsLeftOver: 0,
		            nullInput: false,
		            invalidEra: null,
		            invalidMonth: null,
		            invalidFormat: false,
		            userInvalidated: false,
		            iso: false,
		            parsedDateParts: [],
		            era: null,
		            meridiem: null,
		            rfc2822: false,
		            weekdayMismatch: false,
		        };
		    }

		    function getParsingFlags(m) {
		        if (m._pf == null) {
		            m._pf = defaultParsingFlags();
		        }
		        return m._pf;
		    }

		    var some;
		    if (Array.prototype.some) {
		        some = Array.prototype.some;
		    } else {
		        some = function (fun) {
		            var t = Object(this),
		                len = t.length >>> 0,
		                i;

		            for (i = 0; i < len; i++) {
		                if (i in t && fun.call(this, t[i], i, t)) {
		                    return true;
		                }
		            }

		            return false;
		        };
		    }

		    function isValid(m) {
		        if (m._isValid == null) {
		            var flags = getParsingFlags(m),
		                parsedParts = some.call(flags.parsedDateParts, function (i) {
		                    return i != null;
		                }),
		                isNowValid =
		                    !isNaN(m._d.getTime()) &&
		                    flags.overflow < 0 &&
		                    !flags.empty &&
		                    !flags.invalidEra &&
		                    !flags.invalidMonth &&
		                    !flags.invalidWeekday &&
		                    !flags.weekdayMismatch &&
		                    !flags.nullInput &&
		                    !flags.invalidFormat &&
		                    !flags.userInvalidated &&
		                    (!flags.meridiem || (flags.meridiem && parsedParts));

		            if (m._strict) {
		                isNowValid =
		                    isNowValid &&
		                    flags.charsLeftOver === 0 &&
		                    flags.unusedTokens.length === 0 &&
		                    flags.bigHour === undefined;
		            }

		            if (Object.isFrozen == null || !Object.isFrozen(m)) {
		                m._isValid = isNowValid;
		            } else {
		                return isNowValid;
		            }
		        }
		        return m._isValid;
		    }

		    function createInvalid(flags) {
		        var m = createUTC(NaN);
		        if (flags != null) {
		            extend(getParsingFlags(m), flags);
		        } else {
		            getParsingFlags(m).userInvalidated = true;
		        }

		        return m;
		    }

		    // Plugins that add properties should also add the key here (null value),
		    // so we can properly clone ourselves.
		    var momentProperties = (hooks.momentProperties = []),
		        updateInProgress = false;

		    function copyConfig(to, from) {
		        var i,
		            prop,
		            val,
		            momentPropertiesLen = momentProperties.length;

		        if (!isUndefined(from._isAMomentObject)) {
		            to._isAMomentObject = from._isAMomentObject;
		        }
		        if (!isUndefined(from._i)) {
		            to._i = from._i;
		        }
		        if (!isUndefined(from._f)) {
		            to._f = from._f;
		        }
		        if (!isUndefined(from._l)) {
		            to._l = from._l;
		        }
		        if (!isUndefined(from._strict)) {
		            to._strict = from._strict;
		        }
		        if (!isUndefined(from._tzm)) {
		            to._tzm = from._tzm;
		        }
		        if (!isUndefined(from._isUTC)) {
		            to._isUTC = from._isUTC;
		        }
		        if (!isUndefined(from._offset)) {
		            to._offset = from._offset;
		        }
		        if (!isUndefined(from._pf)) {
		            to._pf = getParsingFlags(from);
		        }
		        if (!isUndefined(from._locale)) {
		            to._locale = from._locale;
		        }

		        if (momentPropertiesLen > 0) {
		            for (i = 0; i < momentPropertiesLen; i++) {
		                prop = momentProperties[i];
		                val = from[prop];
		                if (!isUndefined(val)) {
		                    to[prop] = val;
		                }
		            }
		        }

		        return to;
		    }

		    // Moment prototype object
		    function Moment(config) {
		        copyConfig(this, config);
		        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
		        if (!this.isValid()) {
		            this._d = new Date(NaN);
		        }
		        // Prevent infinite loop in case updateOffset creates new moment
		        // objects.
		        if (updateInProgress === false) {
		            updateInProgress = true;
		            hooks.updateOffset(this);
		            updateInProgress = false;
		        }
		    }

		    function isMoment(obj) {
		        return (
		            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
		        );
		    }

		    function warn(msg) {
		        if (
		            hooks.suppressDeprecationWarnings === false &&
		            typeof console !== 'undefined' &&
		            console.warn
		        ) {
		            console.warn('Deprecation warning: ' + msg);
		        }
		    }

		    function deprecate(msg, fn) {
		        var firstTime = true;

		        return extend(function () {
		            if (hooks.deprecationHandler != null) {
		                hooks.deprecationHandler(null, msg);
		            }
		            if (firstTime) {
		                var args = [],
		                    arg,
		                    i,
		                    key,
		                    argLen = arguments.length;
		                for (i = 0; i < argLen; i++) {
		                    arg = '';
		                    if (typeof arguments[i] === 'object') {
		                        arg += '\n[' + i + '] ';
		                        for (key in arguments[0]) {
		                            if (hasOwnProp(arguments[0], key)) {
		                                arg += key + ': ' + arguments[0][key] + ', ';
		                            }
		                        }
		                        arg = arg.slice(0, -2); // Remove trailing comma and space
		                    } else {
		                        arg = arguments[i];
		                    }
		                    args.push(arg);
		                }
		                warn(
		                    msg +
		                        '\nArguments: ' +
		                        Array.prototype.slice.call(args).join('') +
		                        '\n' +
		                        new Error().stack
		                );
		                firstTime = false;
		            }
		            return fn.apply(this, arguments);
		        }, fn);
		    }

		    var deprecations = {};

		    function deprecateSimple(name, msg) {
		        if (hooks.deprecationHandler != null) {
		            hooks.deprecationHandler(name, msg);
		        }
		        if (!deprecations[name]) {
		            warn(msg);
		            deprecations[name] = true;
		        }
		    }

		    hooks.suppressDeprecationWarnings = false;
		    hooks.deprecationHandler = null;

		    function isFunction(input) {
		        return (
		            (typeof Function !== 'undefined' && input instanceof Function) ||
		            Object.prototype.toString.call(input) === '[object Function]'
		        );
		    }

		    function set(config) {
		        var prop, i;
		        for (i in config) {
		            if (hasOwnProp(config, i)) {
		                prop = config[i];
		                if (isFunction(prop)) {
		                    this[i] = prop;
		                } else {
		                    this['_' + i] = prop;
		                }
		            }
		        }
		        this._config = config;
		        // Lenient ordinal parsing accepts just a number in addition to
		        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
		        // TODO: Remove "ordinalParse" fallback in next major release.
		        this._dayOfMonthOrdinalParseLenient = new RegExp(
		            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
		                '|' +
		                /\d{1,2}/.source
		        );
		    }

		    function mergeConfigs(parentConfig, childConfig) {
		        var res = extend({}, parentConfig),
		            prop;
		        for (prop in childConfig) {
		            if (hasOwnProp(childConfig, prop)) {
		                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
		                    res[prop] = {};
		                    extend(res[prop], parentConfig[prop]);
		                    extend(res[prop], childConfig[prop]);
		                } else if (childConfig[prop] != null) {
		                    res[prop] = childConfig[prop];
		                } else {
		                    delete res[prop];
		                }
		            }
		        }
		        for (prop in parentConfig) {
		            if (
		                hasOwnProp(parentConfig, prop) &&
		                !hasOwnProp(childConfig, prop) &&
		                isObject(parentConfig[prop])
		            ) {
		                // make sure changes to properties don't modify parent config
		                res[prop] = extend({}, res[prop]);
		            }
		        }
		        return res;
		    }

		    function Locale(config) {
		        if (config != null) {
		            this.set(config);
		        }
		    }

		    var keys;

		    if (Object.keys) {
		        keys = Object.keys;
		    } else {
		        keys = function (obj) {
		            var i,
		                res = [];
		            for (i in obj) {
		                if (hasOwnProp(obj, i)) {
		                    res.push(i);
		                }
		            }
		            return res;
		        };
		    }

		    var defaultCalendar = {
		        sameDay: '[Today at] LT',
		        nextDay: '[Tomorrow at] LT',
		        nextWeek: 'dddd [at] LT',
		        lastDay: '[Yesterday at] LT',
		        lastWeek: '[Last] dddd [at] LT',
		        sameElse: 'L',
		    };

		    function calendar(key, mom, now) {
		        var output = this._calendar[key] || this._calendar['sameElse'];
		        return isFunction(output) ? output.call(mom, now) : output;
		    }

		    function zeroFill(number, targetLength, forceSign) {
		        var absNumber = '' + Math.abs(number),
		            zerosToFill = targetLength - absNumber.length,
		            sign = number >= 0;
		        return (
		            (sign ? (forceSign ? '+' : '') : '-') +
		            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
		            absNumber
		        );
		    }

		    var formattingTokens =
		            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
		        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
		        formatFunctions = {},
		        formatTokenFunctions = {};

		    // token:    'M'
		    // padded:   ['MM', 2]
		    // ordinal:  'Mo'
		    // callback: function () { this.month() + 1 }
		    function addFormatToken(token, padded, ordinal, callback) {
		        var func = callback;
		        if (typeof callback === 'string') {
		            func = function () {
		                return this[callback]();
		            };
		        }
		        if (token) {
		            formatTokenFunctions[token] = func;
		        }
		        if (padded) {
		            formatTokenFunctions[padded[0]] = function () {
		                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
		            };
		        }
		        if (ordinal) {
		            formatTokenFunctions[ordinal] = function () {
		                return this.localeData().ordinal(
		                    func.apply(this, arguments),
		                    token
		                );
		            };
		        }
		    }

		    function removeFormattingTokens(input) {
		        if (input.match(/\[[\s\S]/)) {
		            return input.replace(/^\[|\]$/g, '');
		        }
		        return input.replace(/\\/g, '');
		    }

		    function makeFormatFunction(format) {
		        var array = format.match(formattingTokens),
		            i,
		            length;

		        for (i = 0, length = array.length; i < length; i++) {
		            if (formatTokenFunctions[array[i]]) {
		                array[i] = formatTokenFunctions[array[i]];
		            } else {
		                array[i] = removeFormattingTokens(array[i]);
		            }
		        }

		        return function (mom) {
		            var output = '',
		                i;
		            for (i = 0; i < length; i++) {
		                output += isFunction(array[i])
		                    ? array[i].call(mom, format)
		                    : array[i];
		            }
		            return output;
		        };
		    }

		    // format date using native date object
		    function formatMoment(m, format) {
		        if (!m.isValid()) {
		            return m.localeData().invalidDate();
		        }

		        format = expandFormat(format, m.localeData());
		        formatFunctions[format] =
		            formatFunctions[format] || makeFormatFunction(format);

		        return formatFunctions[format](m);
		    }

		    function expandFormat(format, locale) {
		        var i = 5;

		        function replaceLongDateFormatTokens(input) {
		            return locale.longDateFormat(input) || input;
		        }

		        localFormattingTokens.lastIndex = 0;
		        while (i >= 0 && localFormattingTokens.test(format)) {
		            format = format.replace(
		                localFormattingTokens,
		                replaceLongDateFormatTokens
		            );
		            localFormattingTokens.lastIndex = 0;
		            i -= 1;
		        }

		        return format;
		    }

		    var defaultLongDateFormat = {
		        LTS: 'h:mm:ss A',
		        LT: 'h:mm A',
		        L: 'MM/DD/YYYY',
		        LL: 'MMMM D, YYYY',
		        LLL: 'MMMM D, YYYY h:mm A',
		        LLLL: 'dddd, MMMM D, YYYY h:mm A',
		    };

		    function longDateFormat(key) {
		        var format = this._longDateFormat[key],
		            formatUpper = this._longDateFormat[key.toUpperCase()];

		        if (format || !formatUpper) {
		            return format;
		        }

		        this._longDateFormat[key] = formatUpper
		            .match(formattingTokens)
		            .map(function (tok) {
		                if (
		                    tok === 'MMMM' ||
		                    tok === 'MM' ||
		                    tok === 'DD' ||
		                    tok === 'dddd'
		                ) {
		                    return tok.slice(1);
		                }
		                return tok;
		            })
		            .join('');

		        return this._longDateFormat[key];
		    }

		    var defaultInvalidDate = 'Invalid date';

		    function invalidDate() {
		        return this._invalidDate;
		    }

		    var defaultOrdinal = '%d',
		        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

		    function ordinal(number) {
		        return this._ordinal.replace('%d', number);
		    }

		    var defaultRelativeTime = {
		        future: 'in %s',
		        past: '%s ago',
		        s: 'a few seconds',
		        ss: '%d seconds',
		        m: 'a minute',
		        mm: '%d minutes',
		        h: 'an hour',
		        hh: '%d hours',
		        d: 'a day',
		        dd: '%d days',
		        w: 'a week',
		        ww: '%d weeks',
		        M: 'a month',
		        MM: '%d months',
		        y: 'a year',
		        yy: '%d years',
		    };

		    function relativeTime(number, withoutSuffix, string, isFuture) {
		        var output = this._relativeTime[string];
		        return isFunction(output)
		            ? output(number, withoutSuffix, string, isFuture)
		            : output.replace(/%d/i, number);
		    }

		    function pastFuture(diff, output) {
		        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
		        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
		    }

		    var aliases = {};

		    function addUnitAlias(unit, shorthand) {
		        var lowerCase = unit.toLowerCase();
		        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
		    }

		    function normalizeUnits(units) {
		        return typeof units === 'string'
		            ? aliases[units] || aliases[units.toLowerCase()]
		            : undefined;
		    }

		    function normalizeObjectUnits(inputObject) {
		        var normalizedInput = {},
		            normalizedProp,
		            prop;

		        for (prop in inputObject) {
		            if (hasOwnProp(inputObject, prop)) {
		                normalizedProp = normalizeUnits(prop);
		                if (normalizedProp) {
		                    normalizedInput[normalizedProp] = inputObject[prop];
		                }
		            }
		        }

		        return normalizedInput;
		    }

		    var priorities = {};

		    function addUnitPriority(unit, priority) {
		        priorities[unit] = priority;
		    }

		    function getPrioritizedUnits(unitsObj) {
		        var units = [],
		            u;
		        for (u in unitsObj) {
		            if (hasOwnProp(unitsObj, u)) {
		                units.push({ unit: u, priority: priorities[u] });
		            }
		        }
		        units.sort(function (a, b) {
		            return a.priority - b.priority;
		        });
		        return units;
		    }

		    function isLeapYear(year) {
		        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
		    }

		    function absFloor(number) {
		        if (number < 0) {
		            // -0 -> 0
		            return Math.ceil(number) || 0;
		        } else {
		            return Math.floor(number);
		        }
		    }

		    function toInt(argumentForCoercion) {
		        var coercedNumber = +argumentForCoercion,
		            value = 0;

		        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
		            value = absFloor(coercedNumber);
		        }

		        return value;
		    }

		    function makeGetSet(unit, keepTime) {
		        return function (value) {
		            if (value != null) {
		                set$1(this, unit, value);
		                hooks.updateOffset(this, keepTime);
		                return this;
		            } else {
		                return get(this, unit);
		            }
		        };
		    }

		    function get(mom, unit) {
		        return mom.isValid()
		            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
		            : NaN;
		    }

		    function set$1(mom, unit, value) {
		        if (mom.isValid() && !isNaN(value)) {
		            if (
		                unit === 'FullYear' &&
		                isLeapYear(mom.year()) &&
		                mom.month() === 1 &&
		                mom.date() === 29
		            ) {
		                value = toInt(value);
		                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
		                    value,
		                    mom.month(),
		                    daysInMonth(value, mom.month())
		                );
		            } else {
		                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
		            }
		        }
		    }

		    // MOMENTS

		    function stringGet(units) {
		        units = normalizeUnits(units);
		        if (isFunction(this[units])) {
		            return this[units]();
		        }
		        return this;
		    }

		    function stringSet(units, value) {
		        if (typeof units === 'object') {
		            units = normalizeObjectUnits(units);
		            var prioritized = getPrioritizedUnits(units),
		                i,
		                prioritizedLen = prioritized.length;
		            for (i = 0; i < prioritizedLen; i++) {
		                this[prioritized[i].unit](units[prioritized[i].unit]);
		            }
		        } else {
		            units = normalizeUnits(units);
		            if (isFunction(this[units])) {
		                return this[units](value);
		            }
		        }
		        return this;
		    }

		    var match1 = /\d/, //       0 - 9
		        match2 = /\d\d/, //      00 - 99
		        match3 = /\d{3}/, //     000 - 999
		        match4 = /\d{4}/, //    0000 - 9999
		        match6 = /[+-]?\d{6}/, // -999999 - 999999
		        match1to2 = /\d\d?/, //       0 - 99
		        match3to4 = /\d\d\d\d?/, //     999 - 9999
		        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
		        match1to3 = /\d{1,3}/, //       0 - 999
		        match1to4 = /\d{1,4}/, //       0 - 9999
		        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
		        matchUnsigned = /\d+/, //       0 - inf
		        matchSigned = /[+-]?\d+/, //    -inf - inf
		        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
		        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
		        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
		        // any word (or two) characters or numbers including two/three word month in arabic.
		        // includes scottish gaelic two word and hyphenated months
		        matchWord =
		            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
		        regexes;

		    regexes = {};

		    function addRegexToken(token, regex, strictRegex) {
		        regexes[token] = isFunction(regex)
		            ? regex
		            : function (isStrict, localeData) {
		                  return isStrict && strictRegex ? strictRegex : regex;
		              };
		    }

		    function getParseRegexForToken(token, config) {
		        if (!hasOwnProp(regexes, token)) {
		            return new RegExp(unescapeFormat(token));
		        }

		        return regexes[token](config._strict, config._locale);
		    }

		    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
		    function unescapeFormat(s) {
		        return regexEscape(
		            s
		                .replace('\\', '')
		                .replace(
		                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
		                    function (matched, p1, p2, p3, p4) {
		                        return p1 || p2 || p3 || p4;
		                    }
		                )
		        );
		    }

		    function regexEscape(s) {
		        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
		    }

		    var tokens = {};

		    function addParseToken(token, callback) {
		        var i,
		            func = callback,
		            tokenLen;
		        if (typeof token === 'string') {
		            token = [token];
		        }
		        if (isNumber(callback)) {
		            func = function (input, array) {
		                array[callback] = toInt(input);
		            };
		        }
		        tokenLen = token.length;
		        for (i = 0; i < tokenLen; i++) {
		            tokens[token[i]] = func;
		        }
		    }

		    function addWeekParseToken(token, callback) {
		        addParseToken(token, function (input, array, config, token) {
		            config._w = config._w || {};
		            callback(input, config._w, config, token);
		        });
		    }

		    function addTimeToArrayFromToken(token, input, config) {
		        if (input != null && hasOwnProp(tokens, token)) {
		            tokens[token](input, config._a, config, token);
		        }
		    }

		    var YEAR = 0,
		        MONTH = 1,
		        DATE = 2,
		        HOUR = 3,
		        MINUTE = 4,
		        SECOND = 5,
		        MILLISECOND = 6,
		        WEEK = 7,
		        WEEKDAY = 8;

		    function mod(n, x) {
		        return ((n % x) + x) % x;
		    }

		    var indexOf;

		    if (Array.prototype.indexOf) {
		        indexOf = Array.prototype.indexOf;
		    } else {
		        indexOf = function (o) {
		            // I know
		            var i;
		            for (i = 0; i < this.length; ++i) {
		                if (this[i] === o) {
		                    return i;
		                }
		            }
		            return -1;
		        };
		    }

		    function daysInMonth(year, month) {
		        if (isNaN(year) || isNaN(month)) {
		            return NaN;
		        }
		        var modMonth = mod(month, 12);
		        year += (month - modMonth) / 12;
		        return modMonth === 1
		            ? isLeapYear(year)
		                ? 29
		                : 28
		            : 31 - ((modMonth % 7) % 2);
		    }

		    // FORMATTING

		    addFormatToken('M', ['MM', 2], 'Mo', function () {
		        return this.month() + 1;
		    });

		    addFormatToken('MMM', 0, 0, function (format) {
		        return this.localeData().monthsShort(this, format);
		    });

		    addFormatToken('MMMM', 0, 0, function (format) {
		        return this.localeData().months(this, format);
		    });

		    // ALIASES

		    addUnitAlias('month', 'M');

		    // PRIORITY

		    addUnitPriority('month', 8);

		    // PARSING

		    addRegexToken('M', match1to2);
		    addRegexToken('MM', match1to2, match2);
		    addRegexToken('MMM', function (isStrict, locale) {
		        return locale.monthsShortRegex(isStrict);
		    });
		    addRegexToken('MMMM', function (isStrict, locale) {
		        return locale.monthsRegex(isStrict);
		    });

		    addParseToken(['M', 'MM'], function (input, array) {
		        array[MONTH] = toInt(input) - 1;
		    });

		    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
		        var month = config._locale.monthsParse(input, token, config._strict);
		        // if we didn't find a month name, mark the date as invalid.
		        if (month != null) {
		            array[MONTH] = month;
		        } else {
		            getParsingFlags(config).invalidMonth = input;
		        }
		    });

		    // LOCALES

		    var defaultLocaleMonths =
		            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
		                '_'
		            ),
		        defaultLocaleMonthsShort =
		            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
		        defaultMonthsShortRegex = matchWord,
		        defaultMonthsRegex = matchWord;

		    function localeMonths(m, format) {
		        if (!m) {
		            return isArray(this._months)
		                ? this._months
		                : this._months['standalone'];
		        }
		        return isArray(this._months)
		            ? this._months[m.month()]
		            : this._months[
		                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
		                      ? 'format'
		                      : 'standalone'
		              ][m.month()];
		    }

		    function localeMonthsShort(m, format) {
		        if (!m) {
		            return isArray(this._monthsShort)
		                ? this._monthsShort
		                : this._monthsShort['standalone'];
		        }
		        return isArray(this._monthsShort)
		            ? this._monthsShort[m.month()]
		            : this._monthsShort[
		                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
		              ][m.month()];
		    }

		    function handleStrictParse(monthName, format, strict) {
		        var i,
		            ii,
		            mom,
		            llc = monthName.toLocaleLowerCase();
		        if (!this._monthsParse) {
		            // this is not used
		            this._monthsParse = [];
		            this._longMonthsParse = [];
		            this._shortMonthsParse = [];
		            for (i = 0; i < 12; ++i) {
		                mom = createUTC([2000, i]);
		                this._shortMonthsParse[i] = this.monthsShort(
		                    mom,
		                    ''
		                ).toLocaleLowerCase();
		                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
		            }
		        }

		        if (strict) {
		            if (format === 'MMM') {
		                ii = indexOf.call(this._shortMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._longMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        } else {
		            if (format === 'MMM') {
		                ii = indexOf.call(this._shortMonthsParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._longMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._longMonthsParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._shortMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        }
		    }

		    function localeMonthsParse(monthName, format, strict) {
		        var i, mom, regex;

		        if (this._monthsParseExact) {
		            return handleStrictParse.call(this, monthName, format, strict);
		        }

		        if (!this._monthsParse) {
		            this._monthsParse = [];
		            this._longMonthsParse = [];
		            this._shortMonthsParse = [];
		        }

		        // TODO: add sorting
		        // Sorting makes sure if one month (or abbr) is a prefix of another
		        // see sorting in computeMonthsParse
		        for (i = 0; i < 12; i++) {
		            // make the regex if we don't have it already
		            mom = createUTC([2000, i]);
		            if (strict && !this._longMonthsParse[i]) {
		                this._longMonthsParse[i] = new RegExp(
		                    '^' + this.months(mom, '').replace('.', '') + '$',
		                    'i'
		                );
		                this._shortMonthsParse[i] = new RegExp(
		                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
		                    'i'
		                );
		            }
		            if (!strict && !this._monthsParse[i]) {
		                regex =
		                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
		                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
		            }
		            // test the regex
		            if (
		                strict &&
		                format === 'MMMM' &&
		                this._longMonthsParse[i].test(monthName)
		            ) {
		                return i;
		            } else if (
		                strict &&
		                format === 'MMM' &&
		                this._shortMonthsParse[i].test(monthName)
		            ) {
		                return i;
		            } else if (!strict && this._monthsParse[i].test(monthName)) {
		                return i;
		            }
		        }
		    }

		    // MOMENTS

		    function setMonth(mom, value) {
		        var dayOfMonth;

		        if (!mom.isValid()) {
		            // No op
		            return mom;
		        }

		        if (typeof value === 'string') {
		            if (/^\d+$/.test(value)) {
		                value = toInt(value);
		            } else {
		                value = mom.localeData().monthsParse(value);
		                // TODO: Another silent failure?
		                if (!isNumber(value)) {
		                    return mom;
		                }
		            }
		        }

		        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
		        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
		        return mom;
		    }

		    function getSetMonth(value) {
		        if (value != null) {
		            setMonth(this, value);
		            hooks.updateOffset(this, true);
		            return this;
		        } else {
		            return get(this, 'Month');
		        }
		    }

		    function getDaysInMonth() {
		        return daysInMonth(this.year(), this.month());
		    }

		    function monthsShortRegex(isStrict) {
		        if (this._monthsParseExact) {
		            if (!hasOwnProp(this, '_monthsRegex')) {
		                computeMonthsParse.call(this);
		            }
		            if (isStrict) {
		                return this._monthsShortStrictRegex;
		            } else {
		                return this._monthsShortRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_monthsShortRegex')) {
		                this._monthsShortRegex = defaultMonthsShortRegex;
		            }
		            return this._monthsShortStrictRegex && isStrict
		                ? this._monthsShortStrictRegex
		                : this._monthsShortRegex;
		        }
		    }

		    function monthsRegex(isStrict) {
		        if (this._monthsParseExact) {
		            if (!hasOwnProp(this, '_monthsRegex')) {
		                computeMonthsParse.call(this);
		            }
		            if (isStrict) {
		                return this._monthsStrictRegex;
		            } else {
		                return this._monthsRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_monthsRegex')) {
		                this._monthsRegex = defaultMonthsRegex;
		            }
		            return this._monthsStrictRegex && isStrict
		                ? this._monthsStrictRegex
		                : this._monthsRegex;
		        }
		    }

		    function computeMonthsParse() {
		        function cmpLenRev(a, b) {
		            return b.length - a.length;
		        }

		        var shortPieces = [],
		            longPieces = [],
		            mixedPieces = [],
		            i,
		            mom;
		        for (i = 0; i < 12; i++) {
		            // make the regex if we don't have it already
		            mom = createUTC([2000, i]);
		            shortPieces.push(this.monthsShort(mom, ''));
		            longPieces.push(this.months(mom, ''));
		            mixedPieces.push(this.months(mom, ''));
		            mixedPieces.push(this.monthsShort(mom, ''));
		        }
		        // Sorting makes sure if one month (or abbr) is a prefix of another it
		        // will match the longer piece.
		        shortPieces.sort(cmpLenRev);
		        longPieces.sort(cmpLenRev);
		        mixedPieces.sort(cmpLenRev);
		        for (i = 0; i < 12; i++) {
		            shortPieces[i] = regexEscape(shortPieces[i]);
		            longPieces[i] = regexEscape(longPieces[i]);
		        }
		        for (i = 0; i < 24; i++) {
		            mixedPieces[i] = regexEscape(mixedPieces[i]);
		        }

		        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		        this._monthsShortRegex = this._monthsRegex;
		        this._monthsStrictRegex = new RegExp(
		            '^(' + longPieces.join('|') + ')',
		            'i'
		        );
		        this._monthsShortStrictRegex = new RegExp(
		            '^(' + shortPieces.join('|') + ')',
		            'i'
		        );
		    }

		    // FORMATTING

		    addFormatToken('Y', 0, 0, function () {
		        var y = this.year();
		        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
		    });

		    addFormatToken(0, ['YY', 2], 0, function () {
		        return this.year() % 100;
		    });

		    addFormatToken(0, ['YYYY', 4], 0, 'year');
		    addFormatToken(0, ['YYYYY', 5], 0, 'year');
		    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

		    // ALIASES

		    addUnitAlias('year', 'y');

		    // PRIORITIES

		    addUnitPriority('year', 1);

		    // PARSING

		    addRegexToken('Y', matchSigned);
		    addRegexToken('YY', match1to2, match2);
		    addRegexToken('YYYY', match1to4, match4);
		    addRegexToken('YYYYY', match1to6, match6);
		    addRegexToken('YYYYYY', match1to6, match6);

		    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
		    addParseToken('YYYY', function (input, array) {
		        array[YEAR] =
		            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
		    });
		    addParseToken('YY', function (input, array) {
		        array[YEAR] = hooks.parseTwoDigitYear(input);
		    });
		    addParseToken('Y', function (input, array) {
		        array[YEAR] = parseInt(input, 10);
		    });

		    // HELPERS

		    function daysInYear(year) {
		        return isLeapYear(year) ? 366 : 365;
		    }

		    // HOOKS

		    hooks.parseTwoDigitYear = function (input) {
		        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
		    };

		    // MOMENTS

		    var getSetYear = makeGetSet('FullYear', true);

		    function getIsLeapYear() {
		        return isLeapYear(this.year());
		    }

		    function createDate(y, m, d, h, M, s, ms) {
		        // can't just apply() to create a date:
		        // https://stackoverflow.com/q/181348
		        var date;
		        // the date constructor remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            // preserve leap years using a full 400 year cycle, then reset
		            date = new Date(y + 400, m, d, h, M, s, ms);
		            if (isFinite(date.getFullYear())) {
		                date.setFullYear(y);
		            }
		        } else {
		            date = new Date(y, m, d, h, M, s, ms);
		        }

		        return date;
		    }

		    function createUTCDate(y) {
		        var date, args;
		        // the Date.UTC function remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            args = Array.prototype.slice.call(arguments);
		            // preserve leap years using a full 400 year cycle, then reset
		            args[0] = y + 400;
		            date = new Date(Date.UTC.apply(null, args));
		            if (isFinite(date.getUTCFullYear())) {
		                date.setUTCFullYear(y);
		            }
		        } else {
		            date = new Date(Date.UTC.apply(null, arguments));
		        }

		        return date;
		    }

		    // start-of-first-week - start-of-year
		    function firstWeekOffset(year, dow, doy) {
		        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
		            fwd = 7 + dow - doy,
		            // first-week day local weekday -- which local weekday is fwd
		            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

		        return -fwdlw + fwd - 1;
		    }

		    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
		    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
		        var localWeekday = (7 + weekday - dow) % 7,
		            weekOffset = firstWeekOffset(year, dow, doy),
		            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
		            resYear,
		            resDayOfYear;

		        if (dayOfYear <= 0) {
		            resYear = year - 1;
		            resDayOfYear = daysInYear(resYear) + dayOfYear;
		        } else if (dayOfYear > daysInYear(year)) {
		            resYear = year + 1;
		            resDayOfYear = dayOfYear - daysInYear(year);
		        } else {
		            resYear = year;
		            resDayOfYear = dayOfYear;
		        }

		        return {
		            year: resYear,
		            dayOfYear: resDayOfYear,
		        };
		    }

		    function weekOfYear(mom, dow, doy) {
		        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
		            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
		            resWeek,
		            resYear;

		        if (week < 1) {
		            resYear = mom.year() - 1;
		            resWeek = week + weeksInYear(resYear, dow, doy);
		        } else if (week > weeksInYear(mom.year(), dow, doy)) {
		            resWeek = week - weeksInYear(mom.year(), dow, doy);
		            resYear = mom.year() + 1;
		        } else {
		            resYear = mom.year();
		            resWeek = week;
		        }

		        return {
		            week: resWeek,
		            year: resYear,
		        };
		    }

		    function weeksInYear(year, dow, doy) {
		        var weekOffset = firstWeekOffset(year, dow, doy),
		            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
		        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
		    }

		    // FORMATTING

		    addFormatToken('w', ['ww', 2], 'wo', 'week');
		    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

		    // ALIASES

		    addUnitAlias('week', 'w');
		    addUnitAlias('isoWeek', 'W');

		    // PRIORITIES

		    addUnitPriority('week', 5);
		    addUnitPriority('isoWeek', 5);

		    // PARSING

		    addRegexToken('w', match1to2);
		    addRegexToken('ww', match1to2, match2);
		    addRegexToken('W', match1to2);
		    addRegexToken('WW', match1to2, match2);

		    addWeekParseToken(
		        ['w', 'ww', 'W', 'WW'],
		        function (input, week, config, token) {
		            week[token.substr(0, 1)] = toInt(input);
		        }
		    );

		    // HELPERS

		    // LOCALES

		    function localeWeek(mom) {
		        return weekOfYear(mom, this._week.dow, this._week.doy).week;
		    }

		    var defaultLocaleWeek = {
		        dow: 0, // Sunday is the first day of the week.
		        doy: 6, // The week that contains Jan 6th is the first week of the year.
		    };

		    function localeFirstDayOfWeek() {
		        return this._week.dow;
		    }

		    function localeFirstDayOfYear() {
		        return this._week.doy;
		    }

		    // MOMENTS

		    function getSetWeek(input) {
		        var week = this.localeData().week(this);
		        return input == null ? week : this.add((input - week) * 7, 'd');
		    }

		    function getSetISOWeek(input) {
		        var week = weekOfYear(this, 1, 4).week;
		        return input == null ? week : this.add((input - week) * 7, 'd');
		    }

		    // FORMATTING

		    addFormatToken('d', 0, 'do', 'day');

		    addFormatToken('dd', 0, 0, function (format) {
		        return this.localeData().weekdaysMin(this, format);
		    });

		    addFormatToken('ddd', 0, 0, function (format) {
		        return this.localeData().weekdaysShort(this, format);
		    });

		    addFormatToken('dddd', 0, 0, function (format) {
		        return this.localeData().weekdays(this, format);
		    });

		    addFormatToken('e', 0, 0, 'weekday');
		    addFormatToken('E', 0, 0, 'isoWeekday');

		    // ALIASES

		    addUnitAlias('day', 'd');
		    addUnitAlias('weekday', 'e');
		    addUnitAlias('isoWeekday', 'E');

		    // PRIORITY
		    addUnitPriority('day', 11);
		    addUnitPriority('weekday', 11);
		    addUnitPriority('isoWeekday', 11);

		    // PARSING

		    addRegexToken('d', match1to2);
		    addRegexToken('e', match1to2);
		    addRegexToken('E', match1to2);
		    addRegexToken('dd', function (isStrict, locale) {
		        return locale.weekdaysMinRegex(isStrict);
		    });
		    addRegexToken('ddd', function (isStrict, locale) {
		        return locale.weekdaysShortRegex(isStrict);
		    });
		    addRegexToken('dddd', function (isStrict, locale) {
		        return locale.weekdaysRegex(isStrict);
		    });

		    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
		        var weekday = config._locale.weekdaysParse(input, token, config._strict);
		        // if we didn't get a weekday name, mark the date as invalid
		        if (weekday != null) {
		            week.d = weekday;
		        } else {
		            getParsingFlags(config).invalidWeekday = input;
		        }
		    });

		    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
		        week[token] = toInt(input);
		    });

		    // HELPERS

		    function parseWeekday(input, locale) {
		        if (typeof input !== 'string') {
		            return input;
		        }

		        if (!isNaN(input)) {
		            return parseInt(input, 10);
		        }

		        input = locale.weekdaysParse(input);
		        if (typeof input === 'number') {
		            return input;
		        }

		        return null;
		    }

		    function parseIsoWeekday(input, locale) {
		        if (typeof input === 'string') {
		            return locale.weekdaysParse(input) % 7 || 7;
		        }
		        return isNaN(input) ? null : input;
		    }

		    // LOCALES
		    function shiftWeekdays(ws, n) {
		        return ws.slice(n, 7).concat(ws.slice(0, n));
		    }

		    var defaultLocaleWeekdays =
		            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		        defaultWeekdaysRegex = matchWord,
		        defaultWeekdaysShortRegex = matchWord,
		        defaultWeekdaysMinRegex = matchWord;

		    function localeWeekdays(m, format) {
		        var weekdays = isArray(this._weekdays)
		            ? this._weekdays
		            : this._weekdays[
		                  m && m !== true && this._weekdays.isFormat.test(format)
		                      ? 'format'
		                      : 'standalone'
		              ];
		        return m === true
		            ? shiftWeekdays(weekdays, this._week.dow)
		            : m
		            ? weekdays[m.day()]
		            : weekdays;
		    }

		    function localeWeekdaysShort(m) {
		        return m === true
		            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
		            : m
		            ? this._weekdaysShort[m.day()]
		            : this._weekdaysShort;
		    }

		    function localeWeekdaysMin(m) {
		        return m === true
		            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
		            : m
		            ? this._weekdaysMin[m.day()]
		            : this._weekdaysMin;
		    }

		    function handleStrictParse$1(weekdayName, format, strict) {
		        var i,
		            ii,
		            mom,
		            llc = weekdayName.toLocaleLowerCase();
		        if (!this._weekdaysParse) {
		            this._weekdaysParse = [];
		            this._shortWeekdaysParse = [];
		            this._minWeekdaysParse = [];

		            for (i = 0; i < 7; ++i) {
		                mom = createUTC([2000, 1]).day(i);
		                this._minWeekdaysParse[i] = this.weekdaysMin(
		                    mom,
		                    ''
		                ).toLocaleLowerCase();
		                this._shortWeekdaysParse[i] = this.weekdaysShort(
		                    mom,
		                    ''
		                ).toLocaleLowerCase();
		                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
		            }
		        }

		        if (strict) {
		            if (format === 'dddd') {
		                ii = indexOf.call(this._weekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else if (format === 'ddd') {
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        } else {
		            if (format === 'dddd') {
		                ii = indexOf.call(this._weekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else if (format === 'ddd') {
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._weekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._weekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        }
		    }

		    function localeWeekdaysParse(weekdayName, format, strict) {
		        var i, mom, regex;

		        if (this._weekdaysParseExact) {
		            return handleStrictParse$1.call(this, weekdayName, format, strict);
		        }

		        if (!this._weekdaysParse) {
		            this._weekdaysParse = [];
		            this._minWeekdaysParse = [];
		            this._shortWeekdaysParse = [];
		            this._fullWeekdaysParse = [];
		        }

		        for (i = 0; i < 7; i++) {
		            // make the regex if we don't have it already

		            mom = createUTC([2000, 1]).day(i);
		            if (strict && !this._fullWeekdaysParse[i]) {
		                this._fullWeekdaysParse[i] = new RegExp(
		                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
		                    'i'
		                );
		                this._shortWeekdaysParse[i] = new RegExp(
		                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
		                    'i'
		                );
		                this._minWeekdaysParse[i] = new RegExp(
		                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
		                    'i'
		                );
		            }
		            if (!this._weekdaysParse[i]) {
		                regex =
		                    '^' +
		                    this.weekdays(mom, '') +
		                    '|^' +
		                    this.weekdaysShort(mom, '') +
		                    '|^' +
		                    this.weekdaysMin(mom, '');
		                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
		            }
		            // test the regex
		            if (
		                strict &&
		                format === 'dddd' &&
		                this._fullWeekdaysParse[i].test(weekdayName)
		            ) {
		                return i;
		            } else if (
		                strict &&
		                format === 'ddd' &&
		                this._shortWeekdaysParse[i].test(weekdayName)
		            ) {
		                return i;
		            } else if (
		                strict &&
		                format === 'dd' &&
		                this._minWeekdaysParse[i].test(weekdayName)
		            ) {
		                return i;
		            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
		                return i;
		            }
		        }
		    }

		    // MOMENTS

		    function getSetDayOfWeek(input) {
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }
		        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
		        if (input != null) {
		            input = parseWeekday(input, this.localeData());
		            return this.add(input - day, 'd');
		        } else {
		            return day;
		        }
		    }

		    function getSetLocaleDayOfWeek(input) {
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }
		        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
		        return input == null ? weekday : this.add(input - weekday, 'd');
		    }

		    function getSetISODayOfWeek(input) {
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }

		        // behaves the same as moment#day except
		        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
		        // as a setter, sunday should belong to the previous week.

		        if (input != null) {
		            var weekday = parseIsoWeekday(input, this.localeData());
		            return this.day(this.day() % 7 ? weekday : weekday - 7);
		        } else {
		            return this.day() || 7;
		        }
		    }

		    function weekdaysRegex(isStrict) {
		        if (this._weekdaysParseExact) {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                computeWeekdaysParse.call(this);
		            }
		            if (isStrict) {
		                return this._weekdaysStrictRegex;
		            } else {
		                return this._weekdaysRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                this._weekdaysRegex = defaultWeekdaysRegex;
		            }
		            return this._weekdaysStrictRegex && isStrict
		                ? this._weekdaysStrictRegex
		                : this._weekdaysRegex;
		        }
		    }

		    function weekdaysShortRegex(isStrict) {
		        if (this._weekdaysParseExact) {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                computeWeekdaysParse.call(this);
		            }
		            if (isStrict) {
		                return this._weekdaysShortStrictRegex;
		            } else {
		                return this._weekdaysShortRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
		                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
		            }
		            return this._weekdaysShortStrictRegex && isStrict
		                ? this._weekdaysShortStrictRegex
		                : this._weekdaysShortRegex;
		        }
		    }

		    function weekdaysMinRegex(isStrict) {
		        if (this._weekdaysParseExact) {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                computeWeekdaysParse.call(this);
		            }
		            if (isStrict) {
		                return this._weekdaysMinStrictRegex;
		            } else {
		                return this._weekdaysMinRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
		                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
		            }
		            return this._weekdaysMinStrictRegex && isStrict
		                ? this._weekdaysMinStrictRegex
		                : this._weekdaysMinRegex;
		        }
		    }

		    function computeWeekdaysParse() {
		        function cmpLenRev(a, b) {
		            return b.length - a.length;
		        }

		        var minPieces = [],
		            shortPieces = [],
		            longPieces = [],
		            mixedPieces = [],
		            i,
		            mom,
		            minp,
		            shortp,
		            longp;
		        for (i = 0; i < 7; i++) {
		            // make the regex if we don't have it already
		            mom = createUTC([2000, 1]).day(i);
		            minp = regexEscape(this.weekdaysMin(mom, ''));
		            shortp = regexEscape(this.weekdaysShort(mom, ''));
		            longp = regexEscape(this.weekdays(mom, ''));
		            minPieces.push(minp);
		            shortPieces.push(shortp);
		            longPieces.push(longp);
		            mixedPieces.push(minp);
		            mixedPieces.push(shortp);
		            mixedPieces.push(longp);
		        }
		        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
		        // will match the longer piece.
		        minPieces.sort(cmpLenRev);
		        shortPieces.sort(cmpLenRev);
		        longPieces.sort(cmpLenRev);
		        mixedPieces.sort(cmpLenRev);

		        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		        this._weekdaysShortRegex = this._weekdaysRegex;
		        this._weekdaysMinRegex = this._weekdaysRegex;

		        this._weekdaysStrictRegex = new RegExp(
		            '^(' + longPieces.join('|') + ')',
		            'i'
		        );
		        this._weekdaysShortStrictRegex = new RegExp(
		            '^(' + shortPieces.join('|') + ')',
		            'i'
		        );
		        this._weekdaysMinStrictRegex = new RegExp(
		            '^(' + minPieces.join('|') + ')',
		            'i'
		        );
		    }

		    // FORMATTING

		    function hFormat() {
		        return this.hours() % 12 || 12;
		    }

		    function kFormat() {
		        return this.hours() || 24;
		    }

		    addFormatToken('H', ['HH', 2], 0, 'hour');
		    addFormatToken('h', ['hh', 2], 0, hFormat);
		    addFormatToken('k', ['kk', 2], 0, kFormat);

		    addFormatToken('hmm', 0, 0, function () {
		        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
		    });

		    addFormatToken('hmmss', 0, 0, function () {
		        return (
		            '' +
		            hFormat.apply(this) +
		            zeroFill(this.minutes(), 2) +
		            zeroFill(this.seconds(), 2)
		        );
		    });

		    addFormatToken('Hmm', 0, 0, function () {
		        return '' + this.hours() + zeroFill(this.minutes(), 2);
		    });

		    addFormatToken('Hmmss', 0, 0, function () {
		        return (
		            '' +
		            this.hours() +
		            zeroFill(this.minutes(), 2) +
		            zeroFill(this.seconds(), 2)
		        );
		    });

		    function meridiem(token, lowercase) {
		        addFormatToken(token, 0, 0, function () {
		            return this.localeData().meridiem(
		                this.hours(),
		                this.minutes(),
		                lowercase
		            );
		        });
		    }

		    meridiem('a', true);
		    meridiem('A', false);

		    // ALIASES

		    addUnitAlias('hour', 'h');

		    // PRIORITY
		    addUnitPriority('hour', 13);

		    // PARSING

		    function matchMeridiem(isStrict, locale) {
		        return locale._meridiemParse;
		    }

		    addRegexToken('a', matchMeridiem);
		    addRegexToken('A', matchMeridiem);
		    addRegexToken('H', match1to2);
		    addRegexToken('h', match1to2);
		    addRegexToken('k', match1to2);
		    addRegexToken('HH', match1to2, match2);
		    addRegexToken('hh', match1to2, match2);
		    addRegexToken('kk', match1to2, match2);

		    addRegexToken('hmm', match3to4);
		    addRegexToken('hmmss', match5to6);
		    addRegexToken('Hmm', match3to4);
		    addRegexToken('Hmmss', match5to6);

		    addParseToken(['H', 'HH'], HOUR);
		    addParseToken(['k', 'kk'], function (input, array, config) {
		        var kInput = toInt(input);
		        array[HOUR] = kInput === 24 ? 0 : kInput;
		    });
		    addParseToken(['a', 'A'], function (input, array, config) {
		        config._isPm = config._locale.isPM(input);
		        config._meridiem = input;
		    });
		    addParseToken(['h', 'hh'], function (input, array, config) {
		        array[HOUR] = toInt(input);
		        getParsingFlags(config).bigHour = true;
		    });
		    addParseToken('hmm', function (input, array, config) {
		        var pos = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos));
		        array[MINUTE] = toInt(input.substr(pos));
		        getParsingFlags(config).bigHour = true;
		    });
		    addParseToken('hmmss', function (input, array, config) {
		        var pos1 = input.length - 4,
		            pos2 = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos1));
		        array[MINUTE] = toInt(input.substr(pos1, 2));
		        array[SECOND] = toInt(input.substr(pos2));
		        getParsingFlags(config).bigHour = true;
		    });
		    addParseToken('Hmm', function (input, array, config) {
		        var pos = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos));
		        array[MINUTE] = toInt(input.substr(pos));
		    });
		    addParseToken('Hmmss', function (input, array, config) {
		        var pos1 = input.length - 4,
		            pos2 = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos1));
		        array[MINUTE] = toInt(input.substr(pos1, 2));
		        array[SECOND] = toInt(input.substr(pos2));
		    });

		    // LOCALES

		    function localeIsPM(input) {
		        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
		        // Using charAt should be more compatible.
		        return (input + '').toLowerCase().charAt(0) === 'p';
		    }

		    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
		        // Setting the hour should keep the time, because the user explicitly
		        // specified which hour they want. So trying to maintain the same hour (in
		        // a new timezone) makes sense. Adding/subtracting hours does not follow
		        // this rule.
		        getSetHour = makeGetSet('Hours', true);

		    function localeMeridiem(hours, minutes, isLower) {
		        if (hours > 11) {
		            return isLower ? 'pm' : 'PM';
		        } else {
		            return isLower ? 'am' : 'AM';
		        }
		    }

		    var baseConfig = {
		        calendar: defaultCalendar,
		        longDateFormat: defaultLongDateFormat,
		        invalidDate: defaultInvalidDate,
		        ordinal: defaultOrdinal,
		        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
		        relativeTime: defaultRelativeTime,

		        months: defaultLocaleMonths,
		        monthsShort: defaultLocaleMonthsShort,

		        week: defaultLocaleWeek,

		        weekdays: defaultLocaleWeekdays,
		        weekdaysMin: defaultLocaleWeekdaysMin,
		        weekdaysShort: defaultLocaleWeekdaysShort,

		        meridiemParse: defaultLocaleMeridiemParse,
		    };

		    // internal storage for locale config files
		    var locales = {},
		        localeFamilies = {},
		        globalLocale;

		    function commonPrefix(arr1, arr2) {
		        var i,
		            minl = Math.min(arr1.length, arr2.length);
		        for (i = 0; i < minl; i += 1) {
		            if (arr1[i] !== arr2[i]) {
		                return i;
		            }
		        }
		        return minl;
		    }

		    function normalizeLocale(key) {
		        return key ? key.toLowerCase().replace('_', '-') : key;
		    }

		    // pick the locale from the array
		    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
		    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
		    function chooseLocale(names) {
		        var i = 0,
		            j,
		            next,
		            locale,
		            split;

		        while (i < names.length) {
		            split = normalizeLocale(names[i]).split('-');
		            j = split.length;
		            next = normalizeLocale(names[i + 1]);
		            next = next ? next.split('-') : null;
		            while (j > 0) {
		                locale = loadLocale(split.slice(0, j).join('-'));
		                if (locale) {
		                    return locale;
		                }
		                if (
		                    next &&
		                    next.length >= j &&
		                    commonPrefix(split, next) >= j - 1
		                ) {
		                    //the next array item is better than a shallower substring of this one
		                    break;
		                }
		                j--;
		            }
		            i++;
		        }
		        return globalLocale;
		    }

		    function isLocaleNameSane(name) {
		        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
		        return name.match('^[^/\\\\]*$') != null;
		    }

		    function loadLocale(name) {
		        var oldLocale = null,
		            aliasedRequire;
		        // TODO: Find a better way to register and load all the locales in Node
		        if (
		            locales[name] === undefined &&
		            'object' !== 'undefined' &&
		            module &&
		            module.exports &&
		            isLocaleNameSane(name)
		        ) {
		            try {
		                oldLocale = globalLocale._abbr;
		                aliasedRequire = commonjsRequire;
		                aliasedRequire('./locale/' + name);
		                getSetGlobalLocale(oldLocale);
		            } catch (e) {
		                // mark as not found to avoid repeating expensive file require call causing high CPU
		                // when trying to find en-US, en_US, en-us for every format call
		                locales[name] = null; // null means not found
		            }
		        }
		        return locales[name];
		    }

		    // This function will load locale and then set the global locale.  If
		    // no arguments are passed in, it will simply return the current global
		    // locale key.
		    function getSetGlobalLocale(key, values) {
		        var data;
		        if (key) {
		            if (isUndefined(values)) {
		                data = getLocale(key);
		            } else {
		                data = defineLocale(key, values);
		            }

		            if (data) {
		                // moment.duration._locale = moment._locale = data;
		                globalLocale = data;
		            } else {
		                if (typeof console !== 'undefined' && console.warn) {
		                    //warn user if arguments are passed but the locale could not be set
		                    console.warn(
		                        'Locale ' + key + ' not found. Did you forget to load it?'
		                    );
		                }
		            }
		        }

		        return globalLocale._abbr;
		    }

		    function defineLocale(name, config) {
		        if (config !== null) {
		            var locale,
		                parentConfig = baseConfig;
		            config.abbr = name;
		            if (locales[name] != null) {
		                deprecateSimple(
		                    'defineLocaleOverride',
		                    'use moment.updateLocale(localeName, config) to change ' +
		                        'an existing locale. moment.defineLocale(localeName, ' +
		                        'config) should only be used for creating a new locale ' +
		                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
		                );
		                parentConfig = locales[name]._config;
		            } else if (config.parentLocale != null) {
		                if (locales[config.parentLocale] != null) {
		                    parentConfig = locales[config.parentLocale]._config;
		                } else {
		                    locale = loadLocale(config.parentLocale);
		                    if (locale != null) {
		                        parentConfig = locale._config;
		                    } else {
		                        if (!localeFamilies[config.parentLocale]) {
		                            localeFamilies[config.parentLocale] = [];
		                        }
		                        localeFamilies[config.parentLocale].push({
		                            name: name,
		                            config: config,
		                        });
		                        return null;
		                    }
		                }
		            }
		            locales[name] = new Locale(mergeConfigs(parentConfig, config));

		            if (localeFamilies[name]) {
		                localeFamilies[name].forEach(function (x) {
		                    defineLocale(x.name, x.config);
		                });
		            }

		            // backwards compat for now: also set the locale
		            // make sure we set the locale AFTER all child locales have been
		            // created, so we won't end up with the child locale set.
		            getSetGlobalLocale(name);

		            return locales[name];
		        } else {
		            // useful for testing
		            delete locales[name];
		            return null;
		        }
		    }

		    function updateLocale(name, config) {
		        if (config != null) {
		            var locale,
		                tmpLocale,
		                parentConfig = baseConfig;

		            if (locales[name] != null && locales[name].parentLocale != null) {
		                // Update existing child locale in-place to avoid memory-leaks
		                locales[name].set(mergeConfigs(locales[name]._config, config));
		            } else {
		                // MERGE
		                tmpLocale = loadLocale(name);
		                if (tmpLocale != null) {
		                    parentConfig = tmpLocale._config;
		                }
		                config = mergeConfigs(parentConfig, config);
		                if (tmpLocale == null) {
		                    // updateLocale is called for creating a new locale
		                    // Set abbr so it will have a name (getters return
		                    // undefined otherwise).
		                    config.abbr = name;
		                }
		                locale = new Locale(config);
		                locale.parentLocale = locales[name];
		                locales[name] = locale;
		            }

		            // backwards compat for now: also set the locale
		            getSetGlobalLocale(name);
		        } else {
		            // pass null for config to unupdate, useful for tests
		            if (locales[name] != null) {
		                if (locales[name].parentLocale != null) {
		                    locales[name] = locales[name].parentLocale;
		                    if (name === getSetGlobalLocale()) {
		                        getSetGlobalLocale(name);
		                    }
		                } else if (locales[name] != null) {
		                    delete locales[name];
		                }
		            }
		        }
		        return locales[name];
		    }

		    // returns locale data
		    function getLocale(key) {
		        var locale;

		        if (key && key._locale && key._locale._abbr) {
		            key = key._locale._abbr;
		        }

		        if (!key) {
		            return globalLocale;
		        }

		        if (!isArray(key)) {
		            //short-circuit everything else
		            locale = loadLocale(key);
		            if (locale) {
		                return locale;
		            }
		            key = [key];
		        }

		        return chooseLocale(key);
		    }

		    function listLocales() {
		        return keys(locales);
		    }

		    function checkOverflow(m) {
		        var overflow,
		            a = m._a;

		        if (a && getParsingFlags(m).overflow === -2) {
		            overflow =
		                a[MONTH] < 0 || a[MONTH] > 11
		                    ? MONTH
		                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
		                    ? DATE
		                    : a[HOUR] < 0 ||
		                      a[HOUR] > 24 ||
		                      (a[HOUR] === 24 &&
		                          (a[MINUTE] !== 0 ||
		                              a[SECOND] !== 0 ||
		                              a[MILLISECOND] !== 0))
		                    ? HOUR
		                    : a[MINUTE] < 0 || a[MINUTE] > 59
		                    ? MINUTE
		                    : a[SECOND] < 0 || a[SECOND] > 59
		                    ? SECOND
		                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
		                    ? MILLISECOND
		                    : -1;

		            if (
		                getParsingFlags(m)._overflowDayOfYear &&
		                (overflow < YEAR || overflow > DATE)
		            ) {
		                overflow = DATE;
		            }
		            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
		                overflow = WEEK;
		            }
		            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
		                overflow = WEEKDAY;
		            }

		            getParsingFlags(m).overflow = overflow;
		        }

		        return m;
		    }

		    // iso 8601 regex
		    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
		    var extendedIsoRegex =
		            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		        basicIsoRegex =
		            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
		        isoDates = [
		            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
		            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
		            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
		            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
		            ['YYYY-DDD', /\d{4}-\d{3}/],
		            ['YYYY-MM', /\d{4}-\d\d/, false],
		            ['YYYYYYMMDD', /[+-]\d{10}/],
		            ['YYYYMMDD', /\d{8}/],
		            ['GGGG[W]WWE', /\d{4}W\d{3}/],
		            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
		            ['YYYYDDD', /\d{7}/],
		            ['YYYYMM', /\d{6}/, false],
		            ['YYYY', /\d{4}/, false],
		        ],
		        // iso time formats and regexes
		        isoTimes = [
		            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
		            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
		            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
		            ['HH:mm', /\d\d:\d\d/],
		            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
		            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
		            ['HHmmss', /\d\d\d\d\d\d/],
		            ['HHmm', /\d\d\d\d/],
		            ['HH', /\d\d/],
		        ],
		        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
		        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
		        rfc2822 =
		            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
		        obsOffsets = {
		            UT: 0,
		            GMT: 0,
		            EDT: -4 * 60,
		            EST: -5 * 60,
		            CDT: -5 * 60,
		            CST: -6 * 60,
		            MDT: -6 * 60,
		            MST: -7 * 60,
		            PDT: -7 * 60,
		            PST: -8 * 60,
		        };

		    // date from iso format
		    function configFromISO(config) {
		        var i,
		            l,
		            string = config._i,
		            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
		            allowTime,
		            dateFormat,
		            timeFormat,
		            tzFormat,
		            isoDatesLen = isoDates.length,
		            isoTimesLen = isoTimes.length;

		        if (match) {
		            getParsingFlags(config).iso = true;
		            for (i = 0, l = isoDatesLen; i < l; i++) {
		                if (isoDates[i][1].exec(match[1])) {
		                    dateFormat = isoDates[i][0];
		                    allowTime = isoDates[i][2] !== false;
		                    break;
		                }
		            }
		            if (dateFormat == null) {
		                config._isValid = false;
		                return;
		            }
		            if (match[3]) {
		                for (i = 0, l = isoTimesLen; i < l; i++) {
		                    if (isoTimes[i][1].exec(match[3])) {
		                        // match[2] should be 'T' or space
		                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
		                        break;
		                    }
		                }
		                if (timeFormat == null) {
		                    config._isValid = false;
		                    return;
		                }
		            }
		            if (!allowTime && timeFormat != null) {
		                config._isValid = false;
		                return;
		            }
		            if (match[4]) {
		                if (tzRegex.exec(match[4])) {
		                    tzFormat = 'Z';
		                } else {
		                    config._isValid = false;
		                    return;
		                }
		            }
		            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
		            configFromStringAndFormat(config);
		        } else {
		            config._isValid = false;
		        }
		    }

		    function extractFromRFC2822Strings(
		        yearStr,
		        monthStr,
		        dayStr,
		        hourStr,
		        minuteStr,
		        secondStr
		    ) {
		        var result = [
		            untruncateYear(yearStr),
		            defaultLocaleMonthsShort.indexOf(monthStr),
		            parseInt(dayStr, 10),
		            parseInt(hourStr, 10),
		            parseInt(minuteStr, 10),
		        ];

		        if (secondStr) {
		            result.push(parseInt(secondStr, 10));
		        }

		        return result;
		    }

		    function untruncateYear(yearStr) {
		        var year = parseInt(yearStr, 10);
		        if (year <= 49) {
		            return 2000 + year;
		        } else if (year <= 999) {
		            return 1900 + year;
		        }
		        return year;
		    }

		    function preprocessRFC2822(s) {
		        // Remove comments and folding whitespace and replace multiple-spaces with a single space
		        return s
		            .replace(/\([^()]*\)|[\n\t]/g, ' ')
		            .replace(/(\s\s+)/g, ' ')
		            .replace(/^\s\s*/, '')
		            .replace(/\s\s*$/, '');
		    }

		    function checkWeekday(weekdayStr, parsedInput, config) {
		        if (weekdayStr) {
		            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
		            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
		                weekdayActual = new Date(
		                    parsedInput[0],
		                    parsedInput[1],
		                    parsedInput[2]
		                ).getDay();
		            if (weekdayProvided !== weekdayActual) {
		                getParsingFlags(config).weekdayMismatch = true;
		                config._isValid = false;
		                return false;
		            }
		        }
		        return true;
		    }

		    function calculateOffset(obsOffset, militaryOffset, numOffset) {
		        if (obsOffset) {
		            return obsOffsets[obsOffset];
		        } else if (militaryOffset) {
		            // the only allowed military tz is Z
		            return 0;
		        } else {
		            var hm = parseInt(numOffset, 10),
		                m = hm % 100,
		                h = (hm - m) / 100;
		            return h * 60 + m;
		        }
		    }

		    // date and time from ref 2822 format
		    function configFromRFC2822(config) {
		        var match = rfc2822.exec(preprocessRFC2822(config._i)),
		            parsedArray;
		        if (match) {
		            parsedArray = extractFromRFC2822Strings(
		                match[4],
		                match[3],
		                match[2],
		                match[5],
		                match[6],
		                match[7]
		            );
		            if (!checkWeekday(match[1], parsedArray, config)) {
		                return;
		            }

		            config._a = parsedArray;
		            config._tzm = calculateOffset(match[8], match[9], match[10]);

		            config._d = createUTCDate.apply(null, config._a);
		            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

		            getParsingFlags(config).rfc2822 = true;
		        } else {
		            config._isValid = false;
		        }
		    }

		    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
		    function configFromString(config) {
		        var matched = aspNetJsonRegex.exec(config._i);
		        if (matched !== null) {
		            config._d = new Date(+matched[1]);
		            return;
		        }

		        configFromISO(config);
		        if (config._isValid === false) {
		            delete config._isValid;
		        } else {
		            return;
		        }

		        configFromRFC2822(config);
		        if (config._isValid === false) {
		            delete config._isValid;
		        } else {
		            return;
		        }

		        if (config._strict) {
		            config._isValid = false;
		        } else {
		            // Final attempt, use Input Fallback
		            hooks.createFromInputFallback(config);
		        }
		    }

		    hooks.createFromInputFallback = deprecate(
		        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
		            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
		            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
		        function (config) {
		            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
		        }
		    );

		    // Pick the first defined of two or three arguments.
		    function defaults(a, b, c) {
		        if (a != null) {
		            return a;
		        }
		        if (b != null) {
		            return b;
		        }
		        return c;
		    }

		    function currentDateArray(config) {
		        // hooks is actually the exported moment object
		        var nowValue = new Date(hooks.now());
		        if (config._useUTC) {
		            return [
		                nowValue.getUTCFullYear(),
		                nowValue.getUTCMonth(),
		                nowValue.getUTCDate(),
		            ];
		        }
		        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
		    }

		    // convert an array to a date.
		    // the array should mirror the parameters below
		    // note: all values past the year are optional and will default to the lowest possible value.
		    // [year, month, day , hour, minute, second, millisecond]
		    function configFromArray(config) {
		        var i,
		            date,
		            input = [],
		            currentDate,
		            expectedWeekday,
		            yearToUse;

		        if (config._d) {
		            return;
		        }

		        currentDate = currentDateArray(config);

		        //compute day of the year from weeks and weekdays
		        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
		            dayOfYearFromWeekInfo(config);
		        }

		        //if the day of the year is set, figure out what it is
		        if (config._dayOfYear != null) {
		            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

		            if (
		                config._dayOfYear > daysInYear(yearToUse) ||
		                config._dayOfYear === 0
		            ) {
		                getParsingFlags(config)._overflowDayOfYear = true;
		            }

		            date = createUTCDate(yearToUse, 0, config._dayOfYear);
		            config._a[MONTH] = date.getUTCMonth();
		            config._a[DATE] = date.getUTCDate();
		        }

		        // Default to current date.
		        // * if no year, month, day of month are given, default to today
		        // * if day of month is given, default month and year
		        // * if month is given, default only year
		        // * if year is given, don't default anything
		        for (i = 0; i < 3 && config._a[i] == null; ++i) {
		            config._a[i] = input[i] = currentDate[i];
		        }

		        // Zero out whatever was not defaulted, including time
		        for (; i < 7; i++) {
		            config._a[i] = input[i] =
		                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
		        }

		        // Check for 24:00:00.000
		        if (
		            config._a[HOUR] === 24 &&
		            config._a[MINUTE] === 0 &&
		            config._a[SECOND] === 0 &&
		            config._a[MILLISECOND] === 0
		        ) {
		            config._nextDay = true;
		            config._a[HOUR] = 0;
		        }

		        config._d = (config._useUTC ? createUTCDate : createDate).apply(
		            null,
		            input
		        );
		        expectedWeekday = config._useUTC
		            ? config._d.getUTCDay()
		            : config._d.getDay();

		        // Apply timezone offset from input. The actual utcOffset can be changed
		        // with parseZone.
		        if (config._tzm != null) {
		            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
		        }

		        if (config._nextDay) {
		            config._a[HOUR] = 24;
		        }

		        // check for mismatching day of week
		        if (
		            config._w &&
		            typeof config._w.d !== 'undefined' &&
		            config._w.d !== expectedWeekday
		        ) {
		            getParsingFlags(config).weekdayMismatch = true;
		        }
		    }

		    function dayOfYearFromWeekInfo(config) {
		        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

		        w = config._w;
		        if (w.GG != null || w.W != null || w.E != null) {
		            dow = 1;
		            doy = 4;

		            // TODO: We need to take the current isoWeekYear, but that depends on
		            // how we interpret now (local, utc, fixed offset). So create
		            // a now version of current config (take local/utc/offset flags, and
		            // create now).
		            weekYear = defaults(
		                w.GG,
		                config._a[YEAR],
		                weekOfYear(createLocal(), 1, 4).year
		            );
		            week = defaults(w.W, 1);
		            weekday = defaults(w.E, 1);
		            if (weekday < 1 || weekday > 7) {
		                weekdayOverflow = true;
		            }
		        } else {
		            dow = config._locale._week.dow;
		            doy = config._locale._week.doy;

		            curWeek = weekOfYear(createLocal(), dow, doy);

		            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

		            // Default to current week.
		            week = defaults(w.w, curWeek.week);

		            if (w.d != null) {
		                // weekday -- low day numbers are considered next week
		                weekday = w.d;
		                if (weekday < 0 || weekday > 6) {
		                    weekdayOverflow = true;
		                }
		            } else if (w.e != null) {
		                // local weekday -- counting starts from beginning of week
		                weekday = w.e + dow;
		                if (w.e < 0 || w.e > 6) {
		                    weekdayOverflow = true;
		                }
		            } else {
		                // default to beginning of week
		                weekday = dow;
		            }
		        }
		        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
		            getParsingFlags(config)._overflowWeeks = true;
		        } else if (weekdayOverflow != null) {
		            getParsingFlags(config)._overflowWeekday = true;
		        } else {
		            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
		            config._a[YEAR] = temp.year;
		            config._dayOfYear = temp.dayOfYear;
		        }
		    }

		    // constant that refers to the ISO standard
		    hooks.ISO_8601 = function () {};

		    // constant that refers to the RFC 2822 form
		    hooks.RFC_2822 = function () {};

		    // date from string and format string
		    function configFromStringAndFormat(config) {
		        // TODO: Move this to another part of the creation flow to prevent circular deps
		        if (config._f === hooks.ISO_8601) {
		            configFromISO(config);
		            return;
		        }
		        if (config._f === hooks.RFC_2822) {
		            configFromRFC2822(config);
		            return;
		        }
		        config._a = [];
		        getParsingFlags(config).empty = true;

		        // This array is used to make a Date, either with `new Date` or `Date.UTC`
		        var string = '' + config._i,
		            i,
		            parsedInput,
		            tokens,
		            token,
		            skipped,
		            stringLength = string.length,
		            totalParsedInputLength = 0,
		            era,
		            tokenLen;

		        tokens =
		            expandFormat(config._f, config._locale).match(formattingTokens) || [];
		        tokenLen = tokens.length;
		        for (i = 0; i < tokenLen; i++) {
		            token = tokens[i];
		            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
		                [])[0];
		            if (parsedInput) {
		                skipped = string.substr(0, string.indexOf(parsedInput));
		                if (skipped.length > 0) {
		                    getParsingFlags(config).unusedInput.push(skipped);
		                }
		                string = string.slice(
		                    string.indexOf(parsedInput) + parsedInput.length
		                );
		                totalParsedInputLength += parsedInput.length;
		            }
		            // don't parse if it's not a known token
		            if (formatTokenFunctions[token]) {
		                if (parsedInput) {
		                    getParsingFlags(config).empty = false;
		                } else {
		                    getParsingFlags(config).unusedTokens.push(token);
		                }
		                addTimeToArrayFromToken(token, parsedInput, config);
		            } else if (config._strict && !parsedInput) {
		                getParsingFlags(config).unusedTokens.push(token);
		            }
		        }

		        // add remaining unparsed input length to the string
		        getParsingFlags(config).charsLeftOver =
		            stringLength - totalParsedInputLength;
		        if (string.length > 0) {
		            getParsingFlags(config).unusedInput.push(string);
		        }

		        // clear _12h flag if hour is <= 12
		        if (
		            config._a[HOUR] <= 12 &&
		            getParsingFlags(config).bigHour === true &&
		            config._a[HOUR] > 0
		        ) {
		            getParsingFlags(config).bigHour = undefined;
		        }

		        getParsingFlags(config).parsedDateParts = config._a.slice(0);
		        getParsingFlags(config).meridiem = config._meridiem;
		        // handle meridiem
		        config._a[HOUR] = meridiemFixWrap(
		            config._locale,
		            config._a[HOUR],
		            config._meridiem
		        );

		        // handle era
		        era = getParsingFlags(config).era;
		        if (era !== null) {
		            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
		        }

		        configFromArray(config);
		        checkOverflow(config);
		    }

		    function meridiemFixWrap(locale, hour, meridiem) {
		        var isPm;

		        if (meridiem == null) {
		            // nothing to do
		            return hour;
		        }
		        if (locale.meridiemHour != null) {
		            return locale.meridiemHour(hour, meridiem);
		        } else if (locale.isPM != null) {
		            // Fallback
		            isPm = locale.isPM(meridiem);
		            if (isPm && hour < 12) {
		                hour += 12;
		            }
		            if (!isPm && hour === 12) {
		                hour = 0;
		            }
		            return hour;
		        } else {
		            // this is not supposed to happen
		            return hour;
		        }
		    }

		    // date from string and array of format strings
		    function configFromStringAndArray(config) {
		        var tempConfig,
		            bestMoment,
		            scoreToBeat,
		            i,
		            currentScore,
		            validFormatFound,
		            bestFormatIsValid = false,
		            configfLen = config._f.length;

		        if (configfLen === 0) {
		            getParsingFlags(config).invalidFormat = true;
		            config._d = new Date(NaN);
		            return;
		        }

		        for (i = 0; i < configfLen; i++) {
		            currentScore = 0;
		            validFormatFound = false;
		            tempConfig = copyConfig({}, config);
		            if (config._useUTC != null) {
		                tempConfig._useUTC = config._useUTC;
		            }
		            tempConfig._f = config._f[i];
		            configFromStringAndFormat(tempConfig);

		            if (isValid(tempConfig)) {
		                validFormatFound = true;
		            }

		            // if there is any input that was not parsed add a penalty for that format
		            currentScore += getParsingFlags(tempConfig).charsLeftOver;

		            //or tokens
		            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

		            getParsingFlags(tempConfig).score = currentScore;

		            if (!bestFormatIsValid) {
		                if (
		                    scoreToBeat == null ||
		                    currentScore < scoreToBeat ||
		                    validFormatFound
		                ) {
		                    scoreToBeat = currentScore;
		                    bestMoment = tempConfig;
		                    if (validFormatFound) {
		                        bestFormatIsValid = true;
		                    }
		                }
		            } else {
		                if (currentScore < scoreToBeat) {
		                    scoreToBeat = currentScore;
		                    bestMoment = tempConfig;
		                }
		            }
		        }

		        extend(config, bestMoment || tempConfig);
		    }

		    function configFromObject(config) {
		        if (config._d) {
		            return;
		        }

		        var i = normalizeObjectUnits(config._i),
		            dayOrDate = i.day === undefined ? i.date : i.day;
		        config._a = map(
		            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
		            function (obj) {
		                return obj && parseInt(obj, 10);
		            }
		        );

		        configFromArray(config);
		    }

		    function createFromConfig(config) {
		        var res = new Moment(checkOverflow(prepareConfig(config)));
		        if (res._nextDay) {
		            // Adding is smart enough around DST
		            res.add(1, 'd');
		            res._nextDay = undefined;
		        }

		        return res;
		    }

		    function prepareConfig(config) {
		        var input = config._i,
		            format = config._f;

		        config._locale = config._locale || getLocale(config._l);

		        if (input === null || (format === undefined && input === '')) {
		            return createInvalid({ nullInput: true });
		        }

		        if (typeof input === 'string') {
		            config._i = input = config._locale.preparse(input);
		        }

		        if (isMoment(input)) {
		            return new Moment(checkOverflow(input));
		        } else if (isDate(input)) {
		            config._d = input;
		        } else if (isArray(format)) {
		            configFromStringAndArray(config);
		        } else if (format) {
		            configFromStringAndFormat(config);
		        } else {
		            configFromInput(config);
		        }

		        if (!isValid(config)) {
		            config._d = null;
		        }

		        return config;
		    }

		    function configFromInput(config) {
		        var input = config._i;
		        if (isUndefined(input)) {
		            config._d = new Date(hooks.now());
		        } else if (isDate(input)) {
		            config._d = new Date(input.valueOf());
		        } else if (typeof input === 'string') {
		            configFromString(config);
		        } else if (isArray(input)) {
		            config._a = map(input.slice(0), function (obj) {
		                return parseInt(obj, 10);
		            });
		            configFromArray(config);
		        } else if (isObject(input)) {
		            configFromObject(config);
		        } else if (isNumber(input)) {
		            // from milliseconds
		            config._d = new Date(input);
		        } else {
		            hooks.createFromInputFallback(config);
		        }
		    }

		    function createLocalOrUTC(input, format, locale, strict, isUTC) {
		        var c = {};

		        if (format === true || format === false) {
		            strict = format;
		            format = undefined;
		        }

		        if (locale === true || locale === false) {
		            strict = locale;
		            locale = undefined;
		        }

		        if (
		            (isObject(input) && isObjectEmpty(input)) ||
		            (isArray(input) && input.length === 0)
		        ) {
		            input = undefined;
		        }
		        // object construction must be done this way.
		        // https://github.com/moment/moment/issues/1423
		        c._isAMomentObject = true;
		        c._useUTC = c._isUTC = isUTC;
		        c._l = locale;
		        c._i = input;
		        c._f = format;
		        c._strict = strict;

		        return createFromConfig(c);
		    }

		    function createLocal(input, format, locale, strict) {
		        return createLocalOrUTC(input, format, locale, strict, false);
		    }

		    var prototypeMin = deprecate(
		            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
		            function () {
		                var other = createLocal.apply(null, arguments);
		                if (this.isValid() && other.isValid()) {
		                    return other < this ? this : other;
		                } else {
		                    return createInvalid();
		                }
		            }
		        ),
		        prototypeMax = deprecate(
		            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
		            function () {
		                var other = createLocal.apply(null, arguments);
		                if (this.isValid() && other.isValid()) {
		                    return other > this ? this : other;
		                } else {
		                    return createInvalid();
		                }
		            }
		        );

		    // Pick a moment m from moments so that m[fn](other) is true for all
		    // other. This relies on the function fn to be transitive.
		    //
		    // moments should either be an array of moment objects or an array, whose
		    // first element is an array of moment objects.
		    function pickBy(fn, moments) {
		        var res, i;
		        if (moments.length === 1 && isArray(moments[0])) {
		            moments = moments[0];
		        }
		        if (!moments.length) {
		            return createLocal();
		        }
		        res = moments[0];
		        for (i = 1; i < moments.length; ++i) {
		            if (!moments[i].isValid() || moments[i][fn](res)) {
		                res = moments[i];
		            }
		        }
		        return res;
		    }

		    // TODO: Use [].sort instead?
		    function min() {
		        var args = [].slice.call(arguments, 0);

		        return pickBy('isBefore', args);
		    }

		    function max() {
		        var args = [].slice.call(arguments, 0);

		        return pickBy('isAfter', args);
		    }

		    var now = function () {
		        return Date.now ? Date.now() : +new Date();
		    };

		    var ordering = [
		        'year',
		        'quarter',
		        'month',
		        'week',
		        'day',
		        'hour',
		        'minute',
		        'second',
		        'millisecond',
		    ];

		    function isDurationValid(m) {
		        var key,
		            unitHasDecimal = false,
		            i,
		            orderLen = ordering.length;
		        for (key in m) {
		            if (
		                hasOwnProp(m, key) &&
		                !(
		                    indexOf.call(ordering, key) !== -1 &&
		                    (m[key] == null || !isNaN(m[key]))
		                )
		            ) {
		                return false;
		            }
		        }

		        for (i = 0; i < orderLen; ++i) {
		            if (m[ordering[i]]) {
		                if (unitHasDecimal) {
		                    return false; // only allow non-integers for smallest unit
		                }
		                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
		                    unitHasDecimal = true;
		                }
		            }
		        }

		        return true;
		    }

		    function isValid$1() {
		        return this._isValid;
		    }

		    function createInvalid$1() {
		        return createDuration(NaN);
		    }

		    function Duration(duration) {
		        var normalizedInput = normalizeObjectUnits(duration),
		            years = normalizedInput.year || 0,
		            quarters = normalizedInput.quarter || 0,
		            months = normalizedInput.month || 0,
		            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
		            days = normalizedInput.day || 0,
		            hours = normalizedInput.hour || 0,
		            minutes = normalizedInput.minute || 0,
		            seconds = normalizedInput.second || 0,
		            milliseconds = normalizedInput.millisecond || 0;

		        this._isValid = isDurationValid(normalizedInput);

		        // representation for dateAddRemove
		        this._milliseconds =
		            +milliseconds +
		            seconds * 1e3 + // 1000
		            minutes * 6e4 + // 1000 * 60
		            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
		        // Because of dateAddRemove treats 24 hours as different from a
		        // day when working around DST, we need to store them separately
		        this._days = +days + weeks * 7;
		        // It is impossible to translate months into days without knowing
		        // which months you are are talking about, so we have to store
		        // it separately.
		        this._months = +months + quarters * 3 + years * 12;

		        this._data = {};

		        this._locale = getLocale();

		        this._bubble();
		    }

		    function isDuration(obj) {
		        return obj instanceof Duration;
		    }

		    function absRound(number) {
		        if (number < 0) {
		            return Math.round(-1 * number) * -1;
		        } else {
		            return Math.round(number);
		        }
		    }

		    // compare two arrays, return the number of differences
		    function compareArrays(array1, array2, dontConvert) {
		        var len = Math.min(array1.length, array2.length),
		            lengthDiff = Math.abs(array1.length - array2.length),
		            diffs = 0,
		            i;
		        for (i = 0; i < len; i++) {
		            if (
		                (dontConvert && array1[i] !== array2[i]) ||
		                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
		            ) {
		                diffs++;
		            }
		        }
		        return diffs + lengthDiff;
		    }

		    // FORMATTING

		    function offset(token, separator) {
		        addFormatToken(token, 0, 0, function () {
		            var offset = this.utcOffset(),
		                sign = '+';
		            if (offset < 0) {
		                offset = -offset;
		                sign = '-';
		            }
		            return (
		                sign +
		                zeroFill(~~(offset / 60), 2) +
		                separator +
		                zeroFill(~~offset % 60, 2)
		            );
		        });
		    }

		    offset('Z', ':');
		    offset('ZZ', '');

		    // PARSING

		    addRegexToken('Z', matchShortOffset);
		    addRegexToken('ZZ', matchShortOffset);
		    addParseToken(['Z', 'ZZ'], function (input, array, config) {
		        config._useUTC = true;
		        config._tzm = offsetFromString(matchShortOffset, input);
		    });

		    // HELPERS

		    // timezone chunker
		    // '+10:00' > ['10',  '00']
		    // '-1530'  > ['-15', '30']
		    var chunkOffset = /([\+\-]|\d\d)/gi;

		    function offsetFromString(matcher, string) {
		        var matches = (string || '').match(matcher),
		            chunk,
		            parts,
		            minutes;

		        if (matches === null) {
		            return null;
		        }

		        chunk = matches[matches.length - 1] || [];
		        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
		        minutes = +(parts[1] * 60) + toInt(parts[2]);

		        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
		    }

		    // Return a moment from input, that is local/utc/zone equivalent to model.
		    function cloneWithOffset(input, model) {
		        var res, diff;
		        if (model._isUTC) {
		            res = model.clone();
		            diff =
		                (isMoment(input) || isDate(input)
		                    ? input.valueOf()
		                    : createLocal(input).valueOf()) - res.valueOf();
		            // Use low-level api, because this fn is low-level api.
		            res._d.setTime(res._d.valueOf() + diff);
		            hooks.updateOffset(res, false);
		            return res;
		        } else {
		            return createLocal(input).local();
		        }
		    }

		    function getDateOffset(m) {
		        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
		        // https://github.com/moment/moment/pull/1871
		        return -Math.round(m._d.getTimezoneOffset());
		    }

		    // HOOKS

		    // This function will be called whenever a moment is mutated.
		    // It is intended to keep the offset in sync with the timezone.
		    hooks.updateOffset = function () {};

		    // MOMENTS

		    // keepLocalTime = true means only change the timezone, without
		    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
		    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
		    // +0200, so we adjust the time as needed, to be valid.
		    //
		    // Keeping the time actually adds/subtracts (one hour)
		    // from the actual represented time. That is why we call updateOffset
		    // a second time. In case it wants us to change the offset again
		    // _changeInProgress == true case, then we have to adjust, because
		    // there is no such time in the given timezone.
		    function getSetOffset(input, keepLocalTime, keepMinutes) {
		        var offset = this._offset || 0,
		            localAdjust;
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }
		        if (input != null) {
		            if (typeof input === 'string') {
		                input = offsetFromString(matchShortOffset, input);
		                if (input === null) {
		                    return this;
		                }
		            } else if (Math.abs(input) < 16 && !keepMinutes) {
		                input = input * 60;
		            }
		            if (!this._isUTC && keepLocalTime) {
		                localAdjust = getDateOffset(this);
		            }
		            this._offset = input;
		            this._isUTC = true;
		            if (localAdjust != null) {
		                this.add(localAdjust, 'm');
		            }
		            if (offset !== input) {
		                if (!keepLocalTime || this._changeInProgress) {
		                    addSubtract(
		                        this,
		                        createDuration(input - offset, 'm'),
		                        1,
		                        false
		                    );
		                } else if (!this._changeInProgress) {
		                    this._changeInProgress = true;
		                    hooks.updateOffset(this, true);
		                    this._changeInProgress = null;
		                }
		            }
		            return this;
		        } else {
		            return this._isUTC ? offset : getDateOffset(this);
		        }
		    }

		    function getSetZone(input, keepLocalTime) {
		        if (input != null) {
		            if (typeof input !== 'string') {
		                input = -input;
		            }

		            this.utcOffset(input, keepLocalTime);

		            return this;
		        } else {
		            return -this.utcOffset();
		        }
		    }

		    function setOffsetToUTC(keepLocalTime) {
		        return this.utcOffset(0, keepLocalTime);
		    }

		    function setOffsetToLocal(keepLocalTime) {
		        if (this._isUTC) {
		            this.utcOffset(0, keepLocalTime);
		            this._isUTC = false;

		            if (keepLocalTime) {
		                this.subtract(getDateOffset(this), 'm');
		            }
		        }
		        return this;
		    }

		    function setOffsetToParsedOffset() {
		        if (this._tzm != null) {
		            this.utcOffset(this._tzm, false, true);
		        } else if (typeof this._i === 'string') {
		            var tZone = offsetFromString(matchOffset, this._i);
		            if (tZone != null) {
		                this.utcOffset(tZone);
		            } else {
		                this.utcOffset(0, true);
		            }
		        }
		        return this;
		    }

		    function hasAlignedHourOffset(input) {
		        if (!this.isValid()) {
		            return false;
		        }
		        input = input ? createLocal(input).utcOffset() : 0;

		        return (this.utcOffset() - input) % 60 === 0;
		    }

		    function isDaylightSavingTime() {
		        return (
		            this.utcOffset() > this.clone().month(0).utcOffset() ||
		            this.utcOffset() > this.clone().month(5).utcOffset()
		        );
		    }

		    function isDaylightSavingTimeShifted() {
		        if (!isUndefined(this._isDSTShifted)) {
		            return this._isDSTShifted;
		        }

		        var c = {},
		            other;

		        copyConfig(c, this);
		        c = prepareConfig(c);

		        if (c._a) {
		            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
		            this._isDSTShifted =
		                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
		        } else {
		            this._isDSTShifted = false;
		        }

		        return this._isDSTShifted;
		    }

		    function isLocal() {
		        return this.isValid() ? !this._isUTC : false;
		    }

		    function isUtcOffset() {
		        return this.isValid() ? this._isUTC : false;
		    }

		    function isUtc() {
		        return this.isValid() ? this._isUTC && this._offset === 0 : false;
		    }

		    // ASP.NET json date format regex
		    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
		        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
		        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
		        // and further modified to allow for strings containing both week and day
		        isoRegex =
		            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

		    function createDuration(input, key) {
		        var duration = input,
		            // matching against regexp is expensive, do it on demand
		            match = null,
		            sign,
		            ret,
		            diffRes;

		        if (isDuration(input)) {
		            duration = {
		                ms: input._milliseconds,
		                d: input._days,
		                M: input._months,
		            };
		        } else if (isNumber(input) || !isNaN(+input)) {
		            duration = {};
		            if (key) {
		                duration[key] = +input;
		            } else {
		                duration.milliseconds = +input;
		            }
		        } else if ((match = aspNetRegex.exec(input))) {
		            sign = match[1] === '-' ? -1 : 1;
		            duration = {
		                y: 0,
		                d: toInt(match[DATE]) * sign,
		                h: toInt(match[HOUR]) * sign,
		                m: toInt(match[MINUTE]) * sign,
		                s: toInt(match[SECOND]) * sign,
		                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
		            };
		        } else if ((match = isoRegex.exec(input))) {
		            sign = match[1] === '-' ? -1 : 1;
		            duration = {
		                y: parseIso(match[2], sign),
		                M: parseIso(match[3], sign),
		                w: parseIso(match[4], sign),
		                d: parseIso(match[5], sign),
		                h: parseIso(match[6], sign),
		                m: parseIso(match[7], sign),
		                s: parseIso(match[8], sign),
		            };
		        } else if (duration == null) {
		            // checks for null or undefined
		            duration = {};
		        } else if (
		            typeof duration === 'object' &&
		            ('from' in duration || 'to' in duration)
		        ) {
		            diffRes = momentsDifference(
		                createLocal(duration.from),
		                createLocal(duration.to)
		            );

		            duration = {};
		            duration.ms = diffRes.milliseconds;
		            duration.M = diffRes.months;
		        }

		        ret = new Duration(duration);

		        if (isDuration(input) && hasOwnProp(input, '_locale')) {
		            ret._locale = input._locale;
		        }

		        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
		            ret._isValid = input._isValid;
		        }

		        return ret;
		    }

		    createDuration.fn = Duration.prototype;
		    createDuration.invalid = createInvalid$1;

		    function parseIso(inp, sign) {
		        // We'd normally use ~~inp for this, but unfortunately it also
		        // converts floats to ints.
		        // inp may be undefined, so careful calling replace on it.
		        var res = inp && parseFloat(inp.replace(',', '.'));
		        // apply sign while we're at it
		        return (isNaN(res) ? 0 : res) * sign;
		    }

		    function positiveMomentsDifference(base, other) {
		        var res = {};

		        res.months =
		            other.month() - base.month() + (other.year() - base.year()) * 12;
		        if (base.clone().add(res.months, 'M').isAfter(other)) {
		            --res.months;
		        }

		        res.milliseconds = +other - +base.clone().add(res.months, 'M');

		        return res;
		    }

		    function momentsDifference(base, other) {
		        var res;
		        if (!(base.isValid() && other.isValid())) {
		            return { milliseconds: 0, months: 0 };
		        }

		        other = cloneWithOffset(other, base);
		        if (base.isBefore(other)) {
		            res = positiveMomentsDifference(base, other);
		        } else {
		            res = positiveMomentsDifference(other, base);
		            res.milliseconds = -res.milliseconds;
		            res.months = -res.months;
		        }

		        return res;
		    }

		    // TODO: remove 'name' arg after deprecation is removed
		    function createAdder(direction, name) {
		        return function (val, period) {
		            var dur, tmp;
		            //invert the arguments, but complain about it
		            if (period !== null && !isNaN(+period)) {
		                deprecateSimple(
		                    name,
		                    'moment().' +
		                        name +
		                        '(period, number) is deprecated. Please use moment().' +
		                        name +
		                        '(number, period). ' +
		                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
		                );
		                tmp = val;
		                val = period;
		                period = tmp;
		            }

		            dur = createDuration(val, period);
		            addSubtract(this, dur, direction);
		            return this;
		        };
		    }

		    function addSubtract(mom, duration, isAdding, updateOffset) {
		        var milliseconds = duration._milliseconds,
		            days = absRound(duration._days),
		            months = absRound(duration._months);

		        if (!mom.isValid()) {
		            // No op
		            return;
		        }

		        updateOffset = updateOffset == null ? true : updateOffset;

		        if (months) {
		            setMonth(mom, get(mom, 'Month') + months * isAdding);
		        }
		        if (days) {
		            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
		        }
		        if (milliseconds) {
		            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
		        }
		        if (updateOffset) {
		            hooks.updateOffset(mom, days || months);
		        }
		    }

		    var add = createAdder(1, 'add'),
		        subtract = createAdder(-1, 'subtract');

		    function isString(input) {
		        return typeof input === 'string' || input instanceof String;
		    }

		    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
		    function isMomentInput(input) {
		        return (
		            isMoment(input) ||
		            isDate(input) ||
		            isString(input) ||
		            isNumber(input) ||
		            isNumberOrStringArray(input) ||
		            isMomentInputObject(input) ||
		            input === null ||
		            input === undefined
		        );
		    }

		    function isMomentInputObject(input) {
		        var objectTest = isObject(input) && !isObjectEmpty(input),
		            propertyTest = false,
		            properties = [
		                'years',
		                'year',
		                'y',
		                'months',
		                'month',
		                'M',
		                'days',
		                'day',
		                'd',
		                'dates',
		                'date',
		                'D',
		                'hours',
		                'hour',
		                'h',
		                'minutes',
		                'minute',
		                'm',
		                'seconds',
		                'second',
		                's',
		                'milliseconds',
		                'millisecond',
		                'ms',
		            ],
		            i,
		            property,
		            propertyLen = properties.length;

		        for (i = 0; i < propertyLen; i += 1) {
		            property = properties[i];
		            propertyTest = propertyTest || hasOwnProp(input, property);
		        }

		        return objectTest && propertyTest;
		    }

		    function isNumberOrStringArray(input) {
		        var arrayTest = isArray(input),
		            dataTypeTest = false;
		        if (arrayTest) {
		            dataTypeTest =
		                input.filter(function (item) {
		                    return !isNumber(item) && isString(input);
		                }).length === 0;
		        }
		        return arrayTest && dataTypeTest;
		    }

		    function isCalendarSpec(input) {
		        var objectTest = isObject(input) && !isObjectEmpty(input),
		            propertyTest = false,
		            properties = [
		                'sameDay',
		                'nextDay',
		                'lastDay',
		                'nextWeek',
		                'lastWeek',
		                'sameElse',
		            ],
		            i,
		            property;

		        for (i = 0; i < properties.length; i += 1) {
		            property = properties[i];
		            propertyTest = propertyTest || hasOwnProp(input, property);
		        }

		        return objectTest && propertyTest;
		    }

		    function getCalendarFormat(myMoment, now) {
		        var diff = myMoment.diff(now, 'days', true);
		        return diff < -6
		            ? 'sameElse'
		            : diff < -1
		            ? 'lastWeek'
		            : diff < 0
		            ? 'lastDay'
		            : diff < 1
		            ? 'sameDay'
		            : diff < 2
		            ? 'nextDay'
		            : diff < 7
		            ? 'nextWeek'
		            : 'sameElse';
		    }

		    function calendar$1(time, formats) {
		        // Support for single parameter, formats only overload to the calendar function
		        if (arguments.length === 1) {
		            if (!arguments[0]) {
		                time = undefined;
		                formats = undefined;
		            } else if (isMomentInput(arguments[0])) {
		                time = arguments[0];
		                formats = undefined;
		            } else if (isCalendarSpec(arguments[0])) {
		                formats = arguments[0];
		                time = undefined;
		            }
		        }
		        // We want to compare the start of today, vs this.
		        // Getting start-of-today depends on whether we're local/utc/offset or not.
		        var now = time || createLocal(),
		            sod = cloneWithOffset(now, this).startOf('day'),
		            format = hooks.calendarFormat(this, sod) || 'sameElse',
		            output =
		                formats &&
		                (isFunction(formats[format])
		                    ? formats[format].call(this, now)
		                    : formats[format]);

		        return this.format(
		            output || this.localeData().calendar(format, this, createLocal(now))
		        );
		    }

		    function clone() {
		        return new Moment(this);
		    }

		    function isAfter(input, units) {
		        var localInput = isMoment(input) ? input : createLocal(input);
		        if (!(this.isValid() && localInput.isValid())) {
		            return false;
		        }
		        units = normalizeUnits(units) || 'millisecond';
		        if (units === 'millisecond') {
		            return this.valueOf() > localInput.valueOf();
		        } else {
		            return localInput.valueOf() < this.clone().startOf(units).valueOf();
		        }
		    }

		    function isBefore(input, units) {
		        var localInput = isMoment(input) ? input : createLocal(input);
		        if (!(this.isValid() && localInput.isValid())) {
		            return false;
		        }
		        units = normalizeUnits(units) || 'millisecond';
		        if (units === 'millisecond') {
		            return this.valueOf() < localInput.valueOf();
		        } else {
		            return this.clone().endOf(units).valueOf() < localInput.valueOf();
		        }
		    }

		    function isBetween(from, to, units, inclusivity) {
		        var localFrom = isMoment(from) ? from : createLocal(from),
		            localTo = isMoment(to) ? to : createLocal(to);
		        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
		            return false;
		        }
		        inclusivity = inclusivity || '()';
		        return (
		            (inclusivity[0] === '('
		                ? this.isAfter(localFrom, units)
		                : !this.isBefore(localFrom, units)) &&
		            (inclusivity[1] === ')'
		                ? this.isBefore(localTo, units)
		                : !this.isAfter(localTo, units))
		        );
		    }

		    function isSame(input, units) {
		        var localInput = isMoment(input) ? input : createLocal(input),
		            inputMs;
		        if (!(this.isValid() && localInput.isValid())) {
		            return false;
		        }
		        units = normalizeUnits(units) || 'millisecond';
		        if (units === 'millisecond') {
		            return this.valueOf() === localInput.valueOf();
		        } else {
		            inputMs = localInput.valueOf();
		            return (
		                this.clone().startOf(units).valueOf() <= inputMs &&
		                inputMs <= this.clone().endOf(units).valueOf()
		            );
		        }
		    }

		    function isSameOrAfter(input, units) {
		        return this.isSame(input, units) || this.isAfter(input, units);
		    }

		    function isSameOrBefore(input, units) {
		        return this.isSame(input, units) || this.isBefore(input, units);
		    }

		    function diff(input, units, asFloat) {
		        var that, zoneDelta, output;

		        if (!this.isValid()) {
		            return NaN;
		        }

		        that = cloneWithOffset(input, this);

		        if (!that.isValid()) {
		            return NaN;
		        }

		        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

		        units = normalizeUnits(units);

		        switch (units) {
		            case 'year':
		                output = monthDiff(this, that) / 12;
		                break;
		            case 'month':
		                output = monthDiff(this, that);
		                break;
		            case 'quarter':
		                output = monthDiff(this, that) / 3;
		                break;
		            case 'second':
		                output = (this - that) / 1e3;
		                break; // 1000
		            case 'minute':
		                output = (this - that) / 6e4;
		                break; // 1000 * 60
		            case 'hour':
		                output = (this - that) / 36e5;
		                break; // 1000 * 60 * 60
		            case 'day':
		                output = (this - that - zoneDelta) / 864e5;
		                break; // 1000 * 60 * 60 * 24, negate dst
		            case 'week':
		                output = (this - that - zoneDelta) / 6048e5;
		                break; // 1000 * 60 * 60 * 24 * 7, negate dst
		            default:
		                output = this - that;
		        }

		        return asFloat ? output : absFloor(output);
		    }

		    function monthDiff(a, b) {
		        if (a.date() < b.date()) {
		            // end-of-month calculations work correct when the start month has more
		            // days than the end month.
		            return -monthDiff(b, a);
		        }
		        // difference in months
		        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
		            // b is in (anchor - 1 month, anchor + 1 month)
		            anchor = a.clone().add(wholeMonthDiff, 'months'),
		            anchor2,
		            adjust;

		        if (b - anchor < 0) {
		            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
		            // linear across the month
		            adjust = (b - anchor) / (anchor - anchor2);
		        } else {
		            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
		            // linear across the month
		            adjust = (b - anchor) / (anchor2 - anchor);
		        }

		        //check for negative zero, return zero if negative zero
		        return -(wholeMonthDiff + adjust) || 0;
		    }

		    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
		    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

		    function toString() {
		        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
		    }

		    function toISOString(keepOffset) {
		        if (!this.isValid()) {
		            return null;
		        }
		        var utc = keepOffset !== true,
		            m = utc ? this.clone().utc() : this;
		        if (m.year() < 0 || m.year() > 9999) {
		            return formatMoment(
		                m,
		                utc
		                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
		                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
		            );
		        }
		        if (isFunction(Date.prototype.toISOString)) {
		            // native implementation is ~50x faster, use it when we can
		            if (utc) {
		                return this.toDate().toISOString();
		            } else {
		                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
		                    .toISOString()
		                    .replace('Z', formatMoment(m, 'Z'));
		            }
		        }
		        return formatMoment(
		            m,
		            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
		        );
		    }

		    /**
		     * Return a human readable representation of a moment that can
		     * also be evaluated to get a new moment which is the same
		     *
		     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
		     */
		    function inspect() {
		        if (!this.isValid()) {
		            return 'moment.invalid(/* ' + this._i + ' */)';
		        }
		        var func = 'moment',
		            zone = '',
		            prefix,
		            year,
		            datetime,
		            suffix;
		        if (!this.isLocal()) {
		            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
		            zone = 'Z';
		        }
		        prefix = '[' + func + '("]';
		        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
		        datetime = '-MM-DD[T]HH:mm:ss.SSS';
		        suffix = zone + '[")]';

		        return this.format(prefix + year + datetime + suffix);
		    }

		    function format(inputString) {
		        if (!inputString) {
		            inputString = this.isUtc()
		                ? hooks.defaultFormatUtc
		                : hooks.defaultFormat;
		        }
		        var output = formatMoment(this, inputString);
		        return this.localeData().postformat(output);
		    }

		    function from(time, withoutSuffix) {
		        if (
		            this.isValid() &&
		            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
		        ) {
		            return createDuration({ to: this, from: time })
		                .locale(this.locale())
		                .humanize(!withoutSuffix);
		        } else {
		            return this.localeData().invalidDate();
		        }
		    }

		    function fromNow(withoutSuffix) {
		        return this.from(createLocal(), withoutSuffix);
		    }

		    function to(time, withoutSuffix) {
		        if (
		            this.isValid() &&
		            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
		        ) {
		            return createDuration({ from: this, to: time })
		                .locale(this.locale())
		                .humanize(!withoutSuffix);
		        } else {
		            return this.localeData().invalidDate();
		        }
		    }

		    function toNow(withoutSuffix) {
		        return this.to(createLocal(), withoutSuffix);
		    }

		    // If passed a locale key, it will set the locale for this
		    // instance.  Otherwise, it will return the locale configuration
		    // variables for this instance.
		    function locale(key) {
		        var newLocaleData;

		        if (key === undefined) {
		            return this._locale._abbr;
		        } else {
		            newLocaleData = getLocale(key);
		            if (newLocaleData != null) {
		                this._locale = newLocaleData;
		            }
		            return this;
		        }
		    }

		    var lang = deprecate(
		        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
		        function (key) {
		            if (key === undefined) {
		                return this.localeData();
		            } else {
		                return this.locale(key);
		            }
		        }
		    );

		    function localeData() {
		        return this._locale;
		    }

		    var MS_PER_SECOND = 1000,
		        MS_PER_MINUTE = 60 * MS_PER_SECOND,
		        MS_PER_HOUR = 60 * MS_PER_MINUTE,
		        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

		    // actual modulo - handles negative numbers (for dates before 1970):
		    function mod$1(dividend, divisor) {
		        return ((dividend % divisor) + divisor) % divisor;
		    }

		    function localStartOfDate(y, m, d) {
		        // the date constructor remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            // preserve leap years using a full 400 year cycle, then reset
		            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
		        } else {
		            return new Date(y, m, d).valueOf();
		        }
		    }

		    function utcStartOfDate(y, m, d) {
		        // Date.UTC remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            // preserve leap years using a full 400 year cycle, then reset
		            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
		        } else {
		            return Date.UTC(y, m, d);
		        }
		    }

		    function startOf(units) {
		        var time, startOfDate;
		        units = normalizeUnits(units);
		        if (units === undefined || units === 'millisecond' || !this.isValid()) {
		            return this;
		        }

		        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

		        switch (units) {
		            case 'year':
		                time = startOfDate(this.year(), 0, 1);
		                break;
		            case 'quarter':
		                time = startOfDate(
		                    this.year(),
		                    this.month() - (this.month() % 3),
		                    1
		                );
		                break;
		            case 'month':
		                time = startOfDate(this.year(), this.month(), 1);
		                break;
		            case 'week':
		                time = startOfDate(
		                    this.year(),
		                    this.month(),
		                    this.date() - this.weekday()
		                );
		                break;
		            case 'isoWeek':
		                time = startOfDate(
		                    this.year(),
		                    this.month(),
		                    this.date() - (this.isoWeekday() - 1)
		                );
		                break;
		            case 'day':
		            case 'date':
		                time = startOfDate(this.year(), this.month(), this.date());
		                break;
		            case 'hour':
		                time = this._d.valueOf();
		                time -= mod$1(
		                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
		                    MS_PER_HOUR
		                );
		                break;
		            case 'minute':
		                time = this._d.valueOf();
		                time -= mod$1(time, MS_PER_MINUTE);
		                break;
		            case 'second':
		                time = this._d.valueOf();
		                time -= mod$1(time, MS_PER_SECOND);
		                break;
		        }

		        this._d.setTime(time);
		        hooks.updateOffset(this, true);
		        return this;
		    }

		    function endOf(units) {
		        var time, startOfDate;
		        units = normalizeUnits(units);
		        if (units === undefined || units === 'millisecond' || !this.isValid()) {
		            return this;
		        }

		        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

		        switch (units) {
		            case 'year':
		                time = startOfDate(this.year() + 1, 0, 1) - 1;
		                break;
		            case 'quarter':
		                time =
		                    startOfDate(
		                        this.year(),
		                        this.month() - (this.month() % 3) + 3,
		                        1
		                    ) - 1;
		                break;
		            case 'month':
		                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
		                break;
		            case 'week':
		                time =
		                    startOfDate(
		                        this.year(),
		                        this.month(),
		                        this.date() - this.weekday() + 7
		                    ) - 1;
		                break;
		            case 'isoWeek':
		                time =
		                    startOfDate(
		                        this.year(),
		                        this.month(),
		                        this.date() - (this.isoWeekday() - 1) + 7
		                    ) - 1;
		                break;
		            case 'day':
		            case 'date':
		                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
		                break;
		            case 'hour':
		                time = this._d.valueOf();
		                time +=
		                    MS_PER_HOUR -
		                    mod$1(
		                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
		                        MS_PER_HOUR
		                    ) -
		                    1;
		                break;
		            case 'minute':
		                time = this._d.valueOf();
		                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
		                break;
		            case 'second':
		                time = this._d.valueOf();
		                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
		                break;
		        }

		        this._d.setTime(time);
		        hooks.updateOffset(this, true);
		        return this;
		    }

		    function valueOf() {
		        return this._d.valueOf() - (this._offset || 0) * 60000;
		    }

		    function unix() {
		        return Math.floor(this.valueOf() / 1000);
		    }

		    function toDate() {
		        return new Date(this.valueOf());
		    }

		    function toArray() {
		        var m = this;
		        return [
		            m.year(),
		            m.month(),
		            m.date(),
		            m.hour(),
		            m.minute(),
		            m.second(),
		            m.millisecond(),
		        ];
		    }

		    function toObject() {
		        var m = this;
		        return {
		            years: m.year(),
		            months: m.month(),
		            date: m.date(),
		            hours: m.hours(),
		            minutes: m.minutes(),
		            seconds: m.seconds(),
		            milliseconds: m.milliseconds(),
		        };
		    }

		    function toJSON() {
		        // new Date(NaN).toJSON() === null
		        return this.isValid() ? this.toISOString() : null;
		    }

		    function isValid$2() {
		        return isValid(this);
		    }

		    function parsingFlags() {
		        return extend({}, getParsingFlags(this));
		    }

		    function invalidAt() {
		        return getParsingFlags(this).overflow;
		    }

		    function creationData() {
		        return {
		            input: this._i,
		            format: this._f,
		            locale: this._locale,
		            isUTC: this._isUTC,
		            strict: this._strict,
		        };
		    }

		    addFormatToken('N', 0, 0, 'eraAbbr');
		    addFormatToken('NN', 0, 0, 'eraAbbr');
		    addFormatToken('NNN', 0, 0, 'eraAbbr');
		    addFormatToken('NNNN', 0, 0, 'eraName');
		    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

		    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
		    addFormatToken('y', ['yy', 2], 0, 'eraYear');
		    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
		    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

		    addRegexToken('N', matchEraAbbr);
		    addRegexToken('NN', matchEraAbbr);
		    addRegexToken('NNN', matchEraAbbr);
		    addRegexToken('NNNN', matchEraName);
		    addRegexToken('NNNNN', matchEraNarrow);

		    addParseToken(
		        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
		        function (input, array, config, token) {
		            var era = config._locale.erasParse(input, token, config._strict);
		            if (era) {
		                getParsingFlags(config).era = era;
		            } else {
		                getParsingFlags(config).invalidEra = input;
		            }
		        }
		    );

		    addRegexToken('y', matchUnsigned);
		    addRegexToken('yy', matchUnsigned);
		    addRegexToken('yyy', matchUnsigned);
		    addRegexToken('yyyy', matchUnsigned);
		    addRegexToken('yo', matchEraYearOrdinal);

		    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
		    addParseToken(['yo'], function (input, array, config, token) {
		        var match;
		        if (config._locale._eraYearOrdinalRegex) {
		            match = input.match(config._locale._eraYearOrdinalRegex);
		        }

		        if (config._locale.eraYearOrdinalParse) {
		            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
		        } else {
		            array[YEAR] = parseInt(input, 10);
		        }
		    });

		    function localeEras(m, format) {
		        var i,
		            l,
		            date,
		            eras = this._eras || getLocale('en')._eras;
		        for (i = 0, l = eras.length; i < l; ++i) {
		            switch (typeof eras[i].since) {
		                case 'string':
		                    // truncate time
		                    date = hooks(eras[i].since).startOf('day');
		                    eras[i].since = date.valueOf();
		                    break;
		            }

		            switch (typeof eras[i].until) {
		                case 'undefined':
		                    eras[i].until = +Infinity;
		                    break;
		                case 'string':
		                    // truncate time
		                    date = hooks(eras[i].until).startOf('day').valueOf();
		                    eras[i].until = date.valueOf();
		                    break;
		            }
		        }
		        return eras;
		    }

		    function localeErasParse(eraName, format, strict) {
		        var i,
		            l,
		            eras = this.eras(),
		            name,
		            abbr,
		            narrow;
		        eraName = eraName.toUpperCase();

		        for (i = 0, l = eras.length; i < l; ++i) {
		            name = eras[i].name.toUpperCase();
		            abbr = eras[i].abbr.toUpperCase();
		            narrow = eras[i].narrow.toUpperCase();

		            if (strict) {
		                switch (format) {
		                    case 'N':
		                    case 'NN':
		                    case 'NNN':
		                        if (abbr === eraName) {
		                            return eras[i];
		                        }
		                        break;

		                    case 'NNNN':
		                        if (name === eraName) {
		                            return eras[i];
		                        }
		                        break;

		                    case 'NNNNN':
		                        if (narrow === eraName) {
		                            return eras[i];
		                        }
		                        break;
		                }
		            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
		                return eras[i];
		            }
		        }
		    }

		    function localeErasConvertYear(era, year) {
		        var dir = era.since <= era.until ? +1 : -1;
		        if (year === undefined) {
		            return hooks(era.since).year();
		        } else {
		            return hooks(era.since).year() + (year - era.offset) * dir;
		        }
		    }

		    function getEraName() {
		        var i,
		            l,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (eras[i].since <= val && val <= eras[i].until) {
		                return eras[i].name;
		            }
		            if (eras[i].until <= val && val <= eras[i].since) {
		                return eras[i].name;
		            }
		        }

		        return '';
		    }

		    function getEraNarrow() {
		        var i,
		            l,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (eras[i].since <= val && val <= eras[i].until) {
		                return eras[i].narrow;
		            }
		            if (eras[i].until <= val && val <= eras[i].since) {
		                return eras[i].narrow;
		            }
		        }

		        return '';
		    }

		    function getEraAbbr() {
		        var i,
		            l,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (eras[i].since <= val && val <= eras[i].until) {
		                return eras[i].abbr;
		            }
		            if (eras[i].until <= val && val <= eras[i].since) {
		                return eras[i].abbr;
		            }
		        }

		        return '';
		    }

		    function getEraYear() {
		        var i,
		            l,
		            dir,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            dir = eras[i].since <= eras[i].until ? +1 : -1;

		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (
		                (eras[i].since <= val && val <= eras[i].until) ||
		                (eras[i].until <= val && val <= eras[i].since)
		            ) {
		                return (
		                    (this.year() - hooks(eras[i].since).year()) * dir +
		                    eras[i].offset
		                );
		            }
		        }

		        return this.year();
		    }

		    function erasNameRegex(isStrict) {
		        if (!hasOwnProp(this, '_erasNameRegex')) {
		            computeErasParse.call(this);
		        }
		        return isStrict ? this._erasNameRegex : this._erasRegex;
		    }

		    function erasAbbrRegex(isStrict) {
		        if (!hasOwnProp(this, '_erasAbbrRegex')) {
		            computeErasParse.call(this);
		        }
		        return isStrict ? this._erasAbbrRegex : this._erasRegex;
		    }

		    function erasNarrowRegex(isStrict) {
		        if (!hasOwnProp(this, '_erasNarrowRegex')) {
		            computeErasParse.call(this);
		        }
		        return isStrict ? this._erasNarrowRegex : this._erasRegex;
		    }

		    function matchEraAbbr(isStrict, locale) {
		        return locale.erasAbbrRegex(isStrict);
		    }

		    function matchEraName(isStrict, locale) {
		        return locale.erasNameRegex(isStrict);
		    }

		    function matchEraNarrow(isStrict, locale) {
		        return locale.erasNarrowRegex(isStrict);
		    }

		    function matchEraYearOrdinal(isStrict, locale) {
		        return locale._eraYearOrdinalRegex || matchUnsigned;
		    }

		    function computeErasParse() {
		        var abbrPieces = [],
		            namePieces = [],
		            narrowPieces = [],
		            mixedPieces = [],
		            i,
		            l,
		            eras = this.eras();

		        for (i = 0, l = eras.length; i < l; ++i) {
		            namePieces.push(regexEscape(eras[i].name));
		            abbrPieces.push(regexEscape(eras[i].abbr));
		            narrowPieces.push(regexEscape(eras[i].narrow));

		            mixedPieces.push(regexEscape(eras[i].name));
		            mixedPieces.push(regexEscape(eras[i].abbr));
		            mixedPieces.push(regexEscape(eras[i].narrow));
		        }

		        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
		        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
		        this._erasNarrowRegex = new RegExp(
		            '^(' + narrowPieces.join('|') + ')',
		            'i'
		        );
		    }

		    // FORMATTING

		    addFormatToken(0, ['gg', 2], 0, function () {
		        return this.weekYear() % 100;
		    });

		    addFormatToken(0, ['GG', 2], 0, function () {
		        return this.isoWeekYear() % 100;
		    });

		    function addWeekYearFormatToken(token, getter) {
		        addFormatToken(0, [token, token.length], 0, getter);
		    }

		    addWeekYearFormatToken('gggg', 'weekYear');
		    addWeekYearFormatToken('ggggg', 'weekYear');
		    addWeekYearFormatToken('GGGG', 'isoWeekYear');
		    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

		    // ALIASES

		    addUnitAlias('weekYear', 'gg');
		    addUnitAlias('isoWeekYear', 'GG');

		    // PRIORITY

		    addUnitPriority('weekYear', 1);
		    addUnitPriority('isoWeekYear', 1);

		    // PARSING

		    addRegexToken('G', matchSigned);
		    addRegexToken('g', matchSigned);
		    addRegexToken('GG', match1to2, match2);
		    addRegexToken('gg', match1to2, match2);
		    addRegexToken('GGGG', match1to4, match4);
		    addRegexToken('gggg', match1to4, match4);
		    addRegexToken('GGGGG', match1to6, match6);
		    addRegexToken('ggggg', match1to6, match6);

		    addWeekParseToken(
		        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
		        function (input, week, config, token) {
		            week[token.substr(0, 2)] = toInt(input);
		        }
		    );

		    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
		        week[token] = hooks.parseTwoDigitYear(input);
		    });

		    // MOMENTS

		    function getSetWeekYear(input) {
		        return getSetWeekYearHelper.call(
		            this,
		            input,
		            this.week(),
		            this.weekday(),
		            this.localeData()._week.dow,
		            this.localeData()._week.doy
		        );
		    }

		    function getSetISOWeekYear(input) {
		        return getSetWeekYearHelper.call(
		            this,
		            input,
		            this.isoWeek(),
		            this.isoWeekday(),
		            1,
		            4
		        );
		    }

		    function getISOWeeksInYear() {
		        return weeksInYear(this.year(), 1, 4);
		    }

		    function getISOWeeksInISOWeekYear() {
		        return weeksInYear(this.isoWeekYear(), 1, 4);
		    }

		    function getWeeksInYear() {
		        var weekInfo = this.localeData()._week;
		        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
		    }

		    function getWeeksInWeekYear() {
		        var weekInfo = this.localeData()._week;
		        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
		    }

		    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
		        var weeksTarget;
		        if (input == null) {
		            return weekOfYear(this, dow, doy).year;
		        } else {
		            weeksTarget = weeksInYear(input, dow, doy);
		            if (week > weeksTarget) {
		                week = weeksTarget;
		            }
		            return setWeekAll.call(this, input, week, weekday, dow, doy);
		        }
		    }

		    function setWeekAll(weekYear, week, weekday, dow, doy) {
		        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
		            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

		        this.year(date.getUTCFullYear());
		        this.month(date.getUTCMonth());
		        this.date(date.getUTCDate());
		        return this;
		    }

		    // FORMATTING

		    addFormatToken('Q', 0, 'Qo', 'quarter');

		    // ALIASES

		    addUnitAlias('quarter', 'Q');

		    // PRIORITY

		    addUnitPriority('quarter', 7);

		    // PARSING

		    addRegexToken('Q', match1);
		    addParseToken('Q', function (input, array) {
		        array[MONTH] = (toInt(input) - 1) * 3;
		    });

		    // MOMENTS

		    function getSetQuarter(input) {
		        return input == null
		            ? Math.ceil((this.month() + 1) / 3)
		            : this.month((input - 1) * 3 + (this.month() % 3));
		    }

		    // FORMATTING

		    addFormatToken('D', ['DD', 2], 'Do', 'date');

		    // ALIASES

		    addUnitAlias('date', 'D');

		    // PRIORITY
		    addUnitPriority('date', 9);

		    // PARSING

		    addRegexToken('D', match1to2);
		    addRegexToken('DD', match1to2, match2);
		    addRegexToken('Do', function (isStrict, locale) {
		        // TODO: Remove "ordinalParse" fallback in next major release.
		        return isStrict
		            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
		            : locale._dayOfMonthOrdinalParseLenient;
		    });

		    addParseToken(['D', 'DD'], DATE);
		    addParseToken('Do', function (input, array) {
		        array[DATE] = toInt(input.match(match1to2)[0]);
		    });

		    // MOMENTS

		    var getSetDayOfMonth = makeGetSet('Date', true);

		    // FORMATTING

		    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

		    // ALIASES

		    addUnitAlias('dayOfYear', 'DDD');

		    // PRIORITY
		    addUnitPriority('dayOfYear', 4);

		    // PARSING

		    addRegexToken('DDD', match1to3);
		    addRegexToken('DDDD', match3);
		    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
		        config._dayOfYear = toInt(input);
		    });

		    // HELPERS

		    // MOMENTS

		    function getSetDayOfYear(input) {
		        var dayOfYear =
		            Math.round(
		                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
		            ) + 1;
		        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
		    }

		    // FORMATTING

		    addFormatToken('m', ['mm', 2], 0, 'minute');

		    // ALIASES

		    addUnitAlias('minute', 'm');

		    // PRIORITY

		    addUnitPriority('minute', 14);

		    // PARSING

		    addRegexToken('m', match1to2);
		    addRegexToken('mm', match1to2, match2);
		    addParseToken(['m', 'mm'], MINUTE);

		    // MOMENTS

		    var getSetMinute = makeGetSet('Minutes', false);

		    // FORMATTING

		    addFormatToken('s', ['ss', 2], 0, 'second');

		    // ALIASES

		    addUnitAlias('second', 's');

		    // PRIORITY

		    addUnitPriority('second', 15);

		    // PARSING

		    addRegexToken('s', match1to2);
		    addRegexToken('ss', match1to2, match2);
		    addParseToken(['s', 'ss'], SECOND);

		    // MOMENTS

		    var getSetSecond = makeGetSet('Seconds', false);

		    // FORMATTING

		    addFormatToken('S', 0, 0, function () {
		        return ~~(this.millisecond() / 100);
		    });

		    addFormatToken(0, ['SS', 2], 0, function () {
		        return ~~(this.millisecond() / 10);
		    });

		    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
		    addFormatToken(0, ['SSSS', 4], 0, function () {
		        return this.millisecond() * 10;
		    });
		    addFormatToken(0, ['SSSSS', 5], 0, function () {
		        return this.millisecond() * 100;
		    });
		    addFormatToken(0, ['SSSSSS', 6], 0, function () {
		        return this.millisecond() * 1000;
		    });
		    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
		        return this.millisecond() * 10000;
		    });
		    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
		        return this.millisecond() * 100000;
		    });
		    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
		        return this.millisecond() * 1000000;
		    });

		    // ALIASES

		    addUnitAlias('millisecond', 'ms');

		    // PRIORITY

		    addUnitPriority('millisecond', 16);

		    // PARSING

		    addRegexToken('S', match1to3, match1);
		    addRegexToken('SS', match1to3, match2);
		    addRegexToken('SSS', match1to3, match3);

		    var token, getSetMillisecond;
		    for (token = 'SSSS'; token.length <= 9; token += 'S') {
		        addRegexToken(token, matchUnsigned);
		    }

		    function parseMs(input, array) {
		        array[MILLISECOND] = toInt(('0.' + input) * 1000);
		    }

		    for (token = 'S'; token.length <= 9; token += 'S') {
		        addParseToken(token, parseMs);
		    }

		    getSetMillisecond = makeGetSet('Milliseconds', false);

		    // FORMATTING

		    addFormatToken('z', 0, 0, 'zoneAbbr');
		    addFormatToken('zz', 0, 0, 'zoneName');

		    // MOMENTS

		    function getZoneAbbr() {
		        return this._isUTC ? 'UTC' : '';
		    }

		    function getZoneName() {
		        return this._isUTC ? 'Coordinated Universal Time' : '';
		    }

		    var proto = Moment.prototype;

		    proto.add = add;
		    proto.calendar = calendar$1;
		    proto.clone = clone;
		    proto.diff = diff;
		    proto.endOf = endOf;
		    proto.format = format;
		    proto.from = from;
		    proto.fromNow = fromNow;
		    proto.to = to;
		    proto.toNow = toNow;
		    proto.get = stringGet;
		    proto.invalidAt = invalidAt;
		    proto.isAfter = isAfter;
		    proto.isBefore = isBefore;
		    proto.isBetween = isBetween;
		    proto.isSame = isSame;
		    proto.isSameOrAfter = isSameOrAfter;
		    proto.isSameOrBefore = isSameOrBefore;
		    proto.isValid = isValid$2;
		    proto.lang = lang;
		    proto.locale = locale;
		    proto.localeData = localeData;
		    proto.max = prototypeMax;
		    proto.min = prototypeMin;
		    proto.parsingFlags = parsingFlags;
		    proto.set = stringSet;
		    proto.startOf = startOf;
		    proto.subtract = subtract;
		    proto.toArray = toArray;
		    proto.toObject = toObject;
		    proto.toDate = toDate;
		    proto.toISOString = toISOString;
		    proto.inspect = inspect;
		    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
		        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
		            return 'Moment<' + this.format() + '>';
		        };
		    }
		    proto.toJSON = toJSON;
		    proto.toString = toString;
		    proto.unix = unix;
		    proto.valueOf = valueOf;
		    proto.creationData = creationData;
		    proto.eraName = getEraName;
		    proto.eraNarrow = getEraNarrow;
		    proto.eraAbbr = getEraAbbr;
		    proto.eraYear = getEraYear;
		    proto.year = getSetYear;
		    proto.isLeapYear = getIsLeapYear;
		    proto.weekYear = getSetWeekYear;
		    proto.isoWeekYear = getSetISOWeekYear;
		    proto.quarter = proto.quarters = getSetQuarter;
		    proto.month = getSetMonth;
		    proto.daysInMonth = getDaysInMonth;
		    proto.week = proto.weeks = getSetWeek;
		    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
		    proto.weeksInYear = getWeeksInYear;
		    proto.weeksInWeekYear = getWeeksInWeekYear;
		    proto.isoWeeksInYear = getISOWeeksInYear;
		    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
		    proto.date = getSetDayOfMonth;
		    proto.day = proto.days = getSetDayOfWeek;
		    proto.weekday = getSetLocaleDayOfWeek;
		    proto.isoWeekday = getSetISODayOfWeek;
		    proto.dayOfYear = getSetDayOfYear;
		    proto.hour = proto.hours = getSetHour;
		    proto.minute = proto.minutes = getSetMinute;
		    proto.second = proto.seconds = getSetSecond;
		    proto.millisecond = proto.milliseconds = getSetMillisecond;
		    proto.utcOffset = getSetOffset;
		    proto.utc = setOffsetToUTC;
		    proto.local = setOffsetToLocal;
		    proto.parseZone = setOffsetToParsedOffset;
		    proto.hasAlignedHourOffset = hasAlignedHourOffset;
		    proto.isDST = isDaylightSavingTime;
		    proto.isLocal = isLocal;
		    proto.isUtcOffset = isUtcOffset;
		    proto.isUtc = isUtc;
		    proto.isUTC = isUtc;
		    proto.zoneAbbr = getZoneAbbr;
		    proto.zoneName = getZoneName;
		    proto.dates = deprecate(
		        'dates accessor is deprecated. Use date instead.',
		        getSetDayOfMonth
		    );
		    proto.months = deprecate(
		        'months accessor is deprecated. Use month instead',
		        getSetMonth
		    );
		    proto.years = deprecate(
		        'years accessor is deprecated. Use year instead',
		        getSetYear
		    );
		    proto.zone = deprecate(
		        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
		        getSetZone
		    );
		    proto.isDSTShifted = deprecate(
		        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
		        isDaylightSavingTimeShifted
		    );

		    function createUnix(input) {
		        return createLocal(input * 1000);
		    }

		    function createInZone() {
		        return createLocal.apply(null, arguments).parseZone();
		    }

		    function preParsePostFormat(string) {
		        return string;
		    }

		    var proto$1 = Locale.prototype;

		    proto$1.calendar = calendar;
		    proto$1.longDateFormat = longDateFormat;
		    proto$1.invalidDate = invalidDate;
		    proto$1.ordinal = ordinal;
		    proto$1.preparse = preParsePostFormat;
		    proto$1.postformat = preParsePostFormat;
		    proto$1.relativeTime = relativeTime;
		    proto$1.pastFuture = pastFuture;
		    proto$1.set = set;
		    proto$1.eras = localeEras;
		    proto$1.erasParse = localeErasParse;
		    proto$1.erasConvertYear = localeErasConvertYear;
		    proto$1.erasAbbrRegex = erasAbbrRegex;
		    proto$1.erasNameRegex = erasNameRegex;
		    proto$1.erasNarrowRegex = erasNarrowRegex;

		    proto$1.months = localeMonths;
		    proto$1.monthsShort = localeMonthsShort;
		    proto$1.monthsParse = localeMonthsParse;
		    proto$1.monthsRegex = monthsRegex;
		    proto$1.monthsShortRegex = monthsShortRegex;
		    proto$1.week = localeWeek;
		    proto$1.firstDayOfYear = localeFirstDayOfYear;
		    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

		    proto$1.weekdays = localeWeekdays;
		    proto$1.weekdaysMin = localeWeekdaysMin;
		    proto$1.weekdaysShort = localeWeekdaysShort;
		    proto$1.weekdaysParse = localeWeekdaysParse;

		    proto$1.weekdaysRegex = weekdaysRegex;
		    proto$1.weekdaysShortRegex = weekdaysShortRegex;
		    proto$1.weekdaysMinRegex = weekdaysMinRegex;

		    proto$1.isPM = localeIsPM;
		    proto$1.meridiem = localeMeridiem;

		    function get$1(format, index, field, setter) {
		        var locale = getLocale(),
		            utc = createUTC().set(setter, index);
		        return locale[field](utc, format);
		    }

		    function listMonthsImpl(format, index, field) {
		        if (isNumber(format)) {
		            index = format;
		            format = undefined;
		        }

		        format = format || '';

		        if (index != null) {
		            return get$1(format, index, field, 'month');
		        }

		        var i,
		            out = [];
		        for (i = 0; i < 12; i++) {
		            out[i] = get$1(format, i, field, 'month');
		        }
		        return out;
		    }

		    // ()
		    // (5)
		    // (fmt, 5)
		    // (fmt)
		    // (true)
		    // (true, 5)
		    // (true, fmt, 5)
		    // (true, fmt)
		    function listWeekdaysImpl(localeSorted, format, index, field) {
		        if (typeof localeSorted === 'boolean') {
		            if (isNumber(format)) {
		                index = format;
		                format = undefined;
		            }

		            format = format || '';
		        } else {
		            format = localeSorted;
		            index = format;
		            localeSorted = false;

		            if (isNumber(format)) {
		                index = format;
		                format = undefined;
		            }

		            format = format || '';
		        }

		        var locale = getLocale(),
		            shift = localeSorted ? locale._week.dow : 0,
		            i,
		            out = [];

		        if (index != null) {
		            return get$1(format, (index + shift) % 7, field, 'day');
		        }

		        for (i = 0; i < 7; i++) {
		            out[i] = get$1(format, (i + shift) % 7, field, 'day');
		        }
		        return out;
		    }

		    function listMonths(format, index) {
		        return listMonthsImpl(format, index, 'months');
		    }

		    function listMonthsShort(format, index) {
		        return listMonthsImpl(format, index, 'monthsShort');
		    }

		    function listWeekdays(localeSorted, format, index) {
		        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
		    }

		    function listWeekdaysShort(localeSorted, format, index) {
		        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
		    }

		    function listWeekdaysMin(localeSorted, format, index) {
		        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
		    }

		    getSetGlobalLocale('en', {
		        eras: [
		            {
		                since: '0001-01-01',
		                until: +Infinity,
		                offset: 1,
		                name: 'Anno Domini',
		                narrow: 'AD',
		                abbr: 'AD',
		            },
		            {
		                since: '0000-12-31',
		                until: -Infinity,
		                offset: 1,
		                name: 'Before Christ',
		                narrow: 'BC',
		                abbr: 'BC',
		            },
		        ],
		        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
		        ordinal: function (number) {
		            var b = number % 10,
		                output =
		                    toInt((number % 100) / 10) === 1
		                        ? 'th'
		                        : b === 1
		                        ? 'st'
		                        : b === 2
		                        ? 'nd'
		                        : b === 3
		                        ? 'rd'
		                        : 'th';
		            return number + output;
		        },
		    });

		    // Side effect imports

		    hooks.lang = deprecate(
		        'moment.lang is deprecated. Use moment.locale instead.',
		        getSetGlobalLocale
		    );
		    hooks.langData = deprecate(
		        'moment.langData is deprecated. Use moment.localeData instead.',
		        getLocale
		    );

		    var mathAbs = Math.abs;

		    function abs() {
		        var data = this._data;

		        this._milliseconds = mathAbs(this._milliseconds);
		        this._days = mathAbs(this._days);
		        this._months = mathAbs(this._months);

		        data.milliseconds = mathAbs(data.milliseconds);
		        data.seconds = mathAbs(data.seconds);
		        data.minutes = mathAbs(data.minutes);
		        data.hours = mathAbs(data.hours);
		        data.months = mathAbs(data.months);
		        data.years = mathAbs(data.years);

		        return this;
		    }

		    function addSubtract$1(duration, input, value, direction) {
		        var other = createDuration(input, value);

		        duration._milliseconds += direction * other._milliseconds;
		        duration._days += direction * other._days;
		        duration._months += direction * other._months;

		        return duration._bubble();
		    }

		    // supports only 2.0-style add(1, 's') or add(duration)
		    function add$1(input, value) {
		        return addSubtract$1(this, input, value, 1);
		    }

		    // supports only 2.0-style subtract(1, 's') or subtract(duration)
		    function subtract$1(input, value) {
		        return addSubtract$1(this, input, value, -1);
		    }

		    function absCeil(number) {
		        if (number < 0) {
		            return Math.floor(number);
		        } else {
		            return Math.ceil(number);
		        }
		    }

		    function bubble() {
		        var milliseconds = this._milliseconds,
		            days = this._days,
		            months = this._months,
		            data = this._data,
		            seconds,
		            minutes,
		            hours,
		            years,
		            monthsFromDays;

		        // if we have a mix of positive and negative values, bubble down first
		        // check: https://github.com/moment/moment/issues/2166
		        if (
		            !(
		                (milliseconds >= 0 && days >= 0 && months >= 0) ||
		                (milliseconds <= 0 && days <= 0 && months <= 0)
		            )
		        ) {
		            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
		            days = 0;
		            months = 0;
		        }

		        // The following code bubbles up values, see the tests for
		        // examples of what that means.
		        data.milliseconds = milliseconds % 1000;

		        seconds = absFloor(milliseconds / 1000);
		        data.seconds = seconds % 60;

		        minutes = absFloor(seconds / 60);
		        data.minutes = minutes % 60;

		        hours = absFloor(minutes / 60);
		        data.hours = hours % 24;

		        days += absFloor(hours / 24);

		        // convert days to months
		        monthsFromDays = absFloor(daysToMonths(days));
		        months += monthsFromDays;
		        days -= absCeil(monthsToDays(monthsFromDays));

		        // 12 months -> 1 year
		        years = absFloor(months / 12);
		        months %= 12;

		        data.days = days;
		        data.months = months;
		        data.years = years;

		        return this;
		    }

		    function daysToMonths(days) {
		        // 400 years have 146097 days (taking into account leap year rules)
		        // 400 years have 12 months === 4800
		        return (days * 4800) / 146097;
		    }

		    function monthsToDays(months) {
		        // the reverse of daysToMonths
		        return (months * 146097) / 4800;
		    }

		    function as(units) {
		        if (!this.isValid()) {
		            return NaN;
		        }
		        var days,
		            months,
		            milliseconds = this._milliseconds;

		        units = normalizeUnits(units);

		        if (units === 'month' || units === 'quarter' || units === 'year') {
		            days = this._days + milliseconds / 864e5;
		            months = this._months + daysToMonths(days);
		            switch (units) {
		                case 'month':
		                    return months;
		                case 'quarter':
		                    return months / 3;
		                case 'year':
		                    return months / 12;
		            }
		        } else {
		            // handle milliseconds separately because of floating point math errors (issue #1867)
		            days = this._days + Math.round(monthsToDays(this._months));
		            switch (units) {
		                case 'week':
		                    return days / 7 + milliseconds / 6048e5;
		                case 'day':
		                    return days + milliseconds / 864e5;
		                case 'hour':
		                    return days * 24 + milliseconds / 36e5;
		                case 'minute':
		                    return days * 1440 + milliseconds / 6e4;
		                case 'second':
		                    return days * 86400 + milliseconds / 1000;
		                // Math.floor prevents floating point math errors here
		                case 'millisecond':
		                    return Math.floor(days * 864e5) + milliseconds;
		                default:
		                    throw new Error('Unknown unit ' + units);
		            }
		        }
		    }

		    // TODO: Use this.as('ms')?
		    function valueOf$1() {
		        if (!this.isValid()) {
		            return NaN;
		        }
		        return (
		            this._milliseconds +
		            this._days * 864e5 +
		            (this._months % 12) * 2592e6 +
		            toInt(this._months / 12) * 31536e6
		        );
		    }

		    function makeAs(alias) {
		        return function () {
		            return this.as(alias);
		        };
		    }

		    var asMilliseconds = makeAs('ms'),
		        asSeconds = makeAs('s'),
		        asMinutes = makeAs('m'),
		        asHours = makeAs('h'),
		        asDays = makeAs('d'),
		        asWeeks = makeAs('w'),
		        asMonths = makeAs('M'),
		        asQuarters = makeAs('Q'),
		        asYears = makeAs('y');

		    function clone$1() {
		        return createDuration(this);
		    }

		    function get$2(units) {
		        units = normalizeUnits(units);
		        return this.isValid() ? this[units + 's']() : NaN;
		    }

		    function makeGetter(name) {
		        return function () {
		            return this.isValid() ? this._data[name] : NaN;
		        };
		    }

		    var milliseconds = makeGetter('milliseconds'),
		        seconds = makeGetter('seconds'),
		        minutes = makeGetter('minutes'),
		        hours = makeGetter('hours'),
		        days = makeGetter('days'),
		        months = makeGetter('months'),
		        years = makeGetter('years');

		    function weeks() {
		        return absFloor(this.days() / 7);
		    }

		    var round = Math.round,
		        thresholds = {
		            ss: 44, // a few seconds to seconds
		            s: 45, // seconds to minute
		            m: 45, // minutes to hour
		            h: 22, // hours to day
		            d: 26, // days to month/week
		            w: null, // weeks to month
		            M: 11, // months to year
		        };

		    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
		    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
		        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
		    }

		    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
		        var duration = createDuration(posNegDuration).abs(),
		            seconds = round(duration.as('s')),
		            minutes = round(duration.as('m')),
		            hours = round(duration.as('h')),
		            days = round(duration.as('d')),
		            months = round(duration.as('M')),
		            weeks = round(duration.as('w')),
		            years = round(duration.as('y')),
		            a =
		                (seconds <= thresholds.ss && ['s', seconds]) ||
		                (seconds < thresholds.s && ['ss', seconds]) ||
		                (minutes <= 1 && ['m']) ||
		                (minutes < thresholds.m && ['mm', minutes]) ||
		                (hours <= 1 && ['h']) ||
		                (hours < thresholds.h && ['hh', hours]) ||
		                (days <= 1 && ['d']) ||
		                (days < thresholds.d && ['dd', days]);

		        if (thresholds.w != null) {
		            a =
		                a ||
		                (weeks <= 1 && ['w']) ||
		                (weeks < thresholds.w && ['ww', weeks]);
		        }
		        a = a ||
		            (months <= 1 && ['M']) ||
		            (months < thresholds.M && ['MM', months]) ||
		            (years <= 1 && ['y']) || ['yy', years];

		        a[2] = withoutSuffix;
		        a[3] = +posNegDuration > 0;
		        a[4] = locale;
		        return substituteTimeAgo.apply(null, a);
		    }

		    // This function allows you to set the rounding function for relative time strings
		    function getSetRelativeTimeRounding(roundingFunction) {
		        if (roundingFunction === undefined) {
		            return round;
		        }
		        if (typeof roundingFunction === 'function') {
		            round = roundingFunction;
		            return true;
		        }
		        return false;
		    }

		    // This function allows you to set a threshold for relative time strings
		    function getSetRelativeTimeThreshold(threshold, limit) {
		        if (thresholds[threshold] === undefined) {
		            return false;
		        }
		        if (limit === undefined) {
		            return thresholds[threshold];
		        }
		        thresholds[threshold] = limit;
		        if (threshold === 's') {
		            thresholds.ss = limit - 1;
		        }
		        return true;
		    }

		    function humanize(argWithSuffix, argThresholds) {
		        if (!this.isValid()) {
		            return this.localeData().invalidDate();
		        }

		        var withSuffix = false,
		            th = thresholds,
		            locale,
		            output;

		        if (typeof argWithSuffix === 'object') {
		            argThresholds = argWithSuffix;
		            argWithSuffix = false;
		        }
		        if (typeof argWithSuffix === 'boolean') {
		            withSuffix = argWithSuffix;
		        }
		        if (typeof argThresholds === 'object') {
		            th = Object.assign({}, thresholds, argThresholds);
		            if (argThresholds.s != null && argThresholds.ss == null) {
		                th.ss = argThresholds.s - 1;
		            }
		        }

		        locale = this.localeData();
		        output = relativeTime$1(this, !withSuffix, th, locale);

		        if (withSuffix) {
		            output = locale.pastFuture(+this, output);
		        }

		        return locale.postformat(output);
		    }

		    var abs$1 = Math.abs;

		    function sign(x) {
		        return (x > 0) - (x < 0) || +x;
		    }

		    function toISOString$1() {
		        // for ISO strings we do not use the normal bubbling rules:
		        //  * milliseconds bubble up until they become hours
		        //  * days do not bubble at all
		        //  * months bubble up until they become years
		        // This is because there is no context-free conversion between hours and days
		        // (think of clock changes)
		        // and also not between days and months (28-31 days per month)
		        if (!this.isValid()) {
		            return this.localeData().invalidDate();
		        }

		        var seconds = abs$1(this._milliseconds) / 1000,
		            days = abs$1(this._days),
		            months = abs$1(this._months),
		            minutes,
		            hours,
		            years,
		            s,
		            total = this.asSeconds(),
		            totalSign,
		            ymSign,
		            daysSign,
		            hmsSign;

		        if (!total) {
		            // this is the same as C#'s (Noda) and python (isodate)...
		            // but not other JS (goog.date)
		            return 'P0D';
		        }

		        // 3600 seconds -> 60 minutes -> 1 hour
		        minutes = absFloor(seconds / 60);
		        hours = absFloor(minutes / 60);
		        seconds %= 60;
		        minutes %= 60;

		        // 12 months -> 1 year
		        years = absFloor(months / 12);
		        months %= 12;

		        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
		        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

		        totalSign = total < 0 ? '-' : '';
		        ymSign = sign(this._months) !== sign(total) ? '-' : '';
		        daysSign = sign(this._days) !== sign(total) ? '-' : '';
		        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

		        return (
		            totalSign +
		            'P' +
		            (years ? ymSign + years + 'Y' : '') +
		            (months ? ymSign + months + 'M' : '') +
		            (days ? daysSign + days + 'D' : '') +
		            (hours || minutes || seconds ? 'T' : '') +
		            (hours ? hmsSign + hours + 'H' : '') +
		            (minutes ? hmsSign + minutes + 'M' : '') +
		            (seconds ? hmsSign + s + 'S' : '')
		        );
		    }

		    var proto$2 = Duration.prototype;

		    proto$2.isValid = isValid$1;
		    proto$2.abs = abs;
		    proto$2.add = add$1;
		    proto$2.subtract = subtract$1;
		    proto$2.as = as;
		    proto$2.asMilliseconds = asMilliseconds;
		    proto$2.asSeconds = asSeconds;
		    proto$2.asMinutes = asMinutes;
		    proto$2.asHours = asHours;
		    proto$2.asDays = asDays;
		    proto$2.asWeeks = asWeeks;
		    proto$2.asMonths = asMonths;
		    proto$2.asQuarters = asQuarters;
		    proto$2.asYears = asYears;
		    proto$2.valueOf = valueOf$1;
		    proto$2._bubble = bubble;
		    proto$2.clone = clone$1;
		    proto$2.get = get$2;
		    proto$2.milliseconds = milliseconds;
		    proto$2.seconds = seconds;
		    proto$2.minutes = minutes;
		    proto$2.hours = hours;
		    proto$2.days = days;
		    proto$2.weeks = weeks;
		    proto$2.months = months;
		    proto$2.years = years;
		    proto$2.humanize = humanize;
		    proto$2.toISOString = toISOString$1;
		    proto$2.toString = toISOString$1;
		    proto$2.toJSON = toISOString$1;
		    proto$2.locale = locale;
		    proto$2.localeData = localeData;

		    proto$2.toIsoString = deprecate(
		        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
		        toISOString$1
		    );
		    proto$2.lang = lang;

		    // FORMATTING

		    addFormatToken('X', 0, 0, 'unix');
		    addFormatToken('x', 0, 0, 'valueOf');

		    // PARSING

		    addRegexToken('x', matchSigned);
		    addRegexToken('X', matchTimestamp);
		    addParseToken('X', function (input, array, config) {
		        config._d = new Date(parseFloat(input) * 1000);
		    });
		    addParseToken('x', function (input, array, config) {
		        config._d = new Date(toInt(input));
		    });

		    //! moment.js

		    hooks.version = '2.29.4';

		    setHookCallback(createLocal);

		    hooks.fn = proto;
		    hooks.min = min;
		    hooks.max = max;
		    hooks.now = now;
		    hooks.utc = createUTC;
		    hooks.unix = createUnix;
		    hooks.months = listMonths;
		    hooks.isDate = isDate;
		    hooks.locale = getSetGlobalLocale;
		    hooks.invalid = createInvalid;
		    hooks.duration = createDuration;
		    hooks.isMoment = isMoment;
		    hooks.weekdays = listWeekdays;
		    hooks.parseZone = createInZone;
		    hooks.localeData = getLocale;
		    hooks.isDuration = isDuration;
		    hooks.monthsShort = listMonthsShort;
		    hooks.weekdaysMin = listWeekdaysMin;
		    hooks.defineLocale = defineLocale;
		    hooks.updateLocale = updateLocale;
		    hooks.locales = listLocales;
		    hooks.weekdaysShort = listWeekdaysShort;
		    hooks.normalizeUnits = normalizeUnits;
		    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
		    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
		    hooks.calendarFormat = getCalendarFormat;
		    hooks.prototype = proto;

		    // currently HTML5 input type only supports 24-hour formats
		    hooks.HTML5_FMT = {
		        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
		        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
		        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
		        DATE: 'YYYY-MM-DD', // <input type="date" />
		        TIME: 'HH:mm', // <input type="time" />
		        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
		        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
		        WEEK: 'GGGG-[W]WW', // <input type="week" />
		        MONTH: 'YYYY-MM', // <input type="month" />
		    };

		    return hooks;

		})));
} (moment$1));
	return momentExports$1;
}

var momentExports = requireMoment();
var defaultMoment = /*@__PURE__*/getDefaultExportFromCjs(momentExports);

var defaultFormats$2 = {
    normalDateWithWeekday: "ddd, MMM D",
    normalDate: "D MMMM",
    shortDate: "MMM D",
    monthAndDate: "MMMM D",
    dayOfMonth: "D",
    year: "YYYY",
    month: "MMMM",
    monthShort: "MMM",
    monthAndYear: "MMMM YYYY",
    weekday: "dddd",
    weekdayShort: "ddd",
    minutes: "mm",
    hours12h: "hh",
    hours24h: "HH",
    seconds: "ss",
    fullTime: "LT",
    fullTime12h: "hh:mm A",
    fullTime24h: "HH:mm",
    fullDate: "ll",
    fullDateWithWeekday: "dddd, LL",
    fullDateTime: "lll",
    fullDateTime12h: "ll hh:mm A",
    fullDateTime24h: "ll HH:mm",
    keyboardDate: "L",
    keyboardDateTime: "L LT",
    keyboardDateTime12h: "L hh:mm A",
    keyboardDateTime24h: "L HH:mm",
};
var MomentUtils$2 = /** @class */ (function () {
    function MomentUtils(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, locale = _b.locale, formats = _b.formats, instance = _b.instance;
        this.lib = "moment";
        this.is12HourCycleInCurrentLocale = function () {
            return /A|a/.test(_this.moment.localeData(_this.getCurrentLocaleCode()).longDateFormat("LT"));
        };
        this.getFormatHelperText = function (format) {
            // @see https://github.com/moment/moment/blob/develop/src/lib/format/format.js#L6
            var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
            return format
                .match(localFormattingTokens)
                .map(function (token) {
                var firstCharacter = token[0];
                if (firstCharacter === "L" || firstCharacter === ";") {
                    return _this.moment
                        .localeData(_this.getCurrentLocaleCode())
                        .longDateFormat(token);
                }
                return token;
            })
                .join("")
                .replace(/a/gi, "(a|p)m")
                .toLocaleLowerCase();
        };
        this.getCurrentLocaleCode = function () {
            return _this.locale || _this.moment.locale();
        };
        this.parseISO = function (isoString) {
            return _this.moment(isoString, true);
        };
        this.toISO = function (value) {
            return value.toISOString();
        };
        this.parse = function (value, format) {
            if (value === "") {
                return null;
            }
            if (_this.locale) {
                return _this.moment(value, format, _this.locale, true);
            }
            return _this.moment(value, format, true);
        };
        this.date = function (value) {
            if (value === null) {
                return null;
            }
            var moment = _this.moment(value);
            moment.locale(_this.locale);
            return moment;
        };
        this.toJsDate = function (value) {
            return value.toDate();
        };
        this.isValid = function (value) {
            return _this.moment(value).isValid();
        };
        this.isNull = function (date) {
            return date === null;
        };
        this.getDiff = function (date, comparing, unit) {
            return date.diff(comparing, unit);
        };
        this.isAfter = function (date, value) {
            return date.isAfter(value);
        };
        this.isBefore = function (date, value) {
            return date.isBefore(value);
        };
        this.isAfterDay = function (date, value) {
            return date.isAfter(value, "day");
        };
        this.isBeforeDay = function (date, value) {
            return date.isBefore(value, "day");
        };
        this.isBeforeYear = function (date, value) {
            return date.isBefore(value, "year");
        };
        this.isAfterYear = function (date, value) {
            return date.isAfter(value, "year");
        };
        this.startOfDay = function (date) {
            return date.clone().startOf("day");
        };
        this.endOfDay = function (date) {
            return date.clone().endOf("day");
        };
        this.format = function (date, formatKey) {
            return _this.formatByString(date, _this.formats[formatKey]);
        };
        this.formatByString = function (date, formatString) {
            var clonedDate = date.clone();
            clonedDate.locale(_this.locale);
            return clonedDate.format(formatString);
        };
        this.formatNumber = function (numberToFormat) {
            return numberToFormat;
        };
        this.getHours = function (date) {
            return date.get("hours");
        };
        this.addSeconds = function (date, count) {
            return count < 0
                ? date.clone().subtract(Math.abs(count), "seconds")
                : date.clone().add(count, "seconds");
        };
        this.addMinutes = function (date, count) {
            return count < 0
                ? date.clone().subtract(Math.abs(count), "minutes")
                : date.clone().add(count, "minutes");
        };
        this.addHours = function (date, count) {
            return count < 0
                ? date.clone().subtract(Math.abs(count), "hours")
                : date.clone().add(count, "hours");
        };
        this.addDays = function (date, count) {
            return count < 0
                ? date.clone().subtract(Math.abs(count), "days")
                : date.clone().add(count, "days");
        };
        this.addWeeks = function (date, count) {
            return count < 0
                ? date.clone().subtract(Math.abs(count), "weeks")
                : date.clone().add(count, "weeks");
        };
        this.addMonths = function (date, count) {
            return count < 0
                ? date.clone().subtract(Math.abs(count), "months")
                : date.clone().add(count, "months");
        };
        this.addYears = function (date, count) {
            return count < 0
                ? date.clone().subtract(Math.abs(count), "years")
                : date.clone().add(count, "years");
        };
        this.setHours = function (date, count) {
            return date.clone().hours(count);
        };
        this.getMinutes = function (date) {
            return date.get("minutes");
        };
        this.setMinutes = function (date, count) {
            return date.clone().minutes(count);
        };
        this.getSeconds = function (date) {
            return date.get("seconds");
        };
        this.setSeconds = function (date, count) {
            return date.clone().seconds(count);
        };
        this.getMonth = function (date) {
            return date.get("month");
        };
        this.getDaysInMonth = function (date) {
            return date.daysInMonth();
        };
        this.isSameDay = function (date, comparing) {
            return date.isSame(comparing, "day");
        };
        this.isSameMonth = function (date, comparing) {
            return date.isSame(comparing, "month");
        };
        this.isSameYear = function (date, comparing) {
            return date.isSame(comparing, "year");
        };
        this.isSameHour = function (date, comparing) {
            return date.isSame(comparing, "hour");
        };
        this.setMonth = function (date, count) {
            return date.clone().month(count);
        };
        this.getMeridiemText = function (ampm) {
            if (_this.is12HourCycleInCurrentLocale()) {
                // AM/PM translation only possible in those who have 12 hour cycle in locale.
                return _this.moment
                    .localeData(_this.getCurrentLocaleCode())
                    .meridiem(ampm === "am" ? 0 : 13, 0, false);
            }
            return ampm === "am" ? "AM" : "PM"; // fallback for de, ru, ...etc
        };
        this.startOfYear = function (date) {
            return date.clone().startOf("year");
        };
        this.endOfYear = function (date) {
            return date.clone().endOf("year");
        };
        this.startOfMonth = function (date) {
            return date.clone().startOf("month");
        };
        this.endOfMonth = function (date) {
            return date.clone().endOf("month");
        };
        this.startOfWeek = function (date) {
            return date.clone().startOf("week");
        };
        this.endOfWeek = function (date) {
            return date.clone().endOf("week");
        };
        this.getNextMonth = function (date) {
            return date.clone().add(1, "month");
        };
        this.getPreviousMonth = function (date) {
            return date.clone().subtract(1, "month");
        };
        this.getMonthArray = function (date) {
            var firstMonth = date.clone().startOf("year");
            var monthArray = [firstMonth];
            while (monthArray.length < 12) {
                var prevMonth = monthArray[monthArray.length - 1];
                monthArray.push(_this.getNextMonth(prevMonth));
            }
            return monthArray;
        };
        this.getYear = function (date) {
            return date.get("year");
        };
        this.setYear = function (date, year) {
            return date.clone().set("year", year);
        };
        this.getDate = function (date) {
            return date.get("date");
        };
        this.setDate = function (date, year) {
            return date.clone().set("date", year);
        };
        this.mergeDateAndTime = function (date, time) {
            return date.hour(time.hour()).minute(time.minute()).second(time.second());
        };
        this.getWeekdays = function () {
            return _this.moment.weekdaysShort(true);
        };
        this.isEqual = function (value, comparing) {
            if (value === null && comparing === null) {
                return true;
            }
            return _this.moment(value).isSame(comparing);
        };
        this.getWeekArray = function (date) {
            var start = date.clone().startOf("month").startOf("week");
            var end = date.clone().endOf("month").endOf("week");
            var count = 0;
            var current = start;
            var nestedWeeks = [];
            while (current.isBefore(end)) {
                var weekNumber = Math.floor(count / 7);
                nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
                nestedWeeks[weekNumber].push(current);
                current = current.clone().add(1, "day");
                count += 1;
            }
            return nestedWeeks;
        };
        this.getYearRange = function (start, end) {
            var startDate = _this.moment(start).startOf("year");
            var endDate = _this.moment(end).endOf("year");
            var years = [];
            var current = startDate;
            while (current.isBefore(endDate)) {
                years.push(current);
                current = current.clone().add(1, "year");
            }
            return years;
        };
        this.isWithinRange = function (date, _a) {
            var start = _a[0], end = _a[1];
            return date.isBetween(start, end, null, "[]");
        };
        this.moment = instance || defaultMoment;
        this.locale = locale;
        this.formats = Object.assign({}, defaultFormats$2, formats);
    }
    return MomentUtils;
}());

// From https://momentjs.com/docs/#/displaying/format/
const formatTokenMap$2 = {
    // Month
    M: 'month',
    Mo: 'month',
    MM: 'month',
    MMM: { sectionName: 'month', contentType: 'letter' },
    MMMM: { sectionName: 'month', contentType: 'letter' },
    // Day of Month
    D: 'day',
    Do: 'day',
    DD: 'day',
    // Year
    Y: 'year',
    YY: 'year',
    YYYY: 'year',
    YYYYYY: 'year',
    // AM / PM
    A: 'meridiem',
    a: 'meridiem',
    // Hour
    H: 'hours',
    HH: 'hours',
    h: 'hours',
    hh: 'hours',
    k: 'hours',
    kk: 'hours',
    // Minute
    m: 'minutes',
    mm: 'minutes',
    // Second
    s: 'seconds',
    ss: 'seconds',
};
class AdapterMoment extends MomentUtils$2 {
    constructor() {
        super(...arguments);
        this.isMUIAdapter = true;
        this.formatTokenMap = formatTokenMap$2;
        this.escapedCharacters = { start: '[', end: ']' };
        /**
         * The current getFormatHelperText method uses an outdated format parsing logic.
         * We should use this one in the future to support all localized formats.
         */
        this.expandFormat = (format) => {
            // @see https://github.com/moment/moment/blob/develop/src/lib/format/format.js#L6
            const localFormattingTokens = /(\[[^[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
            return format
                .match(localFormattingTokens)
                .map((token) => {
                const firstCharacter = token[0];
                if (firstCharacter === 'L' || firstCharacter === ';') {
                    return this.moment
                        .localeData(this.getCurrentLocaleCode())
                        .longDateFormat(token);
                }
                return token;
            })
                .join('');
        };
        // Redefined here just to show how it can be written using expandFormat
        this.getFormatHelperText = (format) => {
            return this.expandFormat(format).replace(/a/gi, '(a|p)m').toLocaleLowerCase();
        };
        this.getWeekNumber = (date) => {
            return date.week();
        };
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

var momentHijriExports = {};
var momentHijri = {
  get exports(){ return momentHijriExports; },
  set exports(v){ momentHijriExports = v; },
};

(function (module, exports) {

	/************************************
	    Expose Moment Hijri
	************************************/
	(function (root, factory) {
		/* global define */
		{
			module.exports = factory(requireMoment());
		}
	})(commonjsGlobal, function (moment) { // jshint ignore:line

		if (moment == null) {
			throw new Error('Cannot find moment')
		}

		/************************************
	      Constants
	  ************************************/

		var ummalqura = {
			ummalquraData: [28607, 28636, 28665, 28695, 28724, 28754, 28783, 28813, 28843, 28872, 28901, 28931, 28960, 28990, 29019, 29049, 29078, 29108, 29137, 29167,
	                      29196, 29226, 29255, 29285, 29315, 29345, 29375, 29404, 29434, 29463, 29492, 29522, 29551, 29580, 29610, 29640, 29669, 29699, 29729, 29759,
	                      29788, 29818, 29847, 29876, 29906, 29935, 29964, 29994, 30023, 30053, 30082, 30112, 30141, 30171, 30200, 30230, 30259, 30289, 30318, 30348,
	                      30378, 30408, 30437, 30467, 30496, 30526, 30555, 30585, 30614, 30644, 30673, 30703, 30732, 30762, 30791, 30821, 30850, 30880, 30909, 30939,
	                      30968, 30998, 31027, 31057, 31086, 31116, 31145, 31175, 31204, 31234, 31263, 31293, 31322, 31352, 31381, 31411, 31441, 31471, 31500, 31530,
	                      31559, 31589, 31618, 31648, 31676, 31706, 31736, 31766, 31795, 31825, 31854, 31884, 31913, 31943, 31972, 32002, 32031, 32061, 32090, 32120,
	                      32150, 32180, 32209, 32239, 32268, 32298, 32327, 32357, 32386, 32416, 32445, 32475, 32504, 32534, 32563, 32593, 32622, 32652, 32681, 32711,
	                      32740, 32770, 32799, 32829, 32858, 32888, 32917, 32947, 32976, 33006, 33035, 33065, 33094, 33124, 33153, 33183, 33213, 33243, 33272, 33302,
	                      33331, 33361, 33390, 33420, 33450, 33479, 33509, 33539, 33568, 33598, 33627, 33657, 33686, 33716, 33745, 33775, 33804, 33834, 33863, 33893,
	                      33922, 33952, 33981, 34011, 34040, 34069, 34099, 34128, 34158, 34187, 34217, 34247, 34277, 34306, 34336, 34365, 34395, 34424, 34454, 34483,
	                      34512, 34542, 34571, 34601, 34631, 34660, 34690, 34719, 34749, 34778, 34808, 34837, 34867, 34896, 34926, 34955, 34985, 35015, 35044, 35074,
	                      35103, 35133, 35162, 35192, 35222, 35251, 35280, 35310, 35340, 35370, 35399, 35429, 35458, 35488, 35517, 35547, 35576, 35605, 35635, 35665,
	                      35694, 35723, 35753, 35782, 35811, 35841, 35871, 35901, 35930, 35960, 35989, 36019, 36048, 36078, 36107, 36136, 36166, 36195, 36225, 36254,
	                      36284, 36314, 36343, 36373, 36403, 36433, 36462, 36492, 36521, 36551, 36580, 36610, 36639, 36669, 36698, 36728, 36757, 36786, 36816, 36845,
	                      36875, 36904, 36934, 36963, 36993, 37022, 37052, 37081, 37111, 37141, 37170, 37200, 37229, 37259, 37288, 37318, 37347, 37377, 37406, 37436,
	                      37465, 37495, 37524, 37554, 37584, 37613, 37643, 37672, 37701, 37731, 37760, 37790, 37819, 37849, 37878, 37908, 37938, 37967, 37997, 38027,
	                      38056, 38085, 38115, 38144, 38174, 38203, 38233, 38262, 38292, 38322, 38351, 38381, 38410, 38440, 38469, 38499, 38528, 38558, 38587, 38617,
	                      38646, 38676, 38705, 38735, 38764, 38794, 38823, 38853, 38882, 38912, 38941, 38971, 39001, 39030, 39059, 39089, 39118, 39148, 39178, 39208,
	                      39237, 39267, 39297, 39326, 39355, 39385, 39414, 39444, 39473, 39503, 39532, 39562, 39592, 39621, 39650, 39680, 39709, 39739, 39768, 39798,
	                      39827, 39857, 39886, 39916, 39946, 39975, 40005, 40035, 40064, 40094, 40123, 40153, 40182, 40212, 40241, 40271, 40300, 40330, 40359, 40389,
	                      40418, 40448, 40477, 40507, 40536, 40566, 40595, 40625, 40655, 40685, 40714, 40744, 40773, 40803, 40832, 40862, 40892, 40921, 40951, 40980,
	                      41009, 41039, 41068, 41098, 41127, 41157, 41186, 41216, 41245, 41275, 41304, 41334, 41364, 41393, 41422, 41452, 41481, 41511, 41540, 41570,
	                      41599, 41629, 41658, 41688, 41718, 41748, 41777, 41807, 41836, 41865, 41894, 41924, 41953, 41983, 42012, 42042, 42072, 42102, 42131, 42161,
	                      42190, 42220, 42249, 42279, 42308, 42337, 42367, 42397, 42426, 42456, 42485, 42515, 42545, 42574, 42604, 42633, 42662, 42692, 42721, 42751,
	                      42780, 42810, 42839, 42869, 42899, 42929, 42958, 42988, 43017, 43046, 43076, 43105, 43135, 43164, 43194, 43223, 43253, 43283, 43312, 43342,
	                      43371, 43401, 43430, 43460, 43489, 43519, 43548, 43578, 43607, 43637, 43666, 43696, 43726, 43755, 43785, 43814, 43844, 43873, 43903, 43932,
	                      43962, 43991, 44021, 44050, 44080, 44109, 44139, 44169, 44198, 44228, 44258, 44287, 44317, 44346, 44375, 44405, 44434, 44464, 44493, 44523,
	                      44553, 44582, 44612, 44641, 44671, 44700, 44730, 44759, 44788, 44818, 44847, 44877, 44906, 44936, 44966, 44996, 45025, 45055, 45084, 45114,
	                      45143, 45172, 45202, 45231, 45261, 45290, 45320, 45350, 45380, 45409, 45439, 45468, 45498, 45527, 45556, 45586, 45615, 45644, 45674, 45704,
	                      45733, 45763, 45793, 45823, 45852, 45882, 45911, 45940, 45970, 45999, 46028, 46058, 46088, 46117, 46147, 46177, 46206, 46236, 46265, 46295,
	                      46324, 46354, 46383, 46413, 46442, 46472, 46501, 46531, 46560, 46590, 46620, 46649, 46679, 46708, 46738, 46767, 46797, 46826, 46856, 46885,
	                      46915, 46944, 46974, 47003, 47033, 47063, 47092, 47122, 47151, 47181, 47210, 47240, 47269, 47298, 47328, 47357, 47387, 47417, 47446, 47476,
	                      47506, 47535, 47565, 47594, 47624, 47653, 47682, 47712, 47741, 47771, 47800, 47830, 47860, 47890, 47919, 47949, 47978, 48008, 48037, 48066,
	                      48096, 48125, 48155, 48184, 48214, 48244, 48273, 48303, 48333, 48362, 48392, 48421, 48450, 48480, 48509, 48538, 48568, 48598, 48627, 48657,
	                      48687, 48717, 48746, 48776, 48805, 48834, 48864, 48893, 48922, 48952, 48982, 49011, 49041, 49071, 49100, 49130, 49160, 49189, 49218, 49248,
	                      49277, 49306, 49336, 49365, 49395, 49425, 49455, 49484, 49514, 49543, 49573, 49602, 49632, 49661, 49690, 49720, 49749, 49779, 49809, 49838,
	                      49868, 49898, 49927, 49957, 49986, 50016, 50045, 50075, 50104, 50133, 50163, 50192, 50222, 50252, 50281, 50311, 50340, 50370, 50400, 50429,
	                      50459, 50488, 50518, 50547, 50576, 50606, 50635, 50665, 50694, 50724, 50754, 50784, 50813, 50843, 50872, 50902, 50931, 50960, 50990, 51019,
	                      51049, 51078, 51108, 51138, 51167, 51197, 51227, 51256, 51286, 51315, 51345, 51374, 51403, 51433, 51462, 51492, 51522, 51552, 51582, 51611,
	                      51641, 51670, 51699, 51729, 51758, 51787, 51816, 51846, 51876, 51906, 51936, 51965, 51995, 52025, 52054, 52083, 52113, 52142, 52171, 52200,
	                      52230, 52260, 52290, 52319, 52349, 52379, 52408, 52438, 52467, 52497, 52526, 52555, 52585, 52614, 52644, 52673, 52703, 52733, 52762, 52792,
	                      52822, 52851, 52881, 52910, 52939, 52969, 52998, 53028, 53057, 53087, 53116, 53146, 53176, 53205, 53235, 53264, 53294, 53324, 53353, 53383,
	                      53412, 53441, 53471, 53500, 53530, 53559, 53589, 53619, 53648, 53678, 53708, 53737, 53767, 53796, 53825, 53855, 53884, 53913, 53943, 53973,
	                      54003, 54032, 54062, 54092, 54121, 54151, 54180, 54209, 54239, 54268, 54297, 54327, 54357, 54387, 54416, 54446, 54476, 54505, 54535, 54564,
	                      54593, 54623, 54652, 54681, 54711, 54741, 54770, 54800, 54830, 54859, 54889, 54919, 54948, 54977, 55007, 55036, 55066, 55095, 55125, 55154,
	                      55184, 55213, 55243, 55273, 55302, 55332, 55361, 55391, 55420, 55450, 55479, 55508, 55538, 55567, 55597, 55627, 55657, 55686, 55716, 55745,
	                      55775, 55804, 55834, 55863, 55892, 55922, 55951, 55981, 56011, 56040, 56070, 56100, 56129, 56159, 56188, 56218, 56247, 56276, 56306, 56335,
	                      56365, 56394, 56424, 56454, 56483, 56513, 56543, 56572, 56601, 56631, 56660, 56690, 56719, 56749, 56778, 56808, 56837, 56867, 56897, 56926,
	                      56956, 56985, 57015, 57044, 57074, 57103, 57133, 57162, 57192, 57221, 57251, 57280, 57310, 57340, 57369, 57399, 57429, 57458, 57487, 57517,
	                      57546, 57576, 57605, 57634, 57664, 57694, 57723, 57753, 57783, 57813, 57842, 57871, 57901, 57930, 57959, 57989, 58018, 58048, 58077, 58107,
	                      58137, 58167, 58196, 58226, 58255, 58285, 58314, 58343, 58373, 58402, 58432, 58461, 58491, 58521, 58551, 58580, 58610, 58639, 58669, 58698,
	                      58727, 58757, 58786, 58816, 58845, 58875, 58905, 58934, 58964, 58994, 59023, 59053, 59082, 59111, 59141, 59170, 59200, 59229, 59259, 59288,
	                      59318, 59348, 59377, 59407, 59436, 59466, 59495, 59525, 59554, 59584, 59613, 59643, 59672, 59702, 59731, 59761, 59791, 59820, 59850, 59879,
	                      59909, 59939, 59968, 59997, 60027, 60056, 60086, 60115, 60145, 60174, 60204, 60234, 60264, 60293, 60323, 60352, 60381, 60411, 60440, 60469,
	                      60499, 60528, 60558, 60588, 60618, 60648, 60677, 60707, 60736, 60765, 60795, 60824, 60853, 60883, 60912, 60942, 60972, 61002, 61031, 61061,
	                      61090, 61120, 61149, 61179, 61208, 61237, 61267, 61296, 61326, 61356, 61385, 61415, 61445, 61474, 61504, 61533, 61563, 61592, 61621, 61651,
	                      61680, 61710, 61739, 61769, 61799, 61828, 61858, 61888, 61917, 61947, 61976, 62006, 62035, 62064, 62094, 62123, 62153, 62182, 62212, 62242,
	                      62271, 62301, 62331, 62360, 62390, 62419, 62448, 62478, 62507, 62537, 62566, 62596, 62625, 62655, 62685, 62715, 62744, 62774, 62803, 62832,
	                      62862, 62891, 62921, 62950, 62980, 63009, 63039, 63069, 63099, 63128, 63157, 63187, 63216, 63246, 63275, 63305, 63334, 63363, 63393, 63423,
	                      63453, 63482, 63512, 63541, 63571, 63600, 63630, 63659, 63689, 63718, 63747, 63777, 63807, 63836, 63866, 63895, 63925, 63955, 63984, 64014,
	                      64043, 64073, 64102, 64131, 64161, 64190, 64220, 64249, 64279, 64309, 64339, 64368, 64398, 64427, 64457, 64486, 64515, 64545, 64574, 64603,
	                      64633, 64663, 64692, 64722, 64752, 64782, 64811, 64841, 64870, 64899, 64929, 64958, 64987, 65017, 65047, 65076, 65106, 65136, 65166, 65195,
	                      65225, 65254, 65283, 65313, 65342, 65371, 65401, 65431, 65460, 65490, 65520, 65549, 65579, 65608, 65638, 65667, 65697, 65726, 65755, 65785,
	                      65815, 65844, 65874, 65903, 65933, 65963, 65992, 66022, 66051, 66081, 66110, 66140, 66169, 66199, 66228, 66258, 66287, 66317, 66346, 66376,
	                      66405, 66435, 66465, 66494, 66524, 66553, 66583, 66612, 66641, 66671, 66700, 66730, 66760, 66789, 66819, 66849, 66878, 66908, 66937, 66967,
	                      66996, 67025, 67055, 67084, 67114, 67143, 67173, 67203, 67233, 67262, 67292, 67321, 67351, 67380, 67409, 67439, 67468, 67497, 67527, 67557,
	                      67587, 67617, 67646, 67676, 67705, 67735, 67764, 67793, 67823, 67852, 67882, 67911, 67941, 67971, 68000, 68030, 68060, 68089, 68119, 68148,
	                      68177, 68207, 68236, 68266, 68295, 68325, 68354, 68384, 68414, 68443, 68473, 68502, 68532, 68561, 68591, 68620, 68650, 68679, 68708, 68738,
	                      68768, 68797, 68827, 68857, 68886, 68916, 68946, 68975, 69004, 69034, 69063, 69092, 69122, 69152, 69181, 69211, 69240, 69270, 69300, 69330,
	                      69359, 69388, 69418, 69447, 69476, 69506, 69535, 69565, 69595, 69624, 69654, 69684, 69713, 69743, 69772, 69802, 69831, 69861, 69890, 69919,
	                      69949, 69978, 70008, 70038, 70067, 70097, 70126, 70156, 70186, 70215, 70245, 70274, 70303, 70333, 70362, 70392, 70421, 70451, 70481, 70510,
	                      70540, 70570, 70599, 70629, 70658, 70687, 70717, 70746, 70776, 70805, 70835, 70864, 70894, 70924, 70954, 70983, 71013, 71042, 71071, 71101,
	                      71130, 71159, 71189, 71218, 71248, 71278, 71308, 71337, 71367, 71397, 71426, 71455, 71485, 71514, 71543, 71573, 71602, 71632, 71662, 71691,
	                      71721, 71751, 71781, 71810, 71839, 71869, 71898, 71927, 71957, 71986, 72016, 72046, 72075, 72105, 72135, 72164, 72194, 72223, 72253, 72282,
	                      72311, 72341, 72370, 72400, 72429, 72459, 72489, 72518, 72548, 72577, 72607, 72637, 72666, 72695, 72725, 72754, 72784, 72813, 72843, 72872,
	                      72902, 72931, 72961, 72991, 73020, 73050, 73080, 73109, 73139, 73168, 73197, 73227, 73256, 73286, 73315, 73345, 73375, 73404, 73434, 73464,
	                      73493, 73523, 73552, 73581, 73611, 73640, 73669, 73699, 73729, 73758, 73788, 73818, 73848, 73877, 73907, 73936, 73965, 73995, 74024, 74053,
	                      74083, 74113, 74142, 74172, 74202, 74231, 74261, 74291, 74320, 74349, 74379, 74408, 74437, 74467, 74497, 74526, 74556, 74586, 74615, 74645,
	                      74675, 74704, 74733, 74763, 74792, 74822, 74851, 74881, 74910, 74940, 74969, 74999, 75029, 75058, 75088, 75117, 75147, 75176, 75206, 75235,
	                      75264, 75294, 75323, 75353, 75383, 75412, 75442, 75472, 75501, 75531, 75560, 75590, 75619, 75648, 75678, 75707, 75737, 75766, 75796, 75826,
	                      75856, 75885, 75915, 75944, 75974, 76003, 76032, 76062, 76091, 76121, 76150, 76180, 76210, 76239, 76269, 76299, 76328, 76358, 76387, 76416,
	                      76446, 76475, 76505, 76534, 76564, 76593, 76623, 76653, 76682, 76712, 76741, 76771, 76801, 76830, 76859, 76889, 76918, 76948, 76977, 77007,
	                      77036, 77066, 77096, 77125, 77155, 77185, 77214, 77243, 77273, 77302, 77332, 77361, 77390, 77420, 77450, 77479, 77509, 77539, 77569, 77598,
	                      77627, 77657, 77686, 77715, 77745, 77774, 77804, 77833, 77863, 77893, 77923, 77952, 77982, 78011, 78041, 78070, 78099, 78129, 78158, 78188,
	                      78217, 78247, 78277, 78307, 78336, 78366, 78395, 78425, 78454, 78483, 78513, 78542, 78572, 78601, 78631, 78661, 78690, 78720, 78750, 78779,
	                      78808, 78838, 78867, 78897, 78926, 78956, 78985, 79015, 79044, 79074, 79104, 79133, 79163, 79192, 79222, 79251, 79281, 79310, 79340, 79369,
	                      79399, 79428, 79458, 79487, 79517, 79546, 79576, 79606, 79635, 79665, 79695, 79724, 79753, 79783, 79812, 79841, 79871, 79900, 79930, 79960,
	                      79990]
		};

		var formattingTokens = /(\[[^\[]*\])|(\\)?i(Mo|MM?M?M?|Do|DDDo|DD?D?D?|w[o|w]?|YYYYY|YYYY|YY|gg(ggg?)?)|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g,
			localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g

		, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{1,4}/, parseTokenSixDigits = /[+\-]?\d{1,6}/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+(\.?)|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i, parseTokenT = /T/i, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/

		, unitAliases = {
			hd: 'idate',
			hm: 'imonth',
			hy: 'iyear'
		}

		, formatFunctions = {}

		, ordinalizeTokens = 'DDD w M D'.split(' '), paddedTokens = 'M D w'.split(' ')

		, formatTokenFunctions = {
			iM: function () {
				return this.iMonth() + 1
			},
			iMMM: function (format) {
				return this.localeData().iMonthsShort(this, format)
			},
			iMMMM: function (format) {
				return this.localeData().iMonths(this, format)
			},
			iD: function () {
				return this.iDate()
			},
			iDDD: function () {
				return this.iDayOfYear()
			},
			iw: function () {
				return this.iWeek()
			},
			iYY: function () {
				return leftZeroFill(this.iYear() % 100, 2)
			},
			iYYYY: function () {
				return leftZeroFill(this.iYear(), 4)
			},
			iYYYYY: function () {
				return leftZeroFill(this.iYear(), 5)
			},
			igg: function () {
				return leftZeroFill(this.iWeekYear() % 100, 2)
			},
			igggg: function () {
				return this.iWeekYear()
			},
			iggggg: function () {
				return leftZeroFill(this.iWeekYear(), 5)
			}
		}, i;

		function padToken(func, count) {
			return function (a) {
				return leftZeroFill(func.call(this, a), count)
			}
		}

		function ordinalizeToken(func, period) {
			return function (a) {
				return this.localeData().ordinal(func.call(this, a), period)
			}
		}

		while (ordinalizeTokens.length) {
			i = ordinalizeTokens.pop();
			formatTokenFunctions['i' + i + 'o'] = ordinalizeToken(formatTokenFunctions['i' + i], i);
		}
		while (paddedTokens.length) {
			i = paddedTokens.pop();
			formatTokenFunctions['i' + i + i] = padToken(formatTokenFunctions['i' + i], 2);
		}
		formatTokenFunctions.iDDDD = padToken(formatTokenFunctions.iDDD, 3);

		/************************************
	      Helpers
	  ************************************/

		function extend(a, b) {
			var key;
			for (key in b)
				if (b.hasOwnProperty(key))
					a[key] = b[key];
			return a
		}

		function leftZeroFill(number, targetLength) {
			var output = number + '';
			while (output.length < targetLength)
				output = '0' + output;
			return output
		}

		function isArray(input) {
			return Object.prototype.toString.call(input) === '[object Array]'
		}

		function normalizeUnits(units) {
			return units ? unitAliases[units] || units.toLowerCase().replace(/(.)s$/, '$1') : units
		}

		function setDate(moment, year, month, date) {
			var utc = moment._isUTC ? 'UTC' : '';
			moment._d['set' + utc + 'FullYear'](year);
			moment._d['set' + utc + 'Month'](month);
			moment._d['set' + utc + 'Date'](date);
		}

		function objectCreate(parent) {
			function F() {}
			F.prototype = parent;
			return new F()
		}

		function getPrototypeOf(object) {
			if (Object.getPrototypeOf)
				return Object.getPrototypeOf(object)
			else if (''.__proto__) // jshint ignore:line
				return object.__proto__ // jshint ignore:line
			else
				return object.constructor.prototype
		}

		/************************************
	      Languages
	  ************************************/
		extend(getPrototypeOf(moment.localeData()), {
			_iMonths: ['Muharram'
	                , 'Safar'
	                , 'Rabi\' al-Awwal'
	                , 'Rabi\' al-Thani'
	                , 'Jumada al-Ula'
	                , 'Jumada al-Alkhirah'
	                , 'Rajab'
	                , 'Shaban'
	                , 'Ramadhan'
	                , 'Shawwal'
	                , 'Thul-Qidah'
	                , 'Thul-Hijjah'
	                ],
			iMonths: function (m) {
				return this._iMonths[m.iMonth()]
			}

			,
			_iMonthsShort: ['Muh'
	                      , 'Saf'
	                      , 'Rab-I'
	                      , 'Rab-II'
	                      , 'Jum-I'
	                      , 'Jum-II'
	                      , 'Raj'
	                      , 'Sha'
	                      , 'Ram'
	                      , 'Shw'
	                      , 'Dhu-Q'
	                      , 'Dhu-H'
	                      ],
			iMonthsShort: function (m) {
				return this._iMonthsShort[m.iMonth()]
			}

			,
			iMonthsParse: function (monthName) {
				var i, mom, regex;
				if (!this._iMonthsParse)
					this._iMonthsParse = [];
				for (i = 0; i < 12; i += 1) {
					// Make the regex if we don't have it already.
					if (!this._iMonthsParse[i]) {
						mom = hMoment([2000, (2 + i) % 12, 25]);
						regex = '^' + this.iMonths(mom, '') + '$|^' + this.iMonthsShort(mom, '') + '$';
						this._iMonthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
					}
					// Test the regex.
					if (this._iMonthsParse[i].test(monthName))
						return i
				}
			}
		});
		var iMonthNames = {
			iMonths: '__ _ _ _ _____ _ '.split('_'),
			iMonthsShort: '__ _ _ _ _____ _ '.split('_')
		};

		// Default to the momentjs 2.12+ API
		if (typeof moment.updateLocale === 'function') {
			moment.updateLocale('ar-sa', iMonthNames);
		} else {
			var oldLocale = moment.locale();
			moment.defineLocale('ar-sa', iMonthNames);
			moment.locale(oldLocale);
		}

		/************************************
	      Formatting
	  ************************************/

		function makeFormatFunction(format) {
			var array = format.match(formattingTokens),
				length = array.length,
				i;

			for (i = 0; i < length; i += 1)
				if (formatTokenFunctions[array[i]])
					array[i] = formatTokenFunctions[array[i]];

			return function (mom) {
				var output = '';
				for (i = 0; i < length; i += 1)
					output += array[i] instanceof Function ? '[' + array[i].call(mom, format) + ']' : array[i];
				return output
			}
		}

		/************************************
	      Parsing
	  ************************************/

		function getParseRegexForToken(token, config) {
			switch (token) {
			case 'iDDDD':
				return parseTokenThreeDigits
			case 'iYYYY':
				return parseTokenFourDigits
			case 'iYYYYY':
				return parseTokenSixDigits
			case 'iDDD':
				return parseTokenOneToThreeDigits
			case 'iMMM':
			case 'iMMMM':
				return parseTokenWord
			case 'iMM':
			case 'iDD':
			case 'iYY':
			case 'iM':
			case 'iD':
				return parseTokenOneOrTwoDigits
			case 'DDDD':
				return parseTokenThreeDigits
			case 'YYYY':
				return parseTokenFourDigits
			case 'YYYYY':
				return parseTokenSixDigits
			case 'S':
			case 'SS':
			case 'SSS':
			case 'DDD':
				return parseTokenOneToThreeDigits
			case 'MMM':
			case 'MMMM':
			case 'dd':
			case 'ddd':
			case 'dddd':
				return parseTokenWord
			case 'a':
			case 'A':
				return moment.localeData(config._l)._meridiemParse
			case 'X':
				return parseTokenTimestampMs
			case 'Z':
			case 'ZZ':
				return parseTokenTimezone
			case 'T':
				return parseTokenT
			case 'MM':
			case 'DD':
			case 'YY':
			case 'HH':
			case 'hh':
			case 'mm':
			case 'ss':
			case 'M':
			case 'D':
			case 'd':
			case 'H':
			case 'h':
			case 'm':
			case 's':
				return parseTokenOneOrTwoDigits
			default:
				return new RegExp(token.replace('\\', ''))
			}
		}

		function addTimeToArrayFromToken(token, input, config) {
			var a, datePartArray = config._a;

			switch (token) {
			case 'iM':
			case 'iMM':
				datePartArray[1] = input == null ? 0 : ~~input - 1;
				break
			case 'iMMM':
			case 'iMMMM':
				a = moment.localeData(config._l).iMonthsParse(input);
				if (a != null)
					datePartArray[1] = a;
				else
					config._isValid = false;
				break
			case 'iD':
			case 'iDD':
			case 'iDDD':
			case 'iDDDD':
				if (input != null)
					datePartArray[2] = ~~input;
				break
			case 'iYY':
				datePartArray[0] = ~~input + (~~input > 47 ? 1300 : 1400);
				break
			case 'iYYYY':
			case 'iYYYYY':
				datePartArray[0] = ~~input;
			}
			if (input == null)
				config._isValid = false;
		}

		function dateFromArray(config) {
			var g, h, hy = config._a[0],
				hm = config._a[1],
				hd = config._a[2];

			if ((hy == null) && (hm == null) && (hd == null))
				return [0, 0, 1]
			hy = hy || 0;
			hm = hm || 0;
			hd = hd || 1;
			if (hd < 1 || hd > hMoment.iDaysInMonth(hy, hm))
				config._isValid = false;
			g = toGregorian(hy, hm, hd);
			h = toHijri(g.gy, g.gm, g.gd);
			config._hDiff = 0;
			if (~~h.hy !== hy)
				config._hDiff += 1;
			if (~~h.hm !== hm)
				config._hDiff += 1;
			if (~~h.hd !== hd)
				config._hDiff += 1;
			return [g.gy, g.gm, g.gd]
		}

		function makeDateFromStringAndFormat(config) {
			var tokens = config._f.match(formattingTokens),
				string = config._i,
				len = tokens.length,
				i, token, parsedInput;

			config._a = [];

			for (i = 0; i < len; i += 1) {
				token = tokens[i];
				parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];
				if (parsedInput)
					string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
				if (formatTokenFunctions[token])
					addTimeToArrayFromToken(token, parsedInput, config);
			}
			if (string)
				config._il = string;

			return dateFromArray(config)
		}

		function makeDateFromStringAndArray(config, utc) {
			var len = config._f.length
			, i
			, format
			, tempMoment
			, bestMoment
			, currentScore
			, scoreToBeat;

			if (len === 0) {
				return makeMoment(new Date(NaN))
			}

			for (i = 0; i < len; i += 1) {
				format = config._f[i];
				currentScore = 0;
				tempMoment = makeMoment(config._i, format, config._l, utc);

				if (!tempMoment.isValid()) continue

				currentScore += tempMoment._hDiff;
				if (tempMoment._il)
					currentScore += tempMoment._il.length;
				if (scoreToBeat == null || currentScore < scoreToBeat) {
					scoreToBeat = currentScore;
					bestMoment = tempMoment;
				}
			}

			return bestMoment
		}

		function removeParsedTokens(config) {
			var string = config._i,
				input = '',
				format = '',
				array = config._f.match(formattingTokens),
				len = array.length,
				i, match, parsed;

			for (i = 0; i < len; i += 1) {
				match = array[i];
				parsed = (getParseRegexForToken(match, config).exec(string) || [])[0];
				if (parsed)
					string = string.slice(string.indexOf(parsed) + parsed.length);
				if (!(formatTokenFunctions[match] instanceof Function)) {
					format += match;
					if (parsed)
						input += parsed;
				}
			}
			config._i = input;
			config._f = format;
		}

		/************************************
	      Week of Year
	  ************************************/

		function iWeekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
			var end = firstDayOfWeekOfYear - firstDayOfWeek,
				daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
				adjustedMoment;

			if (daysToDayOfWeek > end) {
				daysToDayOfWeek -= 7;
			}
			if (daysToDayOfWeek < end - 7) {
				daysToDayOfWeek += 7;
			}
			adjustedMoment = hMoment(mom).add(daysToDayOfWeek, 'd');
			return {
				week: Math.ceil(adjustedMoment.iDayOfYear() / 7),
				year: adjustedMoment.iYear()
			}
		}

		/************************************
	      Top Level Functions
	  ************************************/

		function makeMoment(input, format, lang, utc) {
			var config =
				{ _i: input
				, _f: format
				, _l: lang
				}
				, date
				, m
				, hm;
			if (format) {
				if (isArray(format)) {
					return makeDateFromStringAndArray(config, utc)
				} else {
					date = makeDateFromStringAndFormat(config);
					removeParsedTokens(config);
					format = 'YYYY-MM-DD-' + config._f;
					input = leftZeroFill(date[0], 4) + '-'
						+ leftZeroFill(date[1] + 1, 2) + '-'
						+ leftZeroFill(date[2], 2) + '-'
						+ config._i;
				}
			}
			if (utc)
				m = moment.utc(input, format, lang);
			else
				m = moment(input, format, lang);
			if (config._isValid === false)
				m._isValid = false;
			m._hDiff = config._hDiff || 0;
			hm = objectCreate(hMoment.fn);
			extend(hm, m);
			return hm
		}

		function hMoment(input, format, lang) {
			return makeMoment(input, format, lang, false)
		}

		extend(hMoment, moment);
		hMoment.fn = objectCreate(moment.fn);

		hMoment.utc = function (input, format, lang) {
			return makeMoment(input, format, lang, true)
		};

		/************************************
	      hMoment Prototype
	  ************************************/

		hMoment.fn.format = function (format) {
			var i, replace, me = this;

			if (format) {
				i = 5;
				replace = function (input) {
					return me.localeData().longDateFormat(input) || input
				};
				while (i > 0 && localFormattingTokens.test(format)) {
					i -= 1;
					format = format.replace(localFormattingTokens, replace);
				}
				if (!formatFunctions[format]) {
					formatFunctions[format] = makeFormatFunction(format);
				}
				format = formatFunctions[format](this);
			}
			return moment.fn.format.call(this, format)
		};

		hMoment.fn.iYear = function (input) {
			var lastDay, h, g;
			if (typeof input === 'number') {
				h = toHijri(this.year(), this.month(), this.date());
				lastDay = Math.min(h.hd, hMoment.iDaysInMonth(input, h.hm));
				g = toGregorian(input, h.hm, lastDay);
				setDate(this, g.gy, g.gm, g.gd);
				//Workaround: sometimes moment wont set the date correctly if current day is the last in the month
				if (this.month() !== g.gm || this.date() !== g.gd || this.year() !== g.gy) {
					setDate(this, g.gy, g.gm, g.gd);
				}
				moment.updateOffset(this);
				return this
			} else {
				return toHijri(this.year(), this.month(), this.date()).hy
			}
		};

		hMoment.fn.iMonth = function (input) {
			var lastDay, h, g;
			if (input != null) {
				if (typeof input === 'string') {
					input = this.localeData().iMonthsParse(input);
					if(input >= 0) {
						input -= 1;
					} else {
						return this
					}
				}
				h = toHijri(this.year(), this.month(), this.date());
				lastDay = Math.min(h.hd, hMoment.iDaysInMonth(h.hy, input));
				this.iYear(h.hy + div(input, 12));
				input = mod(input, 12);
				if (input < 0) {
					input += 12;
					this.iYear(this.iYear() - 1);
				}
				g = toGregorian(this.iYear(), input, lastDay);
				setDate(this, g.gy, g.gm, g.gd);
				//Workaround: sometimes moment wont set the date correctly if current day is the last in the month
				if (this.month() !== g.gm || this.date() !== g.gd || this.year() !== g.gy) {
					setDate(this, g.gy, g.gm, g.gd);
				}
				moment.updateOffset(this);
				return this
			} else {
				return toHijri(this.year(), this.month(), this.date()).hm
			}
		};

		hMoment.fn.iDate = function (input) {
			var h, g;
			if (typeof input === 'number') {
				h = toHijri(this.year(), this.month(), this.date());
				g = toGregorian(h.hy, h.hm, input);
				setDate(this, g.gy, g.gm, g.gd);
				//Workaround: sometimes moment wont set the date correctly if current day is the last in the month
				if (this.month() !== g.gm || this.date() !== g.gd || this.year() !== g.gy) {
					setDate(this, g.gy, g.gm, g.gd);
				}
				moment.updateOffset(this);
				return this
			} else {
				return toHijri(this.year(), this.month(), this.date()).hd
			}
		};

		hMoment.fn.iDayOfYear = function (input) {
			var dayOfYear = Math.round((hMoment(this).startOf('day') - hMoment(this).startOf('iYear')) / 864e5) + 1;
			return input == null ? dayOfYear : this.add(input - dayOfYear, 'd')
		};

		hMoment.fn.iDaysInMonth = function () {
			return parseInt(hMoment(this).endOf('iMonth').format('iDD'));
		};

		hMoment.fn.iWeek = function (input) {
			var week = iWeekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).week;
			return input == null ? week : this.add( (input - week) * 7, 'd')
		};

		hMoment.fn.iWeekYear = function (input) {
			var year = iWeekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
			return input == null ? year : this.add(input - year, 'y')
		};

		hMoment.fn.add = function (val, units) {
			var temp;
			if (units !== null && !isNaN(+units)) {
				temp = val;
				val = units;
				units = temp;
			}
			units = normalizeUnits(units);
			if (units === 'iyear') {
				this.iYear(this.iYear() + val);
			} else if (units === 'imonth') {
				this.iMonth(this.iMonth() + val);
			} else if (units === 'idate') {
				this.iDate(this.iDate() + val);
			}
			 else {
				moment.fn.add.call(this, val, units);
			}
			return this
		};

		hMoment.fn.subtract = function (val, units) {
			var temp;
			if (units !== null && !isNaN(+units)) {
				temp = val;
				val = units;
				units = temp;
			}
			units = normalizeUnits(units);
			if (units === 'iyear') {
				this.iYear(this.iYear() - val);
			} else if (units === 'imonth') {
				this.iMonth(this.iMonth() - val);
			} else if (units === 'idate') {
				this.iDate(this.iDate() - val);
			} else {
				moment.fn.subtract.call(this, val, units);
			}
			return this
		};

		hMoment.fn.startOf = function (units) {
			units = normalizeUnits(units);
			if (units === 'iyear' || units === 'imonth') {
				if (units === 'iyear') {
					this.iMonth(0);
				}
				this.iDate(1);
				this.hours(0);
				this.minutes(0);
				this.seconds(0);
				this.milliseconds(0);
				return this
			} else {
				return moment.fn.startOf.call(this, units)
			}
		};

		hMoment.fn.endOf = function (units) {
			units = normalizeUnits(units);
			if (units === undefined || units === 'milisecond') {
				return this
			}
			return this.startOf(units).add(1, (units === 'isoweek' ? 'week' : units)).subtract(1, 'milliseconds')
		};

		hMoment.fn.clone = function () {
			return hMoment(this)
		};

		hMoment.fn.iYears = hMoment.fn.iYear;
		hMoment.fn.iMonths = hMoment.fn.iMonth;
		hMoment.fn.iDates = hMoment.fn.iDate;
		hMoment.fn.iWeeks = hMoment.fn.iWeek;

		/************************************
	      hMoment Statics
	  ************************************/

		hMoment.iDaysInMonth = function (year, month) {
			var i = getNewMoonMJDNIndex(year, month + 1),
				daysInMonth = ummalqura.ummalquraData[i] - ummalqura.ummalquraData[i - 1];
			return daysInMonth
		};

		function toHijri(gy, gm, gd) {
			var h = d2h(g2d(gy, gm + 1, gd));
			h.hm -= 1;
			return h
		}

		function toGregorian(hy, hm, hd) {
			var g = d2g(h2d(hy, hm + 1, hd));
			g.gm -= 1;
			return g
		}

		hMoment.iConvert = {
			toHijri: toHijri,
			toGregorian: toGregorian
		};

		return hMoment

		/************************************
	      Hijri Conversion
	  ************************************/

		/*
	    Utility helper functions.
	  */

		function div(a, b) {
			return ~~ (a / b)
		}

		function mod(a, b) {
			return a - ~~(a / b) * b
		}

		/*
	    Converts a date of the Hijri calendar to the Julian Day number.

	    @param hy Hijri year (1356 to 1500)
	    @param hm Hijri month (1 to 12)
	    @param hd Hijri day (1 to 29/30)
	    @return Julian Day number
	  */

		function h2d(hy, hm, hd) {
			var i = getNewMoonMJDNIndex(hy, hm),
				mjdn = hd + ummalqura.ummalquraData[i - 1] - 1,
				jdn = mjdn + 2400000;
			return jdn
		}

		/*
	    Converts the Julian Day number to a date in the Hijri calendar.

	    @param jdn Julian Day number
	    @return
	      hy: Hijri year (1356 to 1500)
	      hm: Hijri month (1 to 12)
	      hd: Hijri day (1 to 29/30)
	  */

		function d2h(jdn) {
			var mjdn = jdn - 2400000,
				i = getNewMoonMJDNIndexByJDN(mjdn),
				totalMonths = i + 16260,
				cYears = Math.floor((totalMonths - 1) / 12),
				hy = cYears + 1,
				hm = totalMonths - 12 * cYears,
				hd = mjdn - ummalqura.ummalquraData[i - 1] + 1;

			return {
				hy: hy,
				hm: hm,
				hd: hd
			}
		}

		/*
	    Calculates the Julian Day number from Gregorian or Julian
	    calendar dates. This integer number corresponds to the noon of
	    the date (i.e. 12 hours of Universal Time).
	    The procedure was tested to be good since 1 March, -100100 (of both
	    calendars) up to a few million years into the future.

	    @param gy Calendar year (years BC numbered 0, -1, -2, ...)
	    @param gm Calendar month (1 to 12)
	    @param gd Calendar day of the month (1 to 28/29/30/31)
	    @return Julian Day number
	  */

		function g2d(gy, gm, gd) {
			var d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) + div(153 * mod(gm + 9, 12) + 2, 5) + gd - 34840408;
			d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
			return d
		}

		/*
	    Calculates Gregorian and Julian calendar dates from the Julian Day number
	    (hdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
	    calendars) to some millions years ahead of the present.

	    @param jdn Julian Day number
	    @return
	      gy: Calendar year (years BC numbered 0, -1, -2, ...)
	      gm: Calendar month (1 to 12)
	      gd: Calendar day of the month M (1 to 28/29/30/31)
	  */

		function d2g(jdn) {
			var j, i, gd, gm, gy;
			j = 4 * jdn + 139361631;
			j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
			i = div(mod(j, 1461), 4) * 5 + 308;
			gd = div(mod(i, 153), 5) + 1;
			gm = mod(div(i, 153), 12) + 1;
			gy = div(j, 1461) - 100100 + div(8 - gm, 6);
			return {
				gy: gy,
				gm: gm,
				gd: gd
			}
		}

		/*
	    Returns the index of the modified Julian day number of the new moon
	    by the given year and month

	    @param hy: Hijri year (1356 to 1500)
	    @param hm: Hijri month (1 to 12)
	    @return
	        i: the index of the new moon in modified Julian day number.
	  */
		function getNewMoonMJDNIndex(hy, hm) {
			var cYears = hy - 1,
				totalMonths = (cYears * 12) + 1 + (hm - 1),
				i = totalMonths - 16260;
			return i
		}

		/*
	    Returns the nearest new moon

	    @param jdn Julian Day number
	    @return
	      i: the index of a modified Julian day number.
	  */
		function getNewMoonMJDNIndexByJDN(mjdn) {
			for (var i = 0; i < ummalqura.ummalquraData.length; i=i+1) {
				if (ummalqura.ummalquraData[i] > mjdn)
					return i
			}
		}

	});
} (momentHijri));

var iMoment = momentHijriExports;

var symbolMap$2 = {
    1: "",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: "",
    0: "",
};
var defaultFormats$1 = {
    dayOfMonth: "iD",
    fullDate: "iYYYY, iMMMM Do",
    fullDateWithWeekday: "iYYYY, iMMMM Do, dddd",
    fullDateTime: "iYYYY, iMMMM Do, hh:mm A",
    fullDateTime12h: "iD iMMMM hh:mm A",
    fullDateTime24h: "iD iMMMM HH:mm",
    fullTime: "LT",
    fullTime12h: "hh:mm A",
    fullTime24h: "HH:mm",
    hours12h: "hh",
    hours24h: "HH",
    keyboardDate: "iYYYY/iMM/iDD",
    keyboardDateTime: "iYYYY/iMM/iDD LT",
    keyboardDateTime12h: "iYYYY/iMM/iDD hh:mm A",
    keyboardDateTime24h: "iYYYY/iMM/iDD HH:mm",
    minutes: "mm",
    month: "iMMMM",
    monthAndDate: "iD iMMMM",
    monthAndYear: "iMMMM iYYYY",
    monthShort: "iMMM",
    weekday: "dddd",
    weekdayShort: "ddd",
    normalDate: "dddd, iD iMMM",
    normalDateWithWeekday: "DD iMMMM",
    seconds: "ss",
    shortDate: "iD iMMM",
    year: "iYYYY",
};
var MomentUtils$1 = /** @class */ (function (_super) {
    __extends(MomentUtils, _super);
    function MomentUtils(_a) {
        var _b = _a === void 0 ? {} : _a, instance = _b.instance, formats = _b.formats;
        var _this = _super.call(this, { locale: "ar-SA", instance: instance }) || this;
        _this.lib = "moment=hijiri";
        _this.toIMoment = function (date) {
            return _this.moment(date ? date.clone() : undefined).locale("ar-SA");
        };
        _this.parse = function (value, format) {
            if (value === "") {
                return null;
            }
            return _this.moment(value, format, true).locale("ar-SA");
        };
        _this.date = function (value) {
            if (value === null) {
                return null;
            }
            return _this.moment(value).locale("ar-SA");
        };
        _this.isBeforeYear = function (date, value) {
            return date.iYear() < value.iYear();
        };
        _this.isAfterYear = function (date, value) {
            return date.iYear() > value.iYear();
        };
        _this.getMonth = function (date) {
            return date.iMonth();
        };
        _this.getDaysInMonth = function (date) {
            return date.daysInMonth();
        };
        _this.startOfYear = function (date) {
            return date.clone().startOf("iYear");
        };
        _this.endOfYear = function (date) {
            return date.clone().endOf("iYear");
        };
        _this.startOfMonth = function (date) {
            return date.clone().startOf("iMonth");
        };
        _this.endOfMonth = function (date) {
            return date.clone().endOf("iMonth");
        };
        _this.getNextMonth = function (date) {
            return date.clone().add(1, "iMonth");
        };
        _this.getPreviousMonth = function (date) {
            return date.clone().subtract(1, "iMonth");
        };
        _this.getYear = function (date) {
            return date.iYear();
        };
        _this.setYear = function (date, year) {
            return date.clone().iYear(year);
        };
        _this.getDate = function (date) {
            return date.iDate();
        };
        _this.setDate = function (date, year) {
            return date.clone().iDate(year);
        };
        _this.getMeridiemText = function (ampm) {
            return ampm === "am"
                ? _this.toIMoment().hours(2).format("A")
                : _this.toIMoment().hours(14).format("A");
        };
        _this.getWeekdays = function () {
            return [0, 1, 2, 3, 4, 5, 6].map(function (dayOfWeek) {
                return _this.toIMoment().weekday(dayOfWeek).format("dd");
            });
        };
        _this.isEqual = function (value, comparing) {
            if (value === null && comparing === null) {
                return true;
            }
            return _this.moment(value).isSame(comparing);
        };
        _this.formatNumber = function (num) {
            return num.replace(/\d/g, function (match) { return symbolMap$2[match]; }).replace(/,/g, "");
        };
        _this.getWeekArray = function (date) {
            var start = date.clone().startOf("iMonth").startOf("week");
            var end = date.clone().endOf("iMonth").endOf("week");
            var count = 0;
            var current = start;
            var nestedWeeks = [];
            while (current.isBefore(end)) {
                var weekNumber = Math.floor(count / 7);
                nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
                nestedWeeks[weekNumber].push(current);
                current = current.clone().add(1, "day");
                count += 1;
            }
            return nestedWeeks;
        };
        _this.getYearRange = function (start, end) {
            // moment-hijri only supports dates between 1356-01-01 H and 1499-12-29 H
            // We need to throw if outside min/max bounds, otherwise the while loop below will be infinite.
            if (start.isBefore("1937-03-14")) {
                throw new Error("min date must be on or after 1356-01-01 H (1937-03-14)");
            }
            if (end.isAfter("2076-11-26")) {
                throw new Error("max date must be on or before 1499-12-29 H (2076-11-26)");
            }
            var startDate = _this.moment(start).startOf("iYear");
            var endDate = _this.moment(end).endOf("iYear");
            var years = [];
            var current = startDate;
            while (current.isBefore(endDate)) {
                years.push(current);
                current = current.clone().add(1, "iYear");
            }
            return years;
        };
        _this.moment = instance || iMoment;
        _this.locale = "ar-SA";
        _this.formats = Object.assign({}, defaultFormats$1, formats);
        return _this;
    }
    return MomentUtils;
}(MomentUtils$2));

/* eslint-disable class-methods-use-this */
// From https://momentjs.com/docs/#/displaying/format/
const formatTokenMap$1 = {
    // Month
    iM: 'month',
    iMo: 'month',
    iMM: 'month',
    iMMM: { sectionName: 'month', contentType: 'letter' },
    iMMMM: { sectionName: 'month', contentType: 'letter' },
    // Day of Month
    iD: 'day',
    iDo: 'day',
    iDD: 'day',
    // Year
    iY: 'year',
    iYY: 'year',
    iYYYY: 'year',
    iYYYYYY: 'year',
    // AM / PM
    A: 'meridiem',
    a: 'meridiem',
    // Hour
    H: 'hours',
    HH: 'hours',
    h: 'hours',
    hh: 'hours',
    k: 'hours',
    kk: 'hours',
    // Minute
    m: 'minutes',
    mm: 'minutes',
    // Second
    s: 'seconds',
    ss: 'seconds',
};
class AdapterMomentHijri extends MomentUtils$1 {
    constructor() {
        super(...arguments);
        this.isMUIAdapter = true;
        this.formatTokenMap = formatTokenMap$1;
        this.escapedCharacters = { start: '[', end: ']' };
        /**
         * The current getFormatHelperText method uses an outdated format parsing logic.
         * We should use this one in the future to support all localized formats.
         */
        this.expandFormat = (format) => {
            // @see https://github.com/moment/moment/blob/develop/src/lib/format/format.js#L6
            const localFormattingTokens = /(\[[^[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
            return format
                .match(localFormattingTokens)
                .map((token) => {
                const firstCharacter = token[0];
                if (firstCharacter === 'L' || firstCharacter === ';') {
                    return this.moment
                        .localeData(this.getCurrentLocaleCode())
                        .longDateFormat(token);
                }
                return token;
            })
                .join('')
                .replace('dd', 'iDD'); // Fix for https://github.com/dmtrKovalenko/date-io/pull/632
        };
        // Redefined here just to show how it can be written using expandFormat
        this.getFormatHelperText = (format) => {
            return this.expandFormat(format)
                .replace(/a/gi, '(a|p)m')
                .replace('iY', 'Y')
                .replace('iM', 'M')
                .replace('iD', 'D')
                .toLocaleLowerCase();
        };
        this.getWeekNumber = (date) => {
            return date.iWeek();
        };
    }
}

/*
  Expose functions.
*/

var jalaaliJs =
  { toJalaali: toJalaali$1
  , toGregorian: toGregorian$1
  , isValidJalaaliDate: isValidJalaaliDate
  , isLeapJalaaliYear: isLeapJalaaliYear
  , jalaaliMonthLength: jalaaliMonthLength
  , jalCal: jalCal
  , j2d: j2d
  , d2j: d2j
  , g2d: g2d
  , d2g: d2g
  , jalaaliToDateObject: jalaaliToDateObject
  , jalaaliWeek: jalaaliWeek
  };

/*
  Jalaali years starting the 33-year rule.
*/
var breaks =  [ -61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210
  , 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178
  ];

/*
  Converts a Gregorian date to Jalaali.
*/
function toJalaali$1(gy, gm, gd) {
  if (Object.prototype.toString.call(gy) === '[object Date]') {
    gd = gy.getDate();
    gm = gy.getMonth() + 1;
    gy = gy.getFullYear();
  }
  return d2j(g2d(gy, gm, gd))
}

/*
  Converts a Jalaali date to Gregorian.
*/
function toGregorian$1(jy, jm, jd) {
  return d2g(j2d(jy, jm, jd))
}

/*
  Checks whether a Jalaali date is valid or not.
*/
function isValidJalaaliDate(jy, jm, jd) {
  return  jy >= -61 && jy <= 3177 &&
          jm >= 1 && jm <= 12 &&
          jd >= 1 && jd <= jalaaliMonthLength(jy, jm)
}

/*
  Is this a leap year or not?
*/
function isLeapJalaaliYear(jy) {
  return jalCalLeap(jy) === 0
}

/*
  Number of days in a given month in a Jalaali year.
*/
function jalaaliMonthLength(jy, jm) {
  if (jm <= 6) return 31
  if (jm <= 11) return 30
  if (isLeapJalaaliYear(jy)) return 30
  return 29
}

/*
    This function determines if the Jalaali (Persian) year is
    leap (366-day long) or is the common year (365 days)

    @param jy Jalaali calendar year (-61 to 3177)
    @returns number of years since the last leap year (0 to 4)
 */
function jalCalLeap(jy) {
  var bl = breaks.length
    , jp = breaks[0]
    , jm
    , jump
    , leap
    , n
    , i;

  if (jy < jp || jy >= breaks[bl - 1])
    throw new Error('Invalid Jalaali year ' + jy)

  for (i = 1; i < bl; i += 1) {
    jm = breaks[i];
    jump = jm - jp;
    if (jy < jm)
      break
    jp = jm;
  }
  n = jy - jp;

  if (jump - n < 6)
    n = n - jump + div$1(jump + 4, 33) * 33;
  leap = mod$1(mod$1(n + 1, 33) - 1, 4);
  if (leap === -1) {
    leap = 4;
  }

  return leap
}

/*
  This function determines if the Jalaali (Persian) year is
  leap (366-day long) or is the common year (365 days), and
  finds the day in March (Gregorian calendar) of the first
  day of the Jalaali year (jy).

  @param jy Jalaali calendar year (-61 to 3177)
  @param withoutLeap when don't need leap (true or false) default is false
  @return
    leap: number of years since the last leap year (0 to 4)
    gy: Gregorian year of the beginning of Jalaali year
    march: the March day of Farvardin the 1st (1st day of jy)
  @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
  @see: http://www.fourmilab.ch/documents/calendar/
*/
function jalCal(jy, withoutLeap) {
  var bl = breaks.length
    , gy = jy + 621
    , leapJ = -14
    , jp = breaks[0]
    , jm
    , jump
    , leap
    , leapG
    , march
    , n
    , i;

  if (jy < jp || jy >= breaks[bl - 1])
    throw new Error('Invalid Jalaali year ' + jy)

  // Find the limiting years for the Jalaali year jy.
  for (i = 1; i < bl; i += 1) {
    jm = breaks[i];
    jump = jm - jp;
    if (jy < jm)
      break
    leapJ = leapJ + div$1(jump, 33) * 8 + div$1(mod$1(jump, 33), 4);
    jp = jm;
  }
  n = jy - jp;

  // Find the number of leap years from AD 621 to the beginning
  // of the current Jalaali year in the Persian calendar.
  leapJ = leapJ + div$1(n, 33) * 8 + div$1(mod$1(n, 33) + 3, 4);
  if (mod$1(jump, 33) === 4 && jump - n === 4)
    leapJ += 1;

  // And the same in the Gregorian calendar (until the year gy).
  leapG = div$1(gy, 4) - div$1((div$1(gy, 100) + 1) * 3, 4) - 150;

  // Determine the Gregorian date of Farvardin the 1st.
  march = 20 + leapJ - leapG;

  // return with gy and march when we don't need leap
  if (withoutLeap) return { gy: gy, march: march };


  // Find how many years have passed since the last leap year.
  if (jump - n < 6)
    n = n - jump + div$1(jump + 4, 33) * 33;
  leap = mod$1(mod$1(n + 1, 33) - 1, 4);
  if (leap === -1) {
    leap = 4;
  }

  return  { leap: leap
          , gy: gy
          , march: march
          }
}

/*
  Converts a date of the Jalaali calendar to the Julian Day number.

  @param jy Jalaali year (1 to 3100)
  @param jm Jalaali month (1 to 12)
  @param jd Jalaali day (1 to 29/31)
  @return Julian Day number
*/
function j2d(jy, jm, jd) {
  var r = jalCal(jy, true);
  return g2d(r.gy, 3, r.march) + (jm - 1) * 31 - div$1(jm, 7) * (jm - 7) + jd - 1
}

/*
  Converts the Julian Day number to a date in the Jalaali calendar.

  @param jdn Julian Day number
  @return
    jy: Jalaali year (1 to 3100)
    jm: Jalaali month (1 to 12)
    jd: Jalaali day (1 to 29/31)
*/
function d2j(jdn) {
  var gy = d2g(jdn).gy // Calculate Gregorian year (gy).
    , jy = gy - 621
    , r = jalCal(jy, false)
    , jdn1f = g2d(gy, 3, r.march)
    , jd
    , jm
    , k;

  // Find number of days that passed since 1 Farvardin.
  k = jdn - jdn1f;
  if (k >= 0) {
    if (k <= 185) {
      // The first 6 months.
      jm = 1 + div$1(k, 31);
      jd = mod$1(k, 31) + 1;
      return  { jy: jy
              , jm: jm
              , jd: jd
              }
    } else {
      // The remaining months.
      k -= 186;
    }
  } else {
    // Previous Jalaali year.
    jy -= 1;
    k += 179;
    if (r.leap === 1)
      k += 1;
  }
  jm = 7 + div$1(k, 30);
  jd = mod$1(k, 30) + 1;
  return  { jy: jy
          , jm: jm
          , jd: jd
          }
}

/*
  Calculates the Julian Day number from Gregorian or Julian
  calendar dates. This integer number corresponds to the noon of
  the date (i.e. 12 hours of Universal Time).
  The procedure was tested to be good since 1 March, -100100 (of both
  calendars) up to a few million years into the future.

  @param gy Calendar year (years BC numbered 0, -1, -2, ...)
  @param gm Calendar month (1 to 12)
  @param gd Calendar day of the month (1 to 28/29/30/31)
  @return Julian Day number
*/
function g2d(gy, gm, gd) {
  var d = div$1((gy + div$1(gm - 8, 6) + 100100) * 1461, 4)
      + div$1(153 * mod$1(gm + 9, 12) + 2, 5)
      + gd - 34840408;
  d = d - div$1(div$1(gy + 100100 + div$1(gm - 8, 6), 100) * 3, 4) + 752;
  return d
}

/*
  Calculates Gregorian and Julian calendar dates from the Julian Day number
  (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
  calendars) to some millions years ahead of the present.

  @param jdn Julian Day number
  @return
    gy: Calendar year (years BC numbered 0, -1, -2, ...)
    gm: Calendar month (1 to 12)
    gd: Calendar day of the month M (1 to 28/29/30/31)
*/
function d2g(jdn) {
  var j
    , i
    , gd
    , gm
    , gy;
  j = 4 * jdn + 139361631;
  j = j + div$1(div$1(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
  i = div$1(mod$1(j, 1461), 4) * 5 + 308;
  gd = div$1(mod$1(i, 153), 5) + 1;
  gm = mod$1(div$1(i, 153), 12) + 1;
  gy = div$1(j, 1461) - 100100 + div$1(8 - gm, 6);
  return  { gy: gy
          , gm: gm
          , gd: gd
          }
}

/**
 * Return Saturday and Friday day of current week(week start in Saturday)
 * @param {number} jy jalaali year
 * @param {number} jm jalaali month
 * @param {number} jd jalaali day
 * @returns Saturday and Friday of current week
 */
function jalaaliWeek(jy, jm, jd) {
  var dayOfWeek = jalaaliToDateObject(jy, jm, jd).getDay();

  var startDayDifference = dayOfWeek == 6 ? 0 : -(dayOfWeek+1);
  var endDayDifference = 6+startDayDifference;

  return {
    saturday: d2j(j2d(jy, jm, jd+startDayDifference)),
    friday: d2j(j2d(jy, jm, jd+endDayDifference))
  }
}

/**
 * Convert Jalaali calendar dates to javascript Date object
 * @param {number} jy jalaali year
 * @param {number} jm jalaali month
 * @param {number} jd jalaali day
 * @param {number} [h] hours
 * @param {number} [m] minutes
 * @param {number} [s] seconds
 * @param {number} [ms] milliseconds
 * @returns Date object of the jalaali calendar dates
 */
function jalaaliToDateObject(
  jy,
  jm,
  jd,
  h,
  m,
  s,
  ms
) {
  var gregorianCalenderDate = toGregorian$1(jy, jm, jd);

  return new Date(
    gregorianCalenderDate.gy,
    gregorianCalenderDate.gm - 1,
    gregorianCalenderDate.gd,
    h || 0,
    m || 0,
    s || 0,
    ms || 0
  );
}

/*
  Utility helper functions.
*/

function div$1(a, b) {
  return ~~(a / b)
}

function mod$1(a, b) {
  return a - ~~(a / b) * b
}

var momentJalaali = jMoment;

var moment = requireMoment()
  , jalaali = jalaaliJs;

/************************************
    Constants
************************************/

var formattingTokens = /(\[[^\[]*\])|(\\)?j(Mo|MM?M?M?|Do|DDDo|DD?D?D?|w[o|w]?|YYYYY|YYYY|YY|gg(ggg?)?|)|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|SS?S?|X|zz?|ZZ?|.)/g
  , localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS?|LL?L?L?|l{1,4})/g

  , parseTokenOneOrTwoDigits = /\d\d?/
  , parseTokenOneToThreeDigits = /\d{1,3}/
  , parseTokenThreeDigits = /\d{3}/
  , parseTokenFourDigits = /\d{1,4}/
  , parseTokenSixDigits = /[+\-]?\d{1,6}/
  , parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i
  , parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/i
  , parseTokenT = /T/i
  , parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/
  , symbolMap$1 = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
  }
  , numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  }


  , unitAliases =
    { jm: 'jmonth'
    , jmonths: 'jmonth'
    , jy: 'jyear'
    , jyears: 'jyear'
    }

  , formatFunctions = {}

  , ordinalizeTokens = 'DDD w M D'.split(' ')
  , paddedTokens = 'M D w'.split(' ')

  , formatTokenFunctions =
    { jM: function () {
        return this.jMonth() + 1
      }
    , jMMM: function (format) {
        return this.localeData().jMonthsShort(this, format)
      }
    , jMMMM: function (format) {
        return this.localeData().jMonths(this, format)
      }
    , jD: function () {
        return this.jDate()
      }
    , jDDD: function () {
        return this.jDayOfYear()
      }
    , jw: function () {
        return this.jWeek()
      }
    , jYY: function () {
        return leftZeroFill(this.jYear() % 100, 2)
      }
    , jYYYY: function () {
        return leftZeroFill(this.jYear(), 4)
      }
    , jYYYYY: function () {
        return leftZeroFill(this.jYear(), 5)
      }
    , jgg: function () {
        return leftZeroFill(this.jWeekYear() % 100, 2)
      }
    , jgggg: function () {
        return this.jWeekYear()
      }
    , jggggg: function () {
        return leftZeroFill(this.jWeekYear(), 5)
      }
    };

function padToken(func, count) {
  return function (a) {
    return leftZeroFill(func.call(this, a), count)
  }
}
function ordinalizeToken(func, period) {
  return function (a) {
    return this.localeData().ordinal(func.call(this, a), period)
  }
}

(function () {
  var i;
  while (ordinalizeTokens.length) {
    i = ordinalizeTokens.pop();
    formatTokenFunctions['j' + i + 'o'] = ordinalizeToken(formatTokenFunctions['j' + i], i);
  }
  while (paddedTokens.length) {
    i = paddedTokens.pop();
    formatTokenFunctions['j' + i + i] = padToken(formatTokenFunctions['j' + i], 2);
  }
  formatTokenFunctions.jDDDD = padToken(formatTokenFunctions.jDDD, 3);
}());

/************************************
    Helpers
************************************/

function extend(a, b) {
  var key;
  for (key in b)
    if (b.hasOwnProperty(key))
      a[key] = b[key];
  return a
}

function leftZeroFill(number, targetLength) {
  var output = number + '';
  while (output.length < targetLength)
    output = '0' + output;
  return output
}

function isArray(input) {
  return Object.prototype.toString.call(input) === '[object Array]'
}

// function compareArrays(array1, array2) {
//   var len = Math.min(array1.length, array2.length)
//     , lengthDiff = Math.abs(array1.length - array2.length)
//     , diffs = 0
//     , i
//   for (i = 0; i < len; i += 1)
//     if (~~array1[i] !== ~~array2[i])
//       diffs += 1
//   return diffs + lengthDiff
// }

function normalizeUnits(units) {
  if (units) {
    var lowered = units.toLowerCase();
    units = unitAliases[lowered] || lowered;
  }
  return units
}

function setDate(m, year, month, date) {
  var d = m._d;
  if (isNaN(year)) {
    m._isValid = false;
  }
  if (m._isUTC) {
    /*eslint-disable new-cap*/
    m._d = new Date(Date.UTC(year, month, date,
        d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()));
    /*eslint-enable new-cap*/
  } else {
    m._d = new Date(year, month, date,
        d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
  }
}

function objectCreate(parent) {
  function F() {}
  F.prototype = parent;
  return new F()
}

function getPrototypeOf(object) {
  if (Object.getPrototypeOf)
    return Object.getPrototypeOf(object)
  else if (''.__proto__)
    return object.__proto__
  else
    return object.constructor.prototype
}

/************************************
    Languages
************************************/
extend(getPrototypeOf(moment.localeData()),
  { _jMonths: [ 'Farvardin'
              , 'Ordibehesht'
              , 'Khordaad'
              , 'Tir'
              , 'Amordaad'
              , 'Shahrivar'
              , 'Mehr'
              , 'Aabaan'
              , 'Aazar'
              , 'Dey'
              , 'Bahman'
              , 'Esfand'
              ]
  , jMonths: function (m) {
      return this._jMonths[m.jMonth()]
    }

  , _jMonthsShort:  [ 'Far'
                    , 'Ord'
                    , 'Kho'
                    , 'Tir'
                    , 'Amo'
                    , 'Sha'
                    , 'Meh'
                    , 'Aab'
                    , 'Aaz'
                    , 'Dey'
                    , 'Bah'
                    , 'Esf'
                    ]
  , jMonthsShort: function (m) {
      return this._jMonthsShort[m.jMonth()]
    }

  , jMonthsParse: function (monthName) {
      var i
        , mom
        , regex;
      if (!this._jMonthsParse)
        this._jMonthsParse = [];
      for (i = 0; i < 12; i += 1) {
        // Make the regex if we don't have it already.
        if (!this._jMonthsParse[i]) {
          mom = jMoment([2000, (2 + i) % 12, 25]);
          regex = '^' + this.jMonths(mom, '') + '|^' + this.jMonthsShort(mom, '');
          this._jMonthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // Test the regex.
        if (this._jMonthsParse[i].test(monthName))
          return i
      }
    }
  }
);

/************************************
    Formatting
************************************/

function makeFormatFunction(format) {
  var array = format.match(formattingTokens)
    , length = array.length
    , i;

  for (i = 0; i < length; i += 1)
    if (formatTokenFunctions[array[i]])
      array[i] = formatTokenFunctions[array[i]];

  return function (mom) {
    var output = '';
    for (i = 0; i < length; i += 1)
      output += array[i] instanceof Function ? '[' + array[i].call(mom, format) + ']' : array[i];
    return output
  }
}

/************************************
    Parsing
************************************/

function getParseRegexForToken(token, config) {
  switch (token) {
  case 'jDDDD':
    return parseTokenThreeDigits
  case 'jYYYY':
    return parseTokenFourDigits
  case 'jYYYYY':
    return parseTokenSixDigits
  case 'jDDD':
    return parseTokenOneToThreeDigits
  case 'jMMM':
  case 'jMMMM':
    return parseTokenWord
  case 'jMM':
  case 'jDD':
  case 'jYY':
  case 'jM':
  case 'jD':
    return parseTokenOneOrTwoDigits
  case 'DDDD':
    return parseTokenThreeDigits
  case 'YYYY':
    return parseTokenFourDigits
  case 'YYYYY':
    return parseTokenSixDigits
  case 'S':
  case 'SS':
  case 'SSS':
  case 'DDD':
    return parseTokenOneToThreeDigits
  case 'MMM':
  case 'MMMM':
  case 'dd':
  case 'ddd':
  case 'dddd':
    return parseTokenWord
  case 'a':
  case 'A':
    return moment.localeData(config._l)._meridiemParse
  case 'X':
    return parseTokenTimestampMs
  case 'Z':
  case 'ZZ':
    return parseTokenTimezone
  case 'T':
    return parseTokenT
  case 'MM':
  case 'DD':
  case 'YY':
  case 'HH':
  case 'hh':
  case 'mm':
  case 'ss':
  case 'M':
  case 'D':
  case 'd':
  case 'H':
  case 'h':
  case 'm':
  case 's':
    return parseTokenOneOrTwoDigits
  default:
    return new RegExp(token.replace('\\', ''))
  }
}

function addTimeToArrayFromToken(token, input, config) {
  var a
    , datePartArray = config._a;

  switch (token) {
  case 'jM':
  case 'jMM':
    datePartArray[1] = input == null ? 0 : ~~input - 1;
    break
  case 'jMMM':
  case 'jMMMM':
    a = moment.localeData(config._l).jMonthsParse(input);
    if (a != null)
      datePartArray[1] = a;
    else
      config._isValid = false;
    break
  case 'jD':
  case 'jDD':
  case 'jDDD':
  case 'jDDDD':
    if (input != null)
      datePartArray[2] = ~~input;
    break
  case 'jYY':
    datePartArray[0] = ~~input + (~~input > 47 ? 1300 : 1400);
    break
  case 'jYYYY':
  case 'jYYYYY':
    datePartArray[0] = ~~input;
  }
  if (input == null)
    config._isValid = false;
}

function dateFromArray(config) {
  var g
    , j
    , jy = config._a[0]
    , jm = config._a[1]
    , jd = config._a[2];

  if ((jy == null) && (jm == null) && (jd == null))
    return [0, 0, 1]
  jy = jy != null ? jy : 0;
  jm = jm != null ? jm : 0;
  jd = jd != null ? jd : 1;
  if (jd < 1 || jd > jMoment.jDaysInMonth(jy, jm) || jm < 0 || jm > 11)
    config._isValid = false;
  g = toGregorian(jy, jm, jd);
  j = toJalaali(g.gy, g.gm, g.gd);
  if (isNaN(g.gy))
    config._isValid = false;
  config._jDiff = 0;
  if (~~j.jy !== jy)
    config._jDiff += 1;
  if (~~j.jm !== jm)
    config._jDiff += 1;
  if (~~j.jd !== jd)
    config._jDiff += 1;
  return [g.gy, g.gm, g.gd]
}

function makeDateFromStringAndFormat(config) {
  var tokens = config._f.match(formattingTokens)
    , string = config._i + ''
    , len = tokens.length
    , i
    , token
    , parsedInput;

  config._a = [];

  for (i = 0; i < len; i += 1) {
    token = tokens[i];
    parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];
    if (parsedInput)
      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
    if (formatTokenFunctions[token])
      addTimeToArrayFromToken(token, parsedInput, config);
  }
  if (string)
    config._il = string;
  return dateFromArray(config)
}

function makeDateFromStringAndArray(config, utc) {
  var len = config._f.length
    , i
    , format
    , tempMoment
    , bestMoment
    , currentScore
    , scoreToBeat;

  if (len === 0) {
    return makeMoment(new Date(NaN))
  }

  for (i = 0; i < len; i += 1) {
    format = config._f[i];
    currentScore = 0;
    tempMoment = makeMoment(config._i, format, config._l, config._strict, utc);

    if (!tempMoment.isValid()) continue

    // currentScore = compareArrays(tempMoment._a, tempMoment.toArray())
    currentScore += tempMoment._jDiff;
    if (tempMoment._il)
      currentScore += tempMoment._il.length;
    if (scoreToBeat == null || currentScore < scoreToBeat) {
      scoreToBeat = currentScore;
      bestMoment = tempMoment;
    }
  }

  return bestMoment
}

function removeParsedTokens(config) {
  var string = config._i + ''
    , input = ''
    , format = ''
    , array = config._f.match(formattingTokens)
    , len = array.length
    , i
    , match
    , parsed;

  for (i = 0; i < len; i += 1) {
    match = array[i];
    parsed = (getParseRegexForToken(match, config).exec(string) || [])[0];
    if (parsed)
      string = string.slice(string.indexOf(parsed) + parsed.length);
    if (!(formatTokenFunctions[match] instanceof Function)) {
      format += match;
      if (parsed)
        input += parsed;
    }
  }
  config._i = input;
  config._f = format;
}

/************************************
    Week of Year
************************************/

function jWeekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
  var end = firstDayOfWeekOfYear - firstDayOfWeek
    , daysToDayOfWeek = firstDayOfWeekOfYear - mom.day()
    , adjustedMoment;

  if (daysToDayOfWeek > end) {
    daysToDayOfWeek -= 7;
  }
  if (daysToDayOfWeek < end - 7) {
    daysToDayOfWeek += 7;
  }
  adjustedMoment = jMoment(mom).add(daysToDayOfWeek, 'd');
  return  { week: Math.ceil(adjustedMoment.jDayOfYear() / 7)
          , year: adjustedMoment.jYear()
          }
}

/************************************
    Top Level Functions
************************************/
var maxTimestamp = 57724432199999;

function makeMoment(input, format, lang, strict, utc) {
  if (typeof lang === 'boolean') {
    strict = lang;
    lang = undefined;
  }

  if (format && typeof format === 'string')
    format = fixFormat(format, moment);

  var config =
      { _i: input
      , _f: format
      , _l: lang
      , _strict: strict
      , _isUTC: utc
      }
    , date
    , m
    , jm
    , origInput = input
    , origFormat = format;
  if (format) {
    if (isArray(format)) {
      return makeDateFromStringAndArray(config, utc)
    } else {
      date = makeDateFromStringAndFormat(config);
      removeParsedTokens(config);
      format = 'YYYY-MM-DD-' + config._f;
      input = leftZeroFill(date[0], 4) + '-'
            + leftZeroFill(date[1] + 1, 2) + '-'
            + leftZeroFill(date[2], 2) + '-'
            + config._i;
    }
  }
  if (utc)
    m = moment.utc(input, format, lang, strict);
  else
    m = moment(input, format, lang, strict);
  if (config._isValid === false)
    m._isValid = false;
  m._jDiff = config._jDiff || 0;
  jm = objectCreate(jMoment.fn);
  extend(jm, m);
  if (strict && format && jm.isValid()) {
    jm._isValid = jm.format(origFormat) === origInput;
  }
  if (m._d.getTime() > maxTimestamp) {
    jm._isValid = false;
  }
  return jm
}

function jMoment(input, format, lang, strict) {
  return makeMoment(input, format, lang, strict, false)
}

extend(jMoment, moment);
jMoment.fn = objectCreate(moment.fn);

jMoment.utc = function (input, format, lang, strict) {
  return makeMoment(input, format, lang, strict, true)
};

jMoment.unix = function (input) {
  return makeMoment(input * 1000)
};

/************************************
    jMoment Prototype
************************************/

function fixFormat(format, _moment) {
  var i = 5;
  var replace = function (input) {
    return _moment.localeData().longDateFormat(input) || input
  };
  while (i > 0 && localFormattingTokens.test(format)) {
    i -= 1;
    format = format.replace(localFormattingTokens, replace);
  }
  return format
}

jMoment.fn.format = function (format) {

  if (format) {
    format = fixFormat(format, this);

    if (!formatFunctions[format]) {
      formatFunctions[format] = makeFormatFunction(format);
    }
    format = formatFunctions[format](this);
  }
  return moment.fn.format.call(this, format)
};

jMoment.fn.jYear = function (input) {
  var lastDay
    , j
    , g;
  if (typeof input === 'number') {
    j = toJalaali(this.year(), this.month(), this.date());
    lastDay = Math.min(j.jd, jMoment.jDaysInMonth(input, j.jm));
    g = toGregorian(input, j.jm, lastDay);
    setDate(this, g.gy, g.gm, g.gd);
    moment.updateOffset(this);
    return this
  } else {
    return toJalaali(this.year(), this.month(), this.date()).jy
  }
};

jMoment.fn.jMonth = function (input) {
  var lastDay
    , j
    , g;
  if (input != null) {
    if (typeof input === 'string') {
      input = this.localeData().jMonthsParse(input);
      if (typeof input !== 'number')
        return this
    }
    j = toJalaali(this.year(), this.month(), this.date());
    lastDay = Math.min(j.jd, jMoment.jDaysInMonth(j.jy, input));
    this.jYear(j.jy + div(input, 12));
    input = mod(input, 12);
    if (input < 0) {
      input += 12;
      this.jYear(this.jYear() - 1);
    }
    g = toGregorian(this.jYear(), input, lastDay);
    setDate(this, g.gy, g.gm, g.gd);
    moment.updateOffset(this);
    return this
  } else {
    return toJalaali(this.year(), this.month(), this.date()).jm
  }
};

jMoment.fn.jDate = function (input) {
  var j
    , g;
  if (typeof input === 'number') {
    j = toJalaali(this.year(), this.month(), this.date());
    g = toGregorian(j.jy, j.jm, input);
    setDate(this, g.gy, g.gm, g.gd);
    moment.updateOffset(this);
    return this
  } else {
    return toJalaali(this.year(), this.month(), this.date()).jd
  }
};

jMoment.fn.jDayOfYear = function (input) {
  var dayOfYear = Math.round((jMoment(this).startOf('day') - jMoment(this).startOf('jYear')) / 864e5) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, 'd')
};

jMoment.fn.jWeek = function (input) {
  var week = jWeekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).week;
  return input == null ? week : this.add((input - week) * 7, 'd')
};

jMoment.fn.jWeekYear = function (input) {
  var year = jWeekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
  return input == null ? year : this.add(input - year, 'y')
};

jMoment.fn.add = function (val, units) {
  var temp;
  if (units !== null && !isNaN(+units)) {
    temp = val;
    val = units;
    units = temp;
  }
  units = normalizeUnits(units);
  if (units === 'jyear') {
    this.jYear(this.jYear() + val);
  } else if (units === 'jmonth') {
    this.jMonth(this.jMonth() + val);
  } else {
    moment.fn.add.call(this, val, units);
    if (isNaN(this.jYear())) {
      this._isValid = false;
    }
  }
  return this
};

jMoment.fn.subtract = function (val, units) {
  var temp;
  if (units !== null && !isNaN(+units)) {
    temp = val;
    val = units;
    units = temp;
  }
  units = normalizeUnits(units);
  if (units === 'jyear') {
    this.jYear(this.jYear() - val);
  } else if (units === 'jmonth') {
    this.jMonth(this.jMonth() - val);
  } else {
    moment.fn.subtract.call(this, val, units);
  }
  return this
};

jMoment.fn.startOf = function (units) {
  units = normalizeUnits(units);
  if (units === 'jyear' || units === 'jmonth') {
    if (units === 'jyear') {
      this.jMonth(0);
    }
    this.jDate(1);
    this.hours(0);
    this.minutes(0);
    this.seconds(0);
    this.milliseconds(0);
    return this
  } else {
    return moment.fn.startOf.call(this, units)
  }
};

jMoment.fn.endOf = function (units) {
  units = normalizeUnits(units);
  if (units === undefined || units === 'milisecond') {
    return this
  }
  return this.startOf(units).add(1, (units === 'isoweek' ? 'week' : units)).subtract(1, 'ms')
};

jMoment.fn.isSame = function (other, units) {
  units = normalizeUnits(units);
  if (units === 'jyear' || units === 'jmonth') {
    return moment.fn.isSame.call(this.startOf(units), other.startOf(units))
  }
  return moment.fn.isSame.call(this, other, units)
};

jMoment.fn.clone = function () {
  return jMoment(this)
};

jMoment.fn.jYears = jMoment.fn.jYear;
jMoment.fn.jMonths = jMoment.fn.jMonth;
jMoment.fn.jDates = jMoment.fn.jDate;
jMoment.fn.jWeeks = jMoment.fn.jWeek;

/************************************
    jMoment Statics
************************************/

jMoment.jDaysInMonth = function (year, month) {
  year += div(month, 12);
  month = mod(month, 12);
  if (month < 0) {
    month += 12;
    year -= 1;
  }
  if (month < 6) {
    return 31
  } else if (month < 11) {
    return 30
  } else if (jMoment.jIsLeapYear(year)) {
    return 30
  } else {
    return 29
  }
};

jMoment.jIsLeapYear = jalaali.isLeapJalaaliYear;

jMoment.loadPersian = function (args) {
  var usePersianDigits =  args !== undefined && args.hasOwnProperty('usePersianDigits') ? args.usePersianDigits : false;
  var dialect =  args !== undefined && args.hasOwnProperty('dialect') ? args.dialect : 'persian';
  moment.locale('fa');
  moment.updateLocale('fa'
  , { months: ('___________').split('_')
    , monthsShort: ('___________').split('_')
    , weekdays:
      {
        'persian': ('\u200c__\u200c__\u200c__').split('_'),
        'persian-modern': ('\u200c__\u200c__\u200c__').split('_')
      }[dialect]
    , weekdaysShort:
      {
        'persian': ('\u200c__\u200c__\u200c__').split('_'),
        'persian-modern': ('\u200c__\u200c__\u200c__').split('_')
      }[dialect]
    , weekdaysMin:
      {
        'persian': '______'.split('_'),
        'persian-modern': '______'.split('_')
      }[dialect]
    , longDateFormat:
      { LT: 'HH:mm'
      , L: 'jYYYY/jMM/jDD'
      , LL: 'jD jMMMM jYYYY'
      , LLL: 'jD jMMMM jYYYY LT'
      , LLLL: 'dddd jD jMMMM jYYYY LT'
      }
    , calendar:
      { sameDay: '[ ] LT'
      , nextDay: '[ ] LT'
      , nextWeek: 'dddd [] LT'
      , lastDay: '[ ] LT'
      , lastWeek: 'dddd [  ] LT'
      , sameElse: 'L'
      }
    , relativeTime:
      { future: ' %s'
      , past: '%s '
      , s: ' '
      , m: '1 '
      , mm: '%d '
      , h: '1 '
      , hh: '%d '
      , d: '1 '
      , dd: '%d '
      , M: '1 '
      , MM: '%d '
      , y: '1 '
      , yy: '%d '
      }
    , preparse: function (string) {
        if (usePersianDigits) {
          return string.replace(/[-]/g, function (match) {
            return numberMap[match]
          }).replace(//g, ',')
        }
        return string
    }
    , postformat: function (string) {
        if (usePersianDigits) {
          return string.replace(/\d/g, function (match) {
            return symbolMap$1[match]
          }).replace(/,/g, '')
        }
        return string
    }
    , ordinal: '%d'
    , week:
      { dow: 6 // Saturday is the first day of the week.
      , doy: 12 // The week that contains Jan 1st is the first week of the year.
      }
    , meridiem: function (hour) {
        return hour < 12 ? '.' : '.'
      }
    , jMonths:
      {
        'persian': ('___________').split('_'),
        'persian-modern': ('___________').split('_')
      }[dialect]
    , jMonthsShort:
      {
        'persian': '___________'.split('_'),
        'persian-modern': '___________'.split('_')
      }[dialect]
    }
  );
};

jMoment.jConvert =  { toJalaali: toJalaali
                    , toGregorian: toGregorian
                    };

/************************************
    Jalaali Conversion
************************************/

function toJalaali(gy, gm, gd) {
  try {
    var j = jalaali.toJalaali(gy, gm + 1, gd);
    j.jm -= 1;
    return j
  } catch (e) {
    return {
      jy: NaN
      , jm: NaN
      , jd: NaN
    }
  }
}

function toGregorian(jy, jm, jd) {
  try {
    var g = jalaali.toGregorian(jy, jm + 1, jd);
    g.gm -= 1;
    return g
  } catch (e) {
    return {
      gy: NaN
      , gm: NaN
      , gd: NaN
    }
  }
}

/*
  Utility helper functions.
*/

function div(a, b) {
  return ~~(a / b)
}

function mod(a, b) {
  return a - ~~(a / b) * b
}

var symbolMap = {
    1: "",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: "",
    0: "",
};
var defaultFormats = {
    dayOfMonth: "jD",
    fullDate: "jYYYY, jMMMM Do",
    fullDateWithWeekday: "dddd Do jMMMM jYYYY",
    fullDateTime: "jYYYY, jMMMM Do, hh:mm A",
    fullDateTime12h: "jD jMMMM hh:mm A",
    fullDateTime24h: "jD jMMMM HH:mm",
    fullTime: "LT",
    fullTime12h: "hh:mm A",
    fullTime24h: "HH:mm",
    hours12h: "hh",
    hours24h: "HH",
    keyboardDate: "jYYYY/jMM/jDD",
    keyboardDateTime: "jYYYY/jMM/jDD LT",
    keyboardDateTime12h: "jYYYY/jMM/jDD hh:mm A",
    keyboardDateTime24h: "jYYYY/jMM/jDD HH:mm",
    minutes: "mm",
    month: "jMMMM",
    monthAndDate: "jD jMMMM",
    monthAndYear: "jMMMM jYYYY",
    monthShort: "jMMM",
    weekday: "dddd",
    weekdayShort: "ddd",
    normalDate: "dddd, jD jMMM",
    normalDateWithWeekday: "DD MMMM",
    seconds: "ss",
    shortDate: "jD jMMM",
    year: "jYYYY",
};
var MomentUtils = /** @class */ (function (_super) {
    __extends(MomentUtils, _super);
    function MomentUtils(_a) {
        var _b = _a === void 0 ? {} : _a, formats = _b.formats, instance = _b.instance;
        var _this = _super.call(this, { locale: "fa", instance: instance }) || this;
        _this.lib = "moment-jalaali";
        _this.toJMoment = function (date) {
            return _this.moment(date ? date.clone() : undefined).locale("fa");
        };
        _this.parse = function (value, format) {
            if (value === "") {
                return null;
            }
            return _this.moment(value, format, true).locale("fa");
        };
        _this.date = function (value) {
            if (value === null) {
                return null;
            }
            return _this.moment(value).locale("fa");
        };
        _this.isBeforeYear = function (date, value) {
            return date.jYear() < value.jYear();
        };
        _this.isAfterYear = function (date, value) {
            return date.jYear() > value.jYear();
        };
        _this.getMonth = function (date) {
            return date.jMonth();
        };
        _this.getDaysInMonth = function (date) {
            return date.daysInMonth();
        };
        _this.startOfYear = function (date) {
            return date.clone().startOf("jYear");
        };
        _this.endOfYear = function (date) {
            return date.clone().endOf("jYear");
        };
        _this.startOfMonth = function (date) {
            return date.clone().startOf("jMonth");
        };
        _this.endOfMonth = function (date) {
            return date.clone().endOf("jMonth");
        };
        _this.getNextMonth = function (date) {
            return date.clone().add(1, "jMonth");
        };
        _this.getPreviousMonth = function (date) {
            return date.clone().subtract(1, "jMonth");
        };
        _this.getYear = function (date) {
            return date.jYear();
        };
        _this.setYear = function (date, year) {
            return date.clone().jYear(year);
        };
        _this.getDate = function (date) {
            return date.jDate();
        };
        _this.setDate = function (date, count) {
            return date.clone().jDate(count);
        };
        _this.getMeridiemText = function (ampm) {
            return ampm === "am"
                ? _this.toJMoment().hours(2).format("A")
                : _this.toJMoment().hours(14).format("A");
        };
        _this.getWeekdays = function () {
            return [0, 1, 2, 3, 4, 5, 6].map(function (dayOfWeek) {
                return _this.toJMoment().weekday(dayOfWeek).format("dd");
            });
        };
        _this.isEqual = function (value, comparing) {
            if (value === null && comparing === null) {
                return true;
            }
            return _this.moment(value).isSame(comparing);
        };
        _this.formatNumber = function (num) {
            return num.replace(/\d/g, function (match) { return symbolMap[match]; }).replace(/,/g, "");
        };
        _this.getWeekArray = function (date) {
            var start = date.clone().startOf("jMonth").startOf("week");
            var end = date.clone().endOf("jMonth").endOf("week");
            var count = 0;
            var current = start;
            var nestedWeeks = [];
            while (current.isBefore(end)) {
                var weekNumber = Math.floor(count / 7);
                nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
                nestedWeeks[weekNumber].push(current);
                current = current.clone().add(1, "day");
                count += 1;
            }
            return nestedWeeks;
        };
        _this.getYearRange = function (start, end) {
            var startDate = _this.moment(start).startOf("jYear");
            var endDate = _this.moment(end).endOf("jYear");
            var years = [];
            var current = startDate;
            while (current.isBefore(endDate)) {
                years.push(current);
                current = current.clone().add(1, "jYear");
            }
            return years;
        };
        _this.moment = instance || momentJalaali;
        _this.locale = "fa";
        _this.formats = Object.assign({}, defaultFormats, formats);
        return _this;
    }
    return MomentUtils;
}(MomentUtils$2));

/* eslint-disable class-methods-use-this */
// From https://momentjs.com/docs/#/displaying/format/
const formatTokenMap = {
    // Month
    jM: 'month',
    jMo: 'month',
    jMM: 'month',
    jMMM: { sectionName: 'month', contentType: 'letter' },
    jMMMM: { sectionName: 'month', contentType: 'letter' },
    // Day of Month
    jD: 'day',
    jDo: 'day',
    jDD: 'day',
    // Year
    jY: 'year',
    jYY: 'year',
    jYYYY: 'year',
    jYYYYYY: 'year',
    // AM / PM
    A: 'meridiem',
    a: 'meridiem',
    // Hour
    H: 'hours',
    HH: 'hours',
    h: 'hours',
    hh: 'hours',
    k: 'hours',
    kk: 'hours',
    // Minute
    m: 'minutes',
    mm: 'minutes',
    // Second
    s: 'seconds',
    ss: 'seconds',
};
class AdapterMomentJalaali extends MomentUtils {
    constructor() {
        super(...arguments);
        this.isMUIAdapter = true;
        this.formatTokenMap = formatTokenMap;
        this.escapedCharacters = { start: '[', end: ']' };
        /**
         * The current getFormatHelperText method uses an outdated format parsing logic.
         * We should use this one in the future to support all localized formats.
         */
        this.expandFormat = (format) => {
            // @see https://github.com/moment/moment/blob/develop/src/lib/format/format.js#L6
            const localFormattingTokens = /(\[[^[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})|./g;
            return format
                .match(localFormattingTokens)
                .map((token) => {
                const firstCharacter = token[0];
                if (firstCharacter === 'L' || firstCharacter === ';') {
                    return this.moment
                        .localeData(this.getCurrentLocaleCode())
                        .longDateFormat(token);
                }
                return token;
            })
                .join('')
                .replace('dd', 'jDD'); // Fix for https://github.com/dmtrKovalenko/date-io/pull/632;
        };
        // Redefined here just to show how it can be written using expandFormat
        this.getFormatHelperText = (format) => {
            return this.expandFormat(format)
                .replace(/a/gi, '(a|p)m')
                .replace('jY', 'Y')
                .replace('jM', 'M')
                .replace('jD', 'D')
                .toLocaleLowerCase();
        };
        this.getWeekNumber = (date) => {
            return date.jWeek();
        };
        this.addYears = (date, count) => {
            return count < 0
                ? date.clone().subtract(Math.abs(count), 'jYear')
                : date.clone().add(count, 'jYear');
        };
        this.addMonths = (date, count) => {
            return count < 0
                ? date.clone().subtract(Math.abs(count), 'jMonth')
                : date.clone().add(count, 'jMonth');
        };
        this.isValid = (value) => {
            // We can't to `this.moment(value)` because moment-jalaali looses the invalidity information when creating a new moment object from an existing one
            if (!this.moment.isMoment(value)) {
                return false;
            }
            return value.isValid();
        };
    }
}

function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

var propTypesExports = {};
var propTypes = {
  get exports(){ return propTypesExports; },
  set exports(v){ propTypesExports = v; },
};

var reactIsExports$2 = {};
var reactIs$3 = {
  get exports(){ return reactIsExports$2; },
  set exports(v){ reactIsExports$2 = v; },
};

var reactIs_production_min$2 = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min$2;

function requireReactIs_production_min$2 () {
	if (hasRequiredReactIs_production_min$2) return reactIs_production_min$2;
	hasRequiredReactIs_production_min$2 = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min$2.AsyncMode=l;reactIs_production_min$2.ConcurrentMode=m;reactIs_production_min$2.ContextConsumer=k;reactIs_production_min$2.ContextProvider=h;reactIs_production_min$2.Element=c;reactIs_production_min$2.ForwardRef=n;reactIs_production_min$2.Fragment=e;reactIs_production_min$2.Lazy=t;reactIs_production_min$2.Memo=r;reactIs_production_min$2.Portal=d;
	reactIs_production_min$2.Profiler=g;reactIs_production_min$2.StrictMode=f;reactIs_production_min$2.Suspense=p;reactIs_production_min$2.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min$2.isConcurrentMode=A;reactIs_production_min$2.isContextConsumer=function(a){return z(a)===k};reactIs_production_min$2.isContextProvider=function(a){return z(a)===h};reactIs_production_min$2.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min$2.isForwardRef=function(a){return z(a)===n};reactIs_production_min$2.isFragment=function(a){return z(a)===e};reactIs_production_min$2.isLazy=function(a){return z(a)===t};
	reactIs_production_min$2.isMemo=function(a){return z(a)===r};reactIs_production_min$2.isPortal=function(a){return z(a)===d};reactIs_production_min$2.isProfiler=function(a){return z(a)===g};reactIs_production_min$2.isStrictMode=function(a){return z(a)===f};reactIs_production_min$2.isSuspense=function(a){return z(a)===p};
	reactIs_production_min$2.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min$2.typeOf=z;
	return reactIs_production_min$2;
}

var reactIs_development$2 = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development$2;

function requireReactIs_development$2 () {
	if (hasRequiredReactIs_development$2) return reactIs_development$2;
	hasRequiredReactIs_development$2 = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development$2.AsyncMode = AsyncMode;
	reactIs_development$2.ConcurrentMode = ConcurrentMode;
	reactIs_development$2.ContextConsumer = ContextConsumer;
	reactIs_development$2.ContextProvider = ContextProvider;
	reactIs_development$2.Element = Element;
	reactIs_development$2.ForwardRef = ForwardRef;
	reactIs_development$2.Fragment = Fragment;
	reactIs_development$2.Lazy = Lazy;
	reactIs_development$2.Memo = Memo;
	reactIs_development$2.Portal = Portal;
	reactIs_development$2.Profiler = Profiler;
	reactIs_development$2.StrictMode = StrictMode;
	reactIs_development$2.Suspense = Suspense;
	reactIs_development$2.isAsyncMode = isAsyncMode;
	reactIs_development$2.isConcurrentMode = isConcurrentMode;
	reactIs_development$2.isContextConsumer = isContextConsumer;
	reactIs_development$2.isContextProvider = isContextProvider;
	reactIs_development$2.isElement = isElement;
	reactIs_development$2.isForwardRef = isForwardRef;
	reactIs_development$2.isFragment = isFragment;
	reactIs_development$2.isLazy = isLazy;
	reactIs_development$2.isMemo = isMemo;
	reactIs_development$2.isPortal = isPortal;
	reactIs_development$2.isProfiler = isProfiler;
	reactIs_development$2.isStrictMode = isStrictMode;
	reactIs_development$2.isSuspense = isSuspense;
	reactIs_development$2.isValidElementType = isValidElementType;
	reactIs_development$2.typeOf = typeOf;
	  })();
	}
	return reactIs_development$2;
}

var hasRequiredReactIs;

function requireReactIs () {
	if (hasRequiredReactIs) return reactIsExports$2;
	hasRequiredReactIs = 1;
	(function (module) {

		if (process.env.NODE_ENV === 'production') {
		  module.exports = requireReactIs_production_min$2();
		} else {
		  module.exports = requireReactIs_development$2();
		}
} (reactIs$3));
	return reactIsExports$2;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;

function requireReactPropTypesSecret () {
	if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
	hasRequiredReactPropTypesSecret = 1;

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	ReactPropTypesSecret_1 = ReactPropTypesSecret;
	return ReactPropTypesSecret_1;
}

var has;
var hasRequiredHas;

function requireHas () {
	if (hasRequiredHas) return has;
	hasRequiredHas = 1;
	has = Function.call.bind(Object.prototype.hasOwnProperty);
	return has;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var checkPropTypes_1;
var hasRequiredCheckPropTypes;

function requireCheckPropTypes () {
	if (hasRequiredCheckPropTypes) return checkPropTypes_1;
	hasRequiredCheckPropTypes = 1;

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  var ReactPropTypesSecret = requireReactPropTypesSecret();
	  var loggedTypeFailures = {};
	  var has = requireHas();

	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) { /**/ }
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
	              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          printWarning(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  if (process.env.NODE_ENV !== 'production') {
	    loggedTypeFailures = {};
	  }
	};

	checkPropTypes_1 = checkPropTypes;
	return checkPropTypes_1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;

function requireFactoryWithTypeCheckers () {
	if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
	hasRequiredFactoryWithTypeCheckers = 1;

	var ReactIs = requireReactIs();
	var assign = requireObjectAssign();

	var ReactPropTypesSecret = requireReactPropTypesSecret();
	var has = requireHas();
	var checkPropTypes = requireCheckPropTypes();

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bigint: createPrimitiveTypeChecker('bigint'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message, data) {
	    this.message = message;
	    this.data = data && typeof data === 'object' ? data: {};
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError(
	          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
	          {expectedType: expectedType}
	        );
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!ReactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (arguments.length > 1) {
	          printWarning(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var expectedTypes = [];
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
	        if (checkerResult == null) {
	          return null;
	        }
	        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
	          expectedTypes.push(checkerResult.data.expectedType);
	        }
	      }
	      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function invalidValidatorError(componentName, location, propFullName, key, type) {
	    return new PropTypeError(
	      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
	      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
	    );
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (has(shapeTypes, key) && typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithTypeCheckers;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;

function requireFactoryWithThrowingShims () {
	if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
	hasRequiredFactoryWithThrowingShims = 1;

	var ReactPropTypesSecret = requireReactPropTypesSecret();

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithThrowingShims;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = requireReactIs();

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes.exports = requireFactoryWithThrowingShims()();
}

function chainPropTypes(propType1, propType2) {
  if (process.env.NODE_ENV === 'production') {
    return () => null;
  }
  return function validate(...args) {
    return propType1(...args) || propType2(...args);
  };
}

function isPlainObject(item) {
  return item !== null && typeof item === 'object' && item.constructor === Object;
}
function deepClone(source) {
  if (!isPlainObject(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach(key => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends({}, target) : target;
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach(key => {
      // Avoid prototype pollution
      if (key === '__proto__') {
        return;
      }
      if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {
        // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}

function isClassComponent$1(elementType) {
  // elementType.prototype?.isReactComponent
  const {
    prototype = {}
  } = elementType;
  return Boolean(prototype.isReactComponent);
}
function acceptingRef(props, propName, componentName, location, propFullName) {
  const element = props[propName];
  const safePropName = propFullName || propName;
  if (element == null ||
  // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for Emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window === 'undefined') {
    return null;
  }
  let warningHint;
  const elementType = element.type;
  /**
   * Blacklisting instead of whitelisting
   *
   * Blacklisting will miss some components, such as React.Fragment. Those will at least
   * trigger a warning in React.
   * We can't whitelist because there is no safe way to detect React.forwardRef
   * or class components. "Safe" means there's no public API.
   *
   */
  if (typeof elementType === 'function' && !isClassComponent$1(elementType)) {
    warningHint = 'Did you accidentally use a plain function component for an element instead?';
  }
  if (warningHint !== undefined) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. ` + `Expected an element that can hold a ref. ${warningHint} ` + 'For more information see https://mui.com/r/caveat-with-refs-guide');
  }
  return null;
}
const elementAcceptingRef = chainPropTypes(propTypesExports.element, acceptingRef);
elementAcceptingRef.isRequired = chainPropTypes(propTypesExports.element.isRequired, acceptingRef);
var elementAcceptingRef$1 = elementAcceptingRef;

function isClassComponent(elementType) {
  // elementType.prototype?.isReactComponent
  const {
    prototype = {}
  } = elementType;
  return Boolean(prototype.isReactComponent);
}
function elementTypeAcceptingRef(props, propName, componentName, location, propFullName) {
  const propValue = props[propName];
  const safePropName = propFullName || propName;
  if (propValue == null ||
  // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window === 'undefined') {
    return null;
  }
  let warningHint;

  /**
   * Blacklisting instead of whitelisting
   *
   * Blacklisting will miss some components, such as React.Fragment. Those will at least
   * trigger a warning in React.
   * We can't whitelist because there is no safe way to detect React.forwardRef
   * or class components. "Safe" means there's no public API.
   *
   */
  if (typeof propValue === 'function' && !isClassComponent(propValue)) {
    warningHint = 'Did you accidentally provide a plain function component instead?';
  }
  if (warningHint !== undefined) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. ` + `Expected an element type that can hold a ref. ${warningHint} ` + 'For more information see https://mui.com/r/caveat-with-refs-guide');
  }
  return null;
}
var elementTypeAcceptingRef$1 = chainPropTypes(propTypesExports.elementType, elementTypeAcceptingRef);

// This module is based on https://github.com/airbnb/prop-types-exact repository.
// However, in order to reduce the number of dependencies and to remove some extra safe checks
// the module was forked.

const specialProperty = 'exact-prop: \u200b';
function exactProp(propTypes) {
  if (process.env.NODE_ENV === 'production') {
    return propTypes;
  }
  return _extends({}, propTypes, {
    [specialProperty]: props => {
      const unsupportedProps = Object.keys(props).filter(prop => !propTypes.hasOwnProperty(prop));
      if (unsupportedProps.length > 0) {
        return new Error(`The following props are not supported: ${unsupportedProps.map(prop => `\`${prop}\``).join(', ')}. Please remove them.`);
      }
      return null;
    }
  });
}

/**
 * WARNING: Don't import this directly.
 * Use `MuiError` from `@mui/utils/macros/MuiError.macro` instead.
 * @param {number} code
 */
function formatMuiErrorMessage(code) {
  // Apply babel-plugin-transform-template-literals in loose mode
  // loose mode is safe iff we're concatenating primitives
  // see https://babeljs.io/docs/en/babel-plugin-transform-template-literals#loose
  /* eslint-disable prefer-template */
  let url = 'https://mui.com/production-error/?code=' + code;
  for (let i = 1; i < arguments.length; i += 1) {
    // rest params over-transpile for this case
    // eslint-disable-next-line prefer-rest-params
    url += '&args[]=' + encodeURIComponent(arguments[i]);
  }
  return 'Minified MUI error #' + code + '; visit ' + url + ' for the full message.';
  /* eslint-enable prefer-template */
}

var reactIsExports$1 = {};
var reactIs$2 = {
  get exports(){ return reactIsExports$1; },
  set exports(v){ reactIsExports$1 = v; },
};

var reactIs_production_min$1 = {};

/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min$1;

function requireReactIs_production_min$1 () {
	if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
	hasRequiredReactIs_production_min$1 = 1;
var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");
	function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}reactIs_production_min$1.ContextConsumer=h;reactIs_production_min$1.ContextProvider=g;reactIs_production_min$1.Element=b;reactIs_production_min$1.ForwardRef=l;reactIs_production_min$1.Fragment=d;reactIs_production_min$1.Lazy=q;reactIs_production_min$1.Memo=p;reactIs_production_min$1.Portal=c;reactIs_production_min$1.Profiler=f;reactIs_production_min$1.StrictMode=e;reactIs_production_min$1.Suspense=m;
	reactIs_production_min$1.SuspenseList=n;reactIs_production_min$1.isAsyncMode=function(){return !1};reactIs_production_min$1.isConcurrentMode=function(){return !1};reactIs_production_min$1.isContextConsumer=function(a){return v(a)===h};reactIs_production_min$1.isContextProvider=function(a){return v(a)===g};reactIs_production_min$1.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b};reactIs_production_min$1.isForwardRef=function(a){return v(a)===l};reactIs_production_min$1.isFragment=function(a){return v(a)===d};reactIs_production_min$1.isLazy=function(a){return v(a)===q};reactIs_production_min$1.isMemo=function(a){return v(a)===p};
	reactIs_production_min$1.isPortal=function(a){return v(a)===c};reactIs_production_min$1.isProfiler=function(a){return v(a)===f};reactIs_production_min$1.isStrictMode=function(a){return v(a)===e};reactIs_production_min$1.isSuspense=function(a){return v(a)===m};reactIs_production_min$1.isSuspenseList=function(a){return v(a)===n};
	reactIs_production_min$1.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};reactIs_production_min$1.typeOf=v;
	return reactIs_production_min$1;
}

var reactIs_development$1 = {};

/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development$1;

function requireReactIs_development$1 () {
	if (hasRequiredReactIs_development$1) return reactIs_development$1;
	hasRequiredReactIs_development$1 = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// ATTENTION
	// When adding new symbols to this file,
	// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
	// The Symbol used to tag the ReactElement-like types.
	var REACT_ELEMENT_TYPE = Symbol.for('react.element');
	var REACT_PORTAL_TYPE = Symbol.for('react.portal');
	var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
	var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
	var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
	var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
	var REACT_CONTEXT_TYPE = Symbol.for('react.context');
	var REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');
	var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
	var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
	var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
	var REACT_MEMO_TYPE = Symbol.for('react.memo');
	var REACT_LAZY_TYPE = Symbol.for('react.lazy');
	var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');

	// -----------------------------------------------------------------------------

	var enableScopeAPI = false; // Experimental Create Event Handle API.
	var enableCacheElement = false;
	var enableTransitionTracing = false; // No known bugs, but needs performance testing

	var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
	// stuff. Intended to enable React core members to more easily debug scheduling
	// issues in DEV builds.

	var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

	var REACT_MODULE_REFERENCE;

	{
	  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
	}

	function isValidElementType(type) {
	  if (typeof type === 'string' || typeof type === 'function') {
	    return true;
	  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


	  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
	    return true;
	  }

	  if (typeof type === 'object' && type !== null) {
	    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
	    // types supported by any Flight configuration anywhere since
	    // we don't know which Flight build this will end up being used
	    // with.
	    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
	      return true;
	    }
	  }

	  return false;
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	          case REACT_SUSPENSE_LIST_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_SERVER_CONTEXT_TYPE:
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	}
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false;
	var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
	    }
	  }

	  return false;
	}
	function isConcurrentMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
	      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
	    }
	  }

	  return false;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}
	function isSuspenseList(object) {
	  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
	}

	reactIs_development$1.ContextConsumer = ContextConsumer;
	reactIs_development$1.ContextProvider = ContextProvider;
	reactIs_development$1.Element = Element;
	reactIs_development$1.ForwardRef = ForwardRef;
	reactIs_development$1.Fragment = Fragment;
	reactIs_development$1.Lazy = Lazy;
	reactIs_development$1.Memo = Memo;
	reactIs_development$1.Portal = Portal;
	reactIs_development$1.Profiler = Profiler;
	reactIs_development$1.StrictMode = StrictMode;
	reactIs_development$1.Suspense = Suspense;
	reactIs_development$1.SuspenseList = SuspenseList;
	reactIs_development$1.isAsyncMode = isAsyncMode;
	reactIs_development$1.isConcurrentMode = isConcurrentMode;
	reactIs_development$1.isContextConsumer = isContextConsumer;
	reactIs_development$1.isContextProvider = isContextProvider;
	reactIs_development$1.isElement = isElement;
	reactIs_development$1.isForwardRef = isForwardRef;
	reactIs_development$1.isFragment = isFragment;
	reactIs_development$1.isLazy = isLazy;
	reactIs_development$1.isMemo = isMemo;
	reactIs_development$1.isPortal = isPortal;
	reactIs_development$1.isProfiler = isProfiler;
	reactIs_development$1.isStrictMode = isStrictMode;
	reactIs_development$1.isSuspense = isSuspense;
	reactIs_development$1.isSuspenseList = isSuspenseList;
	reactIs_development$1.isValidElementType = isValidElementType;
	reactIs_development$1.typeOf = typeOf;
	  })();
	}
	return reactIs_development$1;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactIs_production_min$1();
	} else {
	  module.exports = requireReactIs_development$1();
	}
} (reactIs$2));

// Simplified polyfill for IE11 support
// https://github.com/JamesMGreene/Function.name/blob/58b314d4a983110c3682f1228f845d39ccca1817/Function.name.js#L3
const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName(fn) {
  const match = `${fn}`.match(fnNameMatchRegex);
  const name = match && match[1];
  return name || '';
}
function getFunctionComponentName(Component, fallback = '') {
  return Component.displayName || Component.name || getFunctionName(Component) || fallback;
}
function getWrappedName(outerType, innerType, wrapperName) {
  const functionName = getFunctionComponentName(innerType);
  return outerType.displayName || (functionName !== '' ? `${wrapperName}(${functionName})` : wrapperName);
}

/**
 * cherry-pick from
 * https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/getComponentName.js
 * originally forked from recompose/getDisplayName with added IE11 support
 */
function getDisplayName(Component) {
  if (Component == null) {
    return undefined;
  }
  if (typeof Component === 'string') {
    return Component;
  }
  if (typeof Component === 'function') {
    return getFunctionComponentName(Component, 'Component');
  }

  // TypeScript can't have components as objects but they exist in the form of `memo` or `Suspense`
  if (typeof Component === 'object') {
    switch (Component.$$typeof) {
      case reactIsExports$1.ForwardRef:
        return getWrappedName(Component, Component.render, 'ForwardRef');
      case reactIsExports$1.Memo:
        return getWrappedName(Component, Component.type, 'memo');
      default:
        return undefined;
    }
  }
  return undefined;
}

function HTMLElementType(props, propName, componentName, location, propFullName) {
  if (process.env.NODE_ENV === 'production') {
    return null;
  }
  const propValue = props[propName];
  const safePropName = propFullName || propName;
  if (propValue == null) {
    return null;
  }
  if (propValue && propValue.nodeType !== 1) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. ` + `Expected an HTMLElement.`);
  }
  return null;
}

const refType = propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object]);
var refType$1 = refType;

// It should to be noted that this function isn't equivalent to `text-transform: capitalize`.
//
// A strict capitalization should uppercase the first letter of each word in the sentence.
// We only handle the first word.
function capitalize(string) {
  if (typeof string !== 'string') {
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: \`capitalize(string)\` expects a string argument.` : formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 * Safe chained function.
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 */
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {});
}

// Corresponds to 10 frames at 60 Hz.
// A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.
function debounce$1(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}

function isMuiElement(element, muiNames) {
  return /*#__PURE__*/React__namespace.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
}

function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

function ownerWindow(node) {
  const doc = ownerDocument(node);
  return doc.defaultView || window;
}

function requirePropFactory(componentNameInError, Component) {
  if (process.env.NODE_ENV === 'production') {
    return () => null;
  }

  // eslint-disable-next-line react/forbid-foreign-prop-types
  const prevPropTypes = Component ? _extends({}, Component.propTypes) : null;
  const requireProp = requiredProp => (props, propName, componentName, location, propFullName, ...args) => {
    const propFullNameSafe = propFullName || propName;
    const defaultTypeChecker = prevPropTypes == null ? void 0 : prevPropTypes[propFullNameSafe];
    if (defaultTypeChecker) {
      const typeCheckerResult = defaultTypeChecker(props, propName, componentName, location, propFullName, ...args);
      if (typeCheckerResult) {
        return typeCheckerResult;
      }
    }
    if (typeof props[propName] !== 'undefined' && !props[requiredProp]) {
      return new Error(`The prop \`${propFullNameSafe}\` of ` + `\`${componentNameInError}\` can only be used together with the \`${requiredProp}\` prop.`);
    }
    return null;
  };
  return requireProp;
}

/**
 * TODO v5: consider making it private
 *
 * passes {value} to {ref}
 *
 * WARNING: Be sure to only call this inside a callback that is passed as a ref.
 * Otherwise, make sure to cleanup the previous {ref} if it changes. See
 * https://github.com/mui/material-ui/issues/13539
 *
 * Useful if you want to expose the ref of an inner component to the public API
 * while still using it inside the component.
 * @param ref A ref callback or ref object. If anything falsy, this is a no-op.
 */
function setRef$1(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}

const useEnhancedEffect$2 = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;
var useEnhancedEffect$3 = useEnhancedEffect$2;

let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = React__namespace.useState(idOverride);
  const id = idOverride || defaultId;
  React__namespace.useEffect(() => {
    if (defaultId == null) {
      // Fallback to this default id when possible.
      // Use the incrementing value for client-side rendering only.
      // We can't use it server-side.
      // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id;
}

// eslint-disable-next-line no-useless-concat -- Workaround for https://github.com/webpack/webpack/issues/14814
const maybeReactUseId = React__namespace['useId' + ''];
/**
 *
 * @example <div id={useId()} />
 * @param idOverride
 * @returns {string}
 */
function useId(idOverride) {
  if (maybeReactUseId !== undefined) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.
  return useGlobalId(idOverride);
}

function unsupportedProp(props, propName, componentName, location, propFullName) {
  if (process.env.NODE_ENV === 'production') {
    return null;
  }
  const propFullNameSafe = propFullName || propName;
  if (typeof props[propName] !== 'undefined') {
    return new Error(`The prop \`${propFullNameSafe}\` is not supported. Please remove it.`);
  }
  return null;
}

/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */
function useControlled$2({
  controlled,
  default: defaultProp,
  name,
  state = 'value'
}) {
  // isControlled is ignored in the hook dependency lists as it should never change.
  const {
    current: isControlled
  } = React__namespace.useRef(controlled !== undefined);
  const [valueState, setValue] = React__namespace.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  if (process.env.NODE_ENV !== 'production') {
    React__namespace.useEffect(() => {
      if (isControlled !== (controlled !== undefined)) {
        console.error([`MUI: A component is changing the ${isControlled ? '' : 'un'}controlled ${state} state of ${name} to be ${isControlled ? 'un' : ''}controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', `Decide between using a controlled or uncontrolled ${name} ` + 'element for the lifetime of the component.', "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'].join('\n'));
      }
    }, [state, name, controlled]);
    const {
      current: defaultValue
    } = React__namespace.useRef(defaultProp);
    React__namespace.useEffect(() => {
      if (!isControlled && defaultValue !== defaultProp) {
        console.error([`MUI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. ` + `To suppress this warning opt to use a controlled ${name}.`].join('\n'));
      }
    }, [JSON.stringify(defaultProp)]);
  }
  const setValueIfUncontrolled = React__namespace.useCallback(newValue => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}

/**
 * https://github.com/facebook/react/issues/14099#issuecomment-440013892
 */
function useEventCallback$2(fn) {
  const ref = React__namespace.useRef(fn);
  useEnhancedEffect$3(() => {
    ref.current = fn;
  });
  return React__namespace.useCallback((...args) =>
  // @ts-expect-error hide `this`
  // tslint:disable-next-line:ban-comma-operator
  (0, ref.current)(...args), []);
}

function useForkRef$2(...refs) {
  /**
   * This will create a new function if the refs passed to this hook change and are all defined.
   * This means react will call the old forkRef with `null` and the new forkRef
   * with the ref. Cleanup naturally emerges from this behavior.
   */
  return React__namespace.useMemo(() => {
    if (refs.every(ref => ref == null)) {
      return null;
    }
    return instance => {
      refs.forEach(ref => {
        setRef$1(ref, instance);
      });
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, refs);
}

// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
let hadFocusVisibleRecentlyTimeout;
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  'datetime-local': true
};

/**
 * Computes whether the given element should automatically trigger the
 * `focus-visible` class being added, i.e. whether it should always match
 * `:focus-visible` when focused.
 * @param {Element} node
 * @returns {boolean}
 */
function focusTriggersKeyboardModality(node) {
  const {
    type,
    tagName
  } = node;
  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
    return true;
  }
  if (tagName === 'TEXTAREA' && !node.readOnly) {
    return true;
  }
  if (node.isContentEditable) {
    return true;
  }
  return false;
}

/**
 * Keep track of our keyboard modality state with `hadKeyboardEvent`.
 * If the most recent user interaction was via the keyboard;
 * and the key press did not include a meta, alt/option, or control key;
 * then the modality is keyboard. Otherwise, the modality is not keyboard.
 * @param {KeyboardEvent} event
 */
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}

/**
 * If at any point a user clicks with a pointing device, ensure that we change
 * the modality away from keyboard.
 * This avoids the situation where a user presses a key on an already focused
 * element, and then clicks on a different element, focusing it with a
 * pointing device, while we still think we're in keyboard modality.
 */
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === 'hidden') {
    // If the tab becomes active again, the browser will handle calling focus
    // on the element (Safari actually calls it twice).
    // If this tab change caused a blur on an element with focus-visible,
    // re-apply the class when the user switches back to the tab.
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(doc) {
  doc.addEventListener('keydown', handleKeyDown, true);
  doc.addEventListener('mousedown', handlePointerDown, true);
  doc.addEventListener('pointerdown', handlePointerDown, true);
  doc.addEventListener('touchstart', handlePointerDown, true);
  doc.addEventListener('visibilitychange', handleVisibilityChange, true);
}
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(':focus-visible');
  } catch (error) {
    // Browsers not implementing :focus-visible will throw a SyntaxError.
    // We use our own heuristic for those browsers.
    // Rethrow might be better if it's not the expected error but do we really
    // want to crash if focus-visible malfunctioned?
  }

  // No need for validFocusTarget check. The user does that by attaching it to
  // focusable events only.
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  const ref = React__namespace.useCallback(node => {
    if (node != null) {
      prepare(node.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = React__namespace.useRef(false);

  /**
   * Should be called if a blur event is fired
   */
  function handleBlurVisible() {
    // checking against potential state variable does not suffice if we focus and blur synchronously.
    // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.
    // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.
    // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751
    // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).
    if (isFocusVisibleRef.current) {
      // To detect a tab/window switch, we look for a blur event followed
      // rapidly by a visibility change.
      // If we don't see a visibility change within 100ms, it's probably a
      // regular focus change.
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }

  /**
   * Should be called if a blur event is fired
   */
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}

// A change of the browser zoom change the scrollbar size.
// Credit https://github.com/twbs/bootstrap/blob/488fd8afc535ca3a6ad4dc581f5e89217b6a36ac/js/src/util/scrollbar.js#L14-L18
function getScrollbarSize(doc) {
  // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}

// Source from https://github.com/alitaheri/normalize-scroll-left
let cachedType;

/**
 * Based on the jquery plugin https://github.com/othree/jquery.rtl-scroll-type
 *
 * Types of scrollLeft, assuming scrollWidth=100 and direction is rtl.
 *
 * Type             | <- Most Left | Most Right -> | Initial
 * ---------------- | ------------ | ------------- | -------
 * default          | 0            | 100           | 100
 * negative (spec*) | -100         | 0             | 0
 * reverse          | 100          | 0             | 0
 *
 * Edge 85: default
 * Safari 14: negative
 * Chrome 85: negative
 * Firefox 81: negative
 * IE11: reverse
 *
 * spec* https://drafts.csswg.org/cssom-view/#dom-window-scroll
 */
function detectScrollType() {
  if (cachedType) {
    return cachedType;
  }
  const dummy = document.createElement('div');
  const container = document.createElement('div');
  container.style.width = '10px';
  container.style.height = '1px';
  dummy.appendChild(container);
  dummy.dir = 'rtl';
  dummy.style.fontSize = '14px';
  dummy.style.width = '4px';
  dummy.style.height = '1px';
  dummy.style.position = 'absolute';
  dummy.style.top = '-1000px';
  dummy.style.overflow = 'scroll';
  document.body.appendChild(dummy);
  cachedType = 'reverse';
  if (dummy.scrollLeft > 0) {
    cachedType = 'default';
  } else {
    dummy.scrollLeft = 1;
    if (dummy.scrollLeft === 0) {
      cachedType = 'negative';
    }
  }
  document.body.removeChild(dummy);
  return cachedType;
}

// Based on https://stackoverflow.com/a/24394376
function getNormalizedScrollLeft(element, direction) {
  const scrollLeft = element.scrollLeft;

  // Perform the calculations only when direction is rtl to avoid messing up the ltr behavior
  if (direction !== 'rtl') {
    return scrollLeft;
  }
  const type = detectScrollType();
  switch (type) {
    case 'negative':
      return element.scrollWidth - element.clientWidth + scrollLeft;
    case 'reverse':
      return element.scrollWidth - element.clientWidth - scrollLeft;
    default:
      return scrollLeft;
  }
}

function getTypeByValue(value) {
  const valueType = typeof value;
  switch (valueType) {
    case 'number':
      if (Number.isNaN(value)) {
        return 'NaN';
      }
      if (!Number.isFinite(value)) {
        return 'Infinity';
      }
      if (value !== Math.floor(value)) {
        return 'float';
      }
      return 'number';
    case 'object':
      if (value === null) {
        return 'null';
      }
      return value.constructor.name;
    default:
      return valueType;
  }
}

// IE 11 support
function ponyfillIsInteger(x) {
  // eslint-disable-next-line no-restricted-globals
  return typeof x === 'number' && isFinite(x) && Math.floor(x) === x;
}
const isInteger = Number.isInteger || ponyfillIsInteger;
function requiredInteger(props, propName, componentName, location) {
  const propValue = props[propName];
  if (propValue == null || !isInteger(propValue)) {
    const propType = getTypeByValue(propValue);
    return new RangeError(`Invalid ${location} \`${propName}\` of type \`${propType}\` supplied to \`${componentName}\`, expected \`integer\`.`);
  }
  return null;
}
function validator(props, propName, ...other) {
  const propValue = props[propName];
  if (propValue === undefined) {
    return null;
  }
  return requiredInteger(props, propName, ...other);
}
function validatorNoop() {
  return null;
}
validator.isRequired = requiredInteger;
validatorNoop.isRequired = validatorNoop;
var integerPropType = process.env.NODE_ENV === 'production' ? validatorNoop : validator;

/**
 * Add keys, values of `defaultProps` that does not exist in `props`
 * @param {object} defaultProps
 * @param {object} props
 * @returns {object} resolved props
 */
function resolveProps(defaultProps, props) {
  const output = _extends({}, props);
  Object.keys(defaultProps).forEach(propName => {
    if (propName.toString().match(/^(components|slots)$/)) {
      output[propName] = _extends({}, defaultProps[propName], output[propName]);
    } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
      const defaultSlotProps = defaultProps[propName] || {};
      const slotProps = props[propName];
      output[propName] = {};
      if (!slotProps || !Object.keys(slotProps)) {
        // Reduce the iteration if the slot props is empty
        output[propName] = defaultSlotProps;
      } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
        // Reduce the iteration if the default slot props is empty
        output[propName] = slotProps;
      } else {
        output[propName] = _extends({}, slotProps);
        Object.keys(defaultSlotProps).forEach(slotPropName => {
          output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
        });
      }
    } else if (output[propName] === undefined) {
      output[propName] = defaultProps[propName];
    }
  });
  return output;
}

function composeClasses(slots, getUtilityClass, classes) {
  const output = {};
  Object.keys(slots).forEach(
  // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
  // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
  slot => {
    output[slot] = slots[slot].reduce((acc, key) => {
      if (key) {
        acc.push(getUtilityClass(key));
        if (classes && classes[key]) {
          acc.push(classes[key]);
        }
      }
      return acc;
    }, []).join(' ');
  });
  return output;
}

const defaultGenerator = componentName => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
var ClassNameGenerator$1 = ClassNameGenerator;

const globalStateClassesMapping = {
  active: 'active',
  checked: 'checked',
  completed: 'completed',
  disabled: 'disabled',
  error: 'error',
  expanded: 'expanded',
  focused: 'focused',
  focusVisible: 'focusVisible',
  required: 'required',
  selected: 'selected'
};
function generateUtilityClass(componentName, slot, globalStatePrefix = 'Mui') {
  const globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
}

function generateUtilityClasses(componentName, slots, globalStatePrefix = 'Mui') {
  const result = {};
  slots.forEach(slot => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}

function memoize$1(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */memoize$1(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

/*

Based off glamor's StyleSheet, thanks Sunil 

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? process.env.NODE_ENV === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (process.env.NODE_ENV !== 'production') {
      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;

      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
        // this would only cause problem in speedy mode
        // but we don't want enabling speedy to affect the observable behavior
        // so we report this error at all times
        console.error("You're attempting to insert the following rule:\n" + rule + '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
    }

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (process.env.NODE_ENV !== 'production' && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error("There was a problem inserting the following rule: \"" + rule + "\"", e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;

    if (process.env.NODE_ENV !== 'production') {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };

  return StyleSheet;
}();

var MS = '-ms-';
var MOZ = '-moz-';
var WEBKIT = '-webkit-';

var COMMENT = 'comm';
var RULESET = 'rule';
var DECLARATION = 'decl';
var IMPORT = '@import';
var KEYFRAMES = '@keyframes';

/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs;

/**
 * @param {number}
 * @return {string}
 */
var from = String.fromCharCode;

/**
 * @param {object}
 * @return {object}
 */
var assign = Object.assign;

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function hash$2 (value, length) {
	return charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0
}

/**
 * @param {string} value
 * @return {string}
 */
function trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function match (value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */
function indexof (value, search) {
	return value.indexOf(search)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function append (value, array) {
	return array.push(value), value
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function combine (array, callback) {
	return array.map(callback).join('')
}

var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = '';

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
}

/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */
function copy (root, props) {
	return assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
}

/**
 * @return {number}
 */
function char () {
	return character
}

/**
 * @return {number}
 */
function prev () {
	character = position > 0 ? charat(characters, --position) : 0;

	if (column--, character === 10)
		column = 1, line--;

	return character
}

/**
 * @return {number}
 */
function next () {
	character = position < length ? charat(characters, position++) : 0;

	if (column++, character === 10)
		column = 1, line++;

	return character
}

/**
 * @return {number}
 */
function peek () {
	return charat(characters, position)
}

/**
 * @return {number}
 */
function caret () {
	return position
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice (begin, end) {
	return substr(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, length = strlen(characters = value), position = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (character = peek())
		if (character < 33)
			next();
		else
			break

	return token(type) > 2 || token(character) > 3 ? '' : ' '
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && next())
		// not 0-9 A-F a-f
		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
			break

	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (next())
		switch (character) {
			// ] ) " '
			case type:
				return position
			// " '
			case 34: case 39:
				if (type !== 34 && type !== 39)
					delimiter(character);
				break
			// (
			case 40:
				if (type === 41)
					delimiter(type);
				break
			// \
			case 92:
				next();
				break
		}

	return position
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (next())
		// //
		if (type + character === 47 + 10)
			break
		// /*
		else if (type + character === 42 + 42 && peek() === 47)
			break

	return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		next();

	return slice(index, position)
}

/**
 * @param {string} value
 * @return {object[]}
 */
function compile (value) {
	return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0;
	var offset = 0;
	var length = pseudo;
	var atrule = 0;
	var property = 0;
	var previous = 0;
	var variable = 1;
	var scanning = 1;
	var ampersand = 1;
	var character = 0;
	var type = '';
	var props = rules;
	var children = rulesets;
	var reference = rule;
	var characters = type;

	while (scanning)
		switch (previous = character, character = next()) {
			// (
			case 40:
				if (previous != 108 && charat(characters, length - 1) == 58) {
					if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1)
						ampersand = -1;
					break
				}
			// " ' [
			case 34: case 39: case 91:
				characters += delimit(character);
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += whitespace(previous);
				break
			// \
			case 92:
				characters += escaping(caret() - 1, 7);
				continue
			// /
			case 47:
				switch (peek()) {
					case 42: case 47:
						append(comment(commenter(next(), caret()), root, parent), declarations);
						break
					default:
						characters += '/';
				}
				break
			// {
			case 123 * variable:
				points[index++] = strlen(characters) * ampersand;
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0;
					// ;
					case 59 + offset:
						if (property > 0 && (strlen(characters) - length))
							append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
						break
					// @ ;
					case 59: characters += ';';
					// { rule/at-rule
					default:
						append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);

						if (character === 123)
							if (offset === 0)
								parse(characters, root, reference, reference, props, rulesets, length, points, children);
							else
								switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
									// d m s
									case 100: case 109: case 115:
										parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
										break
									default:
										parse(characters, reference, reference, reference, [''], children, 0, points, children);
								}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
				break
			// :
			case 58:
				length = 1 + strlen(characters), property = previous;
			default:
				if (variable < 1)
					if (character == 123)
						--variable;
					else if (character == 125 && variable++ == 0 && prev() == 125)
						continue

				switch (characters += from(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1);
						break
					// ,
					case 44:
						points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
						break
					// @
					case 64:
						// -
						if (peek() === 45)
							characters += delimit(next());

						atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
						break
					// -
					case 45:
						if (previous === 45 && strlen(characters) == 2)
							variable = 0;
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
	var post = offset - 1;
	var rule = offset === 0 ? rules : [''];
	var size = sizeof(rule);

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
			if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
				props[k++] = z;

	return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment (value, root, parent) {
	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration (value, root, parent, length) {
	return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)
}

/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function serialize (children, callback) {
	var output = '';
	var length = sizeof(children);

	for (var i = 0; i < length; i++)
		output += callback(children[i], i, children, callback) || '';

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function stringify (element, index, children, callback) {
	switch (element.type) {
		case IMPORT: case DECLARATION: return element.return = element.return || element.value
		case COMMENT: return ''
		case KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'
		case RULESET: element.value = element.props.join(',');
	}

	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}

/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware (collection) {
	var length = sizeof(collection);

	return function (element, index, children, callback) {
		var output = '';

		for (var i = 0; i < length; i++)
			output += collection[i](element, index, children, callback) || '';

		return output
	}
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet (callback) {
	return function (element) {
		if (!element.root)
			if (element = element.return)
				callback(element);
	}
}

var weakMemoize = function weakMemoize(func) {
  // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
  var cache = new WeakMap();
  return function (arg) {
    if (cache.has(arg)) {
      // $FlowFixMe
      return cache.get(arg);
    }

    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};

var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;

  while (true) {
    previous = character;
    character = peek(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }

    if (token(character)) {
      break;
    }

    next();
  }

  return slice(begin, position);
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (token(character)) {
      case 0:
        // &\f
        if (character === 38 && peek() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;

      case 2:
        parsed[index] += delimit(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = peek() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += from(character);
    }
  } while (character = next());

  return parsed;
};

var getRules = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};
var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

var isIgnoringComment = function isIgnoringComment(element) {
  return element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};

var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule' || cache.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

    if (unsafePseudoClasses) {
      var isNested = element.parent === children[0]; // in nested rules comments become children of the "auto-inserted" rule
      //
      // considering this input:
      // .a {
      //   .b /* comm */ {}
      //   color: hotpink;
      // }
      // we get output corresponding to this:
      // .a {
      //   & {
      //     /* comm */
      //     color: hotpink;
      //   }
      //   .b {}
      // }

      var commentContainer = isNested ? children[0].children : // global rule at the root level
      children;

      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node = commentContainer[i];

        if (node.line < element.line) {
          break;
        } // it is quite weird but comments are *usually* put at `column: element.column - 1`
        // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
        // this will also match inputs like this:
        // .a {
        //   /* comm */
        //   .b {}
        // }
        //
        // but that is fine
        //
        // it would be the easiest to change the placement of the comment to be the first child of the rule:
        // .a {
        //   .b { /* comm */ }
        // }
        // with such inputs we wouldn't have to search for the comment at all
        // TODO: consider changing this comment placement in the next major version


        if (node.column < element.column) {
          if (isIgnoringComment(node)) {
            return;
          }

          break;
        }
      }

      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};

var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};

var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }

  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user


var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};

var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }

  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

/* eslint-disable no-fallthrough */

function prefix(value, length) {
  switch (hash$2(value, length)) {
    // color-adjust
    case 5103:
      return WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust

    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction

    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order

    case 6165:
      return WEBKIT + value + MS + 'flex-' + value + value;
    // align-items

    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
    // align-self

    case 5443:
      return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
    // align-content

    case 4675:
      return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink

    case 5548:
      return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
    // flex-basis

    case 5292:
      return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
    // flex-grow

    case 6060:
      return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
    // transition

    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
    // cursor

    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
    // background, background-image

    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
    // justify-content

    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)

    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)

    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if (charat(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content

        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch

        case 115:
          return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky

    case 4949:
      // (s)ticky?
      if (charat(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)

    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ':', ':' + WEBKIT) + value;
        // (inline-)?fl(e)x

        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
      }

      break;
    // writing-mode

    case 5936:
      switch (charat(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)

        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb

        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }

      return WEBKIT + value + MS + value + value;
  }

  return value;
}

var prefixer = function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element["return"]) switch (element.type) {
    case DECLARATION:
      element["return"] = prefix(element.value, element.length);
      break;

    case KEYFRAMES:
      return serialize([copy(element, {
        value: replace(element.value, '@', '@' + WEBKIT)
      })], callback);

    case RULESET:
      if (element.length) return combine(element.props, function (value) {
        switch (match(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return serialize([copy(element, {
              props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
            })], callback);
          // :placeholder

          case '::placeholder':
            return serialize([copy(element, {
              props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
            }), copy(element, {
              props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
            }), copy(element, {
              props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
            })], callback);
        }

        return '';
      });
  }
};

var isBrowser$5 = typeof document !== 'undefined';
var getServerStylisCache = isBrowser$5 ? undefined : weakMemoize(function () {
  return memoize$1(function () {
    var cache = {};
    return function (name) {
      return cache[name];
    };
  });
});
var defaultStylisPlugins = [prefixer];

var createCache = function createCache(options) {
  var key = options.key;

  if (process.env.NODE_ENV !== 'production' && !key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\n" + "If multiple caches share the same key they might \"fight\" for each other's style elements.");
  }

  if (isBrowser$5 && key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  if (process.env.NODE_ENV !== 'production') {
    // $FlowFixMe
    if (/[^a-z-]/.test(key)) {
      throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
    }
  }

  var inserted = {};
  var container;
  var nodesToHydrate = [];

  if (isBrowser$5) {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  if (process.env.NODE_ENV !== 'production') {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }

    }), incorrectImportAlarm);
  }

  if (isBrowser$5) {
    var currentSheet;
    var finalizingPlugins = [stringify, process.env.NODE_ENV !== 'production' ? function (element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          // insert empty rule in non-production environments
          // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return serialize(compile(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      if (process.env.NODE_ENV !== 'production' && serialized.map !== undefined) {
        currentSheet = {
          insert: function insert(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  } else {
    var _finalizingPlugins = [stringify];

    var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));

    var _stylis = function _stylis(styles) {
      return serialize(compile(styles), _serializer);
    }; // $FlowFixMe


    var serverStylisCache = getServerStylisCache(stylisPlugins)(key);

    var getRules = function getRules(selector, serialized) {
      var name = serialized.name;

      if (serverStylisCache[name] === undefined) {
        serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      }

      return serverStylisCache[name];
    };

    _insert = function _insert(selector, serialized, sheet, shouldCache) {
      var name = serialized.name;
      var rules = getRules(selector, serialized);

      if (cache.compat === undefined) {
        // in regular mode, we don't set the styles on the inserted cache
        // since we don't need to and that would be wasting memory
        // we return them so that they are rendered in a style tag
        if (shouldCache) {
          cache.inserted[name] = true;
        }

        if ( // using === development instead of !== production
        // because if people do ssr in tests, the source maps showing up would be annoying
        process.env.NODE_ENV === 'development' && serialized.map !== undefined) {
          return rules + serialized.map;
        }

        return rules;
      } else {
        // in compat mode, we put the styles on the inserted cache so
        // that emotion-server can pull out the styles
        // except when we don't want to cache it which was in Global but now
        // is nowhere but we don't want to do a major right now
        // and just in case we're going to leave the case here
        // it's also not affecting client side bundle size
        // so it's really not a big deal
        if (shouldCache) {
          cache.inserted[name] = rules;
        } else {
          return rules;
        }
      }
    };
  }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

var reactIsExports = {};
var reactIs$1 = {
  get exports(){ return reactIsExports; },
  set exports(v){ reactIsExports = v; },
};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
	reactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};
	reactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;
	return reactIs_production_min;
}

var reactIs_development = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development;

function requireReactIs_development () {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development.AsyncMode = AsyncMode;
	reactIs_development.ConcurrentMode = ConcurrentMode;
	reactIs_development.ContextConsumer = ContextConsumer;
	reactIs_development.ContextProvider = ContextProvider;
	reactIs_development.Element = Element;
	reactIs_development.ForwardRef = ForwardRef;
	reactIs_development.Fragment = Fragment;
	reactIs_development.Lazy = Lazy;
	reactIs_development.Memo = Memo;
	reactIs_development.Portal = Portal;
	reactIs_development.Profiler = Profiler;
	reactIs_development.StrictMode = StrictMode;
	reactIs_development.Suspense = Suspense;
	reactIs_development.isAsyncMode = isAsyncMode;
	reactIs_development.isConcurrentMode = isConcurrentMode;
	reactIs_development.isContextConsumer = isContextConsumer;
	reactIs_development.isContextProvider = isContextProvider;
	reactIs_development.isElement = isElement;
	reactIs_development.isForwardRef = isForwardRef;
	reactIs_development.isFragment = isFragment;
	reactIs_development.isLazy = isLazy;
	reactIs_development.isMemo = isMemo;
	reactIs_development.isPortal = isPortal;
	reactIs_development.isProfiler = isProfiler;
	reactIs_development.isStrictMode = isStrictMode;
	reactIs_development.isSuspense = isSuspense;
	reactIs_development.isValidElementType = isValidElementType;
	reactIs_development.typeOf = typeOf;
	  })();
	}
	return reactIs_development;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactIs_production_min();
	} else {
	  module.exports = requireReactIs_development();
	}
} (reactIs$1));

var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

var isBrowser$4 = typeof document !== 'undefined';
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser$4 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;

  if (cache.inserted[serialized.name] === undefined) {
    var stylesForSSR = '';
    var current = serialized;

    do {
      var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

      if (!isBrowser$4 && maybeStyles !== undefined) {
        stylesForSSR += maybeStyles;
      }

      current = current.next;
    } while (current !== undefined);

    if (!isBrowser$4 && stylesForSSR.length !== 0) {
      return stylesForSSR;
    }
  }
};

/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

var ILLEGAL_ESCAPE_SEQUENCE_ERROR$1 = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */memoize$1(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

if (process.env.NODE_ENV !== 'production') {
  var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];
  var oldProcessStyleValue = processStyleValue;
  var msPattern = /^-ms-/;
  var hyphenPattern = /-(.)/g;
  var hyphenatedCache = {};

  processStyleValue = function processStyleValue(key, value) {
    if (key === 'content') {
      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }

    var processed = oldProcessStyleValue(key, value);

    if (processed !== '' && !isCustomProperty(key) && key.indexOf('-') !== -1 && hyphenatedCache[key] === undefined) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, 'ms-').replace(hyphenPattern, function (str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }

    return processed;
  };
}

var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {
    if (process.env.NODE_ENV !== 'production' && interpolation.toString() === 'NO_COMPONENT_SELECTOR') {
      throw new Error(noComponentSelectorMessage);
    }

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles + ";";

          if (process.env.NODE_ENV !== 'production' && interpolation.map !== undefined) {
            styles += interpolation.map;
          }

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        } else if (process.env.NODE_ENV !== 'production') {
          console.error('Functions that are interpolated in css calls will be stringified.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
        }

        break;
      }

    case 'string':
      if (process.env.NODE_ENV !== 'production') {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function (match, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, '') + "`");
          return "${" + fakeVarName + "}";
        });

        if (matched.length) {
          console.error('`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\n' + 'Instead of doing this:\n\n' + [].concat(matched, ["`" + replaced + "`"]).join('\n') + '\n\nYou should wrap it with `css` like this:\n\n' + ("css`" + replaced + "`"));
        }
      }

      break;
  } // finalize string values (regular strings and functions interpolated into css calls)


  if (registered == null) {
    return interpolation;
  }

  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && process.env.NODE_ENV !== 'production') {
          throw new Error(noComponentSelectorMessage);
        }

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }

            default:
              {
                if (process.env.NODE_ENV !== 'production' && _key === 'undefined') {
                  console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                }

                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;

if (process.env.NODE_ENV !== 'production') {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
} // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;
var serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (process.env.NODE_ENV !== 'production' && strings[0] === undefined) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);
    }

    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {
      if (process.env.NODE_ENV !== 'production' && strings[i] === undefined) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);
      }

      styles += strings[i];
    }
  }

  var sourceMap;

  if (process.env.NODE_ENV !== 'production') {
    styles = styles.replace(sourceMapPattern, function (match) {
      sourceMap = match;
      return '';
    });
  } // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = murmur2(styles) + identifierName;

  if (process.env.NODE_ENV !== 'production') {
    // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
    return {
      name: name,
      styles: styles,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};

var isBrowser$3 = typeof document !== 'undefined';

var syncFallback = function syncFallback(create) {
  return create();
};

var useInsertionEffect = React__namespace['useInsertion' + 'Effect'] ? React__namespace['useInsertion' + 'Effect'] : false;
var useInsertionEffectAlwaysWithSyncFallback = !isBrowser$3 ? syncFallback : useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || React$4.useLayoutEffect;

var isBrowser$2 = typeof document !== 'undefined';
var hasOwnProperty = {}.hasOwnProperty;

var EmotionCacheContext = /* #__PURE__ */React$4.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
  key: 'css'
}) : null);

if (process.env.NODE_ENV !== 'production') {
  EmotionCacheContext.displayName = 'EmotionCacheContext';
}

EmotionCacheContext.Provider;

var withEmotionCache = function withEmotionCache(func) {
  // $FlowFixMe
  return /*#__PURE__*/React$4.forwardRef(function (props, ref) {
    // the cache will never be null in the browser
    var cache = React$4.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};

if (!isBrowser$2) {
  withEmotionCache = function withEmotionCache(func) {
    return function (props) {
      var cache = React$4.useContext(EmotionCacheContext);

      if (cache === null) {
        // yes, we're potentially creating this on every render
        // it doesn't actually matter though since it's only on the server
        // so there will only every be a single render
        // that could change in the future because of suspense and etc. but for now,
        // this works and i don't want to optimise for a future thing that we aren't sure about
        cache = createCache({
          key: 'css'
        });
        return /*#__PURE__*/React$4.createElement(EmotionCacheContext.Provider, {
          value: cache
        }, func(props, cache));
      } else {
        return func(props, cache);
      }
    };
  };
}

var ThemeContext$2 = /* #__PURE__ */React$4.createContext({});

if (process.env.NODE_ENV !== 'production') {
  ThemeContext$2.displayName = 'EmotionThemeContext';
}

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var labelPropName = '__EMOTION_LABEL_PLEASE_DO_NOT_USE__';

var Insertion$2 = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {
    return insertStyles(cache, serialized, isStringTag);
  });

  if (!isBrowser$2 && rules !== undefined) {
    var _ref2;

    var serializedNames = serialized.name;
    var next = serialized.next;

    while (next !== undefined) {
      serializedNames += ' ' + next.name;
      next = next.next;
    }

    return /*#__PURE__*/React$4.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref2.nonce = cache.sheet.nonce, _ref2));
  }

  return null;
};

var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = serializeStyles(registeredStyles, undefined, React$4.useContext(ThemeContext$2));

  if (process.env.NODE_ENV !== 'production' && serialized.name.indexOf('-') === -1) {
    var labelFromStack = props[labelPropName];

    if (labelFromStack) {
      serialized = serializeStyles([serialized, 'label:' + labelFromStack + ';']);
    }
  }

  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && (process.env.NODE_ENV === 'production' || key !== labelPropName)) {
      newProps[key] = props[key];
    }
  }

  newProps.ref = ref;
  newProps.className = className;
  return /*#__PURE__*/React$4.createElement(React$4.Fragment, null, /*#__PURE__*/React$4.createElement(Insertion$2, {
    cache: cache,
    serialized: serialized,
    isStringTag: typeof WrappedComponent === 'string'
  }), /*#__PURE__*/React$4.createElement(WrappedComponent, newProps));
});

if (process.env.NODE_ENV !== 'production') {
  Emotion.displayName = 'EmotionCssPropInternal';
}

var pkg = {
	name: "@emotion/react",
	version: "11.10.5",
	main: "dist/emotion-react.cjs.js",
	module: "dist/emotion-react.esm.js",
	browser: {
		"./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
	},
	exports: {
		".": {
			module: {
				worker: "./dist/emotion-react.worker.esm.js",
				browser: "./dist/emotion-react.browser.esm.js",
				"default": "./dist/emotion-react.esm.js"
			},
			"default": "./dist/emotion-react.cjs.js"
		},
		"./jsx-runtime": {
			module: {
				worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
				browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
				"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
			},
			"default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
		},
		"./_isolated-hnrs": {
			module: {
				worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
				browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
				"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
			},
			"default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
		},
		"./jsx-dev-runtime": {
			module: {
				worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
				browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
				"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
			},
			"default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
		},
		"./package.json": "./package.json",
		"./types/css-prop": "./types/css-prop.d.ts",
		"./macro": "./macro.js"
	},
	types: "types/index.d.ts",
	files: [
		"src",
		"dist",
		"jsx-runtime",
		"jsx-dev-runtime",
		"_isolated-hnrs",
		"types/*.d.ts",
		"macro.js",
		"macro.d.ts",
		"macro.js.flow"
	],
	sideEffects: false,
	author: "Emotion Contributors",
	license: "MIT",
	scripts: {
		"test:typescript": "dtslint types"
	},
	dependencies: {
		"@babel/runtime": "^7.18.3",
		"@emotion/babel-plugin": "^11.10.5",
		"@emotion/cache": "^11.10.5",
		"@emotion/serialize": "^1.1.1",
		"@emotion/use-insertion-effect-with-fallbacks": "^1.0.0",
		"@emotion/utils": "^1.2.0",
		"@emotion/weak-memoize": "^0.3.0",
		"hoist-non-react-statics": "^3.3.1"
	},
	peerDependencies: {
		"@babel/core": "^7.0.0",
		react: ">=16.8.0"
	},
	peerDependenciesMeta: {
		"@babel/core": {
			optional: true
		},
		"@types/react": {
			optional: true
		}
	},
	devDependencies: {
		"@babel/core": "^7.18.5",
		"@definitelytyped/dtslint": "0.0.112",
		"@emotion/css": "11.10.5",
		"@emotion/css-prettifier": "1.1.1",
		"@emotion/server": "11.10.0",
		"@emotion/styled": "11.10.5",
		"html-tag-names": "^1.1.2",
		react: "16.14.0",
		"svg-tag-names": "^1.1.1",
		typescript: "^4.5.5"
	},
	repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
	publishConfig: {
		access: "public"
	},
	"umd:main": "dist/emotion-react.umd.min.js",
	preconstruct: {
		entrypoints: [
			"./index.js",
			"./jsx-runtime.js",
			"./jsx-dev-runtime.js",
			"./_isolated-hnrs.js"
		],
		umdName: "emotionReact",
		exports: {
			envConditions: [
				"browser",
				"worker"
			],
			extra: {
				"./types/css-prop": "./types/css-prop.d.ts",
				"./macro": "./macro.js"
			}
		}
	}
};

var warnedAboutCssPropForGlobal = false; // maintain place over rerenders.
// initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
// initial client-side render from SSR, use place of hydrating tag

var Global = /* #__PURE__ */withEmotionCache(function (props, cache) {
  if (process.env.NODE_ENV !== 'production' && !warnedAboutCssPropForGlobal && ( // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  props.className || props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }

  var styles = props.styles;
  var serialized = serializeStyles([styles], undefined, React$4.useContext(ThemeContext$2));

  if (!isBrowser$2) {
    var _ref;

    var serializedNames = serialized.name;
    var serializedStyles = serialized.styles;
    var next = serialized.next;

    while (next !== undefined) {
      serializedNames += ' ' + next.name;
      serializedStyles += next.styles;
      next = next.next;
    }

    var shouldCache = cache.compat === true;
    var rules = cache.insert("", {
      name: serializedNames,
      styles: serializedStyles
    }, cache.sheet, shouldCache);

    if (shouldCache) {
      return null;
    }

    return /*#__PURE__*/React$4.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref.nonce = cache.sheet.nonce, _ref));
  } // yes, i know these hooks are used conditionally
  // but it is based on a constant that will never change at runtime
  // it's effectively like having two implementations and switching them out
  // so it's not actually breaking anything


  var sheetRef = React$4.useRef();
  useInsertionEffectWithLayoutFallback(function () {
    var key = cache.key + "-global"; // use case of https://github.com/emotion-js/emotion/issues/2675

    var sheet = new cache.sheet.constructor({
      key: key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false; // $FlowFixMe

    var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");

    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }

    if (node !== null) {
      rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

      node.setAttribute('data-emotion', key);
      sheet.hydrate([node]);
    }

    sheetRef.current = [sheet, rehydrating];
    return function () {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function () {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0],
        rehydrating = sheetRefCurrent[1];

    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }

    if (serialized.next !== undefined) {
      // insert keyframes
      insertStyles(cache, serialized.next, true);
    }

    if (sheet.tags.length) {
      // if this doesn't exist then it will be null so the style element will be appended
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }

    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});

if (process.env.NODE_ENV !== 'production') {
  Global.displayName = 'EmotionGlobal';
}

function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return serializeStyles(args);
}

var keyframes = function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name; // $FlowFixMe

  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};

var classnames = function classnames(args) {
  var len = args.length;
  var i = 0;
  var cls = '';

  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;

    switch (typeof arg) {
      case 'boolean':
        break;

      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {
            if (process.env.NODE_ENV !== 'production' && arg.styles !== undefined && arg.name !== undefined) {
              console.error('You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n' + '`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.');
            }

            toAdd = '';

            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }

          break;
        }

      default:
        {
          toAdd = arg;
        }
    }

    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }

  return cls;
};

function merge$1(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);

  if (registeredStyles.length < 2) {
    return className;
  }

  return rawClassName + css(registeredStyles);
}

var Insertion$1 = function Insertion(_ref) {
  var cache = _ref.cache,
      serializedArr = _ref.serializedArr;
  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {
    var rules = '';

    for (var i = 0; i < serializedArr.length; i++) {
      var res = insertStyles(cache, serializedArr[i], false);

      if (!isBrowser$2 && res !== undefined) {
        rules += res;
      }
    }

    if (!isBrowser$2) {
      return rules;
    }
  });

  if (!isBrowser$2 && rules.length !== 0) {
    var _ref2;

    return /*#__PURE__*/React$4.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedArr.map(function (serialized) {
      return serialized.name;
    }).join(' '), _ref2.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref2.nonce = cache.sheet.nonce, _ref2));
  }

  return null;
};

var ClassNames = /* #__PURE__ */withEmotionCache(function (props, cache) {
  var hasRendered = false;
  var serializedArr = [];

  var css = function css() {
    if (hasRendered && process.env.NODE_ENV !== 'production') {
      throw new Error('css can only be used during render');
    }

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var serialized = serializeStyles(args, cache.registered);
    serializedArr.push(serialized); // registration has to happen here as the result of this might get consumed by `cx`

    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };

  var cx = function cx() {
    if (hasRendered && process.env.NODE_ENV !== 'production') {
      throw new Error('cx can only be used during render');
    }

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return merge$1(cache.registered, css, classnames(args));
  };

  var content = {
    css: css,
    cx: cx,
    theme: React$4.useContext(ThemeContext$2)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /*#__PURE__*/React$4.createElement(React$4.Fragment, null, /*#__PURE__*/React$4.createElement(Insertion$1, {
    cache: cache,
    serializedArr: serializedArr
  }), ele);
});

if (process.env.NODE_ENV !== 'production') {
  ClassNames.displayName = 'EmotionClassNames';
}

if (process.env.NODE_ENV !== 'production') {
  var isBrowser$1 = typeof document !== 'undefined'; // #1727, #2905 for some reason Jest and Vitest evaluate modules twice if some consuming module gets mocked

  var isTestEnv = typeof jest !== 'undefined' || typeof vi !== 'undefined';

  if (isBrowser$1 && !isTestEnv) {
    // globalThis has wide browser support - https://caniuse.com/?search=globalThis, Node.js 12 and later
    var globalContext = // $FlowIgnore
    typeof globalThis !== 'undefined' ? globalThis // eslint-disable-line no-undef
    : isBrowser$1 ? window : global;
    var globalKey = "__EMOTION_REACT_" + pkg.version.split('.')[0] + "__";

    if (globalContext[globalKey]) {
      console.warn('You are loading @emotion/react when it is already loaded. Running ' + 'multiple instances may cause problems. This can happen if multiple ' + 'versions are used, or if multiple builds of the same version are ' + 'used.');
    }

    globalContext[globalKey] = true;
  }
}

var testOmitPropsOnStringTag = isPropValid;

var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
  return key !== 'theme';
};

var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
  return typeof tag === 'string' && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
  var shouldForwardProp;

  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }

  if (typeof shouldForwardProp !== 'function' && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }

  return shouldForwardProp;
};

var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var isBrowser = typeof document !== 'undefined';

var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {
    return insertStyles(cache, serialized, isStringTag);
  });

  if (!isBrowser && rules !== undefined) {
    var _ref2;

    var serializedNames = serialized.name;
    var next = serialized.next;

    while (next !== undefined) {
      serializedNames += ' ' + next.name;
      next = next.next;
    }

    return /*#__PURE__*/React$4.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref2.nonce = cache.sheet.nonce, _ref2));
  }

  return null;
};

var createStyled$1 = function createStyled(tag, options) {
  if (process.env.NODE_ENV !== 'production') {
    if (tag === undefined) {
      throw new Error('You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.');
    }
  }

  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;

  if (options !== undefined) {
    identifierName = options.label;
    targetClassName = options.target;
  }

  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp('as');
  return function () {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

    if (identifierName !== undefined) {
      styles.push("label:" + identifierName + ";");
    }

    if (args[0] == null || args[0].raw === undefined) {
      styles.push.apply(styles, args);
    } else {
      if (process.env.NODE_ENV !== 'production' && args[0][0] === undefined) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }

      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;

      for (; i < len; i++) {
        if (process.env.NODE_ENV !== 'production' && args[0][i] === undefined) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        }

        styles.push(args[i], args[0][i]);
      }
    } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class


    var Styled = withEmotionCache(function (props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = '';
      var classInterpolations = [];
      var mergedProps = props;

      if (props.theme == null) {
        mergedProps = {};

        for (var key in props) {
          mergedProps[key] = props[key];
        }

        mergedProps.theme = React$4.useContext(ThemeContext$2);
      }

      if (typeof props.className === 'string') {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }

      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;

      if (targetClassName !== undefined) {
        className += " " + targetClassName;
      }

      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};

      for (var _key in props) {
        if (shouldUseAs && _key === 'as') continue;

        if ( // $FlowFixMe
        finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }

      newProps.className = className;
      newProps.ref = ref;
      return /*#__PURE__*/React$4.createElement(React$4.Fragment, null, /*#__PURE__*/React$4.createElement(Insertion, {
        cache: cache,
        serialized: serialized,
        isStringTag: typeof FinalTag === 'string'
      }), /*#__PURE__*/React$4.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, 'toString', {
      value: function value() {
        if (targetClassName === undefined && process.env.NODE_ENV !== 'production') {
          return 'NO_COMPONENT_SELECTOR';
        } // $FlowFixMe: coerce undefined to string


        return "." + targetClassName;
      }
    });

    Styled.withComponent = function (nextTag, nextOptions) {
      return createStyled(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };

    return Styled;
  };
};

var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

var newStyled = createStyled$1.bind();
tags.forEach(function (tagName) {
  // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type
  newStyled[tagName] = newStyled(tagName);
});

var emStyled = newStyled;

function isEmpty$4(obj) {
  return obj === undefined || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$1(props) {
  const {
    styles,
    defaultTheme = {}
  } = props;
  const globalStyles = typeof styles === 'function' ? themeInput => styles(isEmpty$4(themeInput) ? defaultTheme : themeInput) : styles;
  return /*#__PURE__*/jsxRuntime.jsx(Global, {
    styles: globalStyles
  });
}
process.env.NODE_ENV !== "production" ? GlobalStyles$1.propTypes = {
  defaultTheme: propTypesExports.object,
  styles: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.object, propTypesExports.func])
} : void 0;

/** @license MUI v5.11.0
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$2(tag, options) {
  const stylesFactory = emStyled(tag, options);
  if (process.env.NODE_ENV !== 'production') {
    return (...styles) => {
      const component = typeof tag === 'string' ? `"${tag}"` : 'component';
      if (styles.length === 0) {
        console.error([`MUI: Seems like you called \`styled(${component})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join('\n'));
      } else if (styles.some(style => style === undefined)) {
        console.error(`MUI: the styled(${component})(...args) API requires all its args to be defined.`);
      }
      return stylesFactory(...styles);
    };
  }
  return stylesFactory;
}

// eslint-disable-next-line @typescript-eslint/naming-convention
const internal_processStyles = (tag, processor) => {
  // Emotion attaches all the styles as `__emotion_styles`.
  // Ref: https://github.com/emotion-js/emotion/blob/16d971d0da229596d6bcc39d282ba9753c9ee7cf/packages/styled/src/base.js#L186
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};

const responsivePropType = process.env.NODE_ENV !== 'production' ? propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string, propTypesExports.object, propTypesExports.array]) : {};
var responsivePropType$1 = responsivePropType;

function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false // No need to clone deep, it's way faster.
  });
}

// The breakpoint **start** at this value.
// For instance with the first breakpoint xs: [xs, sm[.
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536 // large screen
};

const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ['xs', 'sm', 'md', 'lg', 'xl'],
  up: key => `@media (min-width:${values$1[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === 'object') {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      // key is breakpoint
      if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles].reduce((prev, next) => deepmerge(prev, next), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}

// compute base for responsive values; e.g.,
// [1,2,3] => {xs: true, sm: true, md: true}
// {xs: 1, sm: 2, md: 3} => {xs: true, sm: true, md: true}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  // fixed value
  if (typeof breakpointValues !== 'object') {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i) => {
      if (i < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach(breakpoint => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys = Object.keys(base);
  if (keys.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys.reduce((acc, breakpoint, i) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
      previous = i;
    } else if (typeof breakpointValues === 'object') {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}

function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== 'string') {
    return null;
  }

  // Check if CSS variables are used
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split('.').reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split('.').reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === 'function') {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$2(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;

  // false positive
  // eslint-disable-next-line react/function-component-definition
  const fn = props => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = propValueFinal => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === 'string') {
        // Haven't found value
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = process.env.NODE_ENV !== 'production' ? {
    [prop]: responsivePropType$1
  } : {};
  fn.filterProps = [prop];
  return fn;
}

function compose(...styles) {
  const handlers = styles.reduce((acc, style) => {
    style.filterProps.forEach(prop => {
      acc[prop] = style;
    });
    return acc;
  }, {});

  // false positive
  // eslint-disable-next-line react/function-component-definition
  const fn = props => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = process.env.NODE_ENV !== 'production' ? styles.reduce((acc, style) => Object.assign(acc, style.propTypes), {}) : {};
  fn.filterProps = styles.reduce((acc, style) => acc.concat(style.filterProps), []);
  return fn;
}

function memoize(fn) {
  const cache = {};
  return arg => {
    if (cache[arg] === undefined) {
      cache[arg] = fn(arg);
    }
    return cache[arg];
  };
}

const properties = {
  m: 'margin',
  p: 'padding'
};
const directions = {
  t: 'Top',
  r: 'Right',
  b: 'Bottom',
  l: 'Left',
  x: ['Left', 'Right'],
  y: ['Top', 'Bottom']
};
const aliases = {
  marginX: 'mx',
  marginY: 'my',
  paddingX: 'px',
  paddingY: 'py'
};

// memoize() impact:
// From 300,000 ops/sec
// To 350,000 ops/sec
const getCssProperties = memoize(prop => {
  // It's not a shorthand notation.
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b] = prop.split('');
  const property = properties[a];
  const direction = directions[b] || '';
  return Array.isArray(direction) ? direction.map(dir => property + dir) : [property + direction];
});
const marginKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd'];
const paddingKeys = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd'];
const spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === 'number') {
    return abs => {
      if (typeof abs === 'string') {
        return abs;
      }
      if (process.env.NODE_ENV !== 'production') {
        if (typeof abs !== 'number') {
          console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${abs}.`);
        }
      }
      return themeSpacing * abs;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return abs => {
      if (typeof abs === 'string') {
        return abs;
      }
      if (process.env.NODE_ENV !== 'production') {
        if (!Number.isInteger(abs)) {
          console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.` + `You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join('\n'));
        } else if (abs > themeSpacing.length - 1) {
          console.error([`MUI: The value provided (${abs}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs} > ${themeSpacing.length - 1}, you need to add the missing values.`].join('\n'));
        }
      }
      return themeSpacing[abs];
    };
  }
  if (typeof themeSpacing === 'function') {
    return themeSpacing;
  }
  if (process.env.NODE_ENV !== 'production') {
    console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, 'It should be a number, an array or a function.'].join('\n'));
  }
  return () => undefined;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, 'spacing', 8, 'spacing');
}
function getValue(transformer, propValue) {
  if (typeof propValue === 'string' || propValue == null) {
    return propValue;
  }
  const abs = Math.abs(propValue);
  const transformed = transformer(abs);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === 'number') {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return propValue => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  // Using a hash computation over an array iteration could be faster, but with only 28 items,
  // it's doesn't worth the bundle size.
  if (keys.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$1(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map(prop => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style$1(props, marginKeys);
}
margin.propTypes = process.env.NODE_ENV !== 'production' ? marginKeys.reduce((obj, key) => {
  obj[key] = responsivePropType$1;
  return obj;
}, {}) : {};
margin.filterProps = marginKeys;
function padding(props) {
  return style$1(props, paddingKeys);
}
padding.propTypes = process.env.NODE_ENV !== 'production' ? paddingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType$1;
  return obj;
}, {}) : {};
padding.filterProps = paddingKeys;
process.env.NODE_ENV !== 'production' ? spacingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType$1;
  return obj;
}, {}) : {};

function borderTransform(value) {
  if (typeof value !== 'number') {
    return value;
  }
  return `${value}px solid`;
}
const border = style$2({
  prop: 'border',
  themeKey: 'borders',
  transform: borderTransform
});
const borderTop = style$2({
  prop: 'borderTop',
  themeKey: 'borders',
  transform: borderTransform
});
const borderRight = style$2({
  prop: 'borderRight',
  themeKey: 'borders',
  transform: borderTransform
});
const borderBottom = style$2({
  prop: 'borderBottom',
  themeKey: 'borders',
  transform: borderTransform
});
const borderLeft = style$2({
  prop: 'borderLeft',
  themeKey: 'borders',
  transform: borderTransform
});
const borderColor = style$2({
  prop: 'borderColor',
  themeKey: 'palette'
});
const borderTopColor = style$2({
  prop: 'borderTopColor',
  themeKey: 'palette'
});
const borderRightColor = style$2({
  prop: 'borderRightColor',
  themeKey: 'palette'
});
const borderBottomColor = style$2({
  prop: 'borderBottomColor',
  themeKey: 'palette'
});
const borderLeftColor = style$2({
  prop: 'borderLeftColor',
  themeKey: 'palette'
});

// false positive
// eslint-disable-next-line react/function-component-definition
const borderRadius = props => {
  if (props.borderRadius !== undefined && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, 'shape.borderRadius', 4, 'borderRadius');
    const styleFromPropValue = propValue => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = process.env.NODE_ENV !== 'production' ? {
  borderRadius: responsivePropType$1
} : {};
borderRadius.filterProps = ['borderRadius'];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);

// false positive
// eslint-disable-next-line react/function-component-definition
const gap = props => {
  if (props.gap !== undefined && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, 'spacing', 8, 'gap');
    const styleFromPropValue = propValue => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = process.env.NODE_ENV !== 'production' ? {
  gap: responsivePropType$1
} : {};
gap.filterProps = ['gap'];

// false positive
// eslint-disable-next-line react/function-component-definition
const columnGap = props => {
  if (props.columnGap !== undefined && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, 'spacing', 8, 'columnGap');
    const styleFromPropValue = propValue => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = process.env.NODE_ENV !== 'production' ? {
  columnGap: responsivePropType$1
} : {};
columnGap.filterProps = ['columnGap'];

// false positive
// eslint-disable-next-line react/function-component-definition
const rowGap = props => {
  if (props.rowGap !== undefined && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, 'spacing', 8, 'rowGap');
    const styleFromPropValue = propValue => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = process.env.NODE_ENV !== 'production' ? {
  rowGap: responsivePropType$1
} : {};
rowGap.filterProps = ['rowGap'];
const gridColumn = style$2({
  prop: 'gridColumn'
});
const gridRow = style$2({
  prop: 'gridRow'
});
const gridAutoFlow = style$2({
  prop: 'gridAutoFlow'
});
const gridAutoColumns = style$2({
  prop: 'gridAutoColumns'
});
const gridAutoRows = style$2({
  prop: 'gridAutoRows'
});
const gridTemplateColumns = style$2({
  prop: 'gridTemplateColumns'
});
const gridTemplateRows = style$2({
  prop: 'gridTemplateRows'
});
const gridTemplateAreas = style$2({
  prop: 'gridTemplateAreas'
});
const gridArea = style$2({
  prop: 'gridArea'
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

function paletteTransform(value, userValue) {
  if (userValue === 'grey') {
    return userValue;
  }
  return value;
}
const color = style$2({
  prop: 'color',
  themeKey: 'palette',
  transform: paletteTransform
});
const bgcolor = style$2({
  prop: 'bgcolor',
  cssProperty: 'backgroundColor',
  themeKey: 'palette',
  transform: paletteTransform
});
const backgroundColor = style$2({
  prop: 'backgroundColor',
  themeKey: 'palette',
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);

function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$2({
  prop: 'width',
  transform: sizingTransform
});
const maxWidth = props => {
  if (props.maxWidth !== undefined && props.maxWidth !== null) {
    const styleFromPropValue = propValue => {
      var _props$theme, _props$theme$breakpoi, _props$theme$breakpoi2;
      const breakpoint = ((_props$theme = props.theme) == null ? void 0 : (_props$theme$breakpoi = _props$theme.breakpoints) == null ? void 0 : (_props$theme$breakpoi2 = _props$theme$breakpoi.values) == null ? void 0 : _props$theme$breakpoi2[propValue]) || values$1[propValue];
      return {
        maxWidth: breakpoint || sizingTransform(propValue)
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ['maxWidth'];
const minWidth = style$2({
  prop: 'minWidth',
  transform: sizingTransform
});
const height = style$2({
  prop: 'height',
  transform: sizingTransform
});
const maxHeight = style$2({
  prop: 'maxHeight',
  transform: sizingTransform
});
const minHeight = style$2({
  prop: 'minHeight',
  transform: sizingTransform
});
style$2({
  prop: 'size',
  cssProperty: 'width',
  transform: sizingTransform
});
style$2({
  prop: 'size',
  cssProperty: 'height',
  transform: sizingTransform
});
const boxSizing = style$2({
  prop: 'boxSizing'
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);

const defaultSxConfig = {
  // borders
  border: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderTop: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderRight: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderBottom: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderLeft: {
    themeKey: 'borders',
    transform: borderTransform
  },
  borderColor: {
    themeKey: 'palette'
  },
  borderTopColor: {
    themeKey: 'palette'
  },
  borderRightColor: {
    themeKey: 'palette'
  },
  borderBottomColor: {
    themeKey: 'palette'
  },
  borderLeftColor: {
    themeKey: 'palette'
  },
  borderRadius: {
    themeKey: 'shape.borderRadius',
    style: borderRadius
  },
  // palette
  color: {
    themeKey: 'palette',
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: 'palette',
    cssProperty: 'backgroundColor',
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: 'palette',
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: value => ({
      '@media print': {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: 'zIndex'
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: 'shadows'
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: 'typography'
  },
  fontSize: {
    themeKey: 'typography'
  },
  fontStyle: {
    themeKey: 'typography'
  },
  fontWeight: {
    themeKey: 'typography'
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: 'typography'
  }
};
var defaultSxConfig$1 = defaultSxConfig;

function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every(object => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
}

// eslint-disable-next-line @typescript-eslint/naming-convention
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style
    } = options;
    if (val == null) {
      return null;
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style) {
      return style(props);
    }
    const styleFromPropValue = propValueFinal => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === 'string') {
        // Haven't found value
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null; // Emotion & styled-components will neglect null
    }

    const config = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;

    /*
     * Receive `sxInput` as object or callback
     * and then recursively check keys & values to create media query object styles.
     * (the result will be used in `styled`)
     */
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === 'function') {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== 'object') {
        // value
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css = emptyBreakpoints;
      Object.keys(sxObject).forEach(styleKey => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== undefined) {
          if (typeof value === 'object') {
            if (config[styleKey]) {
              css = merge(css, getThemeValue(styleKey, value, theme, config));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, x => ({
                [styleKey]: x
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css[styleKey] = styleFunctionSx({
                  sx: value,
                  theme
                });
              } else {
                css = merge(css, breakpointsValues);
              }
            }
          } else {
            css = merge(css, getThemeValue(styleKey, value, theme, config));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ['sx'];
var styleFunctionSx$1 = styleFunctionSx;

const _excluded$Q = ["sx"];
const splitProps = props => {
  var _props$theme$unstable, _props$theme;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config = (_props$theme$unstable = props == null ? void 0 : (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig$1;
  Object.keys(props).forEach(prop => {
    if (config[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp(props) {
  const {
      sx: inSx
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$Q);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === 'function') {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject(result)) {
        return systemProps;
      }
      return _extends({}, systemProps, result);
    };
  } else {
    finalSx = _extends({}, systemProps, inSx);
  }
  return _extends({}, otherProps, {
    sx: finalSx
  });
}

const _excluded$P = ["values", "unit", "step"];
const sortBreakpointsValues = values => {
  const breakpointsAsArray = Object.keys(values).map(key => ({
    key,
    val: values[key]
  })) || [];
  // Sort in ascending order
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};

// Keep in mind that @media is inclusive by the CSS specification.
function createBreakpoints(breakpoints) {
  const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536 // large screen
      },

      unit = 'px',
      step = 5
    } = breakpoints,
    other = _objectWithoutPropertiesLoose(breakpoints, _excluded$P);
  const sortedValues = sortBreakpointsValues(values);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values[key] === 'number' ? values[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values[key] === 'number' ? values[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex]] === 'number' ? values[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    // handle first and last key separately, for better readability
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace('@media', '@media not all and');
  }
  return _extends({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}

const shape = {
  borderRadius: 4
};
var shape$1 = shape;

/* tslint:enable:unified-signatures */

function createSpacing(spacingInput = 8) {
  // Already transformed.
  if (spacingInput.mui) {
    return spacingInput;
  }

  // Material Design layouts are visually balanced. Most measurements align to an 8dp grid, which aligns both spacing and the overall layout.
  // Smaller components, such as icons, can align to a 4dp grid.
  // https://m2.material.io/design/layout/understanding-layout.html
  const transform = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing = (...argsInput) => {
    if (process.env.NODE_ENV !== 'production') {
      if (!(argsInput.length <= 4)) {
        console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
      }
    }
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map(argument => {
      const output = transform(argument);
      return typeof output === 'number' ? `${output}px` : output;
    }).join(' ');
  };
  spacing.mui = true;
  return spacing;
}

const _excluded$O = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$1(options = {}, ...args) {
  const {
      breakpoints: breakpointsInput = {},
      palette: paletteInput = {},
      spacing: spacingInput,
      shape: shapeInput = {}
    } = options,
    other = _objectWithoutPropertiesLoose(options, _excluded$O);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: 'ltr',
    components: {},
    // Inject component definitions.
    palette: _extends({
      mode: 'light'
    }, paletteInput),
    spacing,
    shape: _extends({}, shape$1, shapeInput)
  }, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}

const ThemeContext = /*#__PURE__*/React__namespace.createContext(null);
if (process.env.NODE_ENV !== 'production') {
  ThemeContext.displayName = 'ThemeContext';
}
var ThemeContext$1 = ThemeContext;

function useTheme$3() {
  const theme = React__namespace.useContext(ThemeContext$1);
  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__namespace.useDebugValue(theme);
  }
  return theme;
}

function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme = null) {
  const contextTheme = useTheme$3();
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme : contextTheme;
}

const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(defaultTheme = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme);
}

const _excluded$N = ["variant"];
function isEmpty$3(string) {
  return string.length === 0;
}

/**
 * Generates string classKey based on the properties provided. It starts with the
 * variant if defined, and then it appends all other properties in alphabetical order.
 * @param {object} props - the properties for which the classKey should be created.
 */
function propsToClassKey(props) {
  const {
      variant
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$N);
  let classKey = variant || '';
  Object.keys(other).sort().forEach(key => {
    if (key === 'color') {
      classKey += isEmpty$3(classKey) ? props[key] : capitalize(props[key]);
    } else {
      classKey += `${isEmpty$3(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
    }
  });
  return classKey;
}

const _excluded$M = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"],
  _excluded2$3 = ["theme"],
  _excluded3 = ["theme"];
function isEmpty$2(obj) {
  return Object.keys(obj).length === 0;
}

// https://github.com/emotion-js/emotion/blob/26ded6109fcd8ca9875cc2ce4564fee678a3f3c5/packages/styled/src/utils.js#L40
function isStringTag(tag) {
  return typeof tag === 'string' &&
  // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
const getStyleOverrides = (name, theme) => {
  if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
    return theme.components[name].styleOverrides;
  }
  return null;
};
const getVariantStyles = (name, theme) => {
  let variants = [];
  if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
    variants = theme.components[name].variants;
  }
  const variantsStyles = {};
  variants.forEach(definition => {
    const key = propsToClassKey(definition.props);
    variantsStyles[key] = definition.style;
  });
  return variantsStyles;
};
const variantsResolver = (props, styles, theme, name) => {
  var _theme$components, _theme$components$nam;
  const {
    ownerState = {}
  } = props;
  const variantsStyles = [];
  const themeVariants = theme == null ? void 0 : (_theme$components = theme.components) == null ? void 0 : (_theme$components$nam = _theme$components[name]) == null ? void 0 : _theme$components$nam.variants;
  if (themeVariants) {
    themeVariants.forEach(themeVariant => {
      let isMatch = true;
      Object.keys(themeVariant.props).forEach(key => {
        if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
          isMatch = false;
        }
      });
      if (isMatch) {
        variantsStyles.push(styles[propsToClassKey(themeVariant.props)]);
      }
    });
  }
  return variantsStyles;
};

// Update /system/styled/#api in case if this changes
function shouldForwardProp(prop) {
  return prop !== 'ownerState' && prop !== 'theme' && prop !== 'sx' && prop !== 'as';
}
const systemDefaultTheme = createTheme$1();
const lowercaseFirstLetter = string => {
  return string.charAt(0).toLowerCase() + string.slice(1);
};
function createStyled(input = {}) {
  const {
    defaultTheme = systemDefaultTheme,
    rootShouldForwardProp = shouldForwardProp,
    slotShouldForwardProp = shouldForwardProp
  } = input;
  const systemSx = props => {
    const theme = isEmpty$2(props.theme) ? defaultTheme : props.theme;
    return styleFunctionSx$1(_extends({}, props, {
      theme
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    // Filter out the `sx` style function from the previous styled component to prevent unnecessary styles generated by the composite components.
    internal_processStyles(tag, styles => styles.filter(style => !(style != null && style.__mui_systemSx)));
    const {
        name: componentName,
        slot: componentSlot,
        skipVariantsResolver: inputSkipVariantsResolver,
        skipSx: inputSkipSx,
        overridesResolver
      } = inputOptions,
      options = _objectWithoutPropertiesLoose(inputOptions, _excluded$M);

    // if skipVariantsResolver option is defined, take the value, otherwise, true for root and false for other slots.
    const skipVariantsResolver = inputSkipVariantsResolver !== undefined ? inputSkipVariantsResolver : componentSlot && componentSlot !== 'Root' || false;
    const skipSx = inputSkipSx || false;
    let label;
    if (process.env.NODE_ENV !== 'production') {
      if (componentName) {
        label = `${componentName}-${lowercaseFirstLetter(componentSlot || 'Root')}`;
      }
    }
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === 'Root') {
      shouldForwardPropOption = rootShouldForwardProp;
    } else if (componentSlot) {
      // any other slot specified
      shouldForwardPropOption = slotShouldForwardProp;
    } else if (isStringTag(tag)) {
      // for string (html) tag, preserve the behavior in emotion & styled-components.
      shouldForwardPropOption = undefined;
    }
    const defaultStyledResolver = styled$2(tag, _extends({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const muiStyledResolver = (styleArg, ...expressions) => {
      const expressionsWithDefaultTheme = expressions ? expressions.map(stylesArg => {
        // On the server Emotion doesn't use React.forwardRef for creating components, so the created
        // component stays as a function. This condition makes sure that we do not interpolate functions
        // which are basically components used as a selectors.
        return typeof stylesArg === 'function' && stylesArg.__emotion_real !== stylesArg ? _ref => {
          let {
              theme: themeInput
            } = _ref,
            other = _objectWithoutPropertiesLoose(_ref, _excluded2$3);
          return stylesArg(_extends({
            theme: isEmpty$2(themeInput) ? defaultTheme : themeInput
          }, other));
        } : stylesArg;
      }) : [];
      let transformedStyleArg = styleArg;
      if (componentName && overridesResolver) {
        expressionsWithDefaultTheme.push(props => {
          const theme = isEmpty$2(props.theme) ? defaultTheme : props.theme;
          const styleOverrides = getStyleOverrides(componentName, theme);
          if (styleOverrides) {
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = typeof slotStyle === 'function' ? slotStyle(_extends({}, props, {
                theme
              })) : slotStyle;
            });
            return overridesResolver(props, resolvedStyleOverrides);
          }
          return null;
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push(props => {
          const theme = isEmpty$2(props.theme) ? defaultTheme : props.theme;
          return variantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill('');
        // If the type is array, than we need to add placeholders in the template for the overrides, variants and the sx styles.
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      } else if (typeof styleArg === 'function' &&
      // On the server Emotion doesn't use React.forwardRef for creating components, so the created
      // component stays as a function. This condition makes sure that we do not interpolate functions
      // which are basically components used as a selectors.
      styleArg.__emotion_real !== styleArg) {
        // If the type is function, we need to define the default theme.
        transformedStyleArg = _ref2 => {
          let {
              theme: themeInput
            } = _ref2,
            other = _objectWithoutPropertiesLoose(_ref2, _excluded3);
          return styleArg(_extends({
            theme: isEmpty$2(themeInput) ? defaultTheme : themeInput
          }, other));
        };
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (process.env.NODE_ENV !== 'production') {
        let displayName;
        if (componentName) {
          displayName = `${componentName}${componentSlot || ''}`;
        }
        if (displayName === undefined) {
          displayName = `Styled(${getDisplayName(tag)})`;
        }
        Component.displayName = displayName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}

function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}

function useThemeProps$1({
  props,
  name,
  defaultTheme
}) {
  const theme = useTheme$1(defaultTheme);
  const mergedProps = getThemeProps({
    theme,
    name,
    props
  });
  return mergedProps;
}

/**
 * Returns a number whose value is limited to the given range.
 * @param {number} value The value to be clamped
 * @param {number} min The lower boundary of the output range
 * @param {number} max The upper boundary of the output range
 * @returns {number} A number in the range [min, max]
 */
function clamp$1(value, min = 0, max = 1) {
  if (process.env.NODE_ENV !== 'production') {
    if (value < min || value > max) {
      console.error(`MUI: The value provided ${value} is out of range [${min}, ${max}].`);
    }
  }
  return Math.min(Math.max(min, value), max);
}

/**
 * Converts a color from CSS hex format to CSS rgb format.
 * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
 * @returns {string} A CSS rgb color string
 */
function hexToRgb(color) {
  color = color.slice(1);
  const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, 'g');
  let colors = color.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map(n => n + n);
  }
  return colors ? `rgb${colors.length === 4 ? 'a' : ''}(${colors.map((n, index) => {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
  }).join(', ')})` : '';
}

/**
 * Returns an object with the type and values of a color.
 *
 * Note: Does not support rgb % values.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @returns {object} - A MUI color object: {type: string, values: number[]}
 */
function decomposeColor(color) {
  // Idempotent
  if (color.type) {
    return color;
  }
  if (color.charAt(0) === '#') {
    return decomposeColor(hexToRgb(color));
  }
  const marker = color.indexOf('(');
  const type = color.substring(0, marker);
  if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(type) === -1) {
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${color}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : formatMuiErrorMessage(9, color));
  }
  let values = color.substring(marker + 1, color.length - 1);
  let colorSpace;
  if (type === 'color') {
    values = values.split(' ');
    colorSpace = values.shift();
    if (values.length === 4 && values[3].charAt(0) === '/') {
      values[3] = values[3].slice(1);
    }
    if (['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(colorSpace) === -1) {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values = values.split(',');
  }
  values = values.map(value => parseFloat(value));
  return {
    type,
    values,
    colorSpace
  };
}

/**
 * Converts a color object with type and values to a string.
 * @param {object} color - Decomposed color
 * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla', 'color'
 * @param {array} color.values - [n,n,n] or [n,n,n,n]
 * @returns {string} A CSS color string
 */
function recomposeColor(color) {
  const {
    type,
    colorSpace
  } = color;
  let {
    values
  } = color;
  if (type.indexOf('rgb') !== -1) {
    // Only convert the first 3 values to int (i.e. not alpha)
    values = values.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type.indexOf('hsl') !== -1) {
    values[1] = `${values[1]}%`;
    values[2] = `${values[2]}%`;
  }
  if (type.indexOf('color') !== -1) {
    values = `${colorSpace} ${values.join(' ')}`;
  } else {
    values = `${values.join(', ')}`;
  }
  return `${type}(${values})`;
}

/**
 * Converts a color from hsl format to rgb format.
 * @param {string} color - HSL color values
 * @returns {string} rgb color values
 */
function hslToRgb(color) {
  color = decomposeColor(color);
  const {
    values
  } = color;
  const h = values[0];
  const s = values[1] / 100;
  const l = values[2] / 100;
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  let type = 'rgb';
  const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  if (color.type === 'hsla') {
    type += 'a';
    rgb.push(values[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
/**
 * The relative brightness of any point in a color space,
 * normalized to 0 for darkest black and 1 for lightest white.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @returns {number} The relative brightness of the color in the range 0 - 1
 */
function getLuminance(color) {
  color = decomposeColor(color);
  let rgb = color.type === 'hsl' || color.type === 'hsla' ? decomposeColor(hslToRgb(color)).values : color.values;
  rgb = rgb.map(val => {
    if (color.type !== 'color') {
      val /= 255; // normalized
    }

    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });

  // Truncate at 3 digits
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}

/**
 * Calculates the contrast ratio between two colors.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {number} A contrast ratio value in the range 0 - 21.
 */
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}

/**
 * Sets the absolute transparency of a color.
 * Any existing alpha values are overwritten.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} value - value to set the alpha channel to in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function alpha(color, value) {
  color = decomposeColor(color);
  value = clamp$1(value);
  if (color.type === 'rgb' || color.type === 'hsl') {
    color.type += 'a';
  }
  if (color.type === 'color') {
    color.values[3] = `/${value}`;
  } else {
    color.values[3] = value;
  }
  return recomposeColor(color);
}

/**
 * Darkens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function darken(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp$1(coefficient);
  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] *= 1 - coefficient;
  } else if (color.type.indexOf('rgb') !== -1 || color.type.indexOf('color') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color);
}

/**
 * Lightens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function lighten(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp$1(coefficient);
  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] += (100 - color.values[2]) * coefficient;
  } else if (color.type.indexOf('rgb') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (255 - color.values[i]) * coefficient;
    }
  } else if (color.type.indexOf('color') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (1 - color.values[i]) * coefficient;
    }
  }
  return recomposeColor(color);
}

function createMixins(breakpoints, mixins) {
  return _extends({
    toolbar: {
      minHeight: 56,
      [breakpoints.up('xs')]: {
        '@media (orientation: landscape)': {
          minHeight: 48
        }
      },
      [breakpoints.up('sm')]: {
        minHeight: 64
      }
    }
  }, mixins);
}

const common = {
  black: '#000',
  white: '#fff'
};
var common$1 = common;

const grey = {
  50: '#fafafa',
  100: '#f5f5f5',
  200: '#eeeeee',
  300: '#e0e0e0',
  400: '#bdbdbd',
  500: '#9e9e9e',
  600: '#757575',
  700: '#616161',
  800: '#424242',
  900: '#212121',
  A100: '#f5f5f5',
  A200: '#eeeeee',
  A400: '#bdbdbd',
  A700: '#616161'
};
var grey$1 = grey;

const purple = {
  50: '#f3e5f5',
  100: '#e1bee7',
  200: '#ce93d8',
  300: '#ba68c8',
  400: '#ab47bc',
  500: '#9c27b0',
  600: '#8e24aa',
  700: '#7b1fa2',
  800: '#6a1b9a',
  900: '#4a148c',
  A100: '#ea80fc',
  A200: '#e040fb',
  A400: '#d500f9',
  A700: '#aa00ff'
};
var purple$1 = purple;

const red = {
  50: '#ffebee',
  100: '#ffcdd2',
  200: '#ef9a9a',
  300: '#e57373',
  400: '#ef5350',
  500: '#f44336',
  600: '#e53935',
  700: '#d32f2f',
  800: '#c62828',
  900: '#b71c1c',
  A100: '#ff8a80',
  A200: '#ff5252',
  A400: '#ff1744',
  A700: '#d50000'
};
var red$1 = red;

const orange = {
  50: '#fff3e0',
  100: '#ffe0b2',
  200: '#ffcc80',
  300: '#ffb74d',
  400: '#ffa726',
  500: '#ff9800',
  600: '#fb8c00',
  700: '#f57c00',
  800: '#ef6c00',
  900: '#e65100',
  A100: '#ffd180',
  A200: '#ffab40',
  A400: '#ff9100',
  A700: '#ff6d00'
};
var orange$1 = orange;

const blue = {
  50: '#e3f2fd',
  100: '#bbdefb',
  200: '#90caf9',
  300: '#64b5f6',
  400: '#42a5f5',
  500: '#2196f3',
  600: '#1e88e5',
  700: '#1976d2',
  800: '#1565c0',
  900: '#0d47a1',
  A100: '#82b1ff',
  A200: '#448aff',
  A400: '#2979ff',
  A700: '#2962ff'
};
var blue$1 = blue;

const lightBlue = {
  50: '#e1f5fe',
  100: '#b3e5fc',
  200: '#81d4fa',
  300: '#4fc3f7',
  400: '#29b6f6',
  500: '#03a9f4',
  600: '#039be5',
  700: '#0288d1',
  800: '#0277bd',
  900: '#01579b',
  A100: '#80d8ff',
  A200: '#40c4ff',
  A400: '#00b0ff',
  A700: '#0091ea'
};
var lightBlue$1 = lightBlue;

const green = {
  50: '#e8f5e9',
  100: '#c8e6c9',
  200: '#a5d6a7',
  300: '#81c784',
  400: '#66bb6a',
  500: '#4caf50',
  600: '#43a047',
  700: '#388e3c',
  800: '#2e7d32',
  900: '#1b5e20',
  A100: '#b9f6ca',
  A200: '#69f0ae',
  A400: '#00e676',
  A700: '#00c853'
};
var green$1 = green;

const _excluded$L = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: 'rgba(0, 0, 0, 0.87)',
    // Secondary text.
    secondary: 'rgba(0, 0, 0, 0.6)',
    // Disabled text have even lower visual prominence.
    disabled: 'rgba(0, 0, 0, 0.38)'
  },
  // The color used to divide different elements.
  divider: 'rgba(0, 0, 0, 0.12)',
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$1.white,
    default: common$1.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: 'rgba(0, 0, 0, 0.54)',
    // The color of an hovered action.
    hover: 'rgba(0, 0, 0, 0.04)',
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: 'rgba(0, 0, 0, 0.08)',
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: 'rgba(0, 0, 0, 0.26)',
    // The background color of a disabled action.
    disabledBackground: 'rgba(0, 0, 0, 0.12)',
    disabledOpacity: 0.38,
    focus: 'rgba(0, 0, 0, 0.12)',
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common$1.white,
    secondary: 'rgba(255, 255, 255, 0.7)',
    disabled: 'rgba(255, 255, 255, 0.5)',
    icon: 'rgba(255, 255, 255, 0.5)'
  },
  divider: 'rgba(255, 255, 255, 0.12)',
  background: {
    paper: '#121212',
    default: '#121212'
  },
  action: {
    active: common$1.white,
    hover: 'rgba(255, 255, 255, 0.08)',
    hoverOpacity: 0.08,
    selected: 'rgba(255, 255, 255, 0.16)',
    selectedOpacity: 0.16,
    disabled: 'rgba(255, 255, 255, 0.3)',
    disabledBackground: 'rgba(255, 255, 255, 0.12)',
    disabledOpacity: 0.38,
    focus: 'rgba(255, 255, 255, 0.12)',
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === 'light') {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === 'dark') {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: blue$1[200],
      light: blue$1[50],
      dark: blue$1[400]
    };
  }
  return {
    main: blue$1[700],
    light: blue$1[400],
    dark: blue$1[800]
  };
}
function getDefaultSecondary(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: purple$1[200],
      light: purple$1[50],
      dark: purple$1[400]
    };
  }
  return {
    main: purple$1[500],
    light: purple$1[300],
    dark: purple$1[700]
  };
}
function getDefaultError(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: red$1[500],
      light: red$1[300],
      dark: red$1[700]
    };
  }
  return {
    main: red$1[700],
    light: red$1[400],
    dark: red$1[800]
  };
}
function getDefaultInfo(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: lightBlue$1[400],
      light: lightBlue$1[300],
      dark: lightBlue$1[700]
    };
  }
  return {
    main: lightBlue$1[700],
    light: lightBlue$1[500],
    dark: lightBlue$1[900]
  };
}
function getDefaultSuccess(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: green$1[400],
      light: green$1[300],
      dark: green$1[700]
    };
  }
  return {
    main: green$1[800],
    light: green$1[500],
    dark: green$1[900]
  };
}
function getDefaultWarning(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: orange$1[400],
      light: orange$1[300],
      dark: orange$1[700]
    };
  }
  return {
    main: '#ed6c02',
    // closest to orange[800] that pass 3:1.
    light: orange$1[500],
    dark: orange$1[900]
  };
}
function createPalette(palette) {
  const {
      mode = 'light',
      contrastThreshold = 3,
      tonalOffset = 0.2
    } = palette,
    other = _objectWithoutPropertiesLoose(palette, _excluded$L);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);

  // Use the same logic as
  // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
  // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    if (process.env.NODE_ENV !== 'production') {
      const contrast = getContrastRatio(background, contrastText);
      if (contrast < 3) {
        console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, 'falls below the WCAG recommended absolute minimum contrast ratio of 3:1.', 'https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast'].join('\n'));
      }
    }
    return contrastText;
  }
  const augmentColor = ({
    color,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color = _extends({}, color);
    if (!color.main && color[mainShade]) {
      color.main = color[mainShade];
    }
    if (!color.hasOwnProperty('main')) {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${name ? ` (${name})` : ''} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.` : formatMuiErrorMessage(11, name ? ` (${name})` : '', mainShade));
    }
    if (typeof color.main !== 'string') {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${name ? ` (${name})` : ''} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage(12, name ? ` (${name})` : '', JSON.stringify(color.main)));
    }
    addLightOrDark(color, 'light', lightShade, tonalOffset);
    addLightOrDark(color, 'dark', darkShade, tonalOffset);
    if (!color.contrastText) {
      color.contrastText = getContrastText(color.main);
    }
    return color;
  };
  const modes = {
    dark,
    light
  };
  if (process.env.NODE_ENV !== 'production') {
    if (!modes[mode]) {
      console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
    }
  }
  const paletteOutput = deepmerge(_extends({
    // A collection of common colors.
    common: _extends({}, common$1),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: 'primary'
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: 'secondary',
      mainShade: 'A400',
      lightShade: 'A200',
      darkShade: 'A700'
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: 'error'
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: 'warning'
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: 'info'
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: 'success'
    }),
    // The grey colors.
    grey: grey$1,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}

const _excluded$K = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round$1(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: 'uppercase'
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';

/**
 * @see @link{https://m2.material.io/design/typography/the-type-system.html}
 * @see @link{https://m2.material.io/design/typography/understanding-typography.html}
 */
function createTypography(palette, typography) {
  const _ref = typeof typography === 'function' ? typography(palette) : typography,
    {
      fontFamily = defaultFontFamily,
      // The default font size of the Material Specification.
      fontSize = 14,
      // px
      fontWeightLight = 300,
      fontWeightRegular = 400,
      fontWeightMedium = 500,
      fontWeightBold = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize = 16,
      // Apply the CSS properties to all the variants.
      allVariants,
      pxToRem: pxToRem2
    } = _ref,
    other = _objectWithoutPropertiesLoose(_ref, _excluded$K);
  if (process.env.NODE_ENV !== 'production') {
    if (typeof fontSize !== 'number') {
      console.error('MUI: `fontSize` is required to be a number.');
    }
    if (typeof htmlFontSize !== 'number') {
      console.error('MUI: `htmlFontSize` is required to be a number.');
    }
  }
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || (size => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round$1(letterSpacing / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false // No need to clone deep
  });
}

const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(',');
}

// Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss
const shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
var shadows$1 = shadows;

const _excluded$J = ["duration", "easing", "delay"];
// Follow https://material.google.com/motion/duration-easing.html#duration-easing-natural-easing-curves
// to learn the context in which each easing should be used.
const easing = {
  // This is the most common easing curve.
  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
};

// Follow https://m2.material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
// to learn when use what timing
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height) {
  if (!height) {
    return 0;
  }
  const constant = height / 36;

  // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends({}, easing, inputTransitions.easing);
  const mergedDuration = _extends({}, duration, inputTransitions.duration);
  const create = (props = ['all'], options = {}) => {
    const {
        duration: durationOption = mergedDuration.standard,
        easing: easingOption = mergedEasing.easeInOut,
        delay = 0
      } = options,
      other = _objectWithoutPropertiesLoose(options, _excluded$J);
    if (process.env.NODE_ENV !== 'production') {
      const isString = value => typeof value === 'string';
      // IE11 support, replace with Number.isNaN
      // eslint-disable-next-line no-restricted-globals
      const isNumber = value => !isNaN(parseFloat(value));
      if (!isString(props) && !Array.isArray(props)) {
        console.error('MUI: Argument "props" must be a string or Array.');
      }
      if (!isNumber(durationOption) && !isString(durationOption)) {
        console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
      }
      if (!isString(easingOption)) {
        console.error('MUI: Argument "easing" must be a string.');
      }
      if (!isNumber(delay) && !isString(delay)) {
        console.error('MUI: Argument "delay" must be a number or a string.');
      }
      if (Object.keys(other).length !== 0) {
        console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(',')}].`);
      }
    }
    return (Array.isArray(props) ? props : [props]).map(animatedProp => `${animatedProp} ${typeof durationOption === 'string' ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === 'string' ? delay : formatMs(delay)}`).join(',');
  };
  return _extends({
    getAutoHeightDuration,
    create
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}

// We need to centralize the zIndex definitions as they work
// like global values in the browser.
const zIndex = {
  mobileStepper: 1000,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
var zIndex$1 = zIndex;

const _excluded$I = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
      mixins: mixinsInput = {},
      palette: paletteInput = {},
      transitions: transitionsInput = {},
      typography: typographyInput = {}
    } = options,
    other = _objectWithoutPropertiesLoose(options, _excluded$I);
  if (options.vars) {
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: \`vars\` is a private field used for CSS variables support.
Please use another name.` : formatMuiErrorMessage(18));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows$1.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends({}, zIndex$1)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  if (process.env.NODE_ENV !== 'production') {
    const stateClasses = ['active', 'checked', 'completed', 'disabled', 'error', 'expanded', 'focused', 'focusVisible', 'required', 'selected'];
    const traverse = (node, component) => {
      let key;

      // eslint-disable-next-line guard-for-in, no-restricted-syntax
      for (key in node) {
        const child = node[key];
        if (stateClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
          if (process.env.NODE_ENV !== 'production') {
            const stateClass = generateUtilityClass('', key);
            console.error([`MUI: The \`${component}\` component increases ` + `the CSS specificity of the \`${key}\` internal state.`, 'You can not override it like this: ', JSON.stringify(node, null, 2), '', `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), '', 'https://mui.com/r/state-classes-guide'].join('\n'));
          }
          // Remove the style to prevent global conflicts.
          node[key] = {};
        }
      }
    };
    Object.keys(muiTheme.components).forEach(component => {
      const styleOverrides = muiTheme.components[component].styleOverrides;
      if (styleOverrides && component.indexOf('Mui') === 0) {
        traverse(styleOverrides, component);
      }
    });
  }
  muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}

// Ported from Compass
// https://github.com/Compass/compass/blob/master/core/stylesheets/compass/typography/_units.scss
// Emulate the sass function "unit"
function getUnit(input) {
  return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || '';
}

// Emulate the sass function "unitless"
function toUnitless(length) {
  return parseFloat(length);
}

const defaultTheme = createTheme();
var defaultTheme$1 = defaultTheme;

function useTheme() {
  const theme = useTheme$1(defaultTheme$1);
  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__namespace.useDebugValue(theme);
  }
  return theme;
}

function useThemeProps({
  props,
  name
}) {
  return useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme$1
  });
}

const rootShouldForwardProp = prop => shouldForwardProp(prop) && prop !== 'classes';
const slotShouldForwardProp = shouldForwardProp;
const styled = createStyled({
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
var styled$1 = styled;

// Inspired by https://github.com/material-components/material-components-ios/blob/bca36107405594d5b7b16265a5b0ed698f85a5ee/components/Elevation/src/UIColor%2BMaterialElevation.m#L61
const getOverlayAlpha = elevation => {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return (alphaValue / 100).toFixed(2);
};
var getOverlayAlpha$1 = getOverlayAlpha;

var useEventCallback$1 = {};

var useEnhancedEffect$1 = {};

Object.defineProperty(useEnhancedEffect$1, "__esModule", {
  value: true
});
var default_1 = useEnhancedEffect$1.default = void 0;
var React$3 = _interopRequireWildcard$3(React$4);
function _getRequireWildcardCache$3(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache$3 = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard$3(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache$3(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const useEnhancedEffect = typeof window !== 'undefined' ? React$3.useLayoutEffect : React$3.useEffect;
var _default$3 = useEnhancedEffect;
default_1 = useEnhancedEffect$1.default = _default$3;

var _interopRequireDefault$1 = require$$0;
Object.defineProperty(useEventCallback$1, "__esModule", {
  value: true
});
var _default$2 = useEventCallback$1.default = useEventCallback;
var React$2 = _interopRequireWildcard$2(React$4);
var _useEnhancedEffect = _interopRequireDefault$1(useEnhancedEffect$1);
function _getRequireWildcardCache$2(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache$2 = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard$2(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache$2(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * https://github.com/facebook/react/issues/14099#issuecomment-440013892
 */
function useEventCallback(fn) {
  const ref = React$2.useRef(fn);
  (0, _useEnhancedEffect.default)(() => {
    ref.current = fn;
  });
  return React$2.useCallback((...args) =>
  // @ts-expect-error hide `this`
  // tslint:disable-next-line:ban-comma-operator
  (0, ref.current)(...args), []);
}

/**
 * Determines if a given element is a DOM element name (i.e. not a React component).
 */
function isHostComponent(element) {
  return typeof element === 'string';
}

/**
 * Type of the ownerState based on the type of an element it applies to.
 * This resolves to the provided OwnerState for React components and `undefined` for host components.
 * Falls back to `OwnerState | undefined` when the exact type can't be determined in development time.
 */

/**
 * Appends the ownerState object to the props, merging with the existing one if necessary.
 *
 * @param elementType Type of the element that owns the `existingProps`. If the element is a DOM node or undefined, `ownerState` is not applied.
 * @param otherProps Props of the element.
 * @param ownerState
 */
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === undefined || isHostComponent(elementType)) {
    return otherProps;
  }
  return _extends({}, otherProps, {
    ownerState: _extends({}, otherProps.ownerState, ownerState)
  });
}

/**
 * Extracts event handlers from a given object.
 * A prop is considered an event handler if it is a function and its name starts with `on`.
 *
 * @param object An object to extract event handlers from.
 * @param excludeKeys An array of keys to exclude from the returned object.
 */
function extractEventHandlers(object, excludeKeys = []) {
  if (object === undefined) {
    return {};
  }
  const result = {};
  Object.keys(object).filter(prop => prop.match(/^on[A-Z]/) && typeof object[prop] === 'function' && !excludeKeys.includes(prop)).forEach(prop => {
    result[prop] = object[prop];
  });
  return result;
}

/**
 * If `componentProps` is a function, calls it with the provided `ownerState`.
 * Otherwise, just returns `componentProps`.
 */
function resolveComponentProps(componentProps, ownerState) {
  if (typeof componentProps === 'function') {
    return componentProps(ownerState);
  }
  return componentProps;
}

/**
 * Removes event handlers from the given object.
 * A field is considered an event handler if it is a function with a name beginning with `on`.
 *
 * @param object Object to remove event handlers from.
 * @returns Object with event handlers removed.
 */
function omitEventHandlers(object) {
  if (object === undefined) {
    return {};
  }
  const result = {};
  Object.keys(object).filter(prop => !(prop.match(/^on[A-Z]/) && typeof object[prop] === 'function')).forEach(prop => {
    result[prop] = object[prop];
  });
  return result;
}

/**
 * Merges the slot component internal props (usually coming from a hook)
 * with the externally provided ones.
 *
 * The merge order is (the latter overrides the former):
 * 1. The internal props (specified as a getter function to work with get*Props hook result)
 * 2. Additional props (specified internally on an unstyled component)
 * 3. External props specified on the owner component. These should only be used on a root slot.
 * 4. External props specified in the `slotProps.*` prop.
 * 5. The `className` prop - combined from all the above.
 * @param parameters
 * @returns
 */
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    // The simpler case - getSlotProps is not defined, so no internal event handlers are defined,
    // so we can simply merge all the props without having to worry about extracting event handlers.
    const joinedClasses = clsx(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
    const mergedStyle = _extends({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props = _extends({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses.length > 0) {
      props.className = joinedClasses;
    }
    if (Object.keys(mergedStyle).length > 0) {
      props.style = mergedStyle;
    }
    return {
      props,
      internalRef: undefined
    };
  }

  // In this case, getSlotProps is responsible for calling the external event handlers.
  // We don't need to include them in the merged props because of this.

  const eventHandlers = extractEventHandlers(_extends({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);

  // The order of classes is important here.
  // Emotion (that we use in libraries consuming MUI Base) depends on this order
  // to properly override style. It requires the most important classes to be last
  // (see https://github.com/mui/material-ui/pull/33205) for the related discussion.
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}

const _excluded$H = ["elementType", "externalSlotProps", "ownerState"];
/**
 * Builds the props to be passed into the slot of an unstyled component.
 * It merges the internal props of the component with the ones supplied by the user, allowing to customize the behavior.
 * If the slot component is not a host component, it also merges in the `ownerState`.
 *
 * @param parameters.getSlotProps - A function that returns the props to be passed to the slot component.
 */
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
      elementType,
      externalSlotProps,
      ownerState
    } = parameters,
    rest = _objectWithoutPropertiesLoose(parameters, _excluded$H);
  const resolvedComponentsProps = resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef$2(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState(elementType, _extends({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}

/* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex */
// Inspired by https://github.com/focus-trap/tabbable
const candidatesSelector = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'].join(',');
function getTabIndex(node) {
  const tabindexAttr = parseInt(node.getAttribute('tabindex') || '', 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }

  // Browsers do not return `tabIndex` correctly for contentEditable nodes;
  // https://bugs.chromium.org/p/chromium/issues/detail?id=661108&q=contenteditable%20tabindex&can=2
  // so if they don't have a tabindex attribute specifically set, assume it's 0.
  // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
  //  yet they are still part of the regular tab order; in FF, they get a default
  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab
  //  order, consider their tab index to be 0.
  if (node.contentEditable === 'true' || (node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {
    return 0;
  }
  return node.tabIndex;
}
function isNonTabbableRadio(node) {
  if (node.tagName !== 'INPUT' || node.type !== 'radio') {
    return false;
  }
  if (!node.name) {
    return false;
  }
  const getRadio = selector => node.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node.name}"]`);
  }
  return roving !== node;
}
function isNodeMatchingSelectorFocusable(node) {
  if (node.disabled || node.tagName === 'INPUT' && node.type === 'hidden' || isNonTabbableRadio(node)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {
    const nodeTabIndex = getTabIndex(node);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node: node
      });
    }
  });
  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map(a => a.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}

/**
 * Utility component that locks focus inside the component.
 *
 * Demos:
 *
 * - [Focus Trap](https://mui.com/base/react-focus-trap/)
 *
 * API:
 *
 * - [FocusTrap API](https://mui.com/base/api/focus-trap/)
 */
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = React__namespace.useRef(false);
  const sentinelStart = React__namespace.useRef(null);
  const sentinelEnd = React__namespace.useRef(null);
  const nodeToRestore = React__namespace.useRef(null);
  const reactFocusEventTarget = React__namespace.useRef(null);
  // This variable is useful when disableAutoFocus is true.
  // It waits for the active element to move into the component to activate.
  const activated = React__namespace.useRef(false);
  const rootRef = React__namespace.useRef(null);
  // @ts-expect-error TODO upstream fix
  const handleRef = useForkRef$2(children.ref, rootRef);
  const lastKeydown = React__namespace.useRef(null);
  React__namespace.useEffect(() => {
    // We might render an empty child.
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  React__namespace.useEffect(() => {
    // We might render an empty child.
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute('tabIndex')) {
        if (process.env.NODE_ENV !== 'production') {
          console.error(['MUI: The modal content node does not accept focus.', 'For the benefit of assistive technologies, ' + 'the tabIndex of the node is being set to "-1".'].join('\n'));
        }
        rootRef.current.setAttribute('tabIndex', '-1');
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      // restoreLastFocus()
      if (!disableRestoreFocus) {
        // In IE11 it is possible for document.activeElement to be null resulting
        // in nodeToRestore.current being null.
        // Not all elements in IE11 have a focus method.
        // Once IE11 support is dropped the focus() call can be unconditional.
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
    // Missing `disableRestoreFocus` which is fine.
    // We don't support changing that prop on an open FocusTrap
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [open]);
  React__namespace.useEffect(() => {
    // We might render an empty child.
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const contain = nativeEvent => {
      const {
        current: rootElement
      } = rootRef;

      // Cleanup functions are executed lazily in React 17.
      // Contain can be called between the component being unmounted and its cleanup function being run.
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (!rootElement.contains(doc.activeElement)) {
        // if the focus event is not coming from inside the children's react tree, reset the refs
        if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
          reactFocusEventTarget.current = null;
        } else if (reactFocusEventTarget.current !== null) {
          return;
        }
        if (!activated.current) {
          return;
        }
        let tabbable = [];
        if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
          tabbable = getTabbable(rootRef.current);
        }
        if (tabbable.length > 0) {
          var _lastKeydown$current, _lastKeydown$current2;
          const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === 'Tab');
          const focusNext = tabbable[0];
          const focusPrevious = tabbable[tabbable.length - 1];
          if (typeof focusNext !== 'string' && typeof focusPrevious !== 'string') {
            if (isShiftTab) {
              focusPrevious.focus();
            } else {
              focusNext.focus();
            }
          }
        } else {
          rootElement.focus();
        }
      }
    };
    const loopFocus = nativeEvent => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== 'Tab') {
        return;
      }

      // Make sure the next tab starts from the right place.
      // doc.activeElement referes to the origin.
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        // We need to ignore the next contain as
        // it will try to move the focus back to the rootRef element.
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    doc.addEventListener('focusin', contain);
    doc.addEventListener('keydown', loopFocus, true);

    // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area.
    // e.g. https://bugzilla.mozilla.org/show_bug.cgi?id=559561.
    // Instead, we can look if the active element was restored on the BODY element.
    //
    // The whatwg spec defines how the browser should behave but does not explicitly mention any events:
    // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === 'BODY') {
        contain(null);
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener('focusin', contain);
      doc.removeEventListener('keydown', loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = event => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = event => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /*#__PURE__*/React__namespace.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /*#__PURE__*/jsxRuntime.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
process.env.NODE_ENV !== "production" ? FocusTrap.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1,
  /**
   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: propTypesExports.bool,
  /**
   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: propTypesExports.bool,
  /**
   * If `true`, the focus trap will not restore focus to previously focused element once
   * focus trap is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: propTypesExports.bool,
  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: propTypesExports.func,
  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple focus trap mounted at the same time.
   * @default function defaultIsEnabled(): boolean {
   *   return true;
   * }
   */
  isEnabled: propTypesExports.func,
  /**
   * If `true`, focus is locked.
   */
  open: propTypesExports.bool.isRequired
} : void 0;
if (process.env.NODE_ENV !== 'production') {
  // eslint-disable-next-line
  FocusTrap['propTypes' + ''] = exactProp(FocusTrap.propTypes);
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement$1(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement$1(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

var max = Math.max;
var min = Math.min;
var round = Math.round;

function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = isElement(element) ? getWindow(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());

  if (isIE && isHTMLElement$1(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement$1(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (process.env.NODE_ENV !== "production") {
    if (!isHTMLElement$1(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getVariation(placement) {
  return placement.split('-')[1];
}

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if (process.env.NODE_ENV !== "production") {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}

var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement$1(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;

    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement$1(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
    .filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

          break;

        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (modifier.effect != null && typeof modifier.effect !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (process.env.NODE_ENV !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);

          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = getComputedStyle(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (process.env.NODE_ENV !== "production") {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (process.env.NODE_ENV !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

function getContainer$1(container) {
  return typeof container === 'function' ? container() : container;
}

/**
 * Portals provide a first-class way to render children into a DOM node
 * that exists outside the DOM hierarchy of the parent component.
 */
const Portal = /*#__PURE__*/React__namespace.forwardRef(function Portal(props, ref) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = React__namespace.useState(null);
  const handleRef = useForkRef$2( /*#__PURE__*/React__namespace.isValidElement(children) ? children.ref : null, ref);
  useEnhancedEffect$3(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect$3(() => {
    if (mountNode && !disablePortal) {
      setRef$1(ref, mountNode);
      return () => {
        setRef$1(ref, null);
      };
    }
    return undefined;
  }, [ref, mountNode, disablePortal]);
  if (disablePortal) {
    if ( /*#__PURE__*/React__namespace.isValidElement(children)) {
      return /*#__PURE__*/React__namespace.cloneElement(children, {
        ref: handleRef
      });
    }
    return children;
  }
  return /*#__PURE__*/jsxRuntime.jsx(React__namespace.Fragment, {
    children: mountNode ? /*#__PURE__*/ReactDOM__namespace.createPortal(children, mountNode) : mountNode
  });
});
process.env.NODE_ENV !== "production" ? Portal.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The children to render into the `container`.
   */
  children: propTypesExports.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, propTypesExports.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: propTypesExports.bool
} : void 0;
if (process.env.NODE_ENV !== 'production') {
  // eslint-disable-next-line
  Portal['propTypes' + ''] = exactProp(Portal.propTypes);
}
var Portal$1 = Portal;

function getPopperUnstyledUtilityClass(slot) {
  return generateUtilityClass('MuiPopperUnstyled', slot);
}
generateUtilityClasses('MuiPopperUnstyled', ['root']);

const _excluded$G = ["anchorEl", "children", "component", "direction", "disablePortal", "modifiers", "open", "ownerState", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps"],
  _excluded2$2 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
function flipPlacement(placement, direction) {
  if (direction === 'ltr') {
    return placement;
  }
  switch (placement) {
    case 'bottom-end':
      return 'bottom-start';
    case 'bottom-start':
      return 'bottom-end';
    case 'top-end':
      return 'top-start';
    case 'top-start':
      return 'top-end';
    default:
      return placement;
  }
}
function resolveAnchorEl$1(anchorEl) {
  return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
}
function isHTMLElement(element) {
  return element.nodeType !== undefined;
}
function isVirtualElement(element) {
  return !isHTMLElement(element);
}
const useUtilityClasses$11 = () => {
  const slots = {
    root: ['root']
  };
  return composeClasses(slots, getPopperUnstyledUtilityClass, {});
};
const defaultPopperOptions = {};
const PopperTooltip = /*#__PURE__*/React__namespace.forwardRef(function PopperTooltip(props, ref) {
  var _ref;
  const {
      anchorEl,
      children,
      component,
      direction,
      disablePortal,
      modifiers,
      open,
      ownerState,
      placement: initialPlacement,
      popperOptions,
      popperRef: popperRefProp,
      slotProps = {},
      slots = {},
      TransitionProps
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$G);
  const tooltipRef = React__namespace.useRef(null);
  const ownRef = useForkRef$2(tooltipRef, ref);
  const popperRef = React__namespace.useRef(null);
  const handlePopperRef = useForkRef$2(popperRef, popperRefProp);
  const handlePopperRefRef = React__namespace.useRef(handlePopperRef);
  useEnhancedEffect$3(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  React__namespace.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  /**
   * placement initialized from prop but can change during lifetime if modifiers.flip.
   * modifiers.flip is essentially a flip for controlled/uncontrolled behavior
   */
  const [placement, setPlacement] = React__namespace.useState(rtlPlacement);
  const [resolvedAnchorElement, setResolvedAnchorElement] = React__namespace.useState(resolveAnchorEl$1(anchorEl));
  React__namespace.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  React__namespace.useEffect(() => {
    if (anchorEl) {
      setResolvedAnchorElement(resolveAnchorEl$1(anchorEl));
    }
  }, [anchorEl]);
  useEnhancedEffect$3(() => {
    if (!resolvedAnchorElement || !open) {
      return undefined;
    }
    const handlePopperUpdate = data => {
      setPlacement(data.placement);
    };
    if (process.env.NODE_ENV !== 'production') {
      if (resolvedAnchorElement && isHTMLElement(resolvedAnchorElement) && resolvedAnchorElement.nodeType === 1) {
        const box = resolvedAnchorElement.getBoundingClientRect();
        if (process.env.NODE_ENV !== 'test' && box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          console.warn(['MUI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      }
    }
    let popperModifiers = [{
      name: 'preventOverflow',
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: 'flip',
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: 'onUpdate',
      enabled: true,
      phase: 'afterWrite',
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper = createPopper(resolvedAnchorElement, tooltipRef.current, _extends({
      placement: rtlPlacement
    }, popperOptions, {
      modifiers: popperModifiers
    }));
    handlePopperRefRef.current(popper);
    return () => {
      popper.destroy();
      handlePopperRefRef.current(null);
    };
  }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
  const childProps = {
    placement: placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses$11();
  const Root = (_ref = component != null ? component : slots.root) != null ? _ref : 'div';
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: 'tooltip',
      ref: ownRef
    },
    ownerState: _extends({}, props, ownerState),
    className: classes.root
  });
  return /*#__PURE__*/jsxRuntime.jsx(Root, _extends({}, rootProps, {
    children: typeof children === 'function' ? children(childProps) : children
  }));
});

/**
 * Poppers rely on the 3rd party library [Popper.js](https://popper.js.org/docs/v2/) for positioning.
 *
 * Demos:
 *
 * - [Unstyled Popper](https://mui.com/base/react-popper/)
 *
 * API:
 *
 * - [PopperUnstyled API](https://mui.com/base/api/popper-unstyled/)
 */
const PopperUnstyled = /*#__PURE__*/React__namespace.forwardRef(function PopperUnstyled(props, ref) {
  const {
      anchorEl,
      children,
      container: containerProp,
      direction = 'ltr',
      disablePortal = false,
      keepMounted = false,
      modifiers,
      open,
      placement = 'bottom',
      popperOptions = defaultPopperOptions,
      popperRef,
      style,
      transition = false,
      slotProps = {},
      slots = {}
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded2$2);
  const [exited, setExited] = React__namespace.useState(true);
  const handleEnter = () => {
    setExited(false);
  };
  const handleExited = () => {
    setExited(true);
  };
  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }

  // If the container prop is provided, use that
  // If the anchorEl prop is provided, use its parent body element as the container
  // If neither are provided let the Modal take care of choosing the container
  let container;
  if (containerProp) {
    container = containerProp;
  } else if (anchorEl) {
    const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
    container = resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
  }
  const display = !open && keepMounted && (!transition || exited) ? 'none' : undefined;
  const transitionProps = transition ? {
    in: open,
    onEnter: handleEnter,
    onExited: handleExited
  } : undefined;
  return /*#__PURE__*/jsxRuntime.jsx(Portal$1, {
    disablePortal: disablePortal,
    container: container,
    children: /*#__PURE__*/jsxRuntime.jsx(PopperTooltip, _extends({
      anchorEl: anchorEl,
      direction: direction,
      disablePortal: disablePortal,
      modifiers: modifiers,
      ref: ref,
      open: transition ? !exited : open,
      placement: placement,
      popperOptions: popperOptions,
      popperRef: popperRef,
      slotProps: slotProps,
      slots: slots
    }, other, {
      style: _extends({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: 'fixed',
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display
      }, style),
      TransitionProps: transitionProps,
      children: children
    }))
  });
});
process.env.NODE_ENV !== "production" ? PopperUnstyled.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: chainPropTypes(propTypesExports.oneOfType([HTMLElementType, propTypesExports.object, propTypesExports.func]), props => {
    if (props.open) {
      const resolvedAnchorEl = resolveAnchorEl$1(props.anchorEl);
      if (resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) && resolvedAnchorEl.nodeType === 1) {
        const box = resolvedAnchorEl.getBoundingClientRect();
        if (process.env.NODE_ENV !== 'test' && box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          return new Error(['MUI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      } else if (!resolvedAnchorEl || typeof resolvedAnchorEl.getBoundingClientRect !== 'function' || isVirtualElement(resolvedAnchorEl) && resolvedAnchorEl.contextElement != null && resolvedAnchorEl.contextElement.nodeType !== 1) {
        return new Error(['MUI: The `anchorEl` prop provided to the component is invalid.', 'It should be an HTML element instance or a virtualElement ', '(https://popper.js.org/docs/v2/virtual-elements/).'].join('\n'));
      }
    }
    return null;
  }),
  /**
   * Popper render function or node.
   */
  children: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.node, propTypesExports.func]),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, propTypesExports.func]),
  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: propTypesExports.oneOf(['ltr', 'rtl']),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: propTypesExports.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: propTypesExports.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: propTypesExports.arrayOf(propTypesExports.shape({
    data: propTypesExports.object,
    effect: propTypesExports.func,
    enabled: propTypesExports.bool,
    fn: propTypesExports.func,
    name: propTypesExports.any,
    options: propTypesExports.object,
    phase: propTypesExports.oneOf(['afterMain', 'afterRead', 'afterWrite', 'beforeMain', 'beforeRead', 'beforeWrite', 'main', 'read', 'write']),
    requires: propTypesExports.arrayOf(propTypesExports.string),
    requiresIfExists: propTypesExports.arrayOf(propTypesExports.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: propTypesExports.bool.isRequired,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: propTypesExports.oneOf(['auto-end', 'auto-start', 'auto', 'bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: propTypesExports.shape({
    modifiers: propTypesExports.array,
    onFirstUpdate: propTypesExports.func,
    placement: propTypesExports.oneOf(['auto-end', 'auto-start', 'auto', 'bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),
    strategy: propTypesExports.oneOf(['absolute', 'fixed'])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: refType$1,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: propTypesExports.shape({
    root: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: propTypesExports.shape({
    root: propTypesExports.elementType
  }),
  /**
   * @ignore
   */
  style: propTypesExports.object,
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: propTypesExports.bool
} : void 0;
var PopperUnstyled$1 = PopperUnstyled;

// Is a vertical scrollbar displayed?
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute('aria-hidden', 'true');
  } else {
    element.removeAttribute('aria-hidden');
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  // The forbidden HTML tags are the ones from ARIA specification that
  // can be children of body and can't have aria-hidden attribute.
  // cf. https://www.w3.org/TR/html-aria/#docconformance
  const forbiddenTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE', 'LINK', 'MAP', 'META', 'NOSCRIPT', 'PICTURE', 'COL', 'COLGROUP', 'PARAM', 'SLOT', 'SOURCE', 'TRACK'];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, element => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index) => {
    if (callback(item)) {
      idx = index;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      // Compute the size before applying overflow hidden to avoid any scroll jumps.
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: 'padding-right',
        el: container
      });
      // Use computed style, here to get the real padding to add our scrollbar width.
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;

      // .mui-fixed is a global helper.
      const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');
      [].forEach.call(fixedElements, element => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: 'padding-right',
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      // Improve Gatsby support
      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;
    }

    // Block the scroll even if no scrollbar is visible to account for mobile keyboard
    // screensize shrink.
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: 'overflow',
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: 'overflow-x',
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: 'overflow-y',
      el: scrollContainer
    });
    scrollContainer.style.overflow = 'hidden';
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      if (value) {
        el.style.setProperty(property, value);
      } else {
        el.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, element => {
    if (element.getAttribute('aria-hidden') === 'true') {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
/**
 * @ignore - do not document.
 *
 * Proper state management for containers and the modals in those containers.
 * Simplified, but inspired by react-overlay's ModalManager class.
 * Used by the Modal to ensure proper styling of containers.
 */
class ModalManager {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);

    // If the modal we are adding is already in the DOM.
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, item => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);

    // If that was the last modal in a container, clean up the container.
    if (containerInfo.modals.length === 0) {
      // The modal might be closed before it had the chance to be mounted in the DOM.
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        // In case the modal wasn't in the DOM yet.
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      // Otherwise make sure the next top modal is visible to a screen reader.
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      // as soon as a modal is adding its modalRef is undefined. it can't set
      // aria-hidden because the dom element doesn't exist either
      // when modal was unmounted before modalRef gets null
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}

function getModalUtilityClass(slot) {
  return generateUtilityClass('MuiModal', slot);
}
generateUtilityClasses('MuiModal', ['root', 'hidden']);

const _excluded$F = ["children", "classes", "closeAfterTransition", "component", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"];
const useUtilityClasses$10 = ownerState => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ['root', !open && exited && 'hidden'],
    backdrop: ['backdrop']
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
function getContainer(container) {
  return typeof container === 'function' ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty('in') : false;
}

// A modal manager used to track and manage the state of open Modals.
// Modals don't open on the server so this won't conflict with concurrent requests.
const defaultManager = new ModalManager();

/**
 * Modal is a lower-level construct that is leveraged by the following components:
 *
 * *   [Dialog](https://mui.com/material-ui/api/dialog/)
 * *   [Drawer](https://mui.com/material-ui/api/drawer/)
 * *   [Menu](https://mui.com/material-ui/api/menu/)
 * *   [Popover](https://mui.com/material-ui/api/popover/)
 *
 * If you are creating a modal dialog, you probably want to use the [Dialog](https://mui.com/material-ui/api/dialog/) component
 * rather than directly using Modal.
 *
 * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
 *
 * Demos:
 *
 * - [Unstyled Modal](https://mui.com/base/react-modal/)
 *
 * API:
 *
 * - [ModalUnstyled API](https://mui.com/base/api/modal-unstyled/)
 */
const ModalUnstyled = /*#__PURE__*/React__namespace.forwardRef(function ModalUnstyled(props, forwardedRef) {
  var _props$ariaHidden, _ref;
  const {
      children,
      classes: classesProp,
      closeAfterTransition = false,
      component,
      container,
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableEscapeKeyDown = false,
      disablePortal = false,
      disableRestoreFocus = false,
      disableScrollLock = false,
      hideBackdrop = false,
      keepMounted = false,
      // private
      manager = defaultManager,
      onBackdropClick,
      onClose,
      onKeyDown,
      open,
      onTransitionEnter,
      onTransitionExited,
      slotProps = {},
      slots = {}
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$F);
  const [exited, setExited] = React__namespace.useState(!open);
  const modal = React__namespace.useRef({});
  const mountNodeRef = React__namespace.useRef(null);
  const modalRef = React__namespace.useRef(null);
  const handleRef = useForkRef$2(modalRef, forwardedRef);
  const hasTransition = getHasTransition(children);
  const ariaHiddenProp = (_props$ariaHidden = props['aria-hidden']) != null ? _props$ariaHidden : true;
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mountNode = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });

    // Fix a bug on Chrome where the scroll isn't initially 0.
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback$2(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);

    // The element was already mounted.
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = React__namespace.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback$2(node => {
    mountNodeRef.current = node;
    if (!node || !modalRef.current) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = React__namespace.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [manager, ariaHiddenProp]);
  React__namespace.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  React__namespace.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const ownerState = _extends({}, props, {
    classes: classesProp,
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    exited,
    hideBackdrop,
    keepMounted
  });
  const classes = useUtilityClasses$10(ownerState);
  const handleEnter = () => {
    setExited(false);
    if (onTransitionEnter) {
      onTransitionEnter();
    }
  };
  const handleExited = () => {
    setExited(true);
    if (onTransitionExited) {
      onTransitionExited();
    }
    if (closeAfterTransition) {
      handleClose();
    }
  };
  const handleBackdropClick = event => {
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, 'backdropClick');
    }
  };
  const handleKeyDown = event => {
    if (onKeyDown) {
      onKeyDown(event);
    }

    // The handler doesn't take event.defaultPrevented into account:
    //
    // event.preventDefault() is meant to stop default behaviors like
    // clicking a checkbox to check it, hitting a button to submit a form,
    // and hitting left arrow to move the cursor in a text input etc.
    // Only special HTML elements have these default behaviors.
    if (event.key !== 'Escape' || !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      // Swallow the event, in case someone is listening for the escape key on the body.
      event.stopPropagation();
      if (onClose) {
        onClose(event, 'escapeKeyDown');
      }
    }
  };
  const childProps = {};
  if (children.props.tabIndex === undefined) {
    childProps.tabIndex = '-1';
  }

  // It's a Transition like component
  if (hasTransition) {
    childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
    childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
  }
  const Root = (_ref = component != null ? component : slots.root) != null ? _ref : 'div';
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref: handleRef,
      role: 'presentation',
      onKeyDown: handleKeyDown
    },
    className: classes.root,
    ownerState
  });
  const BackdropComponent = slots.backdrop;
  const backdropProps = useSlotProps({
    elementType: BackdropComponent,
    externalSlotProps: slotProps.backdrop,
    additionalProps: {
      'aria-hidden': true,
      onClick: handleBackdropClick,
      open
    },
    className: classes.backdrop,
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /*#__PURE__*/jsxRuntime.jsx(Portal$1
  // @ts-expect-error TODO: include ref to MUI Base Portal props
  , {
    ref: handlePortalRef,
    container: container,
    disablePortal: disablePortal,
    children: /*#__PURE__*/jsxRuntime.jsxs(Root, _extends({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? /*#__PURE__*/jsxRuntime.jsx(BackdropComponent, _extends({}, backdropProps)) : null, /*#__PURE__*/jsxRuntime.jsx(FocusTrap, {
        disableEnforceFocus: disableEnforceFocus,
        disableAutoFocus: disableAutoFocus,
        disableRestoreFocus: disableRestoreFocus,
        isEnabled: isTopModal,
        open: open,
        children: /*#__PURE__*/React__namespace.cloneElement(children, childProps)
      })]
    }))
  });
});
process.env.NODE_ENV !== "production" ? ModalUnstyled.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: propTypesExports.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, propTypesExports.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: propTypesExports.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: propTypesExports.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: propTypesExports.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: propTypesExports.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: propTypesExports.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: propTypesExports.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: propTypesExports.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: propTypesExports.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: propTypesExports.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: propTypesExports.func,
  /**
   * @ignore
   */
  onKeyDown: propTypesExports.func,
  /**
   * If `true`, the component is shown.
   */
  open: propTypesExports.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: propTypesExports.shape({
    backdrop: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object]),
    root: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: propTypesExports.shape({
    backdrop: propTypesExports.elementType,
    root: propTypesExports.elementType
  })
} : void 0;
var ModalUnstyled$1 = ModalUnstyled;

const _excluded$E = ["onChange", "maxRows", "minRows", "style", "value"];
function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}
const styles$3 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: 'hidden',
    // Remove from the content flow
    position: 'absolute',
    // Ignore the scrollbar width
    overflow: 'hidden',
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: 'translateZ(0)'
  }
};
function isEmpty$1(obj) {
  return obj === undefined || obj === null || Object.keys(obj).length === 0;
}
const TextareaAutosize = /*#__PURE__*/React__namespace.forwardRef(function TextareaAutosize(props, ref) {
  const {
      onChange,
      maxRows,
      minRows = 1,
      style,
      value
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$E);
  const {
    current: isControlled
  } = React__namespace.useRef(value != null);
  const inputRef = React__namespace.useRef(null);
  const handleRef = useForkRef$2(ref, inputRef);
  const shadowRef = React__namespace.useRef(null);
  const renders = React__namespace.useRef(0);
  const [state, setState] = React__namespace.useState({});
  const getUpdatedState = React__namespace.useCallback(() => {
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    const computedStyle = containerWindow.getComputedStyle(input);

    // If input's width is shrunk and it's not visible, don't sync height.
    if (computedStyle.width === '0px') {
      return {};
    }
    const inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || 'x';
    if (inputShallow.value.slice(-1) === '\n') {
      // Certain fonts which overflow the line height will cause the textarea
      // to report a different scrollHeight depending on whether the last line
      // is empty. Make it non-empty to avoid this issue.
      inputShallow.value += ' ';
    }
    const boxSizing = computedStyle['box-sizing'];
    const padding = getStyleValue(computedStyle, 'padding-bottom') + getStyleValue(computedStyle, 'padding-top');
    const border = getStyleValue(computedStyle, 'border-bottom-width') + getStyleValue(computedStyle, 'border-top-width');

    // The height of the inner content
    const innerHeight = inputShallow.scrollHeight;

    // Measure height of a textarea with a single row
    inputShallow.value = 'x';
    const singleRowHeight = inputShallow.scrollHeight;

    // The height of the outer content
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);

    // Take the box sizing into account for applying this value as a style.
    const outerHeightStyle = outerHeight + (boxSizing === 'border-box' ? padding + border : 0);
    const overflow = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflow
    };
  }, [maxRows, minRows, props.placeholder]);
  const updateState = (prevState, newState) => {
    const {
      outerHeightStyle,
      overflow
    } = newState;
    // Need a large enough difference to update the height.
    // This prevents infinite rendering loop.
    if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
      renders.current += 1;
      return {
        overflow,
        outerHeightStyle
      };
    }
    if (process.env.NODE_ENV !== 'production') {
      if (renders.current === 20) {
        console.error(['MUI: Too many re-renders. The layout is unstable.', 'TextareaAutosize limits the number of renders to prevent an infinite loop.'].join('\n'));
      }
    }
    return prevState;
  };
  const syncHeight = React__namespace.useCallback(() => {
    const newState = getUpdatedState();
    if (isEmpty$1(newState)) {
      return;
    }
    setState(prevState => {
      return updateState(prevState, newState);
    });
  }, [getUpdatedState]);
  const syncHeightWithFlushSycn = () => {
    const newState = getUpdatedState();
    if (isEmpty$1(newState)) {
      return;
    }

    // In React 18, state updates in a ResizeObserver's callback are happening after the paint which causes flickering
    // when doing some visual updates in it. Using flushSync ensures that the dom will be painted after the states updates happen
    // Related issue - https://github.com/facebook/react/issues/24331
    ReactDOM.flushSync(() => {
      setState(prevState => {
        return updateState(prevState, newState);
      });
    });
  };
  React__namespace.useEffect(() => {
    const handleResize = debounce$1(() => {
      renders.current = 0;

      // If the TextareaAutosize component is replaced by Suspense with a fallback, the last
      // ResizeObserver's handler that runs because of the change in the layout is trying to
      // access a dom node that is no longer there (as the fallback component is being shown instead).
      // See https://github.com/mui/material-ui/issues/32640
      if (inputRef.current) {
        syncHeightWithFlushSycn();
      }
    });
    const containerWindow = ownerWindow(inputRef.current);
    containerWindow.addEventListener('resize', handleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== 'undefined') {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(inputRef.current);
    }
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener('resize', handleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  });
  useEnhancedEffect$3(() => {
    syncHeight();
  });
  React__namespace.useEffect(() => {
    renders.current = 0;
  }, [value]);
  const handleChange = event => {
    renders.current = 0;
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx("textarea", _extends({
      value: value,
      onChange: handleChange,
      ref: handleRef
      // Apply the rows prop to get a "correct" first SSR paint
      ,
      rows: minRows,
      style: _extends({
        height: state.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: state.overflow ? 'hidden' : null
      }, style)
    }, other)), /*#__PURE__*/jsxRuntime.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: _extends({}, styles$3.shadow, style, {
        padding: 0
      })
    })]
  });
});
process.env.NODE_ENV !== "production" ? TextareaAutosize.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * Maximum number of rows to display.
   */
  maxRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * Minimum number of rows to display.
   * @default 1
   */
  minRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * @ignore
   */
  onChange: propTypesExports.func,
  /**
   * @ignore
   */
  placeholder: propTypesExports.string,
  /**
   * @ignore
   */
  style: propTypesExports.object,
  /**
   * @ignore
   */
  value: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.string), propTypesExports.number, propTypesExports.string])
} : void 0;
var TextareaAutosize$1 = TextareaAutosize;

/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}

function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}

var config = {
  disabled: false
};

var timeoutsShape = process.env.NODE_ENV !== 'production' ? propTypesExports.oneOfType([propTypesExports.number, propTypesExports.shape({
  enter: propTypesExports.number,
  exit: propTypesExports.number,
  appear: propTypesExports.number
}).isRequired]) : null;
var classNamesShape = process.env.NODE_ENV !== 'production' ? propTypesExports.oneOfType([propTypesExports.string, propTypesExports.shape({
  enter: propTypesExports.string,
  exit: propTypesExports.string,
  active: propTypesExports.string
}), propTypesExports.shape({
  enter: propTypesExports.string,
  enterDone: propTypesExports.string,
  enterActive: propTypesExports.string,
  exit: propTypesExports.string,
  exitDone: propTypesExports.string,
  exitActive: propTypesExports.string
})]) : null;

var TransitionGroupContext = React$4.createContext(null);

var forceReflow = function forceReflow(node) {
  return node.scrollTop;
};

var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749
          // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.
          // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.

          if (node) forceReflow(node);
        }

        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : ReactDOM.findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      React$4.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : React$4.cloneElement(React$4.Children.only(children), childProps))
    );
  };

  return Transition;
}(React$4.Component);

Transition.contextType = TransitionGroupContext;
Transition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: propTypesExports.shape({
    current: typeof Element === 'undefined' ? propTypesExports.any : function (propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return propTypesExports.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),

  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: propTypesExports.oneOfType([propTypesExports.func.isRequired, propTypesExports.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: propTypesExports.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: propTypesExports.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: propTypesExports.bool,

  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: propTypesExports.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: propTypesExports.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: propTypesExports.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener) pt = pt.isRequired;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return pt.apply(void 0, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: propTypesExports.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: propTypesExports.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: propTypesExports.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: propTypesExports.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: propTypesExports.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: propTypesExports.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: propTypesExports.func
} : {}; // Name the function so it is clearer in the documentation

function noop$1() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;

var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return addClass(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return removeClass$1(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument[0],
          appearing = _this$resolveArgument[1];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };

    _this.onEntering = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument2[0],
          appearing = _this$resolveArgument2[1];

      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };

    _this.onEntered = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument3[0],
          appearing = _this$resolveArgument3[1];

      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };

    _this.onExit = function (maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument4[0];

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };

    _this.onExiting = function (maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument5[0];

      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };

    _this.onExited = function (maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument6[0];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };

    _this.resolveArguments = function (maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
      : [maybeNode, maybeAppearing];
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    var _this$getClassNames = this.getClassNames('enter'),
        doneClassName = _this$getClassNames.doneClassName;

    if (type === 'appear' && phase === 'done' && doneClassName) {
      className += " " + doneClassName;
    } // This is to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      if (node) forceReflow(node);
    }

    if (className) {
      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    }
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      removeClass(node, baseClassName);
    }

    if (activeClassName) {
      removeClass(node, activeClassName);
    }

    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props;
        _this$props.classNames;
        var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);

    return /*#__PURE__*/React$4.createElement(Transition$1, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(React$4.Component);

CSSTransition.defaultProps = {
  classNames: ''
};
CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? _extends({}, Transition$1.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: propTypesExports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: propTypesExports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: propTypesExports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: propTypesExports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: propTypesExports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: propTypesExports.func
}) : {};
var CSSTransition$1 = CSSTransition;

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */

function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && React$4.isValidElement(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) React$4.Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return React$4.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!React$4.isValidElement(child)) return;
    var hasPrev = (key in prevChildMapping);
    var hasNext = (key in nextChildMapping);
    var prevChild = prevChildMapping[key];
    var isLeaving = React$4.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = React$4.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = React$4.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && React$4.isValidElement(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = React$4.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */

var TransitionGroup = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized$w(_this)); // Initial children should all be entering, dependent on appear


    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  } // node is `undefined` when user provided `nodeRef` prop
  ;

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return /*#__PURE__*/React$4.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }

    return /*#__PURE__*/React$4.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /*#__PURE__*/React$4.createElement(Component, props, children));
  };

  return TransitionGroup;
}(React$4.Component);

TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: propTypesExports.any,

  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: propTypesExports.node,

  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: propTypesExports.bool,

  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: propTypesExports.bool,

  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: propTypesExports.bool,

  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: propTypesExports.func
} : {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup$1 = TransitionGroup;

function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = React__namespace.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  React__namespace.useEffect(() => {
    if (!inProp && onExited != null) {
      // react-transition-group#onExited
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return undefined;
  }, [onExited, inProp, timeout]);
  return /*#__PURE__*/jsxRuntime.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /*#__PURE__*/jsxRuntime.jsx("span", {
      className: childClassName
    })
  });
}
process.env.NODE_ENV !== "production" ? Ripple.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: propTypesExports.object.isRequired,
  className: propTypesExports.string,
  /**
   * @ignore - injected from TransitionGroup
   */
  in: propTypesExports.bool,
  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: propTypesExports.func,
  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: propTypesExports.bool,
  /**
   * Diameter of the ripple.
   */
  rippleSize: propTypesExports.number,
  /**
   * Horizontal position of the ripple center.
   */
  rippleX: propTypesExports.number,
  /**
   * Vertical position of the ripple center.
   */
  rippleY: propTypesExports.number,
  /**
   * exit delay
   */
  timeout: propTypesExports.number.isRequired
} : void 0;

const touchRippleClasses = generateUtilityClasses('MuiTouchRipple', ['root', 'ripple', 'rippleVisible', 'ripplePulsate', 'child', 'childLeaving', 'childPulsate']);
var touchRippleClasses$1 = touchRippleClasses;

const _excluded$D = ["center", "classes", "className"];
let _$1 = t => t,
  _t$1,
  _t2$1,
  _t3$1,
  _t4$1;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes(_t$1 || (_t$1 = _$1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
const exitKeyframe = keyframes(_t2$1 || (_t2$1 = _$1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
const pulsateKeyframe = keyframes(_t3$1 || (_t3$1 = _$1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
const TouchRippleRoot = styled$1('span', {
  name: 'MuiTouchRipple',
  slot: 'Root'
})({
  overflow: 'hidden',
  pointerEvents: 'none',
  position: 'absolute',
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: 'inherit'
});

// This `styled()` function invokes keyframes. `styled-components` only supports keyframes
// in string templates. Do not convert these styles in JS object as it will break.
const TouchRippleRipple = styled$1(Ripple, {
  name: 'MuiTouchRipple',
  slot: 'Ripple'
})(_t4$1 || (_t4$1 = _$1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
  theme
}) => theme.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
  theme
}) => theme.transitions.easing.easeInOut);

/**
 * @ignore - internal component.
 *
 * TODO v5: Make private
 */
const TouchRipple = /*#__PURE__*/React__namespace.forwardRef(function TouchRipple(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiTouchRipple'
  });
  const {
      center: centerProp = false,
      classes = {},
      className
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$D);
  const [ripples, setRipples] = React__namespace.useState([]);
  const nextKey = React__namespace.useRef(0);
  const rippleCallback = React__namespace.useRef(null);
  React__namespace.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);

  // Used to filter out mouse emulated events on mobile.
  const ignoringMouseDown = React__namespace.useRef(false);
  // We use a timer in order to only show the ripples for touch "click" like events.
  // We don't want to display the ripple for touch scroll events.
  const startTimer = React__namespace.useRef(null);

  // This is the hook called once the previous timeout is ready.
  const startTimerCommit = React__namespace.useRef(null);
  const container = React__namespace.useRef(null);
  React__namespace.useEffect(() => {
    return () => {
      clearTimeout(startTimer.current);
    };
  }, []);
  const startCommit = React__namespace.useCallback(params => {
    const {
      pulsate,
      rippleX,
      rippleY,
      rippleSize,
      cb
    } = params;
    setRipples(oldRipples => [...oldRipples, /*#__PURE__*/jsxRuntime.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses$1.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses$1.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses$1.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses$1.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses$1.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses$1.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate,
      rippleX: rippleX,
      rippleY: rippleY,
      rippleSize: rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb;
  }, [classes]);
  const start = React__namespace.useCallback((event = {}, options = {}, cb = () => {}) => {
    const {
      pulsate = false,
      center = centerProp || options.pulsate,
      fakeElement = false // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === 'mousedown' && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === 'touchstart') {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };

    // Get the size of the ripple
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === undefined || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);

      // For some reason the animation is broken on Mobile Chrome if the size is even.
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }

    // Touche devices
    if (event != null && event.touches) {
      // check that this isn't another touchstart due to multitouch
      // otherwise we will only clear a single timer when unmounting while two
      // are running
      if (startTimerCommit.current === null) {
        // Prepare the ripple effect.
        startTimerCommit.current = () => {
          startCommit({
            pulsate,
            rippleX,
            rippleY,
            rippleSize,
            cb
          });
        };
        // Delay the execution of the ripple effect.
        startTimer.current = setTimeout(() => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        }, DELAY_RIPPLE); // We have to make a tradeoff with this value.
      }
    } else {
      startCommit({
        pulsate,
        rippleX,
        rippleY,
        rippleSize,
        cb
      });
    }
  }, [centerProp, startCommit]);
  const pulsate = React__namespace.useCallback(() => {
    start({}, {
      pulsate: true
    });
  }, [start]);
  const stop = React__namespace.useCallback((event, cb) => {
    clearTimeout(startTimer.current);

    // The touch interaction occurs too quickly.
    // We still want to show ripple effect.
    if ((event == null ? void 0 : event.type) === 'touchend' && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.current = setTimeout(() => {
        stop(event, cb);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples(oldRipples => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb;
  }, []);
  React__namespace.useImperativeHandle(ref, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]);
  return /*#__PURE__*/jsxRuntime.jsx(TouchRippleRoot, _extends({
    className: clsx(touchRippleClasses$1.root, classes.root, className),
    ref: container
  }, other, {
    children: /*#__PURE__*/jsxRuntime.jsx(TransitionGroup$1, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
process.env.NODE_ENV !== "production" ? TouchRipple.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: propTypesExports.bool,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string
} : void 0;
var TouchRipple$1 = TouchRipple;

function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass('MuiButtonBase', slot);
}
const buttonBaseClasses = generateUtilityClasses('MuiButtonBase', ['root', 'disabled', 'focusVisible']);
var buttonBaseClasses$1 = buttonBaseClasses;

const _excluded$C = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
const useUtilityClasses$$ = ownerState => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', focusVisible && 'focusVisible']
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled$1('button', {
  name: 'MuiButtonBase',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({
  display: 'inline-flex',
  alignItems: 'center',
  justifyContent: 'center',
  position: 'relative',
  boxSizing: 'border-box',
  WebkitTapHighlightColor: 'transparent',
  backgroundColor: 'transparent',
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: 'pointer',
  userSelect: 'none',
  verticalAlign: 'middle',
  MozAppearance: 'none',
  // Reset
  WebkitAppearance: 'none',
  // Reset
  textDecoration: 'none',
  // So we take precedent over the style of a native <a /> element.
  color: 'inherit',
  '&::-moz-focus-inner': {
    borderStyle: 'none' // Remove Firefox dotted outline.
  },

  [`&.${buttonBaseClasses$1.disabled}`]: {
    pointerEvents: 'none',
    // Disable link interactions
    cursor: 'default'
  },
  '@media print': {
    colorAdjust: 'exact'
  }
});

/**
 * `ButtonBase` contains as few styles as possible.
 * It aims to be a simple building block for creating a button.
 * It contains a load of style reset and some focus/ripple logic.
 */
const ButtonBase = /*#__PURE__*/React__namespace.forwardRef(function ButtonBase(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiButtonBase'
  });
  const {
      action,
      centerRipple = false,
      children,
      className,
      component = 'button',
      disabled = false,
      disableRipple = false,
      disableTouchRipple = false,
      focusRipple = false,
      LinkComponent = 'a',
      onBlur,
      onClick,
      onContextMenu,
      onDragLeave,
      onFocus,
      onFocusVisible,
      onKeyDown,
      onKeyUp,
      onMouseDown,
      onMouseLeave,
      onMouseUp,
      onTouchEnd,
      onTouchMove,
      onTouchStart,
      tabIndex = 0,
      TouchRippleProps,
      touchRippleRef,
      type
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$C);
  const buttonRef = React__namespace.useRef(null);
  const rippleRef = React__namespace.useRef(null);
  const handleRippleRef = useForkRef$2(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = React__namespace.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  React__namespace.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = React__namespace.useState(false);
  React__namespace.useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  React__namespace.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback$2(event => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  const handleMouseDown = useRippleHandler('start', onMouseDown);
  const handleContextMenu = useRippleHandler('stop', onContextMenu);
  const handleDragLeave = useRippleHandler('stop', onDragLeave);
  const handleMouseUp = useRippleHandler('stop', onMouseUp);
  const handleMouseLeave = useRippleHandler('stop', event => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler('start', onTouchStart);
  const handleTouchEnd = useRippleHandler('stop', onTouchEnd);
  const handleTouchMove = useRippleHandler('stop', onTouchMove);
  const handleBlur = useRippleHandler('stop', event => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback$2(event => {
    // Fix for https://github.com/facebook/react/issues/7769
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== 'button' && !(button.tagName === 'A' && button.href);
  };

  /**
   * IE11 shim for https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat
   */
  const keydownRef = React__namespace.useRef(false);
  const handleKeyDown = useEventCallback$2(event => {
    // Check if key is already down to avoid repeats being counted as multiple activations
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === ' ') {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === ' ') {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }

    // Keyboard accessibility for non interactive elements
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === 'Enter' && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback$2(event => {
    // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
    // https://codesandbox.io/s/button-keyup-preventdefault-dn7f0
    if (focusRipple && event.key === ' ' && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }

    // Keyboard accessibility for non interactive elements
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === ' ' && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === 'button' && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === 'button') {
    buttonProps.type = type === undefined ? 'button' : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = 'button';
    }
    if (disabled) {
      buttonProps['aria-disabled'] = disabled;
    }
  }
  const handleRef = useForkRef$2(ref, focusVisibleRef, buttonRef);
  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__namespace.useEffect(() => {
      if (enableTouchRipple && !rippleRef.current) {
        console.error(['MUI: The `component` prop provided to ButtonBase is invalid.', 'Please make sure the children prop is rendered in this custom component.'].join('\n'));
      }
    }, [enableTouchRipple]);
  }
  const ownerState = _extends({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses$$(ownerState);
  return /*#__PURE__*/jsxRuntime.jsxs(ButtonBaseRoot, _extends({
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState: ownerState,
    onBlur: handleBlur,
    onClick: onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type: type
  }, buttonProps, other, {
    children: [children, enableTouchRipple ?
    /*#__PURE__*/
    /* TouchRipple is only needed client-side, x2 boost on the server. */
    jsxRuntime.jsx(TouchRipple$1, _extends({
      ref: handleRippleRef,
      center: centerRipple
    }, TouchRippleProps)) : null]
  }));
});
process.env.NODE_ENV !== "production" ? ButtonBase.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: refType$1,
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: propTypesExports.bool,
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: elementTypeAcceptingRef$1,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: propTypesExports.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: propTypesExports.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: propTypesExports.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: propTypesExports.string,
  /**
   * @ignore
   */
  href: propTypesExports /* @typescript-to-proptypes-ignore */.any,
  /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */
  LinkComponent: propTypesExports.elementType,
  /**
   * @ignore
   */
  onBlur: propTypesExports.func,
  /**
   * @ignore
   */
  onClick: propTypesExports.func,
  /**
   * @ignore
   */
  onContextMenu: propTypesExports.func,
  /**
   * @ignore
   */
  onDragLeave: propTypesExports.func,
  /**
   * @ignore
   */
  onFocus: propTypesExports.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: propTypesExports.func,
  /**
   * @ignore
   */
  onKeyDown: propTypesExports.func,
  /**
   * @ignore
   */
  onKeyUp: propTypesExports.func,
  /**
   * @ignore
   */
  onMouseDown: propTypesExports.func,
  /**
   * @ignore
   */
  onMouseLeave: propTypesExports.func,
  /**
   * @ignore
   */
  onMouseUp: propTypesExports.func,
  /**
   * @ignore
   */
  onTouchEnd: propTypesExports.func,
  /**
   * @ignore
   */
  onTouchMove: propTypesExports.func,
  /**
   * @ignore
   */
  onTouchStart: propTypesExports.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * @default 0
   */
  tabIndex: propTypesExports.number,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: propTypesExports.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.shape({
    current: propTypesExports.shape({
      pulsate: propTypesExports.func.isRequired,
      start: propTypesExports.func.isRequired,
      stop: propTypesExports.func.isRequired
    })
  })]),
  /**
   * @ignore
   */
  type: propTypesExports.oneOfType([propTypesExports.oneOf(['button', 'reset', 'submit']), propTypesExports.string])
} : void 0;
var ButtonBase$1 = ButtonBase;

function getIconButtonUtilityClass(slot) {
  return generateUtilityClass('MuiIconButton', slot);
}
const iconButtonClasses = generateUtilityClasses('MuiIconButton', ['root', 'disabled', 'colorInherit', 'colorPrimary', 'colorSecondary', 'colorError', 'colorInfo', 'colorSuccess', 'colorWarning', 'edgeStart', 'edgeEnd', 'sizeSmall', 'sizeMedium', 'sizeLarge']);
var iconButtonClasses$1 = iconButtonClasses;

const _excluded$B = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
const useUtilityClasses$_ = ownerState => {
  const {
    classes,
    disabled,
    color,
    edge,
    size
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', color !== 'default' && `color${capitalize(color)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled$1(ButtonBase$1, {
  name: 'MuiIconButton',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.color !== 'default' && styles[`color${capitalize(ownerState.color)}`], ownerState.edge && styles[`edge${capitalize(ownerState.edge)}`], styles[`size${capitalize(ownerState.size)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  textAlign: 'center',
  flex: '0 0 auto',
  fontSize: theme.typography.pxToRem(24),
  padding: 8,
  borderRadius: '50%',
  overflow: 'visible',
  // Explicitly set the default value to solve a bug on IE11.
  color: (theme.vars || theme).palette.action.active,
  transition: theme.transitions.create('background-color', {
    duration: theme.transitions.duration.shortest
  })
}, !ownerState.disableRipple && {
  '&:hover': {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    '@media (hover: none)': {
      backgroundColor: 'transparent'
    }
  }
}, ownerState.edge === 'start' && {
  marginLeft: ownerState.size === 'small' ? -3 : -12
}, ownerState.edge === 'end' && {
  marginRight: ownerState.size === 'small' ? -3 : -12
}), ({
  theme,
  ownerState
}) => {
  var _palette;
  const palette = (_palette = (theme.vars || theme).palette) == null ? void 0 : _palette[ownerState.color];
  return _extends({}, ownerState.color === 'inherit' && {
    color: 'inherit'
  }, ownerState.color !== 'inherit' && ownerState.color !== 'default' && _extends({
    color: palette == null ? void 0 : palette.main
  }, !ownerState.disableRipple && {
    '&:hover': _extends({}, palette && {
      backgroundColor: theme.vars ? `rgba(${palette.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(palette.main, theme.palette.action.hoverOpacity)
    }, {
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: 'transparent'
      }
    })
  }), ownerState.size === 'small' && {
    padding: 5,
    fontSize: theme.typography.pxToRem(18)
  }, ownerState.size === 'large' && {
    padding: 12,
    fontSize: theme.typography.pxToRem(28)
  }, {
    [`&.${iconButtonClasses$1.disabled}`]: {
      backgroundColor: 'transparent',
      color: (theme.vars || theme).palette.action.disabled
    }
  });
});

/**
 * Refer to the [Icons](/material-ui/icons/) section of the documentation
 * regarding the available icon options.
 */
const IconButton = /*#__PURE__*/React__namespace.forwardRef(function IconButton(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiIconButton'
  });
  const {
      edge = false,
      children,
      className,
      color = 'default',
      disabled = false,
      disableFocusRipple = false,
      size = 'medium'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$B);
  const ownerState = _extends({}, props, {
    edge,
    color,
    disabled,
    disableFocusRipple,
    size
  });
  const classes = useUtilityClasses$_(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(IconButtonRoot, _extends({
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled: disabled,
    ref: ref,
    ownerState: ownerState
  }, other, {
    children: children
  }));
});
process.env.NODE_ENV !== "production" ? IconButton.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The icon to display.
   */
  children: chainPropTypes(propTypesExports.node, props => {
    const found = React__namespace.Children.toArray(props.children).some(child => /*#__PURE__*/React__namespace.isValidElement(child) && child.props.onClick);
    if (found) {
      return new Error(['MUI: You are providing an onClick event listener to a child of a button element.', 'Prefer applying it to the IconButton directly.', 'This guarantees that the whole <button> will be responsive to click events.'].join('\n'));
    }
    return null;
  }),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'default'
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['inherit', 'default', 'primary', 'secondary', 'error', 'info', 'success', 'warning']), propTypesExports.string]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: propTypesExports.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: propTypesExports.bool,
  /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   * @default false
   */
  edge: propTypesExports.oneOf(['end', 'start', false]),
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['small', 'medium', 'large']), propTypesExports.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object])
} : void 0;
var IconButton$1 = IconButton;

function getTypographyUtilityClass(slot) {
  return generateUtilityClass('MuiTypography', slot);
}
generateUtilityClasses('MuiTypography', ['root', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'inherit', 'button', 'caption', 'overline', 'alignLeft', 'alignRight', 'alignCenter', 'alignJustify', 'noWrap', 'gutterBottom', 'paragraph']);

const _excluded$A = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
const useUtilityClasses$Z = ownerState => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ['root', variant, ownerState.align !== 'inherit' && `align${capitalize(align)}`, gutterBottom && 'gutterBottom', noWrap && 'noWrap', paragraph && 'paragraph']
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled$1('span', {
  name: 'MuiTypography',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.variant && styles[ownerState.variant], ownerState.align !== 'inherit' && styles[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles.noWrap, ownerState.gutterBottom && styles.gutterBottom, ownerState.paragraph && styles.paragraph];
  }
})(({
  theme,
  ownerState
}) => _extends({
  margin: 0
}, ownerState.variant && theme.typography[ownerState.variant], ownerState.align !== 'inherit' && {
  textAlign: ownerState.align
}, ownerState.noWrap && {
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  whiteSpace: 'nowrap'
}, ownerState.gutterBottom && {
  marginBottom: '0.35em'
}, ownerState.paragraph && {
  marginBottom: 16
}));
const defaultVariantMapping = {
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  subtitle1: 'h6',
  subtitle2: 'h6',
  body1: 'p',
  body2: 'p',
  inherit: 'p'
};

// TODO v6: deprecate these color values in v5.x and remove the transformation in v6
const colorTransformations = {
  primary: 'primary.main',
  textPrimary: 'text.primary',
  secondary: 'secondary.main',
  textSecondary: 'text.secondary',
  error: 'error.main'
};
const transformDeprecatedColors = color => {
  return colorTransformations[color] || color;
};
const Typography = /*#__PURE__*/React__namespace.forwardRef(function Typography(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: 'MuiTypography'
  });
  const color = transformDeprecatedColors(themeProps.color);
  const props = extendSxProp(_extends({}, themeProps, {
    color
  }));
  const {
      align = 'inherit',
      className,
      component,
      gutterBottom = false,
      noWrap = false,
      paragraph = false,
      variant = 'body1',
      variantMapping = defaultVariantMapping
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$A);
  const ownerState = _extends({}, props, {
    align,
    color,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  });
  const Component = component || (paragraph ? 'p' : variantMapping[variant] || defaultVariantMapping[variant]) || 'span';
  const classes = useUtilityClasses$Z(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(TypographyRoot, _extends({
    as: Component,
    ref: ref,
    ownerState: ownerState,
    className: clsx(classes.root, className)
  }, other));
});
process.env.NODE_ENV !== "production" ? Typography.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Set the text-align on the component.
   * @default 'inherit'
   */
  align: propTypesExports.oneOf(['center', 'inherit', 'justify', 'left', 'right']),
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * If `true`, the text will have a bottom margin.
   * @default false
   */
  gutterBottom: propTypesExports.bool,
  /**
   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
   *
   * Note that text overflow can only happen with block or inline-block level elements
   * (the element needs to have a width in order to overflow).
   * @default false
   */
  noWrap: propTypesExports.bool,
  /**
   * If `true`, the element will be a paragraph element.
   * @default false
   */
  paragraph: propTypesExports.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Applies the theme typography styles.
   * @default 'body1'
   */
  variant: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['body1', 'body2', 'button', 'caption', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'inherit', 'overline', 'subtitle1', 'subtitle2']), propTypesExports.string]),
  /**
   * The component maps the variant prop to a range of different HTML element types.
   * For instance, subtitle1 to `<h6>`.
   * If you wish to change that mapping, you can provide your own.
   * Alternatively, you can use the `component` prop.
   * @default {
   *   h1: 'h1',
   *   h2: 'h2',
   *   h3: 'h3',
   *   h4: 'h4',
   *   h5: 'h5',
   *   h6: 'h6',
   *   subtitle1: 'h6',
   *   subtitle2: 'h6',
   *   body1: 'p',
   *   body2: 'p',
   *   inherit: 'p',
   * }
   */
  variantMapping: propTypesExports /* @typescript-to-proptypes-ignore */.object
} : void 0;
var Typography$1 = Typography;

const CLOCK_WIDTH = 220;
const CLOCK_HOUR_WIDTH = 36;
const clockCenter = {
    x: CLOCK_WIDTH / 2,
    y: CLOCK_WIDTH / 2,
};
const baseClockPoint = {
    x: clockCenter.x,
    y: 0,
};
const cx = baseClockPoint.x - clockCenter.x;
const cy = baseClockPoint.y - clockCenter.y;
const rad2deg = (rad) => rad * (180 / Math.PI);
const getAngleValue = (step, offsetX, offsetY) => {
    const x = offsetX - clockCenter.x;
    const y = offsetY - clockCenter.y;
    const atan = Math.atan2(cx, cy) - Math.atan2(x, y);
    let deg = rad2deg(atan);
    deg = Math.round(deg / step) * step;
    deg %= 360;
    const value = Math.floor(deg / step) || 0;
    const delta = Math.pow(x, 2) + Math.pow(y, 2);
    const distance = Math.sqrt(delta);
    return { value, distance };
};
const getMinutes = (offsetX, offsetY, step = 1) => {
    const angleStep = step * 6;
    let { value } = getAngleValue(angleStep, offsetX, offsetY);
    value = (value * step) % 60;
    return value;
};
const getHours = (offsetX, offsetY, ampm) => {
    const { value, distance } = getAngleValue(30, offsetX, offsetY);
    let hour = value || 12;
    if (!ampm) {
        if (distance < CLOCK_WIDTH / 2 - CLOCK_HOUR_WIDTH) {
            hour += 12;
            hour %= 24;
        }
    }
    else {
        hour %= 12;
    }
    return hour;
};

function getClockPointerUtilityClass(slot) {
    return generateUtilityClass('MuiClockPointer', slot);
}
const clockPointerClasses = generateUtilityClasses('MuiClockPointer', [
    'root',
    'thumb',
]);

const useUtilityClasses$Y = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        thumb: ['thumb'],
    };
    return composeClasses(slots, getClockPointerUtilityClass, classes);
};
const ClockPointerRoot = styled$1('div', {
    name: 'MuiClockPointer',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})(({ theme, ownerState }) => (Object.assign({ width: 2, backgroundColor: (theme.vars || theme).palette.primary.main, position: 'absolute', left: 'calc(50% - 1px)', bottom: '50%', transformOrigin: 'center bottom 0px' }, (ownerState.shouldAnimate && {
    transition: theme.transitions.create(['transform', 'height']),
}))));
const ClockPointerThumb = styled$1('div', {
    name: 'MuiClockPointer',
    slot: 'Thumb',
    overridesResolver: (_, styles) => styles.thumb,
})(({ theme, ownerState }) => (Object.assign({ width: 4, height: 4, backgroundColor: (theme.vars || theme).palette.primary.contrastText, borderRadius: '50%', position: 'absolute', top: -21, left: `calc(50% - ${CLOCK_HOUR_WIDTH / 2}px)`, border: `${(CLOCK_HOUR_WIDTH - 4) / 2}px solid ${(theme.vars || theme).palette.primary.main}`, boxSizing: 'content-box' }, (ownerState.hasSelected && {
    backgroundColor: (theme.vars || theme).palette.primary.main,
}))));
/**
 * @ignore - internal component.
 */
function ClockPointer(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiClockPointer' });
    const { className, hasSelected, isInner, type, viewValue } = props, other = __rest(props, ["className", "hasSelected", "isInner", "type", "viewValue"]);
    const previousType = React__namespace.useRef(type);
    React__namespace.useEffect(() => {
        previousType.current = type;
    }, [type]);
    const ownerState = Object.assign(Object.assign({}, props), { shouldAnimate: previousType.current !== type });
    const classes = useUtilityClasses$Y(ownerState);
    const getAngleStyle = () => {
        const max = type === 'hours' ? 12 : 60;
        let angle = (360 / max) * viewValue;
        if (type === 'hours' && viewValue > 12) {
            angle -= 360; // round up angle to max 360 degrees
        }
        return {
            height: Math.round((isInner ? 0.26 : 0.4) * CLOCK_WIDTH),
            transform: `rotateZ(${angle}deg)`,
        };
    };
    return (React__namespace.createElement(ClockPointerRoot, Object.assign({ style: getAngleStyle(), className: clsx(className, classes.root), ownerState: ownerState }, other),
        React__namespace.createElement(ClockPointerThumb, { ownerState: ownerState, className: classes.thumb })));
}

const MuiPickersAdapterContext = React__namespace.createContext(null);
if (process.env.NODE_ENV !== 'production') {
    MuiPickersAdapterContext.displayName = 'MuiPickersAdapterContext';
}
/**
 * @ignore - do not document.
 */
function LocalizationProvider(inProps) {
    var _a;
    const { localeText: inLocaleText } = inProps, otherInProps = __rest(inProps, ["localeText"]);
    const { utils: parentUtils, localeText: parentLocaleText } = (_a = React__namespace.useContext(MuiPickersAdapterContext)) !== null && _a !== void 0 ? _a : { utils: undefined, localeText: undefined };
    const props = useThemeProps({
        // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
        // We will then merge this theme value with our value manually
        props: otherInProps,
        name: 'MuiLocalizationProvider',
    });
    const { children, dateAdapter: DateAdapter, dateFormats, dateLibInstance, adapterLocale, localeText: themeLocaleText, } = props;
    const localeText = React__namespace.useMemo(() => (Object.assign(Object.assign(Object.assign({}, themeLocaleText), parentLocaleText), inLocaleText)), [themeLocaleText, parentLocaleText, inLocaleText]);
    const utils = React__namespace.useMemo(() => {
        if (!DateAdapter) {
            if (parentUtils) {
                return parentUtils;
            }
            return null;
        }
        const adapter = new DateAdapter({
            locale: adapterLocale,
            formats: dateFormats,
            instance: dateLibInstance,
        });
        if (!adapter.isMUIAdapter) {
            throw new Error([
                'The date adapter should be imported from `date-pickers-modern`, not from `@date-io`',
                "For example, `import { AdapterDayjs } from 'date-pickers-modern'` instead of `import AdapterDayjs from '@date-io/dayjs'`",
            ].join(`\n`));
        }
        return adapter;
    }, [DateAdapter, adapterLocale, dateFormats, dateLibInstance, parentUtils]);
    const defaultDates = React__namespace.useMemo(() => {
        if (!utils) {
            return null;
        }
        return {
            minDate: utils.date('1900-01-01T00:00:00.000'),
            maxDate: utils.date('2099-12-31T00:00:00.000'),
        };
    }, [utils]);
    const contextValue = React__namespace.useMemo(() => {
        return {
            utils,
            defaultDates,
            localeText,
        };
    }, [defaultDates, utils, localeText]);
    return (React__namespace.createElement(MuiPickersAdapterContext.Provider, { value: contextValue }, children));
}
LocalizationProvider.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Locale for the date library you are using
     */
    adapterLocale: propTypesExports.oneOfType([propTypesExports.object, propTypesExports.string]),
    children: propTypesExports.node,
    /**
     * DateIO adapter class function
     */
    dateAdapter: propTypesExports.func,
    /**
     * Formats that are used for any child pickers
     */
    dateFormats: propTypesExports.shape({
        dayOfMonth: propTypesExports.string,
        fullDate: propTypesExports.string,
        fullDateTime: propTypesExports.string,
        fullDateTime12h: propTypesExports.string,
        fullDateTime24h: propTypesExports.string,
        fullDateWithWeekday: propTypesExports.string,
        fullTime: propTypesExports.string,
        fullTime12h: propTypesExports.string,
        fullTime24h: propTypesExports.string,
        hours12h: propTypesExports.string,
        hours24h: propTypesExports.string,
        keyboardDate: propTypesExports.string,
        keyboardDateTime: propTypesExports.string,
        keyboardDateTime12h: propTypesExports.string,
        keyboardDateTime24h: propTypesExports.string,
        minutes: propTypesExports.string,
        month: propTypesExports.string,
        monthAndDate: propTypesExports.string,
        monthAndYear: propTypesExports.string,
        monthShort: propTypesExports.string,
        normalDate: propTypesExports.string,
        normalDateWithWeekday: propTypesExports.string,
        seconds: propTypesExports.string,
        shortDate: propTypesExports.string,
        weekday: propTypesExports.string,
        weekdayShort: propTypesExports.string,
        year: propTypesExports.string,
    }),
    /**
     * Date library instance you are using, if it has some global overrides
     * ```jsx
     * dateLibInstance={momentTimeZone}
     * ```
     */
    dateLibInstance: propTypesExports.any,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
};

const getPickersLocalization = (pickersTranslations) => {
    return {
        components: {
            MuiLocalizationProvider: {
                defaultProps: {
                    localeText: Object.assign({}, pickersTranslations),
                },
            },
        },
    };
};

// This object is not Partial<PickersLocaleText> because it is the default values
const enUSPickers = {
    // Calendar navigation
    previousMonth: 'Previous month',
    nextMonth: 'Next month',
    // View navigation
    openPreviousView: 'open previous view',
    openNextView: 'open next view',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'year view is open, switch to calendar view'
        : 'calendar view is open, switch to year view',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `text input view is open, go to ${viewType} view`
        : `${viewType} view is open, go to text input view`,
    // DateRange placeholders
    start: 'Start',
    end: 'End',
    // Action bar
    cancelButtonLabel: 'Cancel',
    clearButtonLabel: 'Clear',
    okButtonLabel: 'OK',
    todayButtonLabel: 'Today',
    // Toolbar titles
    datePickerToolbarTitle: 'Select date',
    dateTimePickerToolbarTitle: 'Select date & time',
    timePickerToolbarTitle: 'Select time',
    dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null ? 'No time selected' : `Selected time is ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} hours`,
    minutesClockNumberText: (minutes) => `${minutes} minutes`,
    secondsClockNumberText: (seconds) => `${seconds} seconds`,
    // Calendar labels
    calendarWeekNumberHeaderLabel: 'Week number',
    calendarWeekNumberHeaderText: '#',
    calendarWeekNumberAriaLabelText: (weekNumber) => `Week ${weekNumber}`,
    calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Choose date, selected date is ${utils.format(value, 'fullDate')}`
        : 'Choose date',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Choose time, selected time is ${utils.format(value, 'fullTime')}`
        : 'Choose time',
    // Table labels
    timeTableLabel: 'pick time',
    dateTableLabel: 'pick date',
    // Field section placeholders
    fieldYearPlaceholder: (params) => 'Y'.repeat(params.digitAmount),
    fieldMonthPlaceholder: (params) => (params.contentType === 'letter' ? 'MMMM' : 'MM'),
    fieldDayPlaceholder: () => 'DD',
    fieldHoursPlaceholder: () => 'hh',
    fieldMinutesPlaceholder: () => 'mm',
    fieldSecondsPlaceholder: () => 'ss',
    fieldMeridiemPlaceholder: () => 'aa',
};
const DEFAULT_LOCALE = enUSPickers;
const enUS = getPickersLocalization(enUSPickers);

const useLocalizationContext = () => {
    const localization = React__namespace.useContext(MuiPickersAdapterContext);
    if (localization === null) {
        throw new Error([
            'Can not find the date and time pickers localization context.',
            'It looks like you forgot to wrap your component in LocalizationProvider.',
            'This can also happen if you are bundling multiple versions of the `date-pickers-modern` package',
        ].join('\n'));
    }
    if (localization.utils === null) {
        throw new Error([
            'Can not find the date and time pickers adapter from its localization context.',
            'It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider.',
        ].join('\n'));
    }
    const localeText = React__namespace.useMemo(() => (Object.assign(Object.assign({}, DEFAULT_LOCALE), localization.localeText)), [localization.localeText]);
    return React__namespace.useMemo(() => (Object.assign(Object.assign({}, localization), { localeText })), [localization, localeText]);
};
const useUtils = () => useLocalizationContext().utils;
const useDefaultDates = () => useLocalizationContext().defaultDates;
const useLocaleText = () => useLocalizationContext().localeText;
const useNow = () => {
    const utils = useUtils();
    const now = React__namespace.useRef(utils.date());
    return now.current;
};

/**
 * TODO consider getting rid from wrapper variant
 * @ignore - internal component.
 */
const WrapperVariantContext = React__namespace.createContext(null);

function getClockUtilityClass(slot) {
    return generateUtilityClass('MuiClock', slot);
}
const clockClasses = generateUtilityClasses('MuiClock', [
    'root',
    'clock',
    'wrapper',
    'squareMask',
    'pin',
    'amButton',
    'pmButton',
]);

const useUtilityClasses$X = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        clock: ['clock'],
        wrapper: ['wrapper'],
        squareMask: ['squareMask'],
        pin: ['pin'],
        amButton: ['amButton'],
        pmButton: ['pmButton'],
    };
    return composeClasses(slots, getClockUtilityClass, classes);
};
const ClockRoot = styled$1('div', {
    name: 'MuiClock',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})(({ theme }) => ({
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    margin: theme.spacing(2),
}));
const ClockClock = styled$1('div', {
    name: 'MuiClock',
    slot: 'Clock',
    overridesResolver: (_, styles) => styles.clock,
})({
    backgroundColor: 'rgba(0,0,0,.07)',
    borderRadius: '50%',
    height: 220,
    width: 220,
    flexShrink: 0,
    position: 'relative',
    pointerEvents: 'none',
});
const ClockWrapper = styled$1('div', {
    name: 'MuiClock',
    slot: 'Wrapper',
    overridesResolver: (_, styles) => styles.wrapper,
})({
    '&:focus': {
        outline: 'none',
    },
});
const ClockSquareMask = styled$1('div', {
    name: 'MuiClock',
    slot: 'SquareMask',
    overridesResolver: (_, styles) => styles.squareMask,
})(({ ownerState }) => (Object.assign({ width: '100%', height: '100%', position: 'absolute', pointerEvents: 'auto', outline: 0, 
    // Disable scroll capabilities.
    touchAction: 'none', userSelect: 'none' }, (ownerState.disabled
    ? {}
    : {
        '@media (pointer: fine)': {
            cursor: 'pointer',
            borderRadius: '50%',
        },
        '&:active': {
            cursor: 'move',
        },
    }))));
const ClockPin = styled$1('div', {
    name: 'MuiClock',
    slot: 'Pin',
    overridesResolver: (_, styles) => styles.pin,
})(({ theme }) => ({
    width: 6,
    height: 6,
    borderRadius: '50%',
    backgroundColor: (theme.vars || theme).palette.primary.main,
    position: 'absolute',
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)',
}));
const ClockAmButton = styled$1(IconButton$1, {
    name: 'MuiClock',
    slot: 'AmButton',
    overridesResolver: (_, styles) => styles.amButton,
})(({ theme, ownerState }) => (Object.assign({ zIndex: 1, position: 'absolute', bottom: ownerState.ampmInClock ? 64 : 8, left: 8 }, (ownerState.meridiemMode === 'am' && {
    backgroundColor: (theme.vars || theme).palette.primary.main,
    color: (theme.vars || theme).palette.primary.contrastText,
    '&:hover': {
        backgroundColor: (theme.vars || theme).palette.primary.light,
    },
}))));
const ClockPmButton = styled$1(IconButton$1, {
    name: 'MuiClock',
    slot: 'PmButton',
    overridesResolver: (_, styles) => styles.pmButton,
})(({ theme, ownerState }) => (Object.assign({ zIndex: 1, position: 'absolute', bottom: ownerState.ampmInClock ? 64 : 8, right: 8 }, (ownerState.meridiemMode === 'pm' && {
    backgroundColor: (theme.vars || theme).palette.primary.main,
    color: (theme.vars || theme).palette.primary.contrastText,
    '&:hover': {
        backgroundColor: (theme.vars || theme).palette.primary.light,
    },
}))));
/**
 * @ignore - internal component.
 */
function Clock$1(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiClock' });
    const { ampm, ampmInClock, autoFocus, children, value, handleMeridiemChange, isTimeDisabled, meridiemMode, minutesStep = 1, onChange, selectedId, type, viewValue, disabled, readOnly, className, } = props;
    const ownerState = props;
    const utils = useUtils();
    const localeText = useLocaleText();
    const wrapperVariant = React__namespace.useContext(WrapperVariantContext);
    const isMoving = React__namespace.useRef(false);
    const classes = useUtilityClasses$X(ownerState);
    const isSelectedTimeDisabled = isTimeDisabled(viewValue, type);
    const isPointerInner = !ampm && type === 'hours' && (viewValue < 1 || viewValue > 12);
    const handleValueChange = (newValue, isFinish) => {
        if (disabled || readOnly) {
            return;
        }
        if (isTimeDisabled(newValue, type)) {
            return;
        }
        onChange(newValue, isFinish);
    };
    const setTime = (event, isFinish) => {
        let { offsetX, offsetY } = event;
        if (offsetX === undefined) {
            const rect = event.target.getBoundingClientRect();
            offsetX = event.changedTouches[0].clientX - rect.left;
            offsetY = event.changedTouches[0].clientY - rect.top;
        }
        const newSelectedValue = type === 'seconds' || type === 'minutes'
            ? getMinutes(offsetX, offsetY, minutesStep)
            : getHours(offsetX, offsetY, Boolean(ampm));
        handleValueChange(newSelectedValue, isFinish);
    };
    const handleTouchMove = (event) => {
        isMoving.current = true;
        setTime(event, 'shallow');
    };
    const handleTouchEnd = (event) => {
        if (isMoving.current) {
            setTime(event, 'finish');
            isMoving.current = false;
        }
    };
    const handleMouseMove = (event) => {
        // event.buttons & PRIMARY_MOUSE_BUTTON
        if (event.buttons > 0) {
            setTime(event.nativeEvent, 'shallow');
        }
    };
    const handleMouseUp = (event) => {
        if (isMoving.current) {
            isMoving.current = false;
        }
        setTime(event.nativeEvent, 'finish');
    };
    const hasSelected = React__namespace.useMemo(() => {
        if (type === 'hours') {
            return true;
        }
        return viewValue % 5 === 0;
    }, [type, viewValue]);
    const keyboardControlStep = type === 'minutes' ? minutesStep : 1;
    const listboxRef = React__namespace.useRef(null);
    // Since this is rendered when a Popper is opened we can't use passive effects.
    // Focusing in passive effects in Popper causes scroll jump.
    useEnhancedEffect$3(() => {
        if (autoFocus) {
            // The ref not being resolved would be a bug in MUI.
            listboxRef.current.focus();
        }
    }, [autoFocus]);
    const handleKeyDown = (event) => {
        // TODO: Why this early exit?
        if (isMoving.current) {
            return;
        }
        switch (event.key) {
            case 'Home':
                // annulate both hours and minutes
                handleValueChange(0, 'partial');
                event.preventDefault();
                break;
            case 'End':
                handleValueChange(type === 'minutes' ? 59 : 23, 'partial');
                event.preventDefault();
                break;
            case 'ArrowUp':
                handleValueChange(viewValue + keyboardControlStep, 'partial');
                event.preventDefault();
                break;
            case 'ArrowDown':
                handleValueChange(viewValue - keyboardControlStep, 'partial');
                event.preventDefault();
                break;
            // do nothing
        }
    };
    return (React__namespace.createElement(ClockRoot, { className: clsx(className, classes.root) },
        React__namespace.createElement(ClockClock, { className: classes.clock },
            React__namespace.createElement(ClockSquareMask, { "data-mui-test": "clock", onTouchMove: handleTouchMove, onTouchEnd: handleTouchEnd, onMouseUp: handleMouseUp, onMouseMove: handleMouseMove, ownerState: { disabled }, className: classes.squareMask }),
            !isSelectedTimeDisabled && (React__namespace.createElement(React__namespace.Fragment, null,
                React__namespace.createElement(ClockPin, { className: classes.pin }),
                value != null && (React__namespace.createElement(ClockPointer, { type: type, viewValue: viewValue, isInner: isPointerInner, hasSelected: hasSelected })))),
            React__namespace.createElement(ClockWrapper, { "aria-activedescendant": selectedId, "aria-label": localeText.clockLabelText(type, value, utils), ref: listboxRef, role: "listbox", onKeyDown: handleKeyDown, tabIndex: 0, className: classes.wrapper }, children)),
        ampm && (wrapperVariant === 'desktop' || ampmInClock) && (React__namespace.createElement(React__namespace.Fragment, null,
            React__namespace.createElement(ClockAmButton, { "data-mui-test": "in-clock-am-btn", onClick: readOnly ? undefined : () => handleMeridiemChange('am'), disabled: disabled || meridiemMode === null, ownerState: ownerState, className: classes.amButton },
                React__namespace.createElement(Typography$1, { variant: "caption" }, "AM")),
            React__namespace.createElement(ClockPmButton, { disabled: disabled || meridiemMode === null, "data-mui-test": "in-clock-pm-btn", onClick: readOnly ? undefined : () => handleMeridiemChange('pm'), ownerState: ownerState, className: classes.pmButton },
                React__namespace.createElement(Typography$1, { variant: "caption" }, "PM"))))));
}

function getClockNumberUtilityClass(slot) {
    return generateUtilityClass('MuiClockNumber', slot);
}
const clockNumberClasses = generateUtilityClasses('MuiClockNumber', [
    'root',
    'selected',
    'disabled',
]);

const useUtilityClasses$W = (ownerState) => {
    const { classes, selected, disabled } = ownerState;
    const slots = {
        root: ['root', selected && 'selected', disabled && 'disabled'],
    };
    return composeClasses(slots, getClockNumberUtilityClass, classes);
};
const ClockNumberRoot = styled$1('span', {
    name: 'MuiClockNumber',
    slot: 'Root',
    overridesResolver: (_, styles) => [
        styles.root,
        { [`&.${clockNumberClasses.disabled}`]: styles.disabled },
        { [`&.${clockNumberClasses.selected}`]: styles.selected },
    ],
})(({ theme, ownerState }) => (Object.assign({ height: CLOCK_HOUR_WIDTH, width: CLOCK_HOUR_WIDTH, position: 'absolute', left: `calc((100% - ${CLOCK_HOUR_WIDTH}px) / 2)`, display: 'inline-flex', justifyContent: 'center', alignItems: 'center', borderRadius: '50%', color: (theme.vars || theme).palette.text.primary, fontFamily: theme.typography.fontFamily, '&:focused': {
        backgroundColor: (theme.vars || theme).palette.background.paper,
    }, [`&.${clockNumberClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
    }, [`&.${clockNumberClasses.disabled}`]: {
        pointerEvents: 'none',
        color: (theme.vars || theme).palette.text.disabled,
    } }, (ownerState.inner && Object.assign(Object.assign({}, theme.typography.body2), { color: (theme.vars || theme).palette.text.secondary })))));
/**
 * @ignore - internal component.
 */
function ClockNumber(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiClockNumber' });
    const { className, disabled, index, inner, label, selected } = props, other = __rest(props, ["className", "disabled", "index", "inner", "label", "selected"]);
    const ownerState = props;
    const classes = useUtilityClasses$W(ownerState);
    const angle = ((index % 12) / 12) * Math.PI * 2 - Math.PI / 2;
    const length = ((CLOCK_WIDTH - CLOCK_HOUR_WIDTH - 2) / 2) * (inner ? 0.65 : 1);
    const x = Math.round(Math.cos(angle) * length);
    const y = Math.round(Math.sin(angle) * length);
    return (React__namespace.createElement(ClockNumberRoot, Object.assign({ className: clsx(className, classes.root), "aria-disabled": disabled ? true : undefined, "aria-selected": selected ? true : undefined, role: "option", style: {
            transform: `translate(${x}px, ${y + (CLOCK_WIDTH - CLOCK_HOUR_WIDTH) / 2}px`,
        }, ownerState: ownerState }, other), label));
}

/**
 * @ignore - internal component.
 */
const getHourNumbers = ({ ampm, value, getClockNumberText, isDisabled, selectedId, utils, }) => {
    const currentHours = value ? utils.getHours(value) : null;
    const hourNumbers = [];
    const startHour = ampm ? 1 : 0;
    const endHour = ampm ? 12 : 23;
    const isSelected = (hour) => {
        if (currentHours === null) {
            return false;
        }
        if (ampm) {
            if (hour === 12) {
                return currentHours === 12 || currentHours === 0;
            }
            return currentHours === hour || currentHours - 12 === hour;
        }
        return currentHours === hour;
    };
    for (let hour = startHour; hour <= endHour; hour += 1) {
        let label = hour.toString();
        if (hour === 0) {
            label = '00';
        }
        const inner = !ampm && (hour === 0 || hour > 12);
        label = utils.formatNumber(label);
        const selected = isSelected(hour);
        hourNumbers.push(React__namespace.createElement(ClockNumber, { key: hour, id: selected ? selectedId : undefined, index: hour, inner: inner, selected: selected, disabled: isDisabled(hour), label: label, "aria-label": getClockNumberText(label) }));
    }
    return hourNumbers;
};
const getMinutesNumbers = ({ utils, value, isDisabled, getClockNumberText, selectedId, }) => {
    const f = utils.formatNumber;
    return [
        [5, f('05')],
        [10, f('10')],
        [15, f('15')],
        [20, f('20')],
        [25, f('25')],
        [30, f('30')],
        [35, f('35')],
        [40, f('40')],
        [45, f('45')],
        [50, f('50')],
        [55, f('55')],
        [0, f('00')],
    ].map(([numberValue, label], index) => {
        const selected = numberValue === value;
        return (React__namespace.createElement(ClockNumber, { key: numberValue, label: label, id: selected ? selectedId : undefined, index: index + 1, inner: false, disabled: isDisabled(numberValue), selected: selected, "aria-label": getClockNumberText(label) }));
    });
};

function getSvgIconUtilityClass(slot) {
  return generateUtilityClass('MuiSvgIcon', slot);
}
generateUtilityClasses('MuiSvgIcon', ['root', 'colorPrimary', 'colorSecondary', 'colorAction', 'colorError', 'colorDisabled', 'fontSizeInherit', 'fontSizeSmall', 'fontSizeMedium', 'fontSizeLarge']);

const _excluded$z = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$V = ownerState => {
  const {
    color,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ['root', color !== 'inherit' && `color${capitalize(color)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled$1('svg', {
  name: 'MuiSvgIcon',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.color !== 'inherit' && styles[`color${capitalize(ownerState.color)}`], styles[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$transitions2$d, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette$ownerState$c2, _palette2, _palette2$action, _palette3, _palette3$action;
  return {
    userSelect: 'none',
    width: '1em',
    height: '1em',
    display: 'inline-block',
    fill: 'currentColor',
    flexShrink: 0,
    transition: (_theme$transitions = theme.transitions) == null ? void 0 : (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, 'fill', {
      duration: (_theme$transitions2 = theme.transitions) == null ? void 0 : (_theme$transitions2$d = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2$d.shorter
    }),
    fontSize: {
      inherit: 'inherit',
      small: ((_theme$typography = theme.typography) == null ? void 0 : (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || '1.25rem',
      medium: ((_theme$typography2 = theme.typography) == null ? void 0 : (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || '1.5rem',
      large: ((_theme$typography3 = theme.typography) == null ? void 0 : (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || '2.1875rem'
    }[ownerState.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null ? void 0 : (_palette$ownerState$c2 = _palette[ownerState.color]) == null ? void 0 : _palette$ownerState$c2.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme.vars || theme).palette) == null ? void 0 : (_palette2$action = _palette2.action) == null ? void 0 : _palette2$action.active,
      disabled: (_palette3 = (theme.vars || theme).palette) == null ? void 0 : (_palette3$action = _palette3.action) == null ? void 0 : _palette3$action.disabled,
      inherit: undefined
    }[ownerState.color]
  };
});
const SvgIcon = /*#__PURE__*/React__namespace.forwardRef(function SvgIcon(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiSvgIcon'
  });
  const {
      children,
      className,
      color = 'inherit',
      component = 'svg',
      fontSize = 'medium',
      htmlColor,
      inheritViewBox = false,
      titleAccess,
      viewBox = '0 0 24 24'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$z);
  const ownerState = _extends({}, props, {
    color,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$V(ownerState);
  return /*#__PURE__*/jsxRuntime.jsxs(SvgIconRoot, _extends({
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? undefined : true,
    role: titleAccess ? 'img' : undefined,
    ref: ref
  }, more, other, {
    ownerState: ownerState,
    children: [children, titleAccess ? /*#__PURE__*/jsxRuntime.jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
process.env.NODE_ENV !== "production" ? SvgIcon.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Node passed into the SVG element.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['inherit', 'action', 'disabled', 'primary', 'secondary', 'error', 'info', 'success', 'warning']), propTypesExports.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['inherit', 'large', 'medium', 'small']), propTypesExports.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: propTypesExports.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: propTypesExports.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: propTypesExports.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: propTypesExports.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: propTypesExports.string
} : void 0;
SvgIcon.muiName = 'SvgIcon';
var SvgIcon$1 = SvgIcon;

function createSvgIcon(path, displayName) {
  function Component(props, ref) {
    return /*#__PURE__*/jsxRuntime.jsx(SvgIcon$1, _extends({
      "data-testid": `${displayName}Icon`,
      ref: ref
    }, props, {
      children: path
    }));
  }
  if (process.env.NODE_ENV !== 'production') {
    // Need to set `displayName` on the inner component for React.memo.
    // React prior to 16.14 ignores `displayName` on the wrapper.
    Component.displayName = `${displayName}Icon`;
  }
  Component.muiName = SvgIcon$1.muiName;
  return /*#__PURE__*/React__namespace.memo( /*#__PURE__*/React__namespace.forwardRef(Component));
}

/**
 * @ignore - internal component.
 */
const ArrowDropDown = createSvgIcon(React__namespace.createElement("path", { d: "M7 10l5 5 5-5z" }), 'ArrowDropDown');
/**
 * @ignore - internal component.
 */
const ArrowLeft = createSvgIcon(React__namespace.createElement("path", { d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z" }), 'ArrowLeft');
/**
 * @ignore - internal component.
 */
const ArrowRight = createSvgIcon(React__namespace.createElement("path", { d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z" }), 'ArrowRight');
/**
 * @ignore - internal component.
 */
const Calendar = createSvgIcon(React__namespace.createElement("path", { d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z" }), 'Calendar');
/**
 * @ignore - internal component.
 */
const Clock = createSvgIcon(React__namespace.createElement(React__namespace.Fragment, null,
    React__namespace.createElement("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" }),
    React__namespace.createElement("path", { d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z" })), 'Clock');
/**
 * @ignore - internal component.
 */
const DateRange = createSvgIcon(React__namespace.createElement("path", { d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z" }), 'DateRange');
/**
 * @ignore - internal component.
 */
const Pen = createSvgIcon(React__namespace.createElement("path", { d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" }), 'Pen');
/**
 * @ignore - internal component.
 */
const Time = createSvgIcon(React__namespace.createElement(React__namespace.Fragment, null,
    React__namespace.createElement("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" }),
    React__namespace.createElement("path", { d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z" })), 'Time');

function getPickersArrowSwitcherUtilityClass(slot) {
    return generateUtilityClass('MuiPickersArrowSwitcher', slot);
}
generateUtilityClasses('MuiPickersArrowSwitcher', [
    'root',
    'spacer',
    'button',
]);

const PickersArrowSwitcherRoot = styled$1('div', {
    name: 'MuiPickersArrowSwitcher',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({
    display: 'flex',
});
const PickersArrowSwitcherSpacer = styled$1('div', {
    name: 'MuiPickersArrowSwitcher',
    slot: 'Spacer',
    overridesResolver: (props, styles) => styles.spacer,
})(({ theme }) => ({
    width: theme.spacing(3),
}));
const PickersArrowSwitcherButton = styled$1(IconButton$1, {
    name: 'MuiPickersArrowSwitcher',
    slot: 'Button',
    overridesResolver: (props, styles) => styles.button,
})(({ ownerState }) => (Object.assign({}, (ownerState.hidden && {
    visibility: 'hidden',
}))));
const useUtilityClasses$U = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        spacer: ['spacer'],
        button: ['button'],
    };
    return composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
};
const PickersArrowSwitcher = React__namespace.forwardRef(function PickersArrowSwitcher(inProps, ref) {
    var _a, _b, _c, _d;
    const theme = useTheme();
    const isRTL = theme.direction === 'rtl';
    const props = useThemeProps({ props: inProps, name: 'MuiPickersArrowSwitcher' });
    const { children, className, components = {}, componentsProps = {}, isNextDisabled, isNextHidden, onGoToNext, nextLabel, isPreviousDisabled, isPreviousHidden, onGoToPrevious, previousLabel } = props, other = __rest(props, ["children", "className", "components", "componentsProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel"]);
    const ownerState = props;
    const classes = useUtilityClasses$U(ownerState);
    const nextProps = {
        isDisabled: isNextDisabled,
        isHidden: isNextHidden,
        goTo: onGoToNext,
        label: nextLabel,
    };
    const previousProps = {
        isDisabled: isPreviousDisabled,
        isHidden: isPreviousHidden,
        goTo: onGoToPrevious,
        label: previousLabel,
    };
    const [leftProps, rightProps] = isRTL ? [nextProps, previousProps] : [previousProps, nextProps];
    const PreviousIconButton = (_a = components.PreviousIconButton) !== null && _a !== void 0 ? _a : PickersArrowSwitcherButton;
    const previousIconButtonProps = useSlotProps({
        elementType: PreviousIconButton,
        externalSlotProps: componentsProps.previousIconButton,
        additionalProps: {
            size: 'small',
            title: leftProps.label,
            'aria-label': leftProps.label,
            disabled: leftProps.isDisabled,
            edge: 'end',
            onClick: leftProps.goTo,
        },
        ownerState: Object.assign(Object.assign({}, ownerState), { hidden: leftProps.isHidden }),
        className: classes.button,
    });
    const NextIconButton = (_b = components.NextIconButton) !== null && _b !== void 0 ? _b : PickersArrowSwitcherButton;
    const nextIconButtonProps = useSlotProps({
        elementType: NextIconButton,
        externalSlotProps: componentsProps.nextIconButton,
        additionalProps: {
            size: 'small',
            title: rightProps.label,
            'aria-label': rightProps.label,
            disabled: rightProps.isDisabled,
            edge: 'start',
            onClick: rightProps.goTo,
        },
        ownerState: Object.assign(Object.assign({}, ownerState), { hidden: rightProps.isHidden }),
        className: classes.button,
    });
    const LeftArrowIcon = (_c = components === null || components === void 0 ? void 0 : components.LeftArrowIcon) !== null && _c !== void 0 ? _c : ArrowLeft;
    // The spread is here to avoid this bug mui/material-ui#34056
    const _e = useSlotProps({
        elementType: LeftArrowIcon,
        externalSlotProps: componentsProps.leftArrowIcon,
        ownerState: undefined,
    }), leftArrowIconProps = __rest(_e, ["ownerState"]);
    const RightArrowIcon = (_d = components === null || components === void 0 ? void 0 : components.RightArrowIcon) !== null && _d !== void 0 ? _d : ArrowRight;
    // The spread is here to avoid this bug mui/material-ui#34056
    const _f = useSlotProps({
        elementType: RightArrowIcon,
        externalSlotProps: componentsProps.rightArrowIcon,
        ownerState: undefined,
    }), rightArrowIconProps = __rest(_f, ["ownerState"]);
    return (React__namespace.createElement(PickersArrowSwitcherRoot, Object.assign({ ref: ref, className: clsx(classes.root, className), ownerState: ownerState }, other),
        React__namespace.createElement(PreviousIconButton, Object.assign({}, previousIconButtonProps), isRTL ? (React__namespace.createElement(RightArrowIcon, Object.assign({}, rightArrowIconProps))) : (React__namespace.createElement(LeftArrowIcon, Object.assign({}, leftArrowIconProps)))),
        children ? (React__namespace.createElement(Typography$1, { variant: "subtitle1", component: "span" }, children)) : (React__namespace.createElement(PickersArrowSwitcherSpacer, { className: classes.spacer, ownerState: ownerState })),
        React__namespace.createElement(NextIconButton, Object.assign({}, nextIconButtonProps), isRTL ? (React__namespace.createElement(LeftArrowIcon, Object.assign({}, leftArrowIconProps))) : (React__namespace.createElement(RightArrowIcon, Object.assign({}, rightArrowIconProps))))));
});

const getMeridiem = (date, utils) => {
    if (!date) {
        return null;
    }
    return utils.getHours(date) >= 12 ? 'pm' : 'am';
};
const convertValueToMeridiem = (value, meridiem, ampm) => {
    if (ampm) {
        const currentMeridiem = value >= 12 ? 'pm' : 'am';
        if (currentMeridiem !== meridiem) {
            return meridiem === 'am' ? value - 12 : value + 12;
        }
    }
    return value;
};
const convertToMeridiem = (time, meridiem, ampm, utils) => {
    const newHoursAmount = convertValueToMeridiem(utils.getHours(time), meridiem, ampm);
    return utils.setHours(time, newHoursAmount);
};
const getSecondsInDay = (date, utils) => {
    return utils.getHours(date) * 3600 + utils.getMinutes(date) * 60 + utils.getSeconds(date);
};
const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation, utils) => (dateLeft, dateRight) => {
    if (disableIgnoringDatePartForTimeValidation) {
        return utils.isAfter(dateLeft, dateRight);
    }
    return getSecondsInDay(dateLeft, utils) > getSecondsInDay(dateRight, utils);
};

/* Use it instead of .includes method for IE support */
function arrayIncludes(array, itemOrItems) {
    if (Array.isArray(itemOrItems)) {
        return itemOrItems.every((item) => array.indexOf(item) !== -1);
    }
    return array.indexOf(itemOrItems) !== -1;
}
const onSpaceOrEnter = (innerFn, onFocus) => (event) => {
    if (event.key === 'Enter' || event.key === ' ') {
        innerFn(event);
        // prevent any side effects
        event.preventDefault();
        event.stopPropagation();
    }
    if (onFocus) {
        onFocus(event);
    }
};
const executeInTheNextEventLoopTick = (fn) => {
    setTimeout(fn, 0);
};
// https://www.abeautifulsite.net/posts/finding-the-active-element-in-a-shadow-root/
const getActiveElement = (root = document) => {
    const activeEl = root.activeElement;
    if (!activeEl) {
        return null;
    }
    if (activeEl.shadowRoot) {
        return getActiveElement(activeEl.shadowRoot);
    }
    return activeEl;
};

let warnedOnceNotValidView = false;
function useViews({ onChange, onViewChange, openTo, view: inView, views, autoFocus, focusedView: inFocusedView, onFocusedViewChange, }) {
    var _a, _b;
    if (process.env.NODE_ENV !== 'production') {
        if (!warnedOnceNotValidView) {
            if (inView != null && !views.includes(inView)) {
                console.warn(`MUI: \`view="${inView}"\` is not a valid prop.`, `It must be an element of \`views=["${views.join('", "')}"]\`.`);
                warnedOnceNotValidView = true;
            }
            if (inView == null && openTo != null && !views.includes(openTo)) {
                console.warn(`MUI: \`openTo="${openTo}"\` is not a valid prop.`, `It must be an element of \`views=["${views.join('", "')}"]\`.`);
                warnedOnceNotValidView = true;
            }
        }
    }
    const defaultView = React__namespace.useRef(arrayIncludes(views, openTo) ? openTo : views[0]);
    const [view, setView] = useControlled$2({
        name: 'useViews',
        state: 'view',
        controlled: inView,
        default: defaultView.current,
    });
    const defaultFocusedView = React__namespace.useRef(autoFocus ? view : null);
    const [focusedView, setFocusedView] = useControlled$2({
        name: 'useViews',
        state: 'focusedView',
        controlled: inFocusedView,
        default: defaultFocusedView.current,
    });
    const viewIndex = views.indexOf(view);
    const previousView = (_a = views[viewIndex - 1]) !== null && _a !== void 0 ? _a : null;
    const nextView = (_b = views[viewIndex + 1]) !== null && _b !== void 0 ? _b : null;
    const handleChangeView = _default$2((newView) => {
        setView(newView);
        if (onViewChange) {
            onViewChange(newView);
        }
    });
    const goToNextView = _default$2(() => {
        if (nextView) {
            handleChangeView(nextView);
        }
    });
    const setValueAndGoToNextView = _default$2((value, currentViewSelectionState) => {
        const isSelectionFinishedOnCurrentView = currentViewSelectionState === 'finish';
        const globalSelectionState = isSelectionFinishedOnCurrentView && Boolean(nextView)
            ? 'partial'
            : currentViewSelectionState;
        onChange(value, globalSelectionState);
        if (isSelectionFinishedOnCurrentView) {
            goToNextView();
        }
    });
    const handleFocusedViewChange = _default$2((viewToFocus, hasFocus) => {
        if (hasFocus) {
            setFocusedView(viewToFocus);
        }
        else {
            setFocusedView((prevFocusedView) => viewToFocus === prevFocusedView ? null : prevFocusedView);
        }
        onFocusedViewChange === null || onFocusedViewChange === void 0 ? void 0 : onFocusedViewChange(viewToFocus, hasFocus);
    });
    return {
        view,
        setView: handleChangeView,
        focusedView,
        setFocusedView: handleFocusedViewChange,
        nextView,
        previousView,
        goToNextView,
        setValueAndGoToNextView,
    };
}

function useNextMonthDisabled(month, { disableFuture, maxDate }) {
    const utils = useUtils();
    return React__namespace.useMemo(() => {
        const now = utils.date();
        const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, maxDate) ? now : maxDate);
        return !utils.isAfter(lastEnabledMonth, month);
    }, [disableFuture, maxDate, month, utils]);
}
function usePreviousMonthDisabled(month, { disablePast, minDate }) {
    const utils = useUtils();
    return React__namespace.useMemo(() => {
        const now = utils.date();
        const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, minDate) ? now : minDate);
        return !utils.isBefore(firstEnabledMonth, month);
    }, [disablePast, minDate, month, utils]);
}
function useMeridiemMode(date, ampm, onChange) {
    const utils = useUtils();
    const meridiemMode = getMeridiem(date, utils);
    const handleMeridiemChange = React__namespace.useCallback((mode) => {
        const timeWithMeridiem = date == null ? null : convertToMeridiem(date, mode, Boolean(ampm), utils);
        onChange(timeWithMeridiem, 'partial');
    }, [ampm, date, onChange, utils]);
    return { meridiemMode, handleMeridiemChange };
}

function getTimeClockUtilityClass(slot) {
    return generateUtilityClass('MuiTimeClock', slot);
}
const timeClockClasses = generateUtilityClasses('MuiTimeClock', [
    'root',
    'arrowSwitcher',
]);

const DAY_SIZE = 36;
const DAY_MARGIN = 2;
const DIALOG_WIDTH = 320;
const VIEW_HEIGHT = 358;

const PickerViewRoot = styled$1('div')({
    overflowX: 'hidden',
    width: DIALOG_WIDTH,
    maxHeight: VIEW_HEIGHT,
    display: 'flex',
    flexDirection: 'column',
    margin: '0 auto',
});

const useUtilityClasses$T = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        arrowSwitcher: ['arrowSwitcher'],
    };
    return composeClasses(slots, getTimeClockUtilityClass, classes);
};
const TimeClockRoot = styled$1(PickerViewRoot, {
    name: 'MuiTimeClock',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({
    display: 'flex',
    flexDirection: 'column',
});
const TimeCLockArrowSwitcher = styled$1(PickersArrowSwitcher, {
    name: 'MuiTimeClock',
    slot: 'ArrowSwitcher',
    overridesResolver: (props, styles) => styles.arrowSwitcher,
})({
    position: 'absolute',
    right: 12,
    top: 15,
});
// TODO v6: Drop the `showViewSwitcher` prop with the legacy pickers
/**
 *
 * API:
 *
 * - [TimeClock API](https://mui.com/x/api/date-pickers/time-clock/)
 */
const TimeClock = React__namespace.forwardRef(function TimeClock(inProps, ref) {
    const localeText = useLocaleText();
    const now = useNow();
    const utils = useUtils();
    const props = useThemeProps({
        props: inProps,
        name: 'MuiTimeClock',
    });
    const { ampm = utils.is12HourCycleInCurrentLocale(), ampmInClock = false, autoFocus, components, componentsProps, value: valueProp, disableIgnoringDatePartForTimeValidation = false, maxTime, minTime, disableFuture, disablePast, minutesStep = 1, shouldDisableTime, showViewSwitcher, onChange, defaultValue, view: inView, views = ['hours', 'minutes'], openTo, onViewChange, className, sx, disabled, readOnly, } = props;
    const [value, setValue] = useControlled$2({
        name: 'DateCalendar',
        state: 'value',
        controlled: valueProp,
        default: defaultValue !== null && defaultValue !== void 0 ? defaultValue : null,
    });
    const handleValueChange = _default$2((newValue, selectionState) => {
        setValue(newValue);
        onChange === null || onChange === void 0 ? void 0 : onChange(newValue, selectionState);
    });
    const { view, setView, previousView, nextView, setValueAndGoToNextView } = useViews({
        view: inView,
        views,
        openTo,
        onViewChange,
        onChange: handleValueChange,
    });
    const selectedTimeOrMidnight = React__namespace.useMemo(() => value || utils.setSeconds(utils.setMinutes(utils.setHours(now, 0), 0), 0), [value, now, utils]);
    const { meridiemMode, handleMeridiemChange } = useMeridiemMode(selectedTimeOrMidnight, ampm, setValueAndGoToNextView);
    const isTimeDisabled = React__namespace.useCallback((rawValue, viewType) => {
        const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils);
        const shouldCheckPastEnd = viewType === 'hours' || (viewType === 'minutes' && views.includes('seconds'));
        const containsValidTime = ({ start, end }) => {
            if (minTime && isAfter(minTime, end)) {
                return false;
            }
            if (maxTime && isAfter(start, maxTime)) {
                return false;
            }
            if (disableFuture && isAfter(start, now)) {
                return false;
            }
            if (disablePast && isAfter(now, shouldCheckPastEnd ? end : start)) {
                return false;
            }
            return true;
        };
        const isValidValue = (timeValue, step = 1) => {
            if (timeValue % step !== 0) {
                return false;
            }
            if (shouldDisableTime) {
                return !shouldDisableTime(timeValue, viewType);
            }
            return true;
        };
        switch (viewType) {
            case 'hours': {
                const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
                const dateWithNewHours = utils.setHours(selectedTimeOrMidnight, valueWithMeridiem);
                const start = utils.setSeconds(utils.setMinutes(dateWithNewHours, 0), 0);
                const end = utils.setSeconds(utils.setMinutes(dateWithNewHours, 59), 59);
                return !containsValidTime({ start, end }) || !isValidValue(valueWithMeridiem);
            }
            case 'minutes': {
                const dateWithNewMinutes = utils.setMinutes(selectedTimeOrMidnight, rawValue);
                const start = utils.setSeconds(dateWithNewMinutes, 0);
                const end = utils.setSeconds(dateWithNewMinutes, 59);
                return !containsValidTime({ start, end }) || !isValidValue(rawValue, minutesStep);
            }
            case 'seconds': {
                const dateWithNewSeconds = utils.setSeconds(selectedTimeOrMidnight, rawValue);
                const start = dateWithNewSeconds;
                const end = dateWithNewSeconds;
                return !containsValidTime({ start, end }) || !isValidValue(rawValue);
            }
            default:
                throw new Error('not supported');
        }
    }, [
        ampm,
        selectedTimeOrMidnight,
        disableIgnoringDatePartForTimeValidation,
        maxTime,
        meridiemMode,
        minTime,
        minutesStep,
        shouldDisableTime,
        utils,
        disableFuture,
        disablePast,
        now,
        views,
    ]);
    const selectedId = useId();
    const viewProps = React__namespace.useMemo(() => {
        switch (view) {
            case 'hours': {
                const handleHoursChange = (hourValue, isFinish) => {
                    const valueWithMeridiem = convertValueToMeridiem(hourValue, meridiemMode, ampm);
                    setValueAndGoToNextView(utils.setHours(selectedTimeOrMidnight, valueWithMeridiem), isFinish);
                };
                return {
                    onChange: handleHoursChange,
                    viewValue: utils.getHours(selectedTimeOrMidnight),
                    children: getHourNumbers({
                        value,
                        utils,
                        ampm,
                        onChange: handleHoursChange,
                        getClockNumberText: localeText.hoursClockNumberText,
                        isDisabled: (hourValue) => disabled || isTimeDisabled(hourValue, 'hours'),
                        selectedId,
                    }),
                };
            }
            case 'minutes': {
                const minutesValue = utils.getMinutes(selectedTimeOrMidnight);
                const handleMinutesChange = (minuteValue, isFinish) => {
                    setValueAndGoToNextView(utils.setMinutes(selectedTimeOrMidnight, minuteValue), isFinish);
                };
                return {
                    viewValue: minutesValue,
                    onChange: handleMinutesChange,
                    children: getMinutesNumbers({
                        utils,
                        value: minutesValue,
                        onChange: handleMinutesChange,
                        getClockNumberText: localeText.minutesClockNumberText,
                        isDisabled: (minuteValue) => disabled || isTimeDisabled(minuteValue, 'minutes'),
                        selectedId,
                    }),
                };
            }
            case 'seconds': {
                const secondsValue = utils.getSeconds(selectedTimeOrMidnight);
                const handleSecondsChange = (secondValue, isFinish) => {
                    setValueAndGoToNextView(utils.setSeconds(selectedTimeOrMidnight, secondValue), isFinish);
                };
                return {
                    viewValue: secondsValue,
                    onChange: handleSecondsChange,
                    children: getMinutesNumbers({
                        utils,
                        value: secondsValue,
                        onChange: handleSecondsChange,
                        getClockNumberText: localeText.secondsClockNumberText,
                        isDisabled: (secondValue) => disabled || isTimeDisabled(secondValue, 'seconds'),
                        selectedId,
                    }),
                };
            }
            default:
                throw new Error('You must provide the type for ClockView');
        }
    }, [
        view,
        utils,
        value,
        ampm,
        localeText.hoursClockNumberText,
        localeText.minutesClockNumberText,
        localeText.secondsClockNumberText,
        meridiemMode,
        setValueAndGoToNextView,
        selectedTimeOrMidnight,
        isTimeDisabled,
        selectedId,
        disabled,
    ]);
    const ownerState = props;
    const classes = useUtilityClasses$T(ownerState);
    return (React__namespace.createElement(TimeClockRoot, { ref: ref, className: clsx(classes.root, className), ownerState: ownerState, sx: sx },
        showViewSwitcher && (React__namespace.createElement(TimeCLockArrowSwitcher, { className: classes.arrowSwitcher, components: components, componentsProps: componentsProps, onGoToPrevious: () => setView(previousView), isPreviousDisabled: !previousView, previousLabel: localeText.openPreviousView, onGoToNext: () => setView(nextView), isNextDisabled: !nextView, nextLabel: localeText.openNextView, ownerState: ownerState })),
        React__namespace.createElement(Clock$1, Object.assign({ autoFocus: autoFocus, ampmInClock: ampmInClock, value: value, type: view, ampm: ampm, minutesStep: minutesStep, isTimeDisabled: isTimeDisabled, meridiemMode: meridiemMode, handleMeridiemChange: handleMeridiemChange, selectedId: selectedId, disabled: disabled, readOnly: readOnly }, viewProps))));
});
TimeClock.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    /**
     * Set to `true` if focus should be moved to clock picker.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: propTypesExports.object,
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default selected value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value changes.
     * @template TDate
     * @param {TDate | null} value The new value.
     * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {TimeView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Initially open view.
     * @default 'hours'
     */
    openTo: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    showViewSwitcher: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * Controlled open view.
     */
    view: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Views for calendar picker.
     * @default ['hours', 'minutes']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['hours', 'minutes', 'seconds']).isRequired),
};

/**
 * @deprecated Not used internally. Use `MediaQueryListEvent` from lib.dom.d.ts instead.
 */

function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const supportMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia !== 'undefined';
  const [match, setMatch] = React__namespace.useState(() => {
    if (noSsr && supportMatchMedia) {
      return matchMedia(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }

    // Once the component is mounted, we rely on the
    // event listeners to return the correct matches value.
    return defaultMatches;
  });
  useEnhancedEffect$3(() => {
    let active = true;
    if (!supportMatchMedia) {
      return undefined;
    }
    const queryList = matchMedia(query);
    const updateMatch = () => {
      // Workaround Safari wrong implementation of matchMedia
      // TODO can we remove it?
      // https://github.com/mui/material-ui/pull/17315#issuecomment-528286677
      if (active) {
        setMatch(queryList.matches);
      }
    };
    updateMatch();
    // TODO: Use `addEventListener` once support for Safari < 14 is dropped
    queryList.addListener(updateMatch);
    return () => {
      active = false;
      queryList.removeListener(updateMatch);
    };
  }, [query, matchMedia, supportMatchMedia]);
  return match;
}

// eslint-disable-next-line no-useless-concat -- Workaround for https://github.com/webpack/webpack/issues/14814
const maybeReactUseSyncExternalStore = React__namespace['useSyncExternalStore' + ''];
function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia) {
  const getDefaultSnapshot = React__namespace.useCallback(() => defaultMatches, [defaultMatches]);
  const getServerSnapshot = React__namespace.useMemo(() => {
    if (ssrMatchMedia !== null) {
      const {
        matches
      } = ssrMatchMedia(query);
      return () => matches;
    }
    return getDefaultSnapshot;
  }, [getDefaultSnapshot, query, ssrMatchMedia]);
  const [getSnapshot, subscribe] = React__namespace.useMemo(() => {
    if (matchMedia === null) {
      return [getDefaultSnapshot, () => () => {}];
    }
    const mediaQueryList = matchMedia(query);
    return [() => mediaQueryList.matches, notify => {
      // TODO: Use `addEventListener` once support for Safari < 14 is dropped
      mediaQueryList.addListener(notify);
      return () => {
        mediaQueryList.removeListener(notify);
      };
    }];
  }, [getDefaultSnapshot, matchMedia, query]);
  const match = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  return match;
}
function useMediaQuery(queryInput, options = {}) {
  const theme = useTheme$2();
  // Wait for jsdom to support the match media feature.
  // All the browsers MUI support have this built-in.
  // This defensive check is here for simplicity.
  // Most of the time, the match media logic isn't central to people tests.
  const supportMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia !== 'undefined';
  const {
    defaultMatches = false,
    matchMedia = supportMatchMedia ? window.matchMedia : null,
    ssrMatchMedia = null,
    noSsr
  } = getThemeProps({
    name: 'MuiUseMediaQuery',
    props: options,
    theme
  });
  if (process.env.NODE_ENV !== 'production') {
    if (typeof queryInput === 'function' && theme === null) {
      console.error(['MUI: The `query` argument provided is invalid.', 'You are providing a function without a theme in the context.', 'One of the parent elements needs to use a ThemeProvider.'].join('\n'));
    }
  }
  let query = typeof queryInput === 'function' ? queryInput(theme) : queryInput;
  query = query.replace(/^@media( ?)/m, '');

  // TODO: Drop `useMediaQueryOld` and use  `use-sync-external-store` shim in `useMediaQueryNew` once the package is stable
  const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== undefined ? useMediaQueryNew : useMediaQueryOld;
  const match = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__namespace.useDebugValue({
      query,
      match
    });
  }
  return match;
}

const findClosestEnabledDate = ({ date, disableFuture, disablePast, maxDate, minDate, isDateDisabled, utils, }) => {
    const today = utils.startOfDay(utils.date());
    if (disablePast && utils.isBefore(minDate, today)) {
        minDate = today;
    }
    if (disableFuture && utils.isAfter(maxDate, today)) {
        maxDate = today;
    }
    let forward = date;
    let backward = date;
    if (utils.isBefore(date, minDate)) {
        forward = minDate;
        backward = null;
    }
    if (utils.isAfter(date, maxDate)) {
        if (backward) {
            backward = maxDate;
        }
        forward = null;
    }
    while (forward || backward) {
        if (forward && utils.isAfter(forward, maxDate)) {
            forward = null;
        }
        if (backward && utils.isBefore(backward, minDate)) {
            backward = null;
        }
        if (forward) {
            if (!isDateDisabled(forward)) {
                return forward;
            }
            forward = utils.addDays(forward, 1);
        }
        if (backward) {
            if (!isDateDisabled(backward)) {
                return backward;
            }
            backward = utils.addDays(backward, -1);
        }
    }
    return null;
};
const clamp = (utils, value, minDate, maxDate) => {
    if (utils.isBefore(value, minDate)) {
        return minDate;
    }
    if (utils.isAfter(value, maxDate)) {
        return maxDate;
    }
    return value;
};
const replaceInvalidDateByNull = (utils, value) => (value == null || !utils.isValid(value) ? null : value);
const applyDefaultDate = (utils, value, defaultValue) => {
    if (value == null || !utils.isValid(value)) {
        return defaultValue;
    }
    return value;
};

/**
 * @ignore - internal component.
 */
const GridContext = /*#__PURE__*/React__namespace.createContext();
if (process.env.NODE_ENV !== 'production') {
  GridContext.displayName = 'GridContext';
}
var GridContext$1 = GridContext;

function getGridUtilityClass(slot) {
  return generateUtilityClass('MuiGrid', slot);
}
const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const DIRECTIONS = ['column-reverse', 'column', 'row-reverse', 'row'];
const WRAPS = ['nowrap', 'wrap-reverse', 'wrap'];
const GRID_SIZES = ['auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
const gridClasses = generateUtilityClasses('MuiGrid', ['root', 'container', 'item', 'zeroMinWidth',
// spacings
...SPACINGS.map(spacing => `spacing-xs-${spacing}`),
// direction values
...DIRECTIONS.map(direction => `direction-xs-${direction}`),
// wrap values
...WRAPS.map(wrap => `wrap-xs-${wrap}`),
// grid sizes for all breakpoints
...GRID_SIZES.map(size => `grid-xs-${size}`), ...GRID_SIZES.map(size => `grid-sm-${size}`), ...GRID_SIZES.map(size => `grid-md-${size}`), ...GRID_SIZES.map(size => `grid-lg-${size}`), ...GRID_SIZES.map(size => `grid-xl-${size}`)]);

const _excluded$y = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
function getOffset(val) {
  const parse = parseFloat(val);
  return `${parse}${String(val).replace(String(parse), '') || 'px'}`;
}
function generateGrid({
  theme,
  ownerState
}) {
  let size;
  return theme.breakpoints.keys.reduce((globalStyles, breakpoint) => {
    // Use side effect over immutability for better performance.
    let styles = {};
    if (ownerState[breakpoint]) {
      size = ownerState[breakpoint];
    }
    if (!size) {
      return globalStyles;
    }
    if (size === true) {
      // For the auto layouting
      styles = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: '100%'
      };
    } else if (size === 'auto') {
      styles = {
        flexBasis: 'auto',
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: 'none',
        width: 'auto'
      };
    } else {
      const columnsBreakpointValues = resolveBreakpointValues({
        values: ownerState.columns,
        breakpoints: theme.breakpoints.values
      });
      const columnValue = typeof columnsBreakpointValues === 'object' ? columnsBreakpointValues[breakpoint] : columnsBreakpointValues;
      if (columnValue === undefined || columnValue === null) {
        return globalStyles;
      }
      // Keep 7 significant numbers.
      const width = `${Math.round(size / columnValue * 10e7) / 10e5}%`;
      let more = {};
      if (ownerState.container && ownerState.item && ownerState.columnSpacing !== 0) {
        const themeSpacing = theme.spacing(ownerState.columnSpacing);
        if (themeSpacing !== '0px') {
          const fullWidth = `calc(${width} + ${getOffset(themeSpacing)})`;
          more = {
            flexBasis: fullWidth,
            maxWidth: fullWidth
          };
        }
      }

      // Close to the bootstrap implementation:
      // https://github.com/twbs/bootstrap/blob/8fccaa2439e97ec72a4b7dc42ccc1f649790adb0/scss/mixins/_grid.scss#L41
      styles = _extends({
        flexBasis: width,
        flexGrow: 0,
        maxWidth: width
      }, more);
    }

    // No need for a media query for the first size.
    if (theme.breakpoints.values[breakpoint] === 0) {
      Object.assign(globalStyles, styles);
    } else {
      globalStyles[theme.breakpoints.up(breakpoint)] = styles;
    }
    return globalStyles;
  }, {});
}
function generateDirection({
  theme,
  ownerState
}) {
  const directionValues = resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme.breakpoints.values
  });
  return handleBreakpoints({
    theme
  }, directionValues, propValue => {
    const output = {
      flexDirection: propValue
    };
    if (propValue.indexOf('column') === 0) {
      output[`& > .${gridClasses.item}`] = {
        maxWidth: 'none'
      };
    }
    return output;
  });
}

/**
 * Extracts zero value breakpoint keys before a non-zero value breakpoint key.
 * @example { xs: 0, sm: 0, md: 2, lg: 0, xl: 0 } or [0, 0, 2, 0, 0]
 * @returns [xs, sm]
 */
function extractZeroValueBreakpointKeys({
  breakpoints,
  values
}) {
  let nonZeroKey = '';
  Object.keys(values).forEach(key => {
    if (nonZeroKey !== '') {
      return;
    }
    if (values[key] !== 0) {
      nonZeroKey = key;
    }
  });
  const sortedBreakpointKeysByValue = Object.keys(breakpoints).sort((a, b) => {
    return breakpoints[a] - breakpoints[b];
  });
  return sortedBreakpointKeysByValue.slice(0, sortedBreakpointKeysByValue.indexOf(nonZeroKey));
}
function generateRowGap({
  theme,
  ownerState
}) {
  const {
    container,
    rowSpacing
  } = ownerState;
  let styles = {};
  if (container && rowSpacing !== 0) {
    const rowSpacingValues = resolveBreakpointValues({
      values: rowSpacing,
      breakpoints: theme.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof rowSpacingValues === 'object') {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme.breakpoints.values,
        values: rowSpacingValues
      });
    }
    styles = handleBreakpoints({
      theme
    }, rowSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK;
      const themeSpacing = theme.spacing(propValue);
      if (themeSpacing !== '0px') {
        return {
          marginTop: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses.item}`]: {
            paddingTop: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK.includes(breakpoint)) {
        return {};
      }
      return {
        marginTop: 0,
        [`& > .${gridClasses.item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return styles;
}
function generateColumnGap({
  theme,
  ownerState
}) {
  const {
    container,
    columnSpacing
  } = ownerState;
  let styles = {};
  if (container && columnSpacing !== 0) {
    const columnSpacingValues = resolveBreakpointValues({
      values: columnSpacing,
      breakpoints: theme.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof columnSpacingValues === 'object') {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme.breakpoints.values,
        values: columnSpacingValues
      });
    }
    styles = handleBreakpoints({
      theme
    }, columnSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK2;
      const themeSpacing = theme.spacing(propValue);
      if (themeSpacing !== '0px') {
        return {
          width: `calc(100% + ${getOffset(themeSpacing)})`,
          marginLeft: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses.item}`]: {
            paddingLeft: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK2 = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK2.includes(breakpoint)) {
        return {};
      }
      return {
        width: '100%',
        marginLeft: 0,
        [`& > .${gridClasses.item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return styles;
}
function resolveSpacingStyles(spacing, breakpoints, styles = {}) {
  // undefined/null or `spacing` <= 0
  if (!spacing || spacing <= 0) {
    return [];
  }
  // in case of string/number `spacing`
  if (typeof spacing === 'string' && !Number.isNaN(Number(spacing)) || typeof spacing === 'number') {
    return [styles[`spacing-xs-${String(spacing)}`]];
  }
  // in case of object `spacing`
  const spacingStyles = [];
  breakpoints.forEach(breakpoint => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      spacingStyles.push(styles[`spacing-${breakpoint}-${String(value)}`]);
    }
  });
  return spacingStyles;
}

// Default CSS values
// flex: '0 1 auto',
// flexDirection: 'row',
// alignItems: 'flex-start',
// flexWrap: 'nowrap',
// justifyContent: 'flex-start',
const GridRoot = styled$1('div', {
  name: 'MuiGrid',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    const {
      container,
      direction,
      item,
      spacing,
      wrap,
      zeroMinWidth,
      breakpoints
    } = ownerState;
    let spacingStyles = [];

    // in case of grid item
    if (container) {
      spacingStyles = resolveSpacingStyles(spacing, breakpoints, styles);
    }
    const breakpointsStyles = [];
    breakpoints.forEach(breakpoint => {
      const value = ownerState[breakpoint];
      if (value) {
        breakpointsStyles.push(styles[`grid-${breakpoint}-${String(value)}`]);
      }
    });
    return [styles.root, container && styles.container, item && styles.item, zeroMinWidth && styles.zeroMinWidth, ...spacingStyles, direction !== 'row' && styles[`direction-xs-${String(direction)}`], wrap !== 'wrap' && styles[`wrap-xs-${String(wrap)}`], ...breakpointsStyles];
  }
})(({
  ownerState
}) => _extends({
  boxSizing: 'border-box'
}, ownerState.container && {
  display: 'flex',
  flexWrap: 'wrap',
  width: '100%'
}, ownerState.item && {
  margin: 0 // For instance, it's useful when used with a `figure` element.
}, ownerState.zeroMinWidth && {
  minWidth: 0
}, ownerState.wrap !== 'wrap' && {
  flexWrap: ownerState.wrap
}), generateDirection, generateRowGap, generateColumnGap, generateGrid);
function resolveSpacingClasses(spacing, breakpoints) {
  // undefined/null or `spacing` <= 0
  if (!spacing || spacing <= 0) {
    return [];
  }
  // in case of string/number `spacing`
  if (typeof spacing === 'string' && !Number.isNaN(Number(spacing)) || typeof spacing === 'number') {
    return [`spacing-xs-${String(spacing)}`];
  }
  // in case of object `spacing`
  const classes = [];
  breakpoints.forEach(breakpoint => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      const className = `spacing-${breakpoint}-${String(value)}`;
      classes.push(className);
    }
  });
  return classes;
}
const useUtilityClasses$S = ownerState => {
  const {
    classes,
    container,
    direction,
    item,
    spacing,
    wrap,
    zeroMinWidth,
    breakpoints
  } = ownerState;
  let spacingClasses = [];

  // in case of grid item
  if (container) {
    spacingClasses = resolveSpacingClasses(spacing, breakpoints);
  }
  const breakpointsClasses = [];
  breakpoints.forEach(breakpoint => {
    const value = ownerState[breakpoint];
    if (value) {
      breakpointsClasses.push(`grid-${breakpoint}-${String(value)}`);
    }
  });
  const slots = {
    root: ['root', container && 'container', item && 'item', zeroMinWidth && 'zeroMinWidth', ...spacingClasses, direction !== 'row' && `direction-xs-${String(direction)}`, wrap !== 'wrap' && `wrap-xs-${String(wrap)}`, ...breakpointsClasses]
  };
  return composeClasses(slots, getGridUtilityClass, classes);
};
const Grid = /*#__PURE__*/React__namespace.forwardRef(function Grid(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: 'MuiGrid'
  });
  const {
    breakpoints
  } = useTheme();
  const props = extendSxProp(themeProps);
  const {
      className,
      columns: columnsProp,
      columnSpacing: columnSpacingProp,
      component = 'div',
      container = false,
      direction = 'row',
      item = false,
      rowSpacing: rowSpacingProp,
      spacing = 0,
      wrap = 'wrap',
      zeroMinWidth = false
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$y);
  const rowSpacing = rowSpacingProp || spacing;
  const columnSpacing = columnSpacingProp || spacing;
  const columnsContext = React__namespace.useContext(GridContext$1);

  // columns set with default breakpoint unit of 12
  const columns = container ? columnsProp || 12 : columnsContext;
  const breakpointsValues = {};
  const otherFiltered = _extends({}, other);
  breakpoints.keys.forEach(breakpoint => {
    if (other[breakpoint] != null) {
      breakpointsValues[breakpoint] = other[breakpoint];
      delete otherFiltered[breakpoint];
    }
  });
  const ownerState = _extends({}, props, {
    columns,
    container,
    direction,
    item,
    rowSpacing,
    columnSpacing,
    wrap,
    zeroMinWidth,
    spacing
  }, breakpointsValues, {
    breakpoints: breakpoints.keys
  });
  const classes = useUtilityClasses$S(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(GridContext$1.Provider, {
    value: columns,
    children: /*#__PURE__*/jsxRuntime.jsx(GridRoot, _extends({
      ownerState: ownerState,
      className: clsx(classes.root, className),
      as: component,
      ref: ref
    }, otherFiltered))
  });
});
process.env.NODE_ENV !== "production" ? Grid.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The number of columns.
   * @default 12
   */
  columns: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.number), propTypesExports.number, propTypesExports.object]),
  /**
   * Defines the horizontal space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  columnSpacing: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string])), propTypesExports.number, propTypesExports.object, propTypesExports.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * If `true`, the component will have the flex *container* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  container: propTypesExports.bool,
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'row'
   */
  direction: propTypesExports.oneOfType([propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row']), propTypesExports.arrayOf(propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row'])), propTypesExports.object]),
  /**
   * If `true`, the component will have the flex *item* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  item: propTypesExports.bool,
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `lg` breakpoint and wider screens if not overridden.
   * @default false
   */
  lg: propTypesExports.oneOfType([propTypesExports.oneOf(['auto']), propTypesExports.number, propTypesExports.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `md` breakpoint and wider screens if not overridden.
   * @default false
   */
  md: propTypesExports.oneOfType([propTypesExports.oneOf(['auto']), propTypesExports.number, propTypesExports.bool]),
  /**
   * Defines the vertical space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  rowSpacing: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string])), propTypesExports.number, propTypesExports.object, propTypesExports.string]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `sm` breakpoint and wider screens if not overridden.
   * @default false
   */
  sm: propTypesExports.oneOfType([propTypesExports.oneOf(['auto']), propTypesExports.number, propTypesExports.bool]),
  /**
   * Defines the space between the type `item` components.
   * It can only be used on a type `container` component.
   * @default 0
   */
  spacing: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string])), propTypesExports.number, propTypesExports.object, propTypesExports.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Defines the `flex-wrap` style property.
   * It's applied for all screen sizes.
   * @default 'wrap'
   */
  wrap: propTypesExports.oneOf(['nowrap', 'wrap-reverse', 'wrap']),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `xl` breakpoint and wider screens if not overridden.
   * @default false
   */
  xl: propTypesExports.oneOfType([propTypesExports.oneOf(['auto']), propTypesExports.number, propTypesExports.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for all the screen sizes with the lowest priority.
   * @default false
   */
  xs: propTypesExports.oneOfType([propTypesExports.oneOf(['auto']), propTypesExports.number, propTypesExports.bool]),
  /**
   * If `true`, it sets `min-width: 0` on the item.
   * Refer to the limitations section of the documentation to better understand the use case.
   * @default false
   */
  zeroMinWidth: propTypesExports.bool
} : void 0;
if (process.env.NODE_ENV !== 'production') {
  const requireProp = requirePropFactory('Grid', Grid);
  // eslint-disable-next-line no-useless-concat
  Grid['propTypes' + ''] = _extends({}, Grid.propTypes, {
    direction: requireProp('container'),
    lg: requireProp('item'),
    md: requireProp('item'),
    sm: requireProp('item'),
    spacing: requireProp('container'),
    wrap: requireProp('container'),
    xs: requireProp('item'),
    zeroMinWidth: requireProp('item')
  });
}
var Grid$1 = Grid;

function getPickersToolbarUtilityClass(slot) {
    return generateUtilityClass('MuiPickersToolbar', slot);
}
const pickersToolbarClasses = generateUtilityClasses('MuiPickersToolbar', [
    'root',
    'content',
    'penIconButton',
    'penIconButtonLandscape',
]);

const useUtilityClasses$R = (ownerState) => {
    const { classes, isLandscape } = ownerState;
    const slots = {
        root: ['root'],
        content: ['content'],
        penIconButton: ['penIconButton', isLandscape && 'penIconButtonLandscape'],
    };
    return composeClasses(slots, getPickersToolbarUtilityClass, classes);
};
const PickersToolbarRoot = styled$1('div', {
    name: 'MuiPickersToolbar',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})(({ theme, ownerState }) => (Object.assign({ display: 'flex', flexDirection: 'column', alignItems: 'flex-start', justifyContent: 'space-between', padding: theme.spacing(2, 3) }, (ownerState.isLandscape && {
    height: 'auto',
    maxWidth: 160,
    padding: 16,
    justifyContent: 'flex-start',
    flexWrap: 'wrap',
}))));
const PickersToolbarContent = styled$1(Grid$1, {
    name: 'MuiPickersToolbar',
    slot: 'Content',
    overridesResolver: (props, styles) => styles.content,
})(({ ownerState }) => (Object.assign({ flex: 1 }, (!ownerState.isLandscape && {
    alignItems: 'center',
}))));
const PickersToolbarPenIconButton = styled$1(IconButton$1, {
    name: 'MuiPickersToolbar',
    slot: 'PenIconButton',
    overridesResolver: (props, styles) => [
        { [`&.${pickersToolbarClasses.penIconButtonLandscape}`]: styles.penIconButtonLandscape },
        styles.penIconButton,
    ],
})({});
const getViewTypeIcon = (viewType) => viewType === 'time' ? React__namespace.createElement(Clock, { color: "inherit" }) : React__namespace.createElement(Calendar, { color: "inherit" });
const PickersToolbar = React__namespace.forwardRef(function PickersToolbar(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiPickersToolbar' });
    const { children, className, isLandscape, isMobileKeyboardViewOpen, landscapeDirection = 'column', toggleMobileKeyboardView, toolbarTitle, viewType = 'date', } = props;
    const ownerState = props;
    const localeText = useLocaleText();
    const classes = useUtilityClasses$R(ownerState);
    return (React__namespace.createElement(PickersToolbarRoot, { ref: ref, "data-mui-test": "picker-toolbar", className: clsx(classes.root, className), ownerState: ownerState },
        React__namespace.createElement(Typography$1, { "data-mui-test": "picker-toolbar-title", color: "text.secondary", variant: "overline" }, toolbarTitle),
        React__namespace.createElement(PickersToolbarContent, { container: true, justifyContent: isLandscape ? 'flex-start' : 'space-between', className: classes.content, ownerState: ownerState, direction: isLandscape ? landscapeDirection : 'row', alignItems: isLandscape ? 'flex-start' : 'flex-end' },
            children,
            isMobileKeyboardViewOpen != null && toggleMobileKeyboardView != null && (React__namespace.createElement(PickersToolbarPenIconButton, { onClick: toggleMobileKeyboardView, className: classes.penIconButton, ownerState: ownerState, color: "inherit", "data-mui-test": "toggle-mobile-keyboard-view", "aria-label": localeText.inputModeToggleButtonAriaLabel(isMobileKeyboardViewOpen, viewType) }, isMobileKeyboardViewOpen ? getViewTypeIcon(viewType) : React__namespace.createElement(Pen, { color: "inherit" }))))));
});

const isYearOnlyView = (views) => views.length === 1 && views[0] === 'year';
const isYearAndMonthViews = (views) => views.length === 2 && views.indexOf('month') !== -1 && views.indexOf('year') !== -1;
const applyDefaultViewProps = ({ openTo, defaultOpenTo, views, defaultViews, }) => {
    const viewsWithDefault = views !== null && views !== void 0 ? views : defaultViews;
    let openToWithDefault;
    if (openTo != null) {
        openToWithDefault = openTo;
    }
    else if (viewsWithDefault.includes(defaultOpenTo)) {
        openToWithDefault = defaultOpenTo;
    }
    else if (viewsWithDefault.length > 0) {
        openToWithDefault = viewsWithDefault[0];
    }
    else {
        throw new Error('MUI: The `views` prop must contain at least one view');
    }
    return {
        views: viewsWithDefault,
        openTo: openToWithDefault,
    };
};

function getDatePickerToolbarUtilityClass(slot) {
    return generateUtilityClass('MuiDatePickerToolbar', slot);
}
const datePickerToolbarClasses = generateUtilityClasses('MuiDatePickerToolbar', ['root', 'title']);

const useUtilityClasses$Q = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        title: ['title'],
    };
    return composeClasses(slots, getDatePickerToolbarUtilityClass, classes);
};
const DatePickerToolbarRoot = styled$1(PickersToolbar, {
    name: 'MuiDatePickerToolbar',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})({});
const DatePickerToolbarTitle = styled$1(Typography$1, {
    name: 'MuiDatePickerToolbar',
    slot: 'Title',
    overridesResolver: (_, styles) => styles.title,
})(({ ownerState }) => (Object.assign({}, (ownerState.isLandscape && {
    margin: 'auto 16px auto auto',
}))));
/**
 * @ignore - internal component.
 */
const DatePickerToolbar = React__namespace.forwardRef(function DatePickerToolbar(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiDatePickerToolbar' });
    const { value, isLandscape, isMobileKeyboardViewOpen, onChange, toggleMobileKeyboardView, toolbarFormat, toolbarPlaceholder = '', views } = props, other = __rest(props, ["value", "isLandscape", "isMobileKeyboardViewOpen", "onChange", "toggleMobileKeyboardView", "toolbarFormat", "toolbarPlaceholder", "views"]);
    const utils = useUtils();
    const localeText = useLocaleText();
    const classes = useUtilityClasses$Q(props);
    const dateText = React__namespace.useMemo(() => {
        if (!value) {
            return toolbarPlaceholder;
        }
        if (toolbarFormat) {
            return utils.formatByString(value, toolbarFormat);
        }
        if (isYearOnlyView(views)) {
            return utils.format(value, 'year');
        }
        if (isYearAndMonthViews(views)) {
            return utils.format(value, 'month');
        }
        // Little localization hack (Google is doing the same for android native pickers):
        // For english localization it is convenient to include weekday into the date "Mon, Jun 1".
        // For other locales using strings like "June 1", without weekday.
        return /en/.test(utils.getCurrentLocaleCode())
            ? utils.format(value, 'normalDateWithWeekday')
            : utils.format(value, 'normalDate');
    }, [value, toolbarFormat, toolbarPlaceholder, utils, views]);
    const ownerState = props;
    return (React__namespace.createElement(DatePickerToolbarRoot, Object.assign({ ref: ref, toolbarTitle: localeText.datePickerToolbarTitle, isMobileKeyboardViewOpen: isMobileKeyboardViewOpen, toggleMobileKeyboardView: toggleMobileKeyboardView, isLandscape: isLandscape, className: classes.root }, other),
        React__namespace.createElement(DatePickerToolbarTitle, { variant: "h4", "data-mui-test": "datepicker-toolbar-date", align: isLandscape ? 'left' : 'center', ownerState: ownerState, className: classes.title }, dateText)));
});

const getFormatAndMaskByViews = (views, utils) => {
    if (isYearOnlyView(views)) {
        return {
            inputFormat: utils.formats.year,
        };
    }
    if (isYearAndMonthViews(views)) {
        return {
            disableMaskedInput: true,
            inputFormat: utils.formats.monthAndYear,
        };
    }
    return {
        inputFormat: utils.formats.keyboardDate,
    };
};
function useDatePickerDefaultizedProps(props, name) {
    var _a;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    // This is technically unsound if the type parameters appear in optional props.
    // Optional props can be filled by `useThemeProps` with types that don't match the type parameters.
    const themeProps = useThemeProps({
        props,
        name,
    });
    const views = (_a = themeProps.views) !== null && _a !== void 0 ? _a : ['year', 'day'];
    const localeText = React__namespace.useMemo(() => {
        var _a;
        if (((_a = themeProps.localeText) === null || _a === void 0 ? void 0 : _a.toolbarTitle) == null) {
            return themeProps.localeText;
        }
        return Object.assign(Object.assign({}, themeProps.localeText), { datePickerToolbarTitle: themeProps.localeText.toolbarTitle });
    }, [themeProps.localeText]);
    return Object.assign(Object.assign(Object.assign({ openTo: 'day', disableFuture: false, disablePast: false }, getFormatAndMaskByViews(views, utils)), themeProps), { views, minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate), localeText, components: Object.assign({ Toolbar: DatePickerToolbar }, themeProps.components) });
}

const reflow = node => node.scrollTop;
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  const {
    timeout,
    easing,
    style = {}
  } = props;
  return {
    duration: (_style$transitionDura = style.transitionDuration) != null ? _style$transitionDura : typeof timeout === 'number' ? timeout : timeout[options.mode] || 0,
    easing: (_style$transitionTimi = style.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing === 'object' ? easing[options.mode] : easing,
    delay: style.transitionDelay
  };
}

const _excluded$x = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles$2 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: 'none'
  }
};

/*
 TODO v6: remove
 Conditionally apply a workaround for the CSS transition bug in Safari 15.4 / WebKit browsers.
 */
const isWebKit154 = typeof navigator !== 'undefined' && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);

/**
 * The Grow transition is used by the [Tooltip](/material-ui/react-tooltip/) and
 * [Popover](/material-ui/react-popover/) components.
 * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
 */
const Grow = /*#__PURE__*/React__namespace.forwardRef(function Grow(props, ref) {
  const {
      addEndListener,
      appear = true,
      children,
      easing,
      in: inProp,
      onEnter,
      onEntered,
      onEntering,
      onExit,
      onExited,
      onExiting,
      style,
      timeout = 'auto',
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Transition$1
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$x);
  const timer = React__namespace.useRef();
  const autoTimeout = React__namespace.useRef();
  const theme = useTheme();
  const nodeRef = React__namespace.useRef(null);
  const handleRef = useForkRef$2(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = callback => maybeIsAppearing => {
    if (callback) {
      const node = nodeRef.current;

      // onEnterXxx and onExitXxx callbacks have a different arguments.length value.
      if (maybeIsAppearing === undefined) {
        callback(node);
      } else {
        callback(node, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
    reflow(node); // So the animation always start from the start.

    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: 'enter'
    });
    let duration;
    if (timeout === 'auto') {
      duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
      autoTimeout.current = duration;
    } else {
      duration = transitionDuration;
    }
    node.style.transition = [theme.transitions.create('opacity', {
      duration,
      delay
    }), theme.transitions.create('transform', {
      duration: isWebKit154 ? duration : duration * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(',');
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback(node => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: 'exit'
    });
    let duration;
    if (timeout === 'auto') {
      duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
      autoTimeout.current = duration;
    } else {
      duration = transitionDuration;
    }
    node.style.transition = [theme.transitions.create('opacity', {
      duration,
      delay
    }), theme.transitions.create('transform', {
      duration: isWebKit154 ? duration : duration * 0.666,
      delay: isWebKit154 ? delay : delay || duration * 0.333,
      easing: transitionTimingFunction
    })].join(',');
    node.style.opacity = 0;
    node.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = next => {
    if (timeout === 'auto') {
      timer.current = setTimeout(next, autoTimeout.current || 0);
    }
    if (addEndListener) {
      // Old call signature before `react-transition-group` implemented `nodeRef`
      addEndListener(nodeRef.current, next);
    }
  };
  React__namespace.useEffect(() => {
    return () => {
      clearTimeout(timer.current);
    };
  }, []);
  return /*#__PURE__*/jsxRuntime.jsx(TransitionComponent, _extends({
    appear: appear,
    in: inProp,
    nodeRef: nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === 'auto' ? null : timeout
  }, other, {
    children: (state, childProps) => {
      return /*#__PURE__*/React__namespace.cloneElement(children, _extends({
        style: _extends({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === 'exited' && !inProp ? 'hidden' : undefined
        }, styles$2[state], style, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
process.env.NODE_ENV !== "production" ? Grow.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: propTypesExports.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: propTypesExports.bool,
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: propTypesExports.oneOfType([propTypesExports.shape({
    enter: propTypesExports.string,
    exit: propTypesExports.string
  }), propTypesExports.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: propTypesExports.bool,
  /**
   * @ignore
   */
  onEnter: propTypesExports.func,
  /**
   * @ignore
   */
  onEntered: propTypesExports.func,
  /**
   * @ignore
   */
  onEntering: propTypesExports.func,
  /**
   * @ignore
   */
  onExit: propTypesExports.func,
  /**
   * @ignore
   */
  onExited: propTypesExports.func,
  /**
   * @ignore
   */
  onExiting: propTypesExports.func,
  /**
   * @ignore
   */
  style: propTypesExports.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  timeout: propTypesExports.oneOfType([propTypesExports.oneOf(['auto']), propTypesExports.number, propTypesExports.shape({
    appear: propTypesExports.number,
    enter: propTypesExports.number,
    exit: propTypesExports.number
  })])
} : void 0;
Grow.muiSupportAuto = true;
var Grow$1 = Grow;

function getPaperUtilityClass(slot) {
  return generateUtilityClass('MuiPaper', slot);
}
generateUtilityClasses('MuiPaper', ['root', 'rounded', 'outlined', 'elevation', 'elevation0', 'elevation1', 'elevation2', 'elevation3', 'elevation4', 'elevation5', 'elevation6', 'elevation7', 'elevation8', 'elevation9', 'elevation10', 'elevation11', 'elevation12', 'elevation13', 'elevation14', 'elevation15', 'elevation16', 'elevation17', 'elevation18', 'elevation19', 'elevation20', 'elevation21', 'elevation22', 'elevation23', 'elevation24']);

const _excluded$w = ["className", "component", "elevation", "square", "variant"];
const useUtilityClasses$P = ownerState => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ['root', variant, !square && 'rounded', variant === 'elevation' && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled$1('div', {
  name: 'MuiPaper',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.variant], !ownerState.square && styles.rounded, ownerState.variant === 'elevation' && styles[`elevation${ownerState.elevation}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create('box-shadow')
  }, !ownerState.square && {
    borderRadius: theme.shape.borderRadius
  }, ownerState.variant === 'outlined' && {
    border: `1px solid ${(theme.vars || theme).palette.divider}`
  }, ownerState.variant === 'elevation' && _extends({
    boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
  }, !theme.vars && theme.palette.mode === 'dark' && {
    backgroundImage: `linear-gradient(${alpha('#fff', getOverlayAlpha$1(ownerState.elevation))}, ${alpha('#fff', getOverlayAlpha$1(ownerState.elevation))})`
  }, theme.vars && {
    backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
const Paper = /*#__PURE__*/React__namespace.forwardRef(function Paper(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPaper'
  });
  const {
      className,
      component = 'div',
      elevation = 1,
      square = false,
      variant = 'elevation'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$w);
  const ownerState = _extends({}, props, {
    component,
    elevation,
    square,
    variant
  });
  const classes = useUtilityClasses$P(ownerState);
  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const theme = useTheme();
    if (theme.shadows[elevation] === undefined) {
      console.error([`MUI: The elevation provided <Paper elevation={${elevation}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${elevation}]\` is defined.`].join('\n'));
    }
  }
  return /*#__PURE__*/jsxRuntime.jsx(PaperRoot, _extends({
    as: component,
    ownerState: ownerState,
    className: clsx(classes.root, className),
    ref: ref
  }, other));
});
process.env.NODE_ENV !== "production" ? Paper.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: chainPropTypes(integerPropType, props => {
    const {
      elevation,
      variant
    } = props;
    if (elevation > 0 && variant === 'outlined') {
      return new Error(`MUI: Combining \`elevation={${elevation}}\` with \`variant="${variant}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`);
    }
    return null;
  }),
  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: propTypesExports.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['elevation', 'outlined']), propTypesExports.string])
} : void 0;
var Paper$1 = Paper;

const _excluded$v = ["components", "componentsProps", "slots", "slotProps"];
const PopperRoot = styled$1(PopperUnstyled$1, {
  name: 'MuiPopper',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({});

/**
 *
 * Demos:
 *
 * - [Autocomplete](https://mui.com/material-ui/react-autocomplete/)
 * - [Menu](https://mui.com/material-ui/react-menu/)
 * - [Popper](https://mui.com/material-ui/react-popper/)
 *
 * API:
 *
 * - [Popper API](https://mui.com/material-ui/api/popper/)
 */
const Popper = /*#__PURE__*/React__namespace.forwardRef(function Popper(inProps, ref) {
  var _slots$root;
  const theme = useTheme$2();
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPopper'
  });
  const {
      components,
      componentsProps,
      slots,
      slotProps
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$v);
  const RootComponent = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components == null ? void 0 : components.Root;
  return /*#__PURE__*/jsxRuntime.jsx(PopperRoot, _extends({
    direction: theme == null ? void 0 : theme.direction,
    slots: {
      root: RootComponent
    },
    slotProps: slotProps != null ? slotProps : componentsProps
  }, other, {
    ref: ref
  }));
});
process.env.NODE_ENV !== "production" ? Popper.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, propTypesExports.object, propTypesExports.func]),
  /**
   * Popper render function or node.
   */
  children: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.node, propTypesExports.func]),
  /**
   * @ignore
   */
  component: propTypesExports /* @typescript-to-proptypes-ignore */.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypesExports.shape({
    Root: propTypesExports.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  componentsProps: propTypesExports.shape({
    root: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, propTypesExports.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: propTypesExports.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: propTypesExports.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: propTypesExports.arrayOf(propTypesExports.shape({
    data: propTypesExports.object,
    effect: propTypesExports.func,
    enabled: propTypesExports.bool,
    fn: propTypesExports.func,
    name: propTypesExports.any,
    options: propTypesExports.object,
    phase: propTypesExports.oneOf(['afterMain', 'afterRead', 'afterWrite', 'beforeMain', 'beforeRead', 'beforeWrite', 'main', 'read', 'write']),
    requires: propTypesExports.arrayOf(propTypesExports.string),
    requiresIfExists: propTypesExports.arrayOf(propTypesExports.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: propTypesExports.bool.isRequired,
  /**
   * @ignore
   */
  ownerState: propTypesExports.any,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: propTypesExports.oneOf(['auto-end', 'auto-start', 'auto', 'bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: propTypesExports.shape({
    modifiers: propTypesExports.array,
    onFirstUpdate: propTypesExports.func,
    placement: propTypesExports.oneOf(['auto-end', 'auto-start', 'auto', 'bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),
    strategy: propTypesExports.oneOf(['absolute', 'fixed'])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: refType$1,
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: propTypesExports.shape({
    root: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object])
  }),
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: propTypesExports.shape({
    root: propTypesExports.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: propTypesExports.bool
} : void 0;
var MuiPopper = Popper;

function getButtonUtilityClass(slot) {
  return generateUtilityClass('MuiButton', slot);
}
const buttonClasses = generateUtilityClasses('MuiButton', ['root', 'text', 'textInherit', 'textPrimary', 'textSecondary', 'textSuccess', 'textError', 'textInfo', 'textWarning', 'outlined', 'outlinedInherit', 'outlinedPrimary', 'outlinedSecondary', 'outlinedSuccess', 'outlinedError', 'outlinedInfo', 'outlinedWarning', 'contained', 'containedInherit', 'containedPrimary', 'containedSecondary', 'containedSuccess', 'containedError', 'containedInfo', 'containedWarning', 'disableElevation', 'focusVisible', 'disabled', 'colorInherit', 'textSizeSmall', 'textSizeMedium', 'textSizeLarge', 'outlinedSizeSmall', 'outlinedSizeMedium', 'outlinedSizeLarge', 'containedSizeSmall', 'containedSizeMedium', 'containedSizeLarge', 'sizeMedium', 'sizeSmall', 'sizeLarge', 'fullWidth', 'startIcon', 'endIcon', 'iconSizeSmall', 'iconSizeMedium', 'iconSizeLarge']);
var buttonClasses$1 = buttonClasses;

/**
 * @ignore - internal component.
 */
const ButtonGroupContext = /*#__PURE__*/React__namespace.createContext({});
if (process.env.NODE_ENV !== 'production') {
  ButtonGroupContext.displayName = 'ButtonGroupContext';
}
var ButtonGroupContext$1 = ButtonGroupContext;

const _excluded$u = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
const useUtilityClasses$O = ownerState => {
  const {
    color,
    disableElevation,
    fullWidth,
    size,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ['root', variant, `${variant}${capitalize(color)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, color === 'inherit' && 'colorInherit', disableElevation && 'disableElevation', fullWidth && 'fullWidth'],
    label: ['label'],
    startIcon: ['startIcon', `iconSize${capitalize(size)}`],
    endIcon: ['endIcon', `iconSize${capitalize(size)}`]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return _extends({}, classes, composedClasses);
};
const commonIconStyles = ownerState => _extends({}, ownerState.size === 'small' && {
  '& > *:nth-of-type(1)': {
    fontSize: 18
  }
}, ownerState.size === 'medium' && {
  '& > *:nth-of-type(1)': {
    fontSize: 20
  }
}, ownerState.size === 'large' && {
  '& > *:nth-of-type(1)': {
    fontSize: 22
  }
});
const ButtonRoot = styled$1(ButtonBase$1, {
  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
  name: 'MuiButton',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.variant], styles[`${ownerState.variant}${capitalize(ownerState.color)}`], styles[`size${capitalize(ownerState.size)}`], styles[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === 'inherit' && styles.colorInherit, ownerState.disableElevation && styles.disableElevation, ownerState.fullWidth && styles.fullWidth];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  return _extends({}, theme.typography.button, {
    minWidth: 64,
    padding: '6px 16px',
    borderRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create(['background-color', 'box-shadow', 'border-color', 'color'], {
      duration: theme.transitions.duration.short
    }),
    '&:hover': _extends({
      textDecoration: 'none',
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: 'transparent'
      }
    }, ownerState.variant === 'text' && ownerState.color !== 'inherit' && {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: 'transparent'
      }
    }, ownerState.variant === 'outlined' && ownerState.color !== 'inherit' && {
      border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: 'transparent'
      }
    }, ownerState.variant === 'contained' && {
      backgroundColor: (theme.vars || theme).palette.grey.A100,
      boxShadow: (theme.vars || theme).shadows[4],
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        boxShadow: (theme.vars || theme).shadows[2],
        backgroundColor: (theme.vars || theme).palette.grey[300]
      }
    }, ownerState.variant === 'contained' && ownerState.color !== 'inherit' && {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }
    }),
    '&:active': _extends({}, ownerState.variant === 'contained' && {
      boxShadow: (theme.vars || theme).shadows[8]
    }),
    [`&.${buttonClasses$1.focusVisible}`]: _extends({}, ownerState.variant === 'contained' && {
      boxShadow: (theme.vars || theme).shadows[6]
    }),
    [`&.${buttonClasses$1.disabled}`]: _extends({
      color: (theme.vars || theme).palette.action.disabled
    }, ownerState.variant === 'outlined' && {
      border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
    }, ownerState.variant === 'outlined' && ownerState.color === 'secondary' && {
      border: `1px solid ${(theme.vars || theme).palette.action.disabled}`
    }, ownerState.variant === 'contained' && {
      color: (theme.vars || theme).palette.action.disabled,
      boxShadow: (theme.vars || theme).shadows[0],
      backgroundColor: (theme.vars || theme).palette.action.disabledBackground
    })
  }, ownerState.variant === 'text' && {
    padding: '6px 8px'
  }, ownerState.variant === 'text' && ownerState.color !== 'inherit' && {
    color: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.variant === 'outlined' && {
    padding: '5px 15px',
    border: '1px solid currentColor'
  }, ownerState.variant === 'outlined' && ownerState.color !== 'inherit' && {
    color: (theme.vars || theme).palette[ownerState.color].main,
    border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme.palette[ownerState.color].main, 0.5)}`
  }, ownerState.variant === 'contained' && {
    color: theme.vars ?
    // this is safe because grey does not change between default light/dark mode
    theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
    backgroundColor: (theme.vars || theme).palette.grey[300],
    boxShadow: (theme.vars || theme).shadows[2]
  }, ownerState.variant === 'contained' && ownerState.color !== 'inherit' && {
    color: (theme.vars || theme).palette[ownerState.color].contrastText,
    backgroundColor: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.color === 'inherit' && {
    color: 'inherit',
    borderColor: 'currentColor'
  }, ownerState.size === 'small' && ownerState.variant === 'text' && {
    padding: '4px 5px',
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === 'large' && ownerState.variant === 'text' && {
    padding: '8px 11px',
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === 'small' && ownerState.variant === 'outlined' && {
    padding: '3px 9px',
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === 'large' && ownerState.variant === 'outlined' && {
    padding: '7px 21px',
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === 'small' && ownerState.variant === 'contained' && {
    padding: '4px 10px',
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === 'large' && ownerState.variant === 'contained' && {
    padding: '8px 22px',
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.fullWidth && {
    width: '100%'
  });
}, ({
  ownerState
}) => ownerState.disableElevation && {
  boxShadow: 'none',
  '&:hover': {
    boxShadow: 'none'
  },
  [`&.${buttonClasses$1.focusVisible}`]: {
    boxShadow: 'none'
  },
  '&:active': {
    boxShadow: 'none'
  },
  [`&.${buttonClasses$1.disabled}`]: {
    boxShadow: 'none'
  }
});
const ButtonStartIcon = styled$1('span', {
  name: 'MuiButton',
  slot: 'StartIcon',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.startIcon, styles[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends({
  display: 'inherit',
  marginRight: 8,
  marginLeft: -4
}, ownerState.size === 'small' && {
  marginLeft: -2
}, commonIconStyles(ownerState)));
const ButtonEndIcon = styled$1('span', {
  name: 'MuiButton',
  slot: 'EndIcon',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.endIcon, styles[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends({
  display: 'inherit',
  marginRight: -4,
  marginLeft: 8
}, ownerState.size === 'small' && {
  marginRight: -2
}, commonIconStyles(ownerState)));
const Button = /*#__PURE__*/React__namespace.forwardRef(function Button(inProps, ref) {
  // props priority: `inProps` > `contextProps` > `themeDefaultProps`
  const contextProps = React__namespace.useContext(ButtonGroupContext$1);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useThemeProps({
    props: resolvedProps,
    name: 'MuiButton'
  });
  const {
      children,
      color = 'primary',
      component = 'button',
      className,
      disabled = false,
      disableElevation = false,
      disableFocusRipple = false,
      endIcon: endIconProp,
      focusVisibleClassName,
      fullWidth = false,
      size = 'medium',
      startIcon: startIconProp,
      type,
      variant = 'text'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$u);
  const ownerState = _extends({}, props, {
    color,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size,
    type,
    variant
  });
  const classes = useUtilityClasses$O(ownerState);
  const startIcon = startIconProp && /*#__PURE__*/jsxRuntime.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState: ownerState,
    children: startIconProp
  });
  const endIcon = endIconProp && /*#__PURE__*/jsxRuntime.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState: ownerState,
    children: endIconProp
  });
  return /*#__PURE__*/jsxRuntime.jsxs(ButtonRoot, _extends({
    ownerState: ownerState,
    className: clsx(contextProps.className, classes.root, className),
    component: component,
    disabled: disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref: ref,
    type: type
  }, other, {
    classes: classes,
    children: [startIcon, children, endIcon]
  }));
});
process.env.NODE_ENV !== "production" ? Button.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['inherit', 'primary', 'secondary', 'success', 'error', 'info', 'warning']), propTypesExports.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, no elevation is used.
   * @default false
   */
  disableElevation: propTypesExports.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: propTypesExports.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: propTypesExports.bool,
  /**
   * Element placed after the children.
   */
  endIcon: propTypesExports.node,
  /**
   * @ignore
   */
  focusVisibleClassName: propTypesExports.string,
  /**
   * If `true`, the button will take up the full width of its container.
   * @default false
   */
  fullWidth: propTypesExports.bool,
  /**
   * The URL to link to when the button is clicked.
   * If defined, an `a` element will be used as the root node.
   */
  href: propTypesExports.string,
  /**
   * The size of the component.
   * `small` is equivalent to the dense button styling.
   * @default 'medium'
   */
  size: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['small', 'medium', 'large']), propTypesExports.string]),
  /**
   * Element placed before the children.
   */
  startIcon: propTypesExports.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * @ignore
   */
  type: propTypesExports.oneOfType([propTypesExports.oneOf(['button', 'reset', 'submit']), propTypesExports.string]),
  /**
   * The variant to use.
   * @default 'text'
   */
  variant: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['contained', 'outlined', 'text']), propTypesExports.string])
} : void 0;
var Button$1 = Button;

function getDialogActionsUtilityClass(slot) {
  return generateUtilityClass('MuiDialogActions', slot);
}
generateUtilityClasses('MuiDialogActions', ['root', 'spacing']);

const _excluded$t = ["className", "disableSpacing"];
const useUtilityClasses$N = ownerState => {
  const {
    classes,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ['root', !disableSpacing && 'spacing']
  };
  return composeClasses(slots, getDialogActionsUtilityClass, classes);
};
const DialogActionsRoot = styled$1('div', {
  name: 'MuiDialogActions',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, !ownerState.disableSpacing && styles.spacing];
  }
})(({
  ownerState
}) => _extends({
  display: 'flex',
  alignItems: 'center',
  padding: 8,
  justifyContent: 'flex-end',
  flex: '0 0 auto'
}, !ownerState.disableSpacing && {
  '& > :not(:first-of-type)': {
    marginLeft: 8
  }
}));
const DialogActions = /*#__PURE__*/React__namespace.forwardRef(function DialogActions(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiDialogActions'
  });
  const {
      className,
      disableSpacing = false
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$t);
  const ownerState = _extends({}, props, {
    disableSpacing
  });
  const classes = useUtilityClasses$N(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(DialogActionsRoot, _extends({
    className: clsx(classes.root, className),
    ownerState: ownerState,
    ref: ref
  }, other));
});
process.env.NODE_ENV !== "production" ? DialogActions.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * If `true`, the actions do not have additional margin.
   * @default false
   */
  disableSpacing: propTypesExports.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object])
} : void 0;
var DialogActions$1 = DialogActions;

function PickersActionBar(props) {
    const { onAccept, onClear, onCancel, onSetToday, actions } = props, other = __rest(props, ["onAccept", "onClear", "onCancel", "onSetToday", "actions"]);
    const localeText = useLocaleText();
    if (actions == null || actions.length === 0) {
        return null;
    }
    const buttons = actions === null || actions === void 0 ? void 0 : actions.map((actionType) => {
        switch (actionType) {
            case 'clear':
                return (React__namespace.createElement(Button$1, { "data-mui-test": "clear-action-button", onClick: onClear, key: actionType }, localeText.clearButtonLabel));
            case 'cancel':
                return (React__namespace.createElement(Button$1, { onClick: onCancel, key: actionType }, localeText.cancelButtonLabel));
            case 'accept':
                return (React__namespace.createElement(Button$1, { onClick: onAccept, key: actionType }, localeText.okButtonLabel));
            case 'today':
                return (React__namespace.createElement(Button$1, { "data-mui-test": "today-action-button", onClick: onSetToday, key: actionType }, localeText.todayButtonLabel));
            default:
                return null;
        }
    });
    return React__namespace.createElement(DialogActions$1, Object.assign({}, other), buttons);
}
PickersActionBar.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Ordered array of actions to display.
     * If empty, does not display that action bar.
     * @default `['cancel', 'accept']` for mobile and `[]` for desktop
     */
    actions: propTypesExports.arrayOf(propTypesExports.oneOf(['accept', 'cancel', 'clear', 'today']).isRequired),
    /**
     * If `true`, the actions do not have additional margin.
     * @default false
     */
    disableSpacing: propTypesExports.bool,
    onAccept: propTypesExports.func.isRequired,
    onCancel: propTypesExports.func.isRequired,
    onClear: propTypesExports.func.isRequired,
    onSetToday: propTypesExports.func.isRequired,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
};

function getPickersPopperUtilityClass(slot) {
    return generateUtilityClass('MuiPickersPopper', slot);
}
generateUtilityClasses('MuiPickersPopper', ['root', 'paper']);

const useUtilityClasses$M = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        paper: ['paper'],
    };
    return composeClasses(slots, getPickersPopperUtilityClass, classes);
};
const PickersPopperRoot = styled$1(MuiPopper, {
    name: 'MuiPickersPopper',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})(({ theme }) => ({
    zIndex: theme.zIndex.modal,
}));
const PickersPopperPaper = styled$1(Paper$1, {
    name: 'MuiPickersPopper',
    slot: 'Paper',
    overridesResolver: (_, styles) => styles.paper,
})(({ ownerState }) => (Object.assign({ transformOrigin: 'top center', outline: 0 }, (ownerState.placement === 'top' && {
    transformOrigin: 'bottom center',
}))));
function clickedRootScrollbar(event, doc) {
    return (doc.documentElement.clientWidth < event.clientX ||
        doc.documentElement.clientHeight < event.clientY);
}
/**
 * Based on @mui/material/ClickAwayListener without the customization.
 * We can probably strip away even more since children won't be portaled.
 * @param {boolean} active Only listen to clicks when the popper is opened.
 * @param {(event: MouseEvent | TouchEvent) => void} onClickAway The callback to call when clicking outside the popper.
 * @returns {Array} The ref and event handler to listen to the outside clicks.
 */
function useClickAwayListener(active, onClickAway) {
    const movedRef = React__namespace.useRef(false);
    const syntheticEventRef = React__namespace.useRef(false);
    const nodeRef = React__namespace.useRef(null);
    const activatedRef = React__namespace.useRef(false);
    React__namespace.useEffect(() => {
        if (!active) {
            return undefined;
        }
        // Ensure that this hook is not "activated" synchronously.
        // https://github.com/facebook/react/issues/20074
        function armClickAwayListener() {
            activatedRef.current = true;
        }
        document.addEventListener('mousedown', armClickAwayListener, true);
        document.addEventListener('touchstart', armClickAwayListener, true);
        return () => {
            document.removeEventListener('mousedown', armClickAwayListener, true);
            document.removeEventListener('touchstart', armClickAwayListener, true);
            activatedRef.current = false;
        };
    }, [active]);
    // The handler doesn't take event.defaultPrevented into account:
    //
    // event.preventDefault() is meant to stop default behaviors like
    // clicking a checkbox to check it, hitting a button to submit a form,
    // and hitting left arrow to move the cursor in a text input etc.
    // Only special HTML elements have these default behaviors.
    const handleClickAway = useEventCallback$2((event) => {
        if (!activatedRef.current) {
            return;
        }
        // Given developers can stop the propagation of the synthetic event,
        // we can only be confident with a positive value.
        const insideReactTree = syntheticEventRef.current;
        syntheticEventRef.current = false;
        const doc = ownerDocument(nodeRef.current);
        // 1. IE11 support, which trigger the handleClickAway even after the unbind
        // 2. The child might render null.
        // 3. Behave like a blur listener.
        if (!nodeRef.current ||
            // is a TouchEvent?
            ('clientX' in event && clickedRootScrollbar(event, doc))) {
            return;
        }
        // Do not act if user performed touchmove
        if (movedRef.current) {
            movedRef.current = false;
            return;
        }
        let insideDOM;
        // If not enough, can use https://github.com/DieterHolvoet/event-propagation-path/blob/master/propagationPath.js
        if (event.composedPath) {
            insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
        }
        else {
            insideDOM =
                !doc.documentElement.contains(event.target) ||
                    nodeRef.current.contains(event.target);
        }
        if (!insideDOM && !insideReactTree) {
            onClickAway(event);
        }
    });
    // Keep track of mouse/touch events that bubbled up through the portal.
    const handleSynthetic = () => {
        syntheticEventRef.current = true;
    };
    React__namespace.useEffect(() => {
        if (active) {
            const doc = ownerDocument(nodeRef.current);
            const handleTouchMove = () => {
                movedRef.current = true;
            };
            doc.addEventListener('touchstart', handleClickAway);
            doc.addEventListener('touchmove', handleTouchMove);
            return () => {
                doc.removeEventListener('touchstart', handleClickAway);
                doc.removeEventListener('touchmove', handleTouchMove);
            };
        }
        return undefined;
    }, [active, handleClickAway]);
    React__namespace.useEffect(() => {
        // TODO This behavior is not tested automatically
        // It's unclear whether this is due to different update semantics in test (batched in act() vs discrete on click).
        // Or if this is a timing related issues due to different Transition components
        // Once we get rid of all the manual scheduling (e.g. setTimeout(update, 0)) we can revisit this code+test.
        if (active) {
            const doc = ownerDocument(nodeRef.current);
            doc.addEventListener('click', handleClickAway);
            return () => {
                doc.removeEventListener('click', handleClickAway);
                // cleanup `handleClickAway`
                syntheticEventRef.current = false;
            };
        }
        return undefined;
    }, [active, handleClickAway]);
    return [nodeRef, handleSynthetic, handleSynthetic];
}
function PickersPopper(inProps) {
    var _a, _b, _c, _d, _e, _f;
    const props = useThemeProps({ props: inProps, name: 'MuiPickersPopper' });
    const { anchorEl, children, containerRef = null, shouldRestoreFocus, onBlur, onDismiss, onClear, onAccept, onCancel, onSetToday, open, role, components, componentsProps, } = props;
    React__namespace.useEffect(() => {
        function handleKeyDown(nativeEvent) {
            // IE11, Edge (prior to using Bink?) use 'Esc'
            if (open && (nativeEvent.key === 'Escape' || nativeEvent.key === 'Esc')) {
                onDismiss();
            }
        }
        document.addEventListener('keydown', handleKeyDown);
        return () => {
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, [onDismiss, open]);
    const lastFocusedElementRef = React__namespace.useRef(null);
    React__namespace.useEffect(() => {
        if (role === 'tooltip' || (shouldRestoreFocus && !shouldRestoreFocus())) {
            return;
        }
        if (open) {
            lastFocusedElementRef.current = getActiveElement(document);
        }
        else if (lastFocusedElementRef.current &&
            lastFocusedElementRef.current instanceof HTMLElement) {
            // make sure the button is flushed with updated label, before returning focus to it
            // avoids issue, where screen reader could fail to announce selected date after selection
            setTimeout(() => {
                if (lastFocusedElementRef.current instanceof HTMLElement) {
                    lastFocusedElementRef.current.focus();
                }
            });
        }
    }, [open, role, shouldRestoreFocus]);
    const [clickAwayRef, onPaperClick, onPaperTouchStart] = useClickAwayListener(open, onBlur !== null && onBlur !== void 0 ? onBlur : onDismiss);
    const paperRef = React__namespace.useRef(null);
    const handleRef = useForkRef$2(paperRef, containerRef);
    const handlePaperRef = useForkRef$2(handleRef, clickAwayRef);
    const ownerState = props;
    const classes = useUtilityClasses$M(ownerState);
    const handleKeyDown = (event) => {
        if (event.key === 'Escape') {
            // stop the propagation to avoid closing parent modal
            event.stopPropagation();
            onDismiss();
        }
    };
    const ActionBar = (_a = components === null || components === void 0 ? void 0 : components.ActionBar) !== null && _a !== void 0 ? _a : PickersActionBar;
    const actionBarProps = useSlotProps({
        elementType: ActionBar,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.actionBar,
        additionalProps: {
            onAccept,
            onClear,
            onCancel,
            onSetToday,
            actions: [],
        },
        ownerState: { wrapperVariant: 'desktop' },
    });
    const PaperContent = (_b = components === null || components === void 0 ? void 0 : components.PaperContent) !== null && _b !== void 0 ? _b : React__namespace.Fragment;
    const Transition = (_c = components === null || components === void 0 ? void 0 : components.DesktopTransition) !== null && _c !== void 0 ? _c : Grow$1;
    const TrapFocus = (_d = components === null || components === void 0 ? void 0 : components.DesktopTrapFocus) !== null && _d !== void 0 ? _d : FocusTrap;
    const Paper = (_e = components === null || components === void 0 ? void 0 : components.DesktopPaper) !== null && _e !== void 0 ? _e : PickersPopperPaper;
    const paperProps = useSlotProps({
        elementType: Paper,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.desktopPaper,
        additionalProps: {
            tabIndex: -1,
            elevation: 8,
            ref: handlePaperRef,
        },
        className: classes.paper,
        ownerState: {}, // Is overridden below to use `placement
    });
    const Popper = (_f = components === null || components === void 0 ? void 0 : components.Popper) !== null && _f !== void 0 ? _f : PickersPopperRoot;
    const popperProps = useSlotProps({
        elementType: Popper,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.popper,
        additionalProps: {
            transition: true,
            role,
            open,
            anchorEl,
            onKeyDown: handleKeyDown,
        },
        className: classes.root,
        ownerState: props,
    });
    return (React__namespace.createElement(Popper, Object.assign({}, popperProps), ({ TransitionProps, placement }) => (React__namespace.createElement(TrapFocus, Object.assign({ open: open, disableAutoFocus: true, 
        // pickers are managing focus position manually
        // without this prop the focus is returned to the button before `aria-label` is updated
        // which would force screen readers to read too old label
        disableRestoreFocus: true, disableEnforceFocus: role === 'tooltip', isEnabled: () => true }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.desktopTrapFocus),
        React__namespace.createElement(Transition, Object.assign({}, TransitionProps, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.desktopTransition),
            React__namespace.createElement(Paper, Object.assign({}, paperProps, { onClick: (event) => {
                    var _a;
                    onPaperClick(event);
                    (_a = paperProps.onClick) === null || _a === void 0 ? void 0 : _a.call(paperProps, event);
                }, onTouchStart: (event) => {
                    var _a;
                    onPaperTouchStart(event);
                    (_a = paperProps.onTouchStart) === null || _a === void 0 ? void 0 : _a.call(paperProps, event);
                }, ownerState: Object.assign(Object.assign({}, ownerState), { placement }) }),
                React__namespace.createElement(PaperContent, Object.assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.paperContent),
                    children,
                    React__namespace.createElement(ActionBar, Object.assign({}, actionBarProps)))))))));
}

// TODO v6: Drop with the legacy pickers
function DesktopWrapper(props) {
    const { children, DateInputProps, KeyboardDateInputComponent, onClear, onDismiss, onCancel, onAccept, onSetToday, open, components, componentsProps, localeText, } = props;
    const ownInputRef = React__namespace.useRef(null);
    const inputRef = useForkRef$2(DateInputProps.inputRef, ownInputRef);
    return (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: "desktop" },
            React__namespace.createElement(KeyboardDateInputComponent, Object.assign({}, DateInputProps, { inputRef: inputRef })),
            React__namespace.createElement(PickersPopper, { role: "dialog", open: open, anchorEl: ownInputRef.current, onDismiss: onDismiss, onCancel: onCancel, onClear: onClear, onAccept: onAccept, onSetToday: onSetToday, components: components, componentsProps: componentsProps }, children))));
}

function useValidation(props, validate, isSameError, defaultErrorState) {
    const { value, onError } = props;
    const adapter = useLocalizationContext();
    const previousValidationErrorRef = React__namespace.useRef(defaultErrorState);
    const validationError = validate({ adapter, value, props });
    React__namespace.useEffect(() => {
        if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
            onError(validationError, value);
        }
        previousValidationErrorRef.current = validationError;
    }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
    return validationError;
}

const validateDate = ({ props, value, adapter }) => {
    if (value === null) {
        return null;
    }
    const now = adapter.utils.date();
    const minDate = applyDefaultDate(adapter.utils, props.minDate, adapter.defaultDates.minDate);
    const maxDate = applyDefaultDate(adapter.utils, props.maxDate, adapter.defaultDates.maxDate);
    switch (true) {
        case !adapter.utils.isValid(value):
            return 'invalidDate';
        case Boolean(props.shouldDisableDate && props.shouldDisableDate(value)):
            return 'shouldDisableDate';
        case Boolean(props.shouldDisableMonth && props.shouldDisableMonth(value)):
            return 'shouldDisableMonth';
        case Boolean(props.shouldDisableYear && props.shouldDisableYear(value)):
            return 'shouldDisableYear';
        case Boolean(props.disableFuture && adapter.utils.isAfterDay(value, now)):
            return 'disableFuture';
        case Boolean(props.disablePast && adapter.utils.isBeforeDay(value, now)):
            return 'disablePast';
        case Boolean(minDate && adapter.utils.isBeforeDay(value, minDate)):
            return 'minDate';
        case Boolean(maxDate && adapter.utils.isAfterDay(value, maxDate)):
            return 'maxDate';
        default:
            return null;
    }
};
const useIsDateDisabled = ({ shouldDisableDate, shouldDisableMonth, shouldDisableYear, minDate, maxDate, disableFuture, disablePast, }) => {
    const adapter = useLocalizationContext();
    return React__namespace.useCallback((day) => validateDate({
        adapter,
        value: day,
        props: {
            shouldDisableDate,
            shouldDisableMonth,
            shouldDisableYear,
            minDate,
            maxDate,
            disableFuture,
            disablePast,
        },
    }) !== null, [
        adapter,
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        minDate,
        maxDate,
        disableFuture,
        disablePast,
    ]);
};
// TODO v6: Drop with the legacy pickers
const isSameDateError = (a, b) => a === b;
// TODO v6: Drop with the legacy pickers
const useDateValidation = (props) => useValidation(props, validateDate, isSameDateError, null);

const createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils) => (state, action) => {
    switch (action.type) {
        case 'changeMonth':
            return Object.assign(Object.assign({}, state), { slideDirection: action.direction, currentMonth: action.newMonth, isMonthSwitchingAnimating: !reduceAnimations });
        case 'finishMonthSwitchingAnimation':
            return Object.assign(Object.assign({}, state), { isMonthSwitchingAnimating: false });
        case 'changeFocusedDay': {
            if (state.focusedDay != null &&
                action.focusedDay != null &&
                utils.isSameDay(action.focusedDay, state.focusedDay)) {
                return state;
            }
            const needMonthSwitch = action.focusedDay != null &&
                !disableSwitchToMonthOnDayFocus &&
                !utils.isSameMonth(state.currentMonth, action.focusedDay);
            return Object.assign(Object.assign({}, state), { focusedDay: action.focusedDay, isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations && !action.withoutMonthSwitchingAnimation, currentMonth: needMonthSwitch
                    ? utils.startOfMonth(action.focusedDay)
                    : state.currentMonth, slideDirection: action.focusedDay != null && utils.isAfterDay(action.focusedDay, state.currentMonth)
                    ? 'left'
                    : 'right' });
        }
        default:
            throw new Error('missing support');
    }
};
const useCalendarState = ({ value, defaultCalendarMonth, disableFuture, disablePast, disableSwitchToMonthOnDayFocus = false, maxDate, minDate, onMonthChange, reduceAnimations, shouldDisableDate, }) => {
    var _a;
    const now = useNow();
    const utils = useUtils();
    const reducerFn = React__namespace.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils)).current;
    const [calendarState, dispatch] = React__namespace.useReducer(reducerFn, {
        isMonthSwitchingAnimating: false,
        focusedDay: value || now,
        currentMonth: utils.startOfMonth((_a = value !== null && value !== void 0 ? value : defaultCalendarMonth) !== null && _a !== void 0 ? _a : clamp(utils, now, minDate, maxDate)),
        slideDirection: 'left',
    });
    const handleChangeMonth = React__namespace.useCallback((payload) => {
        dispatch(Object.assign({ type: 'changeMonth' }, payload));
        if (onMonthChange) {
            onMonthChange(payload.newMonth);
        }
    }, [onMonthChange]);
    const changeMonth = React__namespace.useCallback((newDate) => {
        const newDateRequested = newDate;
        if (utils.isSameMonth(newDateRequested, calendarState.currentMonth)) {
            return;
        }
        handleChangeMonth({
            newMonth: utils.startOfMonth(newDateRequested),
            direction: utils.isAfterDay(newDateRequested, calendarState.currentMonth)
                ? 'left'
                : 'right',
        });
    }, [calendarState.currentMonth, handleChangeMonth, utils]);
    const isDateDisabled = useIsDateDisabled({
        shouldDisableDate,
        minDate,
        maxDate,
        disableFuture,
        disablePast,
    });
    const onMonthSwitchingAnimationEnd = React__namespace.useCallback(() => {
        dispatch({ type: 'finishMonthSwitchingAnimation' });
    }, []);
    const changeFocusedDay = _default$2((newFocusedDate, withoutMonthSwitchingAnimation) => {
        if (!isDateDisabled(newFocusedDate)) {
            dispatch({
                type: 'changeFocusedDay',
                focusedDay: newFocusedDate,
                withoutMonthSwitchingAnimation,
            });
        }
    });
    return {
        calendarState,
        changeMonth,
        changeFocusedDay,
        isDateDisabled,
        onMonthSwitchingAnimationEnd,
        handleChangeMonth,
    };
};

const _excluded$s = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$1 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};

/**
 * The Fade transition is used by the [Modal](/material-ui/react-modal/) component.
 * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
 */
const Fade = /*#__PURE__*/React__namespace.forwardRef(function Fade(props, ref) {
  const theme = useTheme();
  const defaultTimeout = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
      addEndListener,
      appear = true,
      children,
      easing,
      in: inProp,
      onEnter,
      onEntered,
      onEntering,
      onExit,
      onExited,
      onExiting,
      style,
      timeout = defaultTimeout,
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Transition$1
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$s);
  const nodeRef = React__namespace.useRef(null);
  const handleRef = useForkRef$2(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = callback => maybeIsAppearing => {
    if (callback) {
      const node = nodeRef.current;

      // onEnterXxx and onExitXxx callbacks have a different arguments.length value.
      if (maybeIsAppearing === undefined) {
        callback(node);
      } else {
        callback(node, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
    reflow(node); // So the animation always start from the start.

    const transitionProps = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: 'enter'
    });
    node.style.webkitTransition = theme.transitions.create('opacity', transitionProps);
    node.style.transition = theme.transitions.create('opacity', transitionProps);
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback(node => {
    const transitionProps = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: 'exit'
    });
    node.style.webkitTransition = theme.transitions.create('opacity', transitionProps);
    node.style.transition = theme.transitions.create('opacity', transitionProps);
    if (onExit) {
      onExit(node);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = next => {
    if (addEndListener) {
      // Old call signature before `react-transition-group` implemented `nodeRef`
      addEndListener(nodeRef.current, next);
    }
  };
  return /*#__PURE__*/jsxRuntime.jsx(TransitionComponent, _extends({
    appear: appear,
    in: inProp,
    nodeRef: nodeRef ,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout
  }, other, {
    children: (state, childProps) => {
      return /*#__PURE__*/React__namespace.cloneElement(children, _extends({
        style: _extends({
          opacity: 0,
          visibility: state === 'exited' && !inProp ? 'hidden' : undefined
        }, styles$1[state], style, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
process.env.NODE_ENV !== "production" ? Fade.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: propTypesExports.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: propTypesExports.bool,
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: propTypesExports.oneOfType([propTypesExports.shape({
    enter: propTypesExports.string,
    exit: propTypesExports.string
  }), propTypesExports.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: propTypesExports.bool,
  /**
   * @ignore
   */
  onEnter: propTypesExports.func,
  /**
   * @ignore
   */
  onEntered: propTypesExports.func,
  /**
   * @ignore
   */
  onEntering: propTypesExports.func,
  /**
   * @ignore
   */
  onExit: propTypesExports.func,
  /**
   * @ignore
   */
  onExited: propTypesExports.func,
  /**
   * @ignore
   */
  onExiting: propTypesExports.func,
  /**
   * @ignore
   */
  style: propTypesExports.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  timeout: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.shape({
    appear: propTypesExports.number,
    enter: propTypesExports.number,
    exit: propTypesExports.number
  })])
} : void 0;
var Fade$1 = Fade;

const getPickersFadeTransitionGroupUtilityClass = (slot) => generateUtilityClass('MuiPickersFadeTransitionGroup', slot);
const pickersFadeTransitionGroupClasses = generateUtilityClasses('MuiPickersFadeTransitionGroup', ['root']);

const useUtilityClasses$L = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
    };
    return composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
};
const animationDuration = 500;
const PickersFadeTransitionGroupRoot = styled$1(TransitionGroup$1, {
    name: 'MuiPickersFadeTransitionGroup',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})({
    display: 'block',
    position: 'relative',
});
/**
 * @ignore - do not document.
 */
function PickersFadeTransitionGroup(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiPickersFadeTransitionGroup' });
    const { children, className, reduceAnimations, transKey } = props;
    const classes = useUtilityClasses$L(props);
    if (reduceAnimations) {
        return children;
    }
    return (React__namespace.createElement(PickersFadeTransitionGroupRoot, { className: clsx(classes.root, className) },
        React__namespace.createElement(Fade$1, { appear: false, mountOnEnter: true, unmountOnExit: true, key: transKey, timeout: { appear: animationDuration, enter: animationDuration / 2, exit: 0 } }, children)));
}

function getPickersDayUtilityClass(slot) {
    return generateUtilityClass('MuiPickersDay', slot);
}
const pickersDayClasses = generateUtilityClasses('MuiPickersDay', [
    'root',
    'dayWithMargin',
    'dayOutsideMonth',
    'hiddenDaySpacingFiller',
    'today',
    'selected',
    'disabled',
]);

const useUtilityClasses$K = (ownerState) => {
    const { selected, disableMargin, disableHighlightToday, today, disabled, outsideCurrentMonth, showDaysOutsideCurrentMonth, classes, } = ownerState;
    const slots = {
        root: [
            'root',
            selected && 'selected',
            disabled && 'disabled',
            !disableMargin && 'dayWithMargin',
            !disableHighlightToday && today && 'today',
            outsideCurrentMonth && showDaysOutsideCurrentMonth && 'dayOutsideMonth',
            outsideCurrentMonth && !showDaysOutsideCurrentMonth && 'hiddenDaySpacingFiller',
        ],
        hiddenDaySpacingFiller: ['hiddenDaySpacingFiller'],
    };
    return composeClasses(slots, getPickersDayUtilityClass, classes);
};
const styleArg = ({ theme, ownerState }) => (Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, theme.typography.caption), { width: DAY_SIZE, height: DAY_SIZE, borderRadius: '50%', padding: 0, 
    // background required here to prevent collides with the other days when animating with transition group
    backgroundColor: (theme.vars || theme).palette.background.paper, color: (theme.vars || theme).palette.text.primary, '@media (pointer: fine)': {
        '&:hover': {
            backgroundColor: theme.vars
                ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})`
                : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
        },
    }, '&:focus': {
        backgroundColor: theme.vars
            ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})`
            : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
        [`&.${pickersDayClasses.selected}`]: {
            willChange: 'background-color',
            backgroundColor: (theme.vars || theme).palette.primary.dark,
        },
    }, [`&.${pickersDayClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.main,
        fontWeight: theme.typography.fontWeightMedium,
        transition: theme.transitions.create('background-color', {
            duration: theme.transitions.duration.short,
        }),
        '&:hover': {
            willChange: 'background-color',
            backgroundColor: (theme.vars || theme).palette.primary.dark,
        },
    }, [`&.${pickersDayClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled,
    } }), (!ownerState.disableMargin && {
    margin: `0 ${DAY_MARGIN}px`,
})), (ownerState.outsideCurrentMonth &&
    ownerState.showDaysOutsideCurrentMonth && {
    color: (theme.vars || theme).palette.text.secondary,
})), (!ownerState.disableHighlightToday &&
    ownerState.today && {
    [`&:not(.${pickersDayClasses.selected})`]: {
        border: `1px solid ${(theme.vars || theme).palette.text.secondary}`,
    },
})));
const overridesResolver$1 = (props, styles) => {
    const { ownerState } = props;
    return [
        styles.root,
        !ownerState.disableMargin && styles.dayWithMargin,
        !ownerState.disableHighlightToday && ownerState.today && styles.today,
        !ownerState.outsideCurrentMonth &&
            ownerState.showDaysOutsideCurrentMonth &&
            styles.dayOutsideMonth,
        ownerState.outsideCurrentMonth &&
            !ownerState.showDaysOutsideCurrentMonth &&
            styles.hiddenDaySpacingFiller,
    ];
};
const PickersDayRoot = styled$1(ButtonBase$1, {
    name: 'MuiPickersDay',
    slot: 'Root',
    overridesResolver: overridesResolver$1,
})(styleArg);
const PickersDayFiller = styled$1('div', {
    name: 'MuiPickersDay',
    slot: 'Root',
    overridesResolver: overridesResolver$1,
})(({ theme, ownerState }) => (Object.assign(Object.assign({}, styleArg({ theme, ownerState })), { 
    // visibility: 'hidden' does not work here as it hides the element from screen readers as well
    opacity: 0, pointerEvents: 'none' })));
const noop = () => { };
const PickersDayRaw = React__namespace.forwardRef(function PickersDay(inProps, forwardedRef) {
    const props = useThemeProps({
        props: inProps,
        name: 'MuiPickersDay',
    });
    const { autoFocus = false, className, day, disabled = false, disableHighlightToday = false, disableMargin = false, hidden, isAnimating, onClick, onDaySelect, onFocus = noop, onBlur = noop, onKeyDown = noop, onMouseDown = noop, onMouseEnter = noop, outsideCurrentMonth, selected = false, showDaysOutsideCurrentMonth = false, children, today: isToday = false } = props, other = __rest(props, ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "onMouseEnter", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today"]);
    const ownerState = Object.assign(Object.assign({}, props), { autoFocus,
        disabled,
        disableHighlightToday,
        disableMargin,
        selected,
        showDaysOutsideCurrentMonth, today: isToday });
    const classes = useUtilityClasses$K(ownerState);
    const utils = useUtils();
    const ref = React__namespace.useRef(null);
    const handleRef = useForkRef$2(ref, forwardedRef);
    // Since this is rendered when a Popper is opened we can't use passive effects.
    // Focusing in passive effects in Popper causes scroll jump.
    useEnhancedEffect$3(() => {
        if (autoFocus && !disabled && !isAnimating && !outsideCurrentMonth) {
            // ref.current being null would be a bug in MUI
            ref.current.focus();
        }
    }, [autoFocus, disabled, isAnimating, outsideCurrentMonth]);
    // For day outside of current month, move focus from mouseDown to mouseUp
    // Goal: have the onClick ends before sliding to the new month
    const handleMouseDown = (event) => {
        onMouseDown(event);
        if (outsideCurrentMonth) {
            event.preventDefault();
        }
    };
    const handleClick = (event) => {
        if (!disabled) {
            onDaySelect(day);
        }
        if (outsideCurrentMonth) {
            event.currentTarget.focus();
        }
        if (onClick) {
            onClick(event);
        }
    };
    if (outsideCurrentMonth && !showDaysOutsideCurrentMonth) {
        return (React__namespace.createElement(PickersDayFiller, { className: clsx(classes.root, classes.hiddenDaySpacingFiller, className), ownerState: ownerState, role: other.role }));
    }
    return (React__namespace.createElement(PickersDayRoot, Object.assign({ className: clsx(classes.root, className), ref: handleRef, centerRipple: true, "data-mui-test": "day", disabled: disabled, tabIndex: selected ? 0 : -1, onKeyDown: (event) => onKeyDown(event, day), onFocus: (event) => onFocus(event, day), onBlur: (event) => onBlur(event, day), onMouseEnter: (event) => onMouseEnter(event, day), onClick: handleClick, onMouseDown: handleMouseDown }, other, { ownerState: ownerState }), !children ? utils.format(day, 'dayOfMonth') : children));
});
PickersDayRaw.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * A ref for imperative actions.
     * It currently only supports `focusVisible()` action.
     */
    action: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.shape({
                focusVisible: propTypesExports.func.isRequired,
            }),
        }),
    ]),
    /**
     * If `true`, the ripples are centered.
     * They won't start at the cursor interaction position.
     * @default false
     */
    centerRipple: propTypesExports.bool,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: propTypesExports.object,
    className: propTypesExports.string,
    /**
     * The date to show.
     */
    day: propTypesExports.any.isRequired,
    /**
     * If `true`, renders as disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * If `true`, days are rendering without margin. Useful for displaying linked range of days.
     * @default false
     */
    disableMargin: propTypesExports.bool,
    /**
     * If `true`, the ripple effect is disabled.
     *
     *  Without a ripple there is no styling for :focus-visible by default. Be sure
     * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
     * @default false
     */
    disableRipple: propTypesExports.bool,
    /**
     * If `true`, the touch ripple effect is disabled.
     * @default false
     */
    disableTouchRipple: propTypesExports.bool,
    /**
     * If `true`, the base button will have a keyboard focus ripple.
     * @default false
     */
    focusRipple: propTypesExports.bool,
    /**
     * This prop can help identify which element has keyboard focus.
     * The class name will be applied when the element gains the focus through keyboard interaction.
     * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
     * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
     * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
     * if needed.
     */
    focusVisibleClassName: propTypesExports.string,
    isAnimating: propTypesExports.bool,
    onBlur: propTypesExports.func,
    onDaySelect: propTypesExports.func.isRequired,
    onFocus: propTypesExports.func,
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible: propTypesExports.func,
    onKeyDown: propTypesExports.func,
    onMouseEnter: propTypesExports.func,
    /**
     * If `true`, day is outside of month and will be hidden.
     */
    outsideCurrentMonth: propTypesExports.bool.isRequired,
    /**
     * If `true`, renders as selected.
     * @default false
     */
    selected: propTypesExports.bool,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    style: propTypesExports.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * @default 0
     */
    tabIndex: propTypesExports.number,
    /**
     * If `true`, renders as today date.
     * @default false
     */
    today: propTypesExports.bool,
    /**
     * Props applied to the `TouchRipple` element.
     */
    TouchRippleProps: propTypesExports.object,
    /**
     * A ref that points to the `TouchRipple` element.
     */
    touchRippleRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.shape({
                pulsate: propTypesExports.func.isRequired,
                start: propTypesExports.func.isRequired,
                stop: propTypesExports.func.isRequired,
            }),
        }),
    ]),
};
/**
 *
 * Demos:
 *
 * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
 *
 * API:
 *
 * - [PickersDay API](https://mui.com/x/api/date-pickers/pickers-day/)
 */
const PickersDay = React__namespace.memo(PickersDayRaw);

const getPickersSlideTransitionUtilityClass = (slot) => generateUtilityClass('MuiPickersSlideTransition', slot);
const pickersSlideTransitionClasses = generateUtilityClasses('MuiPickersSlideTransition', [
    'root',
    'slideEnter-left',
    'slideEnter-right',
    'slideEnterActive',
    'slideExit',
    'slideExitActiveLeft-left',
    'slideExitActiveLeft-right',
]);

const useUtilityClasses$J = (ownerState) => {
    const { classes, slideDirection } = ownerState;
    const slots = {
        root: ['root'],
        exit: ['slideExit'],
        enterActive: ['slideEnterActive'],
        enter: [`slideEnter-${slideDirection}`],
        exitActive: [`slideExitActiveLeft-${slideDirection}`],
    };
    return composeClasses(slots, getPickersSlideTransitionUtilityClass, classes);
};
const slideAnimationDuration = 350;
const PickersSlideTransitionRoot = styled$1(TransitionGroup$1, {
    name: 'MuiPickersSlideTransition',
    slot: 'Root',
    overridesResolver: (_, styles) => [
        styles.root,
        { [`.${pickersSlideTransitionClasses['slideEnter-left']}`]: styles['slideEnter-left'] },
        { [`.${pickersSlideTransitionClasses['slideEnter-right']}`]: styles['slideEnter-right'] },
        { [`.${pickersSlideTransitionClasses.slideEnterActive}`]: styles.slideEnterActive },
        { [`.${pickersSlideTransitionClasses.slideExit}`]: styles.slideExit },
        {
            [`.${pickersSlideTransitionClasses['slideExitActiveLeft-left']}`]: styles['slideExitActiveLeft-left'],
        },
        {
            [`.${pickersSlideTransitionClasses['slideExitActiveLeft-right']}`]: styles['slideExitActiveLeft-right'],
        },
    ],
})(({ theme }) => {
    const slideTransition = theme.transitions.create('transform', {
        duration: slideAnimationDuration,
        easing: 'cubic-bezier(0.35, 0.8, 0.4, 1)',
    });
    return {
        display: 'block',
        position: 'relative',
        overflowX: 'hidden',
        '& > *': {
            position: 'absolute',
            top: 0,
            right: 0,
            left: 0,
        },
        [`& .${pickersSlideTransitionClasses['slideEnter-left']}`]: {
            willChange: 'transform',
            transform: 'translate(100%)',
            zIndex: 1,
        },
        [`& .${pickersSlideTransitionClasses['slideEnter-right']}`]: {
            willChange: 'transform',
            transform: 'translate(-100%)',
            zIndex: 1,
        },
        [`& .${pickersSlideTransitionClasses.slideEnterActive}`]: {
            transform: 'translate(0%)',
            transition: slideTransition,
        },
        [`& .${pickersSlideTransitionClasses.slideExit}`]: {
            transform: 'translate(0%)',
        },
        [`& .${pickersSlideTransitionClasses['slideExitActiveLeft-left']}`]: {
            willChange: 'transform',
            transform: 'translate(-100%)',
            transition: slideTransition,
            zIndex: 0,
        },
        [`& .${pickersSlideTransitionClasses['slideExitActiveLeft-right']}`]: {
            willChange: 'transform',
            transform: 'translate(100%)',
            transition: slideTransition,
            zIndex: 0,
        },
    };
});
/**
 * @ignore - do not document.
 */
function PickersSlideTransition(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiPickersSlideTransition' });
    const { children, className, reduceAnimations, slideDirection, transKey, 
    // extracting `classes` from `other`
    classes: providedClasses } = props, other = __rest(props, ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"]);
    const classes = useUtilityClasses$J(props);
    if (reduceAnimations) {
        return React__namespace.createElement("div", { className: clsx(classes.root, className) }, children);
    }
    const transitionClasses = {
        exit: classes.exit,
        enterActive: classes.enterActive,
        enter: classes.enter,
        exitActive: classes.exitActive,
    };
    return (React__namespace.createElement(PickersSlideTransitionRoot, { className: clsx(classes.root, className), childFactory: (element) => React__namespace.cloneElement(element, {
            classNames: transitionClasses,
        }), role: "presentation" },
        React__namespace.createElement(CSSTransition$1, Object.assign({ mountOnEnter: true, unmountOnExit: true, key: transKey, timeout: slideAnimationDuration, classNames: transitionClasses }, other), children)));
}

const getDayCalendarUtilityClass = (slot) => generateUtilityClass('MuiDayCalendar', slot);
const dayPickerClasses = generateUtilityClasses('MuiDayCalendar', [
    'header',
    'weekDayLabel',
    'loadingContainer',
    'slideTransition',
    'monthContainer',
    'weekContainer',
    'weekNumberLabel',
    'weekNumber',
]);

const useUtilityClasses$I = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        header: ['header'],
        weekDayLabel: ['weekDayLabel'],
        loadingContainer: ['loadingContainer'],
        slideTransition: ['slideTransition'],
        monthContainer: ['monthContainer'],
        weekContainer: ['weekContainer'],
        weekNumberLabel: ['weekNumberLabel'],
        weekNumber: ['weekNumber'],
    };
    return composeClasses(slots, getDayCalendarUtilityClass, classes);
};
const defaultDayOfWeekFormatter = (day) => day.charAt(0).toUpperCase();
const weeksContainerHeight$2 = (DAY_SIZE + DAY_MARGIN * 2) * 6;
const PickersCalendarDayHeader = styled$1('div', {
    name: 'MuiDayCalendar',
    slot: 'Header',
    overridesResolver: (_, styles) => styles.header,
})({
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
});
const PickersCalendarWeekDayLabel = styled$1(Typography$1, {
    name: 'MuiDayCalendar',
    slot: 'WeekDayLabel',
    overridesResolver: (_, styles) => styles.weekDayLabel,
})(({ theme }) => ({
    width: 36,
    height: 40,
    margin: '0 2px',
    textAlign: 'center',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    color: (theme.vars || theme).palette.text.secondary,
}));
const PickersCalendarWeekNumberLabel = styled$1(Typography$1, {
    name: 'MuiDayPicker',
    slot: 'WeekNumberLabel',
    overridesResolver: (_, styles) => styles.weekNumberLabel,
})(({ theme }) => ({
    width: 36,
    height: 40,
    margin: '0 2px',
    textAlign: 'center',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    color: theme.palette.text.disabled,
}));
const PickersCalendarWeekNumber = styled$1(Typography$1, {
    name: 'MuiDayPicker',
    slot: 'WeekNumber',
    overridesResolver: (_, styles) => styles.weekNumber,
})(({ theme }) => (Object.assign(Object.assign({}, theme.typography.caption), { width: DAY_SIZE, height: DAY_SIZE, padding: 0, margin: `0 ${DAY_MARGIN}px`, color: theme.palette.text.disabled, fontSize: '0.75rem', alignItems: 'center', justifyContent: 'center', display: 'inline-flex' })));
const PickersCalendarLoadingContainer = styled$1('div', {
    name: 'MuiDayCalendar',
    slot: 'LoadingContainer',
    overridesResolver: (_, styles) => styles.loadingContainer,
})({
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: weeksContainerHeight$2,
});
const PickersCalendarSlideTransition = styled$1(PickersSlideTransition, {
    name: 'MuiDayCalendar',
    slot: 'SlideTransition',
    overridesResolver: (_, styles) => styles.slideTransition,
})({
    minHeight: weeksContainerHeight$2,
});
const PickersCalendarWeekContainer = styled$1('div', {
    name: 'MuiDayCalendar',
    slot: 'MonthContainer',
    overridesResolver: (_, styles) => styles.monthContainer,
})({ overflow: 'hidden' });
const PickersCalendarWeek = styled$1('div', {
    name: 'MuiDayCalendar',
    slot: 'WeekContainer',
    overridesResolver: (_, styles) => styles.weekContainer,
})({
    margin: `${DAY_MARGIN}px 0`,
    display: 'flex',
    justifyContent: 'center',
});
function WrappedDay({ parentProps, day, focusableDay, selectedDays, onFocus, onBlur, onKeyDown, onDaySelect, isDateDisabled, currentMonthNumber, isViewFocused, }) {
    var _a;
    const utils = useUtils();
    const now = useNow();
    const { disabled, disableHighlightToday, isMonthSwitchingAnimating, showDaysOutsideCurrentMonth, components, componentsProps, } = parentProps;
    const isFocusableDay = focusableDay !== null && utils.isSameDay(day, focusableDay);
    const isSelected = selectedDays.some((selectedDay) => utils.isSameDay(selectedDay, day));
    const isToday = utils.isSameDay(day, now);
    const Day = (_a = components === null || components === void 0 ? void 0 : components.Day) !== null && _a !== void 0 ? _a : PickersDay;
    // We don't want to pass to ownerState down, to avoid re-rendering all the day whenever a prop changes.
    const _b = useSlotProps({
        elementType: Day,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.day,
        additionalProps: {
            disableHighlightToday,
            onKeyDown,
            onFocus,
            onBlur,
            onDaySelect,
            showDaysOutsideCurrentMonth,
            role: 'gridcell',
            isAnimating: isMonthSwitchingAnimating,
            // it is used in date range dragging logic by accessing `dataset.timestamp`
            'data-timestamp': utils.toJsDate(day).valueOf(),
        },
        ownerState: Object.assign(Object.assign({}, parentProps), { day, selected: isSelected }),
    }), dayProps = __rest(_b, ["ownerState"]);
    const isDisabled = React__namespace.useMemo(() => disabled || isDateDisabled(day), [disabled, isDateDisabled, day]);
    return (React__namespace.createElement(Day, Object.assign({}, dayProps, { day: day, disabled: isDisabled, autoFocus: isViewFocused && isFocusableDay, today: isToday, outsideCurrentMonth: utils.getMonth(day) !== currentMonthNumber, selected: isSelected, tabIndex: isFocusableDay ? 0 : -1, "aria-selected": isSelected, "aria-current": isToday ? 'date' : undefined })));
}
/**
 * @ignore - do not document.
 */
function DayCalendar(inProps) {
    const now = useNow();
    const utils = useUtils();
    const props = useThemeProps({ props: inProps, name: 'MuiDayCalendar' });
    const classes = useUtilityClasses$I(props);
    const theme = useTheme();
    const { onFocusedDayChange, className, currentMonth, selectedDays, focusedDay, loading, onSelectedDaysChange, onMonthSwitchingAnimationEnd, readOnly, reduceAnimations, renderLoading = () => React__namespace.createElement("span", { "data-mui-test": "loading-progress" }, "..."), slideDirection, TransitionProps, disablePast, disableFuture, minDate, maxDate, shouldDisableDate, shouldDisableMonth, shouldDisableYear, dayOfWeekFormatter = defaultDayOfWeekFormatter, hasFocus, onFocusedViewChange, gridLabelId, displayWeekNumber, fixedWeekNumber, autoFocus, } = props;
    const isDateDisabled = useIsDateDisabled({
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        minDate,
        maxDate,
        disablePast,
        disableFuture,
    });
    const localeText = useLocaleText();
    const [internalHasFocus, setInternalHasFocus] = useControlled$2({
        name: 'DayCalendar',
        state: 'hasFocus',
        controlled: hasFocus,
        default: autoFocus !== null && autoFocus !== void 0 ? autoFocus : false,
    });
    const [internalFocusedDay, setInternalFocusedDay] = React__namespace.useState(() => focusedDay || now);
    const handleDaySelect = _default$2((day) => {
        if (readOnly) {
            return;
        }
        onSelectedDaysChange(day);
    });
    const focusDay = (day) => {
        if (!isDateDisabled(day)) {
            onFocusedDayChange(day);
            setInternalFocusedDay(day);
            onFocusedViewChange === null || onFocusedViewChange === void 0 ? void 0 : onFocusedViewChange(true);
            setInternalHasFocus(true);
        }
    };
    const handleKeyDown = _default$2((event, day) => {
        switch (event.key) {
            case 'ArrowUp':
                focusDay(utils.addDays(day, -7));
                event.preventDefault();
                break;
            case 'ArrowDown':
                focusDay(utils.addDays(day, 7));
                event.preventDefault();
                break;
            case 'ArrowLeft': {
                const newFocusedDayDefault = utils.addDays(day, theme.direction === 'ltr' ? -1 : 1);
                const nextAvailableMonth = theme.direction === 'ltr' ? utils.getPreviousMonth(day) : utils.getNextMonth(day);
                const closestDayToFocus = findClosestEnabledDate({
                    utils,
                    date: newFocusedDayDefault,
                    minDate: theme.direction === 'ltr'
                        ? utils.startOfMonth(nextAvailableMonth)
                        : newFocusedDayDefault,
                    maxDate: theme.direction === 'ltr'
                        ? newFocusedDayDefault
                        : utils.endOfMonth(nextAvailableMonth),
                    isDateDisabled,
                });
                focusDay(closestDayToFocus || newFocusedDayDefault);
                event.preventDefault();
                break;
            }
            case 'ArrowRight': {
                const newFocusedDayDefault = utils.addDays(day, theme.direction === 'ltr' ? 1 : -1);
                const nextAvailableMonth = theme.direction === 'ltr' ? utils.getNextMonth(day) : utils.getPreviousMonth(day);
                const closestDayToFocus = findClosestEnabledDate({
                    utils,
                    date: newFocusedDayDefault,
                    minDate: theme.direction === 'ltr'
                        ? newFocusedDayDefault
                        : utils.startOfMonth(nextAvailableMonth),
                    maxDate: theme.direction === 'ltr'
                        ? utils.endOfMonth(nextAvailableMonth)
                        : newFocusedDayDefault,
                    isDateDisabled,
                });
                focusDay(closestDayToFocus || newFocusedDayDefault);
                event.preventDefault();
                break;
            }
            case 'Home':
                focusDay(utils.startOfWeek(day));
                event.preventDefault();
                break;
            case 'End':
                focusDay(utils.endOfWeek(day));
                event.preventDefault();
                break;
            case 'PageUp':
                focusDay(utils.getNextMonth(day));
                event.preventDefault();
                break;
            case 'PageDown':
                focusDay(utils.getPreviousMonth(day));
                event.preventDefault();
                break;
        }
    });
    const handleFocus = _default$2((event, day) => focusDay(day));
    const handleBlur = _default$2((event, day) => {
        if (internalHasFocus && utils.isSameDay(internalFocusedDay, day)) {
            onFocusedViewChange === null || onFocusedViewChange === void 0 ? void 0 : onFocusedViewChange(false);
        }
    });
    const currentMonthNumber = utils.getMonth(currentMonth);
    const validSelectedDays = React__namespace.useMemo(() => selectedDays.filter((day) => !!day).map((day) => utils.startOfDay(day)), [utils, selectedDays]);
    // need a new ref whenever the `key` of the transition changes: http://reactcommunity.org/react-transition-group/transition/#Transition-prop-nodeRef.
    const transitionKey = currentMonthNumber;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const slideNodeRef = React__namespace.useMemo(() => React__namespace.createRef(), [transitionKey]);
    const startOfCurrentWeek = utils.startOfWeek(now);
    const focusableDay = React__namespace.useMemo(() => {
        const startOfMonth = utils.startOfMonth(currentMonth);
        const endOfMonth = utils.endOfMonth(currentMonth);
        if (isDateDisabled(internalFocusedDay) ||
            utils.isAfterDay(internalFocusedDay, endOfMonth) ||
            utils.isBeforeDay(internalFocusedDay, startOfMonth)) {
            return findClosestEnabledDate({
                utils,
                date: internalFocusedDay,
                minDate: startOfMonth,
                maxDate: endOfMonth,
                disablePast,
                disableFuture,
                isDateDisabled,
            });
        }
        return internalFocusedDay;
    }, [currentMonth, disableFuture, disablePast, internalFocusedDay, isDateDisabled, utils]);
    const weeksToDisplay = React__namespace.useMemo(() => {
        const toDisplay = utils.getWeekArray(currentMonth);
        let nextMonth = utils.addMonths(currentMonth, 1);
        while (fixedWeekNumber && toDisplay.length < fixedWeekNumber) {
            const additionalWeeks = utils.getWeekArray(nextMonth);
            const hasCommonWeek = utils.isSameDay(toDisplay[toDisplay.length - 1][0], additionalWeeks[0][0]);
            additionalWeeks.slice(hasCommonWeek ? 1 : 0).forEach((week) => {
                if (toDisplay.length < fixedWeekNumber) {
                    toDisplay.push(week);
                }
            });
            nextMonth = utils.addMonths(nextMonth, 1);
        }
        return toDisplay;
    }, [currentMonth, fixedWeekNumber, utils]);
    return (React__namespace.createElement("div", { role: "grid", "aria-labelledby": gridLabelId },
        React__namespace.createElement(PickersCalendarDayHeader, { role: "row", className: classes.header },
            displayWeekNumber && (React__namespace.createElement(PickersCalendarWeekNumberLabel, { variant: "caption", role: "columnheader", "aria-label": localeText.calendarWeekNumberHeaderLabel, className: classes.weekNumberLabel }, localeText.calendarWeekNumberHeaderText)),
            utils.getWeekdays().map((day, i) => {
                var _a;
                return (React__namespace.createElement(PickersCalendarWeekDayLabel, { key: day + i.toString(), variant: "caption", role: "columnheader", "aria-label": utils.format(utils.addDays(startOfCurrentWeek, i), 'weekday'), className: classes.weekDayLabel }, (_a = dayOfWeekFormatter === null || dayOfWeekFormatter === void 0 ? void 0 : dayOfWeekFormatter(day)) !== null && _a !== void 0 ? _a : day));
            })),
        loading ? (React__namespace.createElement(PickersCalendarLoadingContainer, { className: classes.loadingContainer }, renderLoading())) : (React__namespace.createElement(PickersCalendarSlideTransition, Object.assign({ transKey: transitionKey, onExited: onMonthSwitchingAnimationEnd, reduceAnimations: reduceAnimations, slideDirection: slideDirection, className: clsx(className, classes.slideTransition) }, TransitionProps, { nodeRef: slideNodeRef }),
            React__namespace.createElement(PickersCalendarWeekContainer, { "data-mui-test": "pickers-calendar", ref: slideNodeRef, role: "rowgroup", className: classes.monthContainer }, weeksToDisplay.map((week) => (React__namespace.createElement(PickersCalendarWeek, { role: "row", key: `week-${week[0]}`, className: classes.weekContainer },
                displayWeekNumber && (React__namespace.createElement(PickersCalendarWeekNumber, { className: classes.weekNumber, role: "rowheader", "aria-label": localeText.calendarWeekNumberAriaLabelText(utils.getWeekNumber(week[0])) }, localeText.calendarWeekNumberText(utils.getWeekNumber(week[0])))),
                week.map((day) => (React__namespace.createElement(WrappedDay, { key: day.toString(), parentProps: props, day: day, selectedDays: validSelectedDays, focusableDay: focusableDay, onKeyDown: handleKeyDown, onFocus: handleFocus, onBlur: handleBlur, onDaySelect: handleDaySelect, isDateDisabled: isDateDisabled, currentMonthNumber: currentMonthNumber, isViewFocused: internalHasFocus })))))))))));
}

function getPickersMonthUtilityClass(slot) {
    return generateUtilityClass('MuiPickersMonth', slot);
}
const pickersMonthClasses = generateUtilityClasses('MuiPickersMonth', [
    'root',
    'modeMobile',
    'modeDesktop',
    'monthButton',
    'disabled',
    'selected',
]);

const useUtilityClasses$H = (ownerState) => {
    const { wrapperVariant, disabled, selected, classes } = ownerState;
    const slots = {
        root: ['root', wrapperVariant && `mode${capitalize(wrapperVariant)}`],
        monthButton: ['monthButton', disabled && 'disabled', selected && 'selected'],
    };
    return composeClasses(slots, getPickersMonthUtilityClass, classes);
};
const PickersMonthRoot = styled$1('div', {
    name: 'MuiPickersMonth',
    slot: 'Root',
    overridesResolver: (_, styles) => [
        styles.root,
        { [`&.${pickersMonthClasses.modeDesktop}`]: styles.modeDesktop },
        { [`&.${pickersMonthClasses.modeMobile}`]: styles.modeMobile },
    ],
})({
    flexBasis: '33.3%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
});
const PickersMonthButton = styled$1('button', {
    name: 'MuiPickersMonth',
    slot: 'MonthButton',
    overridesResolver: (_, styles) => [
        styles.monthButton,
        { [`&.${pickersMonthClasses.disabled}`]: styles.disabled },
        { [`&.${pickersMonthClasses.selected}`]: styles.selected },
    ],
})(({ theme }) => (Object.assign(Object.assign({ color: 'unset', backgroundColor: 'transparent', border: 0, outline: 0 }, theme.typography.subtitle1), { margin: '8px 0', height: 36, width: 72, borderRadius: 18, cursor: 'pointer', '&:focus': {
        backgroundColor: theme.vars
            ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})`
            : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
    }, '&:hover': {
        backgroundColor: theme.vars
            ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})`
            : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
    }, '&:disabled': {
        cursor: 'auto',
        pointerEvents: 'none',
    }, [`&.${pickersMonthClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.secondary,
    }, [`&.${pickersMonthClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.main,
        '&:focus, &:hover': {
            backgroundColor: (theme.vars || theme).palette.primary.dark,
        },
    } })));
/**
 * @ignore - do not document.
 */
const PickersMonth = React__namespace.memo(function PickersMonth(inProps) {
    const props = useThemeProps({
        props: inProps,
        name: 'MuiPickersMonth',
    });
    const { autoFocus, children, disabled, selected, value, tabIndex, onClick, onKeyDown, onFocus, onBlur, 'aria-current': ariaCurrent } = props, other = __rest(props, ["autoFocus", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", 'aria-current']);
    const wrapperVariant = React__namespace.useContext(WrapperVariantContext);
    const ref = React__namespace.useRef(null);
    useEnhancedEffect$3(() => {
        var _a;
        if (autoFocus) {
            (_a = ref.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }, [autoFocus]);
    const ownerState = Object.assign(Object.assign({}, props), { wrapperVariant });
    const classes = useUtilityClasses$H(ownerState);
    return (React__namespace.createElement(PickersMonthRoot, Object.assign({ "data-mui-test": "month", className: classes.root, ownerState: ownerState }, other),
        React__namespace.createElement(PickersMonthButton, { ref: ref, disabled: disabled, type: "button", tabIndex: disabled ? -1 : tabIndex, "aria-current": ariaCurrent, onClick: (event) => onClick(event, value), onKeyDown: (event) => onKeyDown(event, value), onFocus: (event) => onFocus(event, value), onBlur: (event) => onBlur(event, value), className: classes.monthButton, ownerState: ownerState }, children)));
});

function getMonthCalendarUtilityClass(slot) {
    return generateUtilityClass('MuiMonthCalendar', slot);
}
const monthCalendarClasses = generateUtilityClasses('MuiMonthCalendar', ['root']);

const useUtilityClasses$G = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
    };
    return composeClasses(slots, getMonthCalendarUtilityClass, classes);
};
function useMonthCalendarDefaultizedProps(props, name) {
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
        props,
        name,
    });
    return Object.assign(Object.assign({ disableFuture: false, disablePast: false }, themeProps), { minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate) });
}
const MonthCalendarRoot = styled$1('div', {
    name: 'MuiMonthCalendar',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({
    display: 'flex',
    flexWrap: 'wrap',
    alignContent: 'stretch',
    padding: '0 4px',
    width: 320,
});
const MonthCalendar = React__namespace.forwardRef(function MonthCalendar(inProps, ref) {
    const now = useNow();
    const theme = useTheme$1();
    const utils = useUtils();
    const props = useMonthCalendarDefaultizedProps(inProps, 'MuiMonthCalendar');
    const { className, value: valueProp, defaultValue, disabled, disableFuture, disablePast, maxDate, minDate, onChange, shouldDisableMonth, readOnly, disableHighlightToday, autoFocus = false, onMonthFocus, hasFocus, onFocusedViewChange } = props, other = __rest(props, ["className", "value", "defaultValue", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange"]);
    const ownerState = props;
    const classes = useUtilityClasses$G(ownerState);
    const [value, setValue] = useControlled$2({
        name: 'MonthCalendar',
        state: 'value',
        controlled: valueProp,
        default: defaultValue !== null && defaultValue !== void 0 ? defaultValue : null,
    });
    const todayMonth = React__namespace.useMemo(() => utils.getMonth(now), [utils, now]);
    const selectedDateOrStartOfMonth = React__namespace.useMemo(() => value !== null && value !== void 0 ? value : utils.startOfMonth(now), [now, utils, value]);
    const selectedMonth = React__namespace.useMemo(() => {
        if (value != null) {
            return utils.getMonth(value);
        }
        if (disableHighlightToday) {
            return null;
        }
        return utils.getMonth(now);
    }, [now, value, utils, disableHighlightToday]);
    const [focusedMonth, setFocusedMonth] = React__namespace.useState(() => selectedMonth || todayMonth);
    const [internalHasFocus, setInternalHasFocus] = useControlled$2({
        name: 'MonthCalendar',
        state: 'hasFocus',
        controlled: hasFocus,
        default: autoFocus !== null && autoFocus !== void 0 ? autoFocus : false,
    });
    const changeHasFocus = useEventCallback$2((newHasFocus) => {
        setInternalHasFocus(newHasFocus);
        if (onFocusedViewChange) {
            onFocusedViewChange(newHasFocus);
        }
    });
    const isMonthDisabled = useEventCallback$2((month) => {
        const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now, minDate) ? now : minDate);
        const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now, maxDate) ? now : maxDate);
        if (utils.isBefore(month, firstEnabledMonth)) {
            return true;
        }
        if (utils.isAfter(month, lastEnabledMonth)) {
            return true;
        }
        if (!shouldDisableMonth) {
            return false;
        }
        return shouldDisableMonth(month);
    });
    const handleMonthSelection = useEventCallback$2((event, month) => {
        if (readOnly) {
            return;
        }
        const newDate = utils.setMonth(selectedDateOrStartOfMonth, month);
        setValue(newDate);
        onChange === null || onChange === void 0 ? void 0 : onChange(newDate);
    });
    const focusMonth = useEventCallback$2((month) => {
        if (!isMonthDisabled(utils.setMonth(selectedDateOrStartOfMonth, month))) {
            setFocusedMonth(month);
            changeHasFocus(true);
            if (onMonthFocus) {
                onMonthFocus(month);
            }
        }
    });
    React__namespace.useEffect(() => {
        setFocusedMonth((prevFocusedMonth) => selectedMonth !== null && prevFocusedMonth !== selectedMonth
            ? selectedMonth
            : prevFocusedMonth);
    }, [selectedMonth]);
    const handleKeyDown = useEventCallback$2((event, month) => {
        const monthsInYear = 12;
        const monthsInRow = 3;
        switch (event.key) {
            case 'ArrowUp':
                focusMonth((monthsInYear + month - monthsInRow) % monthsInYear);
                event.preventDefault();
                break;
            case 'ArrowDown':
                focusMonth((monthsInYear + month + monthsInRow) % monthsInYear);
                event.preventDefault();
                break;
            case 'ArrowLeft':
                focusMonth((monthsInYear + month + (theme.direction === 'ltr' ? -1 : 1)) % monthsInYear);
                event.preventDefault();
                break;
            case 'ArrowRight':
                focusMonth((monthsInYear + month + (theme.direction === 'ltr' ? 1 : -1)) % monthsInYear);
                event.preventDefault();
                break;
        }
    });
    const handleMonthFocus = useEventCallback$2((event, month) => {
        focusMonth(month);
    });
    const handleMonthBlur = useEventCallback$2((event, month) => {
        if (focusedMonth === month) {
            changeHasFocus(false);
        }
    });
    return (React__namespace.createElement(MonthCalendarRoot, Object.assign({ ref: ref, className: clsx(classes.root, className), ownerState: ownerState }, other), utils.getMonthArray(selectedDateOrStartOfMonth).map((month) => {
        const monthNumber = utils.getMonth(month);
        const monthText = utils.format(month, 'monthShort');
        const isSelected = monthNumber === selectedMonth;
        const isDisabled = disabled || isMonthDisabled(month);
        return (React__namespace.createElement(PickersMonth, { key: monthText, selected: isSelected, value: monthNumber, onClick: handleMonthSelection, onKeyDown: handleKeyDown, autoFocus: internalHasFocus && monthNumber === focusedMonth, disabled: isDisabled, tabIndex: monthNumber === focusedMonth ? 0 : -1, onFocus: handleMonthFocus, onBlur: handleMonthBlur, "aria-current": todayMonth === monthNumber ? 'date' : undefined }, monthText));
    })));
});
MonthCalendar.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    autoFocus: propTypesExports.bool,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: propTypesExports.object,
    /**
     * className applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * The default selected value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true` picker is disabled
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    hasFocus: propTypesExports.bool,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value changes.
     * @template TDate
     * @param {TDate | null} value The new value.
     */
    onChange: propTypesExports.func,
    onFocusedViewChange: propTypesExports.func,
    onMonthFocus: propTypesExports.func,
    /**
     * If `true` picker is readonly
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
};

function getPickersYearUtilityClass(slot) {
    return generateUtilityClass('MuiPickersYear', slot);
}
const pickersYearClasses = generateUtilityClasses('MuiPickersYear', [
    'root',
    'modeDesktop',
    'modeMobile',
    'yearButton',
    'selected',
    'disabled',
]);

const useUtilityClasses$F = (ownerState) => {
    const { wrapperVariant, disabled, selected, classes } = ownerState;
    const slots = {
        root: ['root', wrapperVariant && `mode${capitalize(wrapperVariant)}`],
        yearButton: ['yearButton', disabled && 'disabled', selected && 'selected'],
    };
    return composeClasses(slots, getPickersYearUtilityClass, classes);
};
const PickersYearRoot = styled$1('div', {
    name: 'MuiPickersYear',
    slot: 'Root',
    overridesResolver: (_, styles) => [
        styles.root,
        { [`&.${pickersYearClasses.modeDesktop}`]: styles.modeDesktop },
        { [`&.${pickersYearClasses.modeMobile}`]: styles.modeMobile },
    ],
})(({ ownerState }) => (Object.assign({ flexBasis: '33.3%', display: 'flex', alignItems: 'center', justifyContent: 'center' }, ((ownerState === null || ownerState === void 0 ? void 0 : ownerState.wrapperVariant) === 'desktop' && {
    flexBasis: '25%',
}))));
const PickersYearButton = styled$1('button', {
    name: 'MuiPickersYear',
    slot: 'YearButton',
    overridesResolver: (_, styles) => [
        styles.yearButton,
        { [`&.${pickersYearClasses.disabled}`]: styles.disabled },
        { [`&.${pickersYearClasses.selected}`]: styles.selected },
    ],
})(({ theme }) => (Object.assign(Object.assign({ color: 'unset', backgroundColor: 'transparent', border: 0, outline: 0 }, theme.typography.subtitle1), { margin: '8px 0', height: 36, width: 72, borderRadius: 18, cursor: 'pointer', '&:focus': {
        backgroundColor: theme.vars
            ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.focusOpacity})`
            : alpha(theme.palette.action.active, theme.palette.action.focusOpacity),
    }, '&:hover': {
        backgroundColor: theme.vars
            ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})`
            : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
    }, '&:disabled': {
        cursor: 'auto',
        pointerEvents: 'none',
    }, [`&.${pickersYearClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.secondary,
    }, [`&.${pickersYearClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.contrastText,
        backgroundColor: (theme.vars || theme).palette.primary.main,
        '&:focus, &:hover': {
            backgroundColor: (theme.vars || theme).palette.primary.dark,
        },
    } })));
/**
 * @ignore - internal component.
 */
const PickersYear = React__namespace.memo(function PickersYear(inProps) {
    const props = useThemeProps({
        props: inProps,
        name: 'MuiPickersYear',
    });
    const { autoFocus, className, children, disabled, selected, value, tabIndex, onClick, onKeyDown, onFocus, onBlur, 'aria-current': ariaCurrent } = props, other = __rest(props, ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", 'aria-current']);
    const ref = React__namespace.useRef(null);
    const wrapperVariant = React__namespace.useContext(WrapperVariantContext);
    const ownerState = Object.assign(Object.assign({}, props), { wrapperVariant });
    const classes = useUtilityClasses$F(ownerState);
    // We can't forward the `autoFocus` to the button because it is a native button, not a MUI Button
    React__namespace.useEffect(() => {
        if (autoFocus) {
            // `ref.current` being `null` would be a bug in MUI.
            ref.current.focus();
        }
    }, [autoFocus]);
    return (React__namespace.createElement(PickersYearRoot, Object.assign({ "data-mui-test": "year", className: clsx(classes.root, className), ownerState: ownerState }, other),
        React__namespace.createElement(PickersYearButton, { ref: ref, disabled: disabled, type: "button", tabIndex: disabled ? -1 : tabIndex, "aria-current": ariaCurrent, onClick: (event) => onClick(event, value), onKeyDown: (event) => onKeyDown(event, value), onFocus: (event) => onFocus(event, value), onBlur: (event) => onBlur(event, value), className: classes.yearButton, ownerState: ownerState }, children)));
});

function getYearCalendarUtilityClass(slot) {
    return generateUtilityClass('MuiYearCalendar', slot);
}
const yearCalendarClasses = generateUtilityClasses('MuiYearCalendar', ['root']);

const useUtilityClasses$E = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
    };
    return composeClasses(slots, getYearCalendarUtilityClass, classes);
};
function useYearCalendarDefaultizedProps(props, name) {
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
        props,
        name,
    });
    return Object.assign(Object.assign({ disablePast: false, disableFuture: false }, themeProps), { minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate) });
}
const YearCalendarRoot = styled$1('div', {
    name: 'MuiYearCalendar',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({
    display: 'flex',
    flexDirection: 'row',
    flexWrap: 'wrap',
    overflowY: 'auto',
    height: '100%',
    padding: '0 4px',
    width: 320,
    maxHeight: 304,
});
const YearCalendar = React__namespace.forwardRef(function YearCalendar(inProps, ref) {
    const now = useNow();
    const theme = useTheme$1();
    const utils = useUtils();
    const wrapperVariant = React__namespace.useContext(WrapperVariantContext);
    const props = useYearCalendarDefaultizedProps(inProps, 'MuiYearCalendar');
    const { autoFocus, className, value: valueProp, defaultValue, disabled, disableFuture, disablePast, maxDate, minDate, onChange, readOnly, shouldDisableYear, disableHighlightToday, onYearFocus, hasFocus, onFocusedViewChange } = props, other = __rest(props, ["autoFocus", "className", "value", "defaultValue", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange"]);
    const ownerState = props;
    const classes = useUtilityClasses$E(ownerState);
    const [value, setValue] = useControlled$2({
        name: 'YearCalendar',
        state: 'value',
        controlled: valueProp,
        default: defaultValue !== null && defaultValue !== void 0 ? defaultValue : null,
    });
    const selectedDateOrStartOfYear = React__namespace.useMemo(() => value !== null && value !== void 0 ? value : utils.startOfYear(now), [now, utils, value]);
    const todayYear = React__namespace.useMemo(() => utils.getYear(now), [utils, now]);
    const selectedYear = React__namespace.useMemo(() => {
        if (value != null) {
            return utils.getYear(value);
        }
        if (disableHighlightToday) {
            return null;
        }
        return utils.getYear(now);
    }, [now, value, utils, disableHighlightToday]);
    const [focusedYear, setFocusedYear] = React__namespace.useState(() => selectedYear || todayYear);
    const [internalHasFocus, setInternalHasFocus] = useControlled$2({
        name: 'YearCalendar',
        state: 'hasFocus',
        controlled: hasFocus,
        default: autoFocus !== null && autoFocus !== void 0 ? autoFocus : false,
    });
    const changeHasFocus = useEventCallback$2((newHasFocus) => {
        setInternalHasFocus(newHasFocus);
        if (onFocusedViewChange) {
            onFocusedViewChange(newHasFocus);
        }
    });
    const isYearDisabled = useEventCallback$2((dateToValidate) => {
        if (disablePast && utils.isBeforeYear(dateToValidate, now)) {
            return true;
        }
        if (disableFuture && utils.isAfterYear(dateToValidate, now)) {
            return true;
        }
        if (minDate && utils.isBeforeYear(dateToValidate, minDate)) {
            return true;
        }
        if (maxDate && utils.isAfterYear(dateToValidate, maxDate)) {
            return true;
        }
        if (shouldDisableYear && shouldDisableYear(dateToValidate)) {
            return true;
        }
        return false;
    });
    const handleYearSelection = useEventCallback$2((event, year) => {
        if (readOnly) {
            return;
        }
        const newDate = utils.setYear(selectedDateOrStartOfYear, year);
        setValue(newDate);
        onChange === null || onChange === void 0 ? void 0 : onChange(newDate);
    });
    const focusYear = useEventCallback$2((year) => {
        if (!isYearDisabled(utils.setYear(selectedDateOrStartOfYear, year))) {
            setFocusedYear(year);
            changeHasFocus(true);
            onYearFocus === null || onYearFocus === void 0 ? void 0 : onYearFocus(year);
        }
    });
    React__namespace.useEffect(() => {
        setFocusedYear((prevFocusedYear) => selectedYear !== null && prevFocusedYear !== selectedYear ? selectedYear : prevFocusedYear);
    }, [selectedYear]);
    const handleKeyDown = useEventCallback$2((event, year) => {
        const yearsInRow = wrapperVariant === 'desktop' ? 4 : 3;
        switch (event.key) {
            case 'ArrowUp':
                focusYear(year - yearsInRow);
                event.preventDefault();
                break;
            case 'ArrowDown':
                focusYear(year + yearsInRow);
                event.preventDefault();
                break;
            case 'ArrowLeft':
                focusYear(year + (theme.direction === 'ltr' ? -1 : 1));
                event.preventDefault();
                break;
            case 'ArrowRight':
                focusYear(year + (theme.direction === 'ltr' ? 1 : -1));
                event.preventDefault();
                break;
        }
    });
    const handleYearFocus = useEventCallback$2((event, year) => {
        focusYear(year);
    });
    const handleYearBlur = useEventCallback$2((event, year) => {
        if (focusedYear === year) {
            changeHasFocus(false);
        }
    });
    const scrollerRef = React__namespace.useRef(null);
    const handleRef = useForkRef$2(ref, scrollerRef);
    React__namespace.useEffect(() => {
        if (autoFocus || scrollerRef.current === null) {
            return;
        }
        const tabbableButton = scrollerRef.current.querySelector('[tabindex="0"]');
        if (!tabbableButton) {
            return;
        }
        // Taken from useScroll in x-data-grid, but vertically centered
        const offsetHeight = tabbableButton.offsetHeight;
        const offsetTop = tabbableButton.offsetTop;
        const clientHeight = scrollerRef.current.clientHeight;
        const scrollTop = scrollerRef.current.scrollTop;
        const elementBottom = offsetTop + offsetHeight;
        if (offsetHeight > clientHeight || offsetTop < scrollTop) {
            // Button already visible
            return;
        }
        scrollerRef.current.scrollTop = elementBottom - clientHeight / 2 - offsetHeight / 2;
    }, [autoFocus]);
    return (React__namespace.createElement(YearCalendarRoot, Object.assign({ ref: handleRef, className: clsx(classes.root, className), ownerState: ownerState }, other), utils.getYearRange(minDate, maxDate).map((year) => {
        const yearNumber = utils.getYear(year);
        const isSelected = yearNumber === selectedYear;
        const isDisabled = disabled || isYearDisabled(year);
        return (React__namespace.createElement(PickersYear, { key: utils.format(year, 'year'), selected: isSelected, value: yearNumber, onClick: handleYearSelection, onKeyDown: handleKeyDown, autoFocus: internalHasFocus && yearNumber === focusedYear, disabled: isDisabled, tabIndex: yearNumber === focusedYear ? 0 : -1, onFocus: handleYearFocus, onBlur: handleYearBlur, "aria-current": todayYear === yearNumber ? 'date' : undefined }, utils.format(year, 'year')));
    })));
});
YearCalendar.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    autoFocus: propTypesExports.bool,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: propTypesExports.object,
    /**
     * className applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * The default selected value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true` picker is disabled
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    hasFocus: propTypesExports.bool,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value changes.
     * @template TDate
     * @param {TDate | null} value The new value.
     */
    onChange: propTypesExports.func,
    onFocusedViewChange: propTypesExports.func,
    onYearFocus: propTypesExports.func,
    /**
     * If `true` picker is readonly
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
};

const getPickersCalendarHeaderUtilityClass = (slot) => generateUtilityClass('MuiPickersCalendarHeader', slot);
const pickersCalendarHeaderClasses = generateUtilityClasses('MuiPickersCalendarHeader', ['root', 'labelContainer', 'label', 'switchViewButton', 'switchViewIcon']);

const useUtilityClasses$D = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        labelContainer: ['labelContainer'],
        label: ['label'],
        switchViewButton: ['switchViewButton'],
        switchViewIcon: ['switchViewIcon'],
    };
    return composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
};
const PickersCalendarHeaderRoot = styled$1('div', {
    name: 'MuiPickersCalendarHeader',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})({
    display: 'flex',
    alignItems: 'center',
    marginTop: 16,
    marginBottom: 8,
    paddingLeft: 24,
    paddingRight: 12,
    // prevent jumping in safari
    maxHeight: 30,
    minHeight: 30,
});
const PickersCalendarHeaderLabelContainer = styled$1('div', {
    name: 'MuiPickersCalendarHeader',
    slot: 'LabelContainer',
    overridesResolver: (_, styles) => styles.labelContainer,
})(({ theme }) => (Object.assign(Object.assign({ display: 'flex', overflow: 'hidden', alignItems: 'center', cursor: 'pointer', marginRight: 'auto' }, theme.typography.body1), { fontWeight: theme.typography.fontWeightMedium })));
const PickersCalendarHeaderLabel = styled$1('div', {
    name: 'MuiPickersCalendarHeader',
    slot: 'Label',
    overridesResolver: (_, styles) => styles.label,
})({
    marginRight: 6,
});
const PickersCalendarHeaderSwitchViewButton = styled$1(IconButton$1, {
    name: 'MuiPickersCalendarHeader',
    slot: 'SwitchViewButton',
    overridesResolver: (_, styles) => styles.switchViewButton,
})(({ ownerState }) => (Object.assign({ marginRight: 'auto' }, (ownerState.view === 'year' && {
    [`.${pickersCalendarHeaderClasses.switchViewIcon}`]: {
        transform: 'rotate(180deg)',
    },
}))));
const PickersCalendarHeaderSwitchViewIcon = styled$1(ArrowDropDown, {
    name: 'MuiPickersCalendarHeader',
    slot: 'SwitchViewIcon',
    overridesResolver: (_, styles) => styles.switchViewIcon,
})(({ theme }) => ({
    willChange: 'transform',
    transition: theme.transitions.create('transform'),
    transform: 'rotate(0deg)',
}));
/**
 * @ignore - do not document.
 */
function PickersCalendarHeader(inProps) {
    var _a, _b;
    const localeText = useLocaleText();
    const utils = useUtils();
    const props = useThemeProps({ props: inProps, name: 'MuiPickersCalendarHeader' });
    const { components = {}, componentsProps = {}, currentMonth: month, disabled, disableFuture, disablePast, maxDate, minDate, onMonthChange, onViewChange, view, reduceAnimations, views, labelId, } = props;
    const ownerState = props;
    const classes = useUtilityClasses$D(props);
    const SwitchViewButton = (_a = components.SwitchViewButton) !== null && _a !== void 0 ? _a : PickersCalendarHeaderSwitchViewButton;
    const switchViewButtonProps = useSlotProps({
        elementType: SwitchViewButton,
        externalSlotProps: componentsProps.switchViewButton,
        additionalProps: {
            size: 'small',
            'aria-label': localeText.calendarViewSwitchingButtonAriaLabel(view),
        },
        ownerState,
        className: classes.switchViewButton,
    });
    const SwitchViewIcon = (_b = components.SwitchViewIcon) !== null && _b !== void 0 ? _b : PickersCalendarHeaderSwitchViewIcon;
    // The spread is here to avoid this bug mui/material-ui#34056
    const _c = useSlotProps({
        elementType: SwitchViewIcon,
        externalSlotProps: componentsProps.switchViewIcon,
        ownerState: undefined,
        className: classes.switchViewIcon,
    }), switchViewIconProps = __rest(_c, ["ownerState"]);
    const selectNextMonth = () => onMonthChange(utils.getNextMonth(month), 'left');
    const selectPreviousMonth = () => onMonthChange(utils.getPreviousMonth(month), 'right');
    const isNextMonthDisabled = useNextMonthDisabled(month, {
        disableFuture,
        maxDate,
    });
    const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
        disablePast,
        minDate,
    });
    const handleToggleView = () => {
        if (views.length === 1 || !onViewChange || disabled) {
            return;
        }
        if (views.length === 2) {
            onViewChange(views.find((el) => el !== view) || views[0]);
        }
        else {
            // switching only between first 2
            const nextIndexToOpen = views.indexOf(view) !== 0 ? 0 : 1;
            onViewChange(views[nextIndexToOpen]);
        }
    };
    // No need to display more information
    if (views.length === 1 && views[0] === 'year') {
        return null;
    }
    return (React__namespace.createElement(PickersCalendarHeaderRoot, { ownerState: ownerState, className: classes.root },
        React__namespace.createElement(PickersCalendarHeaderLabelContainer, { role: "presentation", onClick: handleToggleView, ownerState: ownerState, "aria-live": "polite", className: classes.labelContainer },
            React__namespace.createElement(PickersFadeTransitionGroup, { reduceAnimations: reduceAnimations, transKey: utils.format(month, 'monthAndYear') },
                React__namespace.createElement(PickersCalendarHeaderLabel, { id: labelId, "data-mui-test": "calendar-month-and-year-text", ownerState: ownerState, className: classes.label }, utils.format(month, 'monthAndYear'))),
            views.length > 1 && !disabled && (React__namespace.createElement(SwitchViewButton, Object.assign({}, switchViewButtonProps),
                React__namespace.createElement(SwitchViewIcon, Object.assign({}, switchViewIconProps))))),
        React__namespace.createElement(Fade$1, { in: view === 'day' },
            React__namespace.createElement(PickersArrowSwitcher, { components: components, componentsProps: componentsProps, onGoToPrevious: selectPreviousMonth, isPreviousDisabled: isPreviousMonthDisabled, previousLabel: localeText.previousMonth, onGoToNext: selectNextMonth, isNextDisabled: isNextMonthDisabled, nextLabel: localeText.nextMonth }))));
}

const defaultReduceAnimations = typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent);

const getDateCalendarUtilityClass = (slot) => generateUtilityClass('MuiDateCalendar', slot);
const dateCalendarClasses = generateUtilityClasses('MuiDateCalendar', [
    'root',
    'viewTransitionContainer',
]);

const useUtilityClasses$C = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        viewTransitionContainer: ['viewTransitionContainer'],
    };
    return composeClasses(slots, getDateCalendarUtilityClass, classes);
};
function useDateCalendarDefaultizedProps(props, name) {
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
        props,
        name,
    });
    return Object.assign(Object.assign({ loading: false, disablePast: false, disableFuture: false, openTo: 'day', views: ['year', 'day'], reduceAnimations: defaultReduceAnimations, renderLoading: () => React__namespace.createElement("span", { "data-mui-test": "loading-progress" }, "...") }, themeProps), { minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate) });
}
const DateCalendarRoot = styled$1(PickerViewRoot, {
    name: 'MuiDateCalendar',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({
    display: 'flex',
    flexDirection: 'column',
});
const DateCalendarViewTransitionContainer = styled$1(PickersFadeTransitionGroup, {
    name: 'MuiDateCalendar',
    slot: 'ViewTransitionContainer',
    overridesResolver: (props, styles) => styles.viewTransitionContainer,
})({});
/**
 *
 * Demos:
 *
 * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
 *
 * API:
 *
 * - [DateCalendar API](https://mui.com/x/api/date-pickers/date-calendar/)
 */
const DateCalendar = React__namespace.forwardRef(function DateCalendar(inProps, ref) {
    const utils = useUtils();
    const id = useId();
    const props = useDateCalendarDefaultizedProps(inProps, 'MuiDateCalendar');
    const { autoFocus, onViewChange, value: valueProp, defaultValue, disableFuture, disablePast, defaultCalendarMonth, onChange, onYearChange, onMonthChange, reduceAnimations, shouldDisableDate, shouldDisableMonth, shouldDisableYear, view: inView, views, openTo, className, disabled, readOnly, minDate, maxDate, disableHighlightToday, focusedView: inFocusedView, onFocusedViewChange, showDaysOutsideCurrentMonth, fixedWeekNumber, dayOfWeekFormatter, components, componentsProps, loading, renderLoading, displayWeekNumber, sx, } = props;
    const [value, setValue] = useControlled$2({
        name: 'DateCalendar',
        state: 'value',
        controlled: valueProp,
        default: defaultValue !== null && defaultValue !== void 0 ? defaultValue : null,
    });
    const handleValueChange = useEventCallback$2((newValue, selectionState) => {
        setValue(newValue);
        onChange === null || onChange === void 0 ? void 0 : onChange(newValue, selectionState);
    });
    const { view, setView, focusedView, setFocusedView, goToNextView, setValueAndGoToNextView } = useViews({
        view: inView,
        views,
        openTo,
        onChange: handleValueChange,
        onViewChange,
        autoFocus,
        focusedView: inFocusedView,
        onFocusedViewChange,
    });
    const { calendarState, changeFocusedDay, changeMonth, handleChangeMonth, isDateDisabled, onMonthSwitchingAnimationEnd, } = useCalendarState({
        value,
        defaultCalendarMonth,
        reduceAnimations,
        onMonthChange,
        minDate,
        maxDate,
        shouldDisableDate,
        disablePast,
        disableFuture,
    });
    const handleDateMonthChange = useEventCallback$2((newDate) => {
        const startOfMonth = utils.startOfMonth(newDate);
        const endOfMonth = utils.endOfMonth(newDate);
        const closestEnabledDate = isDateDisabled(newDate)
            ? findClosestEnabledDate({
                utils,
                date: newDate,
                minDate: utils.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
                maxDate: utils.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
                disablePast,
                disableFuture,
                isDateDisabled,
            })
            : newDate;
        if (closestEnabledDate) {
            setValueAndGoToNextView(closestEnabledDate, 'finish');
            onMonthChange === null || onMonthChange === void 0 ? void 0 : onMonthChange(startOfMonth);
        }
        else {
            goToNextView();
            changeMonth(startOfMonth);
        }
        changeFocusedDay(closestEnabledDate, true);
    });
    const handleDateYearChange = useEventCallback$2((newDate) => {
        const startOfYear = utils.startOfYear(newDate);
        const endOfYear = utils.endOfYear(newDate);
        const closestEnabledDate = isDateDisabled(newDate)
            ? findClosestEnabledDate({
                utils,
                date: newDate,
                minDate: utils.isBefore(minDate, startOfYear) ? startOfYear : minDate,
                maxDate: utils.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
                disablePast,
                disableFuture,
                isDateDisabled,
            })
            : newDate;
        if (closestEnabledDate) {
            setValueAndGoToNextView(closestEnabledDate, 'finish');
            onYearChange === null || onYearChange === void 0 ? void 0 : onYearChange(closestEnabledDate);
        }
        else {
            goToNextView();
            changeMonth(startOfYear);
        }
        changeFocusedDay(closestEnabledDate, true);
    });
    const handleSelectedDayChange = useEventCallback$2((day) => {
        if (value && day) {
            // If there is a date already selected, then we want to keep its time
            return setValueAndGoToNextView(utils.mergeDateAndTime(day, value), 'finish');
        }
        return setValueAndGoToNextView(day, 'finish');
    });
    React__namespace.useEffect(() => {
        if (value != null && utils.isValid(value)) {
            changeMonth(value);
        }
    }, [value]); // eslint-disable-line
    const ownerState = props;
    const classes = useUtilityClasses$C(ownerState);
    const baseDateValidationProps = {
        disablePast,
        disableFuture,
        maxDate,
        minDate,
    };
    // When disabled, limit the view to the selected date
    const minDateWithDisabled = (disabled && value) || minDate;
    const maxDateWithDisabled = (disabled && value) || maxDate;
    const commonViewProps = {
        disableHighlightToday,
        readOnly,
        disabled,
    };
    const gridLabelId = `${id}-grid-label`;
    const hasFocus = focusedView !== null;
    const prevOpenViewRef = React__namespace.useRef(view);
    React__namespace.useEffect(() => {
        // If the view change and the focus was on the previous view
        // Then we update the focus.
        if (prevOpenViewRef.current === view) {
            return;
        }
        if (focusedView === prevOpenViewRef.current) {
            setFocusedView(view, true);
        }
        prevOpenViewRef.current = view;
    }, [focusedView, setFocusedView, view]);
    const selectedDays = React__namespace.useMemo(() => [value], [value]);
    return (React__namespace.createElement(DateCalendarRoot, { ref: ref, className: clsx(classes.root, className), ownerState: ownerState, sx: sx },
        React__namespace.createElement(PickersCalendarHeader, { views: views, view: view, currentMonth: calendarState.currentMonth, onViewChange: setView, onMonthChange: (newMonth, direction) => handleChangeMonth({ newMonth, direction }), minDate: minDateWithDisabled, maxDate: maxDateWithDisabled, disabled: disabled, disablePast: disablePast, disableFuture: disableFuture, reduceAnimations: reduceAnimations, labelId: gridLabelId, components: components, componentsProps: componentsProps }),
        React__namespace.createElement(DateCalendarViewTransitionContainer, { reduceAnimations: reduceAnimations, className: classes.viewTransitionContainer, transKey: view, ownerState: ownerState },
            React__namespace.createElement("div", null,
                view === 'year' && (React__namespace.createElement(YearCalendar, Object.assign({}, baseDateValidationProps, commonViewProps, { value: value, onChange: handleDateYearChange, shouldDisableYear: shouldDisableYear, hasFocus: hasFocus, onFocusedViewChange: (isViewFocused) => setFocusedView('year', isViewFocused) }))),
                view === 'month' && (React__namespace.createElement(MonthCalendar, Object.assign({}, baseDateValidationProps, commonViewProps, { hasFocus: hasFocus, className: className, value: value, onChange: handleDateMonthChange, shouldDisableMonth: shouldDisableMonth, onFocusedViewChange: (isViewFocused) => setFocusedView('month', isViewFocused) }))),
                view === 'day' && (React__namespace.createElement(DayCalendar, Object.assign({}, calendarState, baseDateValidationProps, commonViewProps, { onMonthSwitchingAnimationEnd: onMonthSwitchingAnimationEnd, onFocusedDayChange: changeFocusedDay, reduceAnimations: reduceAnimations, selectedDays: selectedDays, onSelectedDaysChange: handleSelectedDayChange, shouldDisableDate: shouldDisableDate, shouldDisableMonth: shouldDisableMonth, shouldDisableYear: shouldDisableYear, hasFocus: hasFocus, onFocusedViewChange: (isViewFocused) => setFocusedView('day', isViewFocused), gridLabelId: gridLabelId, showDaysOutsideCurrentMonth: showDaysOutsideCurrentMonth, fixedWeekNumber: fixedWeekNumber, dayOfWeekFormatter: dayOfWeekFormatter, displayWeekNumber: displayWeekNumber, components: components, componentsProps: componentsProps, loading: loading, renderLoading: renderLoading })))))));
});
DateCalendar.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    classes: propTypesExports.object,
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default selected value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Controlled focused view.
     */
    focusedView: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value changes.
     * @template TDate
     * @param {TDate | null} value The new value.
     * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired on focused view change.
     * @template TView
     * @param {TView} view The new view to focus or not.
     * @param {boolean} hasFocus `true` if the view should be focused.
     */
    onFocusedViewChange: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

/**
 * @ignore - internal component.
 */
const FormControlContext = /*#__PURE__*/React__namespace.createContext(undefined);
if (process.env.NODE_ENV !== 'production') {
  FormControlContext.displayName = 'FormControlContext';
}
var FormControlContext$1 = FormControlContext;

function useFormControl() {
  return React__namespace.useContext(FormControlContext$1);
}

function getInputAdornmentUtilityClass(slot) {
  return generateUtilityClass('MuiInputAdornment', slot);
}
const inputAdornmentClasses = generateUtilityClasses('MuiInputAdornment', ['root', 'filled', 'standard', 'outlined', 'positionStart', 'positionEnd', 'disablePointerEvents', 'hiddenLabel', 'sizeSmall']);
var inputAdornmentClasses$1 = inputAdornmentClasses;

var _span$3;
const _excluded$r = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"];
const overridesResolver = (props, styles) => {
  const {
    ownerState
  } = props;
  return [styles.root, styles[`position${capitalize(ownerState.position)}`], ownerState.disablePointerEvents === true && styles.disablePointerEvents, styles[ownerState.variant]];
};
const useUtilityClasses$B = ownerState => {
  const {
    classes,
    disablePointerEvents,
    hiddenLabel,
    position,
    size,
    variant
  } = ownerState;
  const slots = {
    root: ['root', disablePointerEvents && 'disablePointerEvents', position && `position${capitalize(position)}`, variant, hiddenLabel && 'hiddenLabel', size && `size${capitalize(size)}`]
  };
  return composeClasses(slots, getInputAdornmentUtilityClass, classes);
};
const InputAdornmentRoot = styled$1('div', {
  name: 'MuiInputAdornment',
  slot: 'Root',
  overridesResolver
})(({
  theme,
  ownerState
}) => _extends({
  display: 'flex',
  height: '0.01em',
  // Fix IE11 flexbox alignment. To remove at some point.
  maxHeight: '2em',
  alignItems: 'center',
  whiteSpace: 'nowrap',
  color: (theme.vars || theme).palette.action.active
}, ownerState.variant === 'filled' && {
  // Styles applied to the root element if `variant="filled"`.
  [`&.${inputAdornmentClasses$1.positionStart}&:not(.${inputAdornmentClasses$1.hiddenLabel})`]: {
    marginTop: 16
  }
}, ownerState.position === 'start' && {
  // Styles applied to the root element if `position="start"`.
  marginRight: 8
}, ownerState.position === 'end' && {
  // Styles applied to the root element if `position="end"`.
  marginLeft: 8
}, ownerState.disablePointerEvents === true && {
  // Styles applied to the root element if `disablePointerEvents={true}`.
  pointerEvents: 'none'
}));
const InputAdornment = /*#__PURE__*/React__namespace.forwardRef(function InputAdornment(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiInputAdornment'
  });
  const {
      children,
      className,
      component = 'div',
      disablePointerEvents = false,
      disableTypography = false,
      position,
      variant: variantProp
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$r);
  const muiFormControl = useFormControl() || {};
  let variant = variantProp;
  if (variantProp && muiFormControl.variant) {
    if (process.env.NODE_ENV !== 'production') {
      if (variantProp === muiFormControl.variant) {
        console.error('MUI: The `InputAdornment` variant infers the variant prop ' + 'you do not have to provide one.');
      }
    }
  }
  if (muiFormControl && !variant) {
    variant = muiFormControl.variant;
  }
  const ownerState = _extends({}, props, {
    hiddenLabel: muiFormControl.hiddenLabel,
    size: muiFormControl.size,
    disablePointerEvents,
    position,
    variant
  });
  const classes = useUtilityClasses$B(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(FormControlContext$1.Provider, {
    value: null,
    children: /*#__PURE__*/jsxRuntime.jsx(InputAdornmentRoot, _extends({
      as: component,
      ownerState: ownerState,
      className: clsx(classes.root, className),
      ref: ref
    }, other, {
      children: typeof children === 'string' && !disableTypography ? /*#__PURE__*/jsxRuntime.jsx(Typography$1, {
        color: "text.secondary",
        children: children
      }) : /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
        children: [position === 'start' ? /* notranslate needed while Google Translate will not fix zero-width space issue */_span$3 || (_span$3 = /*#__PURE__*/jsxRuntime.jsx("span", {
          className: "notranslate",
          children: "\u200B"
        })) : null, children]
      })
    }))
  });
});
process.env.NODE_ENV !== "production" ? InputAdornment.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component, normally an `IconButton` or string.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * Disable pointer events on the root.
   * This allows for the content of the adornment to focus the `input` on click.
   * @default false
   */
  disablePointerEvents: propTypesExports.bool,
  /**
   * If children is a string then disable wrapping in a Typography component.
   * @default false
   */
  disableTypography: propTypesExports.bool,
  /**
   * The position this adornment should appear relative to the `Input`.
   */
  position: propTypesExports.oneOf(['end', 'start']).isRequired,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The variant to use.
   * Note: If you are using the `TextField` component or the `FormControl` component
   * you do not have to set this manually.
   */
  variant: propTypesExports.oneOf(['filled', 'outlined', 'standard'])
} : void 0;
var MuiInputAdornment = InputAdornment;

const useRifm = props => {
  const [, refresh] = React$4.useReducer(c => c + 1, 0);
  const valueRef = React$4.useRef(null);
  const {
    replace,
    append
  } = props;
  const userValue = replace ? replace(props.format(props.value)) : props.format(props.value); // state of delete button see comments below about inputType support

  const isDeleleteButtonDownRef = React$4.useRef(false);

  const onChange = evt => {
    if (process.env.NODE_ENV !== 'production') {
      if (evt.target.type === 'number') {
        console.error('Rifm does not support input type=number, use type=tel instead.');
        return;
      }

      if (evt.target.type === 'date') {
        console.error('Rifm does not support input type=date.');
        return;
      }
    }

    const eventValue = evt.target.value;
    valueRef.current = [eventValue, // eventValue
    evt.target, // input
    eventValue.length > userValue.length, // isSizeIncreaseOperation
    isDeleleteButtonDownRef.current, // isDeleleteButtonDown
    userValue === props.format(eventValue) // isNoOperation
    ];

    if (process.env.NODE_ENV !== 'production') {
      const formattedEventValue = props.format(eventValue);

      if (eventValue !== formattedEventValue && eventValue.toLowerCase() === formattedEventValue.toLowerCase()) {
        console.warn('Case enforcement does not work with format. Please use replace={value => value.toLowerCase()} instead');
      }
    } // The main trick is to update underlying input with non formatted value (= eventValue)
    // that allows us to calculate right cursor position after formatting (see getCursorPosition)
    // then we format new value and call props.onChange with masked/formatted value
    // and finally we are able to set cursor position into right place


    refresh();
  }; // React prints warn on server in non production mode about useLayoutEffect usage
  // in both cases it's noop


  if (process.env.NODE_ENV === 'production' || typeof window !== 'undefined') {
    React$4.useLayoutEffect(() => {
      if (valueRef.current == null) return;
      let [eventValue, input, isSizeIncreaseOperation, isDeleleteButtonDown, // No operation means that value itself hasn't been changed, BTW cursor, selection etc can be changed
      isNoOperation] = valueRef.current;
      valueRef.current = null; // this usually occurs on deleting special symbols like ' here 123'123.00
      // in case of isDeleleteButtonDown cursor should move differently vs backspace

      const deleteWasNoOp = isDeleleteButtonDown && isNoOperation;
      const valueAfterSelectionStart = eventValue.slice(input.selectionStart);
      const acceptedCharIndexAfterDelete = valueAfterSelectionStart.search(props.accept || /\d/g);
      const charsToSkipAfterDelete = acceptedCharIndexAfterDelete !== -1 ? acceptedCharIndexAfterDelete : 0; // Create string from only accepted symbols

      const clean = str => (str.match(props.accept || /\d/g) || []).join('');

      const valueBeforeSelectionStart = clean(eventValue.substr(0, input.selectionStart)); // trying to find cursor position in formatted value having knowledge about valueBeforeSelectionStart
      // This works because we assume that format doesn't change the order of accepted symbols.
      // Imagine we have formatter which adds ' symbol between numbers, and by default we refuse all non numeric symbols
      // for example we had input = 1'2|'4 (| means cursor position) then user entered '3' symbol
      // inputValue = 1'23'|4 so valueBeforeSelectionStart = 123 and formatted value = 1'2'3'4
      // calling getCursorPosition("1'2'3'4") will give us position after 3, 1'2'3|'4
      // so for formatting just this function to determine cursor position after formatting is enough
      // with masking we need to do some additional checks see `mask` below

      const getCursorPosition = val => {
        let start = 0;
        let cleanPos = 0;

        for (let i = 0; i !== valueBeforeSelectionStart.length; ++i) {
          let newPos = val.indexOf(valueBeforeSelectionStart[i], start) + 1;
          let newCleanPos = clean(val).indexOf(valueBeforeSelectionStart[i], cleanPos) + 1; // this skips position change if accepted symbols order was broken
          // For example fixes edge case with fixed point numbers:
          // You have '0|.00', then press 1, it becomes 01|.00 and after format 1.00, this breaks our assumption
          // that order of accepted symbols is not changed after format,
          // so here we don't update start position if other accepted symbols was inbetween current and new position

          if (newCleanPos - cleanPos > 1) {
            newPos = start;
            newCleanPos = cleanPos;
          }

          cleanPos = Math.max(newCleanPos, cleanPos);
          start = Math.max(start, newPos);
        }

        return start;
      }; // Masking part, for masks if size of mask is above some value
      // we need to replace symbols instead of do nothing as like in format


      if (props.mask === true && isSizeIncreaseOperation && !isNoOperation) {
        let start = getCursorPosition(eventValue);
        const c = clean(eventValue.substr(start))[0];
        start = eventValue.indexOf(c, start);
        eventValue = `${eventValue.substr(0, start)}${eventValue.substr(start + 1)}`;
      }

      let formattedValue = props.format(eventValue);

      if (append != null && // cursor at the end
      input.selectionStart === eventValue.length && !isNoOperation) {
        if (isSizeIncreaseOperation) {
          formattedValue = append(formattedValue);
        } else {
          // If after delete last char is special character and we use append
          // delete it too
          // was: "12-3|" backspace pressed, then should be "12|"
          if (clean(formattedValue.slice(-1)) === '') {
            formattedValue = formattedValue.slice(0, -1);
          }
        }
      }

      const replacedValue = replace ? replace(formattedValue) : formattedValue;

      if (userValue === replacedValue) {
        // if nothing changed for formatted value, just refresh so userValue will be used at render
        refresh();
      } else {
        props.onChange(replacedValue);
      }

      return () => {
        let start = getCursorPosition(formattedValue); // Visually improves working with masked values,
        // like cursor jumping over refused symbols
        // as an example date mask: was "5|1-24-3" then user pressed "6"
        // it becomes "56-|12-43" with this code, and "56|-12-43" without

        if (props.mask != null && (isSizeIncreaseOperation || isDeleleteButtonDown && !deleteWasNoOp)) {
          while (formattedValue[start] && clean(formattedValue[start]) === '') {
            start += 1;
          }
        }

        input.selectionStart = input.selectionEnd = start + (deleteWasNoOp ? 1 + charsToSkipAfterDelete : 0);
      };
    });
  }

  React$4.useEffect(() => {
    // until https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/inputType will be supported
    // by all major browsers (now supported by: +chrome, +safari, ?edge, !firefox)
    // there is no way I found to distinguish in onChange
    // backspace or delete was called in some situations
    // firefox track https://bugzilla.mozilla.org/show_bug.cgi?id=1447239
    const handleKeyDown = evt => {
      if (evt.code === 'Delete') {
        isDeleleteButtonDownRef.current = true;
      }
    };

    const handleKeyUp = evt => {
      if (evt.code === 'Delete') {
        isDeleleteButtonDownRef.current = false;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
    };
  }, []);
  return {
    value: valueRef.current != null ? valueRef.current[0] : userValue,
    onChange
  };
};

const getDisplayDate = (utils, date, inputFormat) => {
    // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?
    // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.
    // Or we ensure `formatByString` is callable with `null`.
    if (date === null || !utils.isValid(date)) {
        return '';
    }
    return utils.formatByString(date, inputFormat);
};
const MASK_USER_INPUT_SYMBOL = '_';
const staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';
const staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';
function getMaskFromCurrentFormat(mask, format, acceptRegex, utils) {
    if (mask) {
        return mask;
    }
    const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);
    const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);
    const inferredFormatPatternWith2Digits = utils
        .formatByString(utils.date(staticDateWith2DigitTokens), format)
        .replace(acceptRegex, '_');
    if (inferredFormatPatternWith1Digits === inferredFormatPatternWith2Digits) {
        return inferredFormatPatternWith1Digits;
    }
    if (process.env.NODE_ENV !== 'production') {
        console.warn([
            `Mask does not support numbers with variable length such as 'M'.`,
            `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`,
            `Falling down to uncontrolled no-mask input.`,
        ].join('\n'));
    }
    return '';
}
function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {
    if (!mask) {
        return false;
    }
    const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);
    const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);
    const inferredFormatPatternWith2Digits = utils
        .formatByString(utils.date(staticDateWith2DigitTokens), format)
        .replace(acceptRegex, '_');
    const isMaskValid = inferredFormatPatternWith2Digits === inferredFormatPatternWith1Digits &&
        mask === inferredFormatPatternWith2Digits;
    if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {
        if (format.includes('MMM')) {
            console.warn([
                `Mask does not support literals such as 'MMM'.`,
                `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`,
                `Falling down to uncontrolled no-mask input.`,
            ].join('\n'));
        }
        else if (inferredFormatPatternWith2Digits &&
            inferredFormatPatternWith2Digits !== inferredFormatPatternWith1Digits) {
            console.warn([
                `Mask does not support numbers with variable length such as 'M'.`,
                `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`,
                `Falling down to uncontrolled no-mask input.`,
            ].join('\n'));
        }
        else if (mask) {
            console.warn([
                `The mask "${mask}" you passed is not valid for the format used ${format}.`,
                `Falling down to uncontrolled no-mask input.`,
            ].join('\n'));
        }
    }
    return isMaskValid;
}
const maskedDateFormatter = (mask, acceptRegexp) => (value) => {
    let outputCharIndex = 0;
    return value
        .split('')
        .map((char, inputCharIndex) => {
        acceptRegexp.lastIndex = 0;
        if (outputCharIndex > mask.length - 1) {
            return '';
        }
        const maskChar = mask[outputCharIndex];
        const nextMaskChar = mask[outputCharIndex + 1];
        const acceptedChar = acceptRegexp.test(char) ? char : '';
        const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;
        outputCharIndex += formattedChar.length;
        const isLastCharacter = inputCharIndex === value.length - 1;
        if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {
            // when cursor at the end of mask part (e.g. month) prerender next symbol "21" -> "21/"
            return formattedChar ? formattedChar + nextMaskChar : '';
        }
        return formattedChar;
    })
        .join('');
};

// TODO v6: Drop with the legacy pickers
const useMaskedInput = ({ acceptRegex = /[\d]/gi, disabled, disableMaskedInput, ignoreInvalidInputs, inputFormat, inputProps, label, mask, onChange, value, readOnly, rifmFormatter, TextFieldProps, validationError, }) => {
    const utils = useUtils();
    const formatHelperText = utils.getFormatHelperText(inputFormat);
    const { shouldUseMaskedInput, maskToUse } = React__namespace.useMemo(() => {
        // formatting of dates is a quite slow thing, so do not make useless .format calls
        if (disableMaskedInput) {
            return { shouldUseMaskedInput: false, maskToUse: '' };
        }
        const computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);
        return {
            shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),
            maskToUse: computedMaskToUse,
        };
    }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);
    const formatter = React__namespace.useMemo(() => shouldUseMaskedInput && maskToUse
        ? maskedDateFormatter(maskToUse, acceptRegex)
        : (st) => st, [acceptRegex, maskToUse, shouldUseMaskedInput]);
    // Track the value of the input
    const [innerInputValue, setInnerInputValue] = React__namespace.useState(value);
    // control the input text
    const [innerDisplayedInputValue, setInnerDisplayedInputValue] = React__namespace.useState(getDisplayDate(utils, value, inputFormat));
    // Inspired from autocomplete: https://github.com/mui/material-ui/blob/2c89d036dc2e16f100528f161600dffc83241768/packages/mui-base/src/AutocompleteUnstyled/useAutocomplete.js#L185:L201
    const prevValue = React__namespace.useRef(null);
    const prevLocale = React__namespace.useRef(utils.locale);
    const prevInputFormat = React__namespace.useRef(inputFormat);
    React__namespace.useEffect(() => {
        const valueHasChanged = value !== prevValue.current;
        const localeHasChanged = utils.locale !== prevLocale.current;
        const inputFormatHasChanged = inputFormat !== prevInputFormat.current;
        prevValue.current = value;
        prevLocale.current = utils.locale;
        prevInputFormat.current = inputFormat;
        if (!valueHasChanged && !localeHasChanged && !inputFormatHasChanged) {
            return;
        }
        const isAcceptedValue = value === null || utils.isValid(value);
        const innerEqualsProvided = innerInputValue === null
            ? value === null
            : value !== null && Math.abs(utils.getDiff(innerInputValue, value, 'seconds')) === 0;
        if (!localeHasChanged && !inputFormatHasChanged && (!isAcceptedValue || innerEqualsProvided)) {
            return;
        }
        // When dev set a new valid value, we trust them
        const newDisplayDate = getDisplayDate(utils, value, inputFormat);
        setInnerInputValue(value);
        setInnerDisplayedInputValue(newDisplayDate);
    }, [utils, value, inputFormat, innerInputValue]);
    const handleChange = (text) => {
        const finalString = text === '' || text === mask ? '' : text;
        setInnerDisplayedInputValue(finalString);
        const date = finalString === null ? null : utils.parse(finalString, inputFormat);
        if (ignoreInvalidInputs && !utils.isValid(date)) {
            return;
        }
        setInnerInputValue(date);
        onChange(date, finalString || undefined);
    };
    const rifmProps = useRifm({
        value: innerDisplayedInputValue,
        onChange: handleChange,
        format: rifmFormatter || formatter,
    });
    const inputStateArgs = shouldUseMaskedInput
        ? rifmProps
        : {
            value: innerDisplayedInputValue,
            onChange: (event) => {
                handleChange(event.currentTarget.value);
            },
        };
    return Object.assign({ label,
        disabled, error: validationError, inputProps: Object.assign(Object.assign(Object.assign({}, inputStateArgs), { disabled, placeholder: formatHelperText, readOnly, type: shouldUseMaskedInput ? 'tel' : 'text' }), inputProps) }, TextFieldProps);
};

// TODO v6: Drop with the legacy pickers
const KeyboardDateInput = React__namespace.forwardRef(function KeyboardDateInput(props, ref) {
    const { className, components = {}, disableOpenPicker, getOpenDialogAriaText: getOpenDialogAriaTextProp, InputAdornmentProps, InputProps, inputRef, openPicker, OpenPickerButtonProps, renderInput } = props, other = __rest(props, ["className", "components", "disableOpenPicker", "getOpenDialogAriaText", "InputAdornmentProps", "InputProps", "inputRef", "openPicker", "OpenPickerButtonProps", "renderInput"]);
    const localeText = useLocaleText();
    const getOpenDialogAriaText = getOpenDialogAriaTextProp !== null && getOpenDialogAriaTextProp !== void 0 ? getOpenDialogAriaTextProp : localeText.openDatePickerDialogue;
    const utils = useUtils();
    const textFieldProps = useMaskedInput(other);
    const adornmentPosition = (InputAdornmentProps === null || InputAdornmentProps === void 0 ? void 0 : InputAdornmentProps.position) || 'end';
    const OpenPickerIcon = components.OpenPickerIcon || Calendar;
    return renderInput(Object.assign(Object.assign({ ref,
        inputRef,
        className }, textFieldProps), { InputProps: Object.assign(Object.assign({}, InputProps), { [`${adornmentPosition}Adornment`]: disableOpenPicker ? undefined : (React__namespace.createElement(MuiInputAdornment, Object.assign({ position: adornmentPosition }, InputAdornmentProps),
                React__namespace.createElement(IconButton$1, Object.assign({ edge: adornmentPosition, "data-mui-test": "open-picker-from-keyboard", disabled: other.disabled || other.readOnly, "aria-label": getOpenDialogAriaText(other.value, utils) }, OpenPickerButtonProps, { onClick: openPicker }),
                    React__namespace.createElement(OpenPickerIcon, null)))) }) }));
});

function getOrientation() {
    if (typeof window === 'undefined') {
        return 'portrait';
    }
    if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
        return Math.abs(window.screen.orientation.angle) === 90 ? 'landscape' : 'portrait';
    }
    // Support IOS safari
    if (window.orientation) {
        return Math.abs(Number(window.orientation)) === 90 ? 'landscape' : 'portrait';
    }
    return 'portrait';
}
const useIsLandscape = (views, customOrientation) => {
    const [orientation, setOrientation] = React__namespace.useState(getOrientation);
    useEnhancedEffect$3(() => {
        const eventHandler = () => {
            setOrientation(getOrientation());
        };
        window.addEventListener('orientationchange', eventHandler);
        return () => {
            window.removeEventListener('orientationchange', eventHandler);
        };
    }, []);
    if (arrayIncludes(views, ['hours', 'minutes', 'seconds'])) {
        // could not display 13:34:44 in landscape mode
        return false;
    }
    const orientationToUse = customOrientation || orientation;
    return orientationToUse === 'landscape';
};

function getCalendarOrClockPickerUtilityClass(slot) {
    return generateUtilityClass('MuiCalendarOrClockPicker', slot);
}
generateUtilityClasses('MuiCalendarOrClockPicker', [
    'root',
    'mobileKeyboardInputView',
]);

const useUtilityClasses$A = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        mobileKeyboardInputView: ['mobileKeyboardInputView'],
    };
    return composeClasses(slots, getCalendarOrClockPickerUtilityClass, classes);
};
const MobileKeyboardInputView = styled$1('div', {
    name: 'MuiCalendarOrClockPicker',
    slot: 'MobileKeyboardInputView',
    overridesResolver: (_, styles) => styles.mobileKeyboardInputView,
})({
    padding: '16px 24px',
});
const PickerRoot = styled$1('div', {
    name: 'MuiCalendarOrClockPicker',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})(({ ownerState }) => (Object.assign({ display: 'flex', flexDirection: 'column' }, (ownerState.isLandscape && {
    flexDirection: 'row',
}))));
const MobileKeyboardTextFieldProps = { fullWidth: true };
const isDatePickerView$2 = (view) => view === 'year' || view === 'month' || view === 'day';
const isTimePickerView$1 = (view) => view === 'hours' || view === 'minutes' || view === 'seconds';
// TODO v6: Drop with the legacy pickers
function CalendarOrClockPicker(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiCalendarOrClockPicker' });
    const { autoFocus, className, value, DateInputProps, isMobileKeyboardViewOpen, onDateChange, onViewChange, openTo, orientation, showToolbar, toggleMobileKeyboardView, views, components, componentsProps, 
    // excluding classes from `other` to avoid passing them down to children
    classes: providedClasses } = props, other = __rest(props, ["autoFocus", "className", "value", "DateInputProps", "isMobileKeyboardViewOpen", "onDateChange", "onViewChange", "openTo", "orientation", "showToolbar", "toggleMobileKeyboardView", "views", "components", "componentsProps", "classes"]);
    const isLandscape = useIsLandscape(views, orientation);
    const wrapperVariant = React__namespace.useContext(WrapperVariantContext);
    const classes = useUtilityClasses$A(props);
    const handleDateChange = React__namespace.useCallback((newDate, selectionState) => {
        onDateChange(newDate, wrapperVariant, selectionState);
    }, [onDateChange, wrapperVariant]);
    const handleViewChange = React__namespace.useCallback((newView) => {
        if (isMobileKeyboardViewOpen) {
            toggleMobileKeyboardView();
        }
        if (onViewChange) {
            onViewChange(newView);
        }
    }, [isMobileKeyboardViewOpen, onViewChange, toggleMobileKeyboardView]);
    const { view, setView, focusedView, setFocusedView, setValueAndGoToNextView } = useViews({
        view: undefined,
        views,
        openTo,
        onChange: handleDateChange,
        onViewChange: handleViewChange,
        autoFocus,
    });
    const Tabs = components === null || components === void 0 ? void 0 : components.Tabs;
    const shouldRenderToolbar = showToolbar !== null && showToolbar !== void 0 ? showToolbar : wrapperVariant !== 'desktop';
    const Toolbar = components === null || components === void 0 ? void 0 : components.Toolbar;
    return (React__namespace.createElement(PickerRoot, { ownerState: { isLandscape }, className: classes.root },
        shouldRenderToolbar && !!Toolbar && (React__namespace.createElement(Toolbar, Object.assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.toolbar, { isLandscape: isLandscape, onChange: handleDateChange, value: value, view: view, onViewChange: setView, views: views, disabled: other.disabled, readOnly: other.readOnly, isMobileKeyboardViewOpen: isMobileKeyboardViewOpen, toggleMobileKeyboardView: toggleMobileKeyboardView }))),
        !!Tabs && (React__namespace.createElement(Tabs, Object.assign({ view: view, onViewChange: setView }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.tabs))),
        React__namespace.createElement(PickerViewRoot, null, isMobileKeyboardViewOpen ? (React__namespace.createElement(MobileKeyboardInputView, { className: classes.mobileKeyboardInputView },
            React__namespace.createElement(KeyboardDateInput, Object.assign({}, DateInputProps, { ignoreInvalidInputs: true, disableOpenPicker: true, TextFieldProps: MobileKeyboardTextFieldProps })))) : (React__namespace.createElement(React__namespace.Fragment, null,
            isDatePickerView$2(view) && (React__namespace.createElement(DateCalendar, Object.assign({ autoFocus: autoFocus, value: value, onViewChange: setView, onChange: setValueAndGoToNextView, view: view, 
                // Unclear why the predicate `isDatePickerView` does not imply the casted type
                views: views.filter(isDatePickerView$2), focusedView: focusedView, onFocusedViewChange: setFocusedView, components: components, componentsProps: componentsProps }, other))),
            isTimePickerView$1(view) && (React__namespace.createElement(TimeClock, Object.assign({}, other, { autoFocus: autoFocus, value: value, view: view, 
                // Unclear why the predicate `isDatePickerView` does not imply the casted type
                views: views.filter(isTimePickerView$1), onChange: setValueAndGoToNextView, onViewChange: setView, showViewSwitcher: wrapperVariant === 'desktop', components: components, componentsProps: componentsProps }))))))));
}

const useOpenState = ({ open, onOpen, onClose }) => {
    const isControllingOpenProp = React__namespace.useRef(typeof open === 'boolean').current;
    const [openState, setIsOpenState] = React__namespace.useState(false);
    // It is required to update inner state in useEffect in order to avoid situation when
    // Our component is not mounted yet, but `open` state is set to `true` (e.g. initially opened)
    React__namespace.useEffect(() => {
        if (isControllingOpenProp) {
            if (typeof open !== 'boolean') {
                throw new Error('You must not mix controlling and uncontrolled mode for `open` prop');
            }
            setIsOpenState(open);
        }
    }, [isControllingOpenProp, open]);
    const setIsOpen = React__namespace.useCallback((newIsOpen) => {
        if (!isControllingOpenProp) {
            setIsOpenState(newIsOpen);
        }
        if (newIsOpen && onOpen) {
            onOpen();
        }
        if (!newIsOpen && onClose) {
            onClose();
        }
    }, [isControllingOpenProp, onOpen, onClose]);
    return { isOpen: openState, setIsOpen };
};

// TODO v6: Drop with the legacy pickers
const usePickerState = (props, valueManager) => {
    const { onAccept, onChange, value: rawValue, closeOnSelect } = props;
    const utils = useUtils();
    const { isOpen, setIsOpen } = useOpenState(props);
    const value = React__namespace.useMemo(() => valueManager.cleanValue(utils, rawValue), [valueManager, utils, rawValue]);
    const [lastValidDateValue, setLastValidDateValue] = React__namespace.useState(value);
    const [dateState, setDateState] = React__namespace.useState(() => ({
        committed: value,
        draft: value,
        resetFallback: value,
    }));
    const setDate = React__namespace.useCallback((params) => {
        setDateState((prev) => {
            switch (params.action) {
                case 'setAll':
                case 'acceptAndClose': {
                    return { draft: params.value, committed: params.value, resetFallback: params.value };
                }
                case 'setCommitted': {
                    return Object.assign(Object.assign({}, prev), { draft: params.value, committed: params.value });
                }
                case 'setDraft': {
                    return Object.assign(Object.assign({}, prev), { draft: params.value });
                }
                default: {
                    return prev;
                }
            }
        });
        if (params.forceOnChangeCall ||
            (!params.skipOnChangeCall &&
                !valueManager.areValuesEqual(utils, dateState.committed, params.value))) {
            onChange(params.value);
        }
        if (params.action === 'acceptAndClose') {
            setIsOpen(false);
            if (onAccept &&
                !valueManager.areValuesEqual(utils, dateState.resetFallback, params.value)) {
                onAccept(params.value);
            }
        }
    }, [onAccept, onChange, setIsOpen, dateState, utils, valueManager]);
    React__namespace.useEffect(() => {
        if (utils.isValid(value)) {
            setLastValidDateValue(value);
        }
    }, [utils, value]);
    React__namespace.useEffect(() => {
        if (isOpen) {
            // Update all dates in state to equal the current prop value
            setDate({ action: 'setAll', value, skipOnChangeCall: true });
        }
    }, [isOpen]); // eslint-disable-line react-hooks/exhaustive-deps
    // Set the draft and committed date to equal the new prop value.
    if (!valueManager.areValuesEqual(utils, dateState.committed, value)) {
        setDate({ action: 'setCommitted', value, skipOnChangeCall: true });
    }
    const wrapperProps = React__namespace.useMemo(() => ({
        open: isOpen,
        onClear: () => {
            // Reset all date in state to the empty value and close picker.
            setDate({
                value: valueManager.emptyValue,
                action: 'acceptAndClose',
                // force `onChange` in cases like input (value) === `Invalid date`
                forceOnChangeCall: !valueManager.areValuesEqual(utils, rawValue, valueManager.emptyValue),
            });
        },
        onAccept: () => {
            // Set all date in state to equal the current draft value and close picker.
            setDate({
                value: dateState.draft,
                action: 'acceptAndClose',
                forceOnChangeCall: !valueManager.areValuesEqual(utils, rawValue, value),
            });
        },
        onDismiss: () => {
            // Set all dates in state to equal the last committed date.
            // e.g. Reset the state to the last committed value.
            setDate({ value: dateState.committed, action: 'acceptAndClose' });
        },
        onCancel: () => {
            // Set all dates in state to equal the last accepted date and close picker.
            // e.g. Reset the state to the last accepted value
            setDate({ value: dateState.resetFallback, action: 'acceptAndClose' });
        },
        onSetToday: () => {
            // Set all dates in state to equal today and close picker.
            setDate({ value: valueManager.getTodayValue(utils), action: 'acceptAndClose' });
        },
    }), [setDate, isOpen, utils, dateState, valueManager, value, rawValue]);
    // Mobile keyboard view is a special case.
    // When it's open picker should work like closed, because we are just showing text field
    const [isMobileKeyboardViewOpen, setMobileKeyboardViewOpen] = React__namespace.useState(false);
    const pickerProps = React__namespace.useMemo(() => ({
        value: dateState.draft,
        isMobileKeyboardViewOpen,
        toggleMobileKeyboardView: () => setMobileKeyboardViewOpen(!isMobileKeyboardViewOpen),
        onDateChange: (newDate, wrapperVariant, selectionState = 'partial') => {
            switch (selectionState) {
                case 'shallow': {
                    // Update the `draft` state but do not fire `onChange`
                    return setDate({ action: 'setDraft', value: newDate, skipOnChangeCall: true });
                }
                case 'partial': {
                    // Update the `draft` state and fire `onChange`
                    return setDate({ action: 'setDraft', value: newDate });
                }
                case 'finish': {
                    if (closeOnSelect !== null && closeOnSelect !== void 0 ? closeOnSelect : wrapperVariant === 'desktop') {
                        // Set all dates in state to equal the new date and close picker.
                        return setDate({ value: newDate, action: 'acceptAndClose' });
                    }
                    // Updates the `committed` state and fire `onChange`
                    return setDate({ value: newDate, action: 'setCommitted' });
                }
                default: {
                    throw new Error('MUI: Invalid selectionState passed to `onDateChange`');
                }
            }
        },
    }), [setDate, isMobileKeyboardViewOpen, dateState.draft, closeOnSelect]);
    const handleInputChange = React__namespace.useCallback((newDate, keyboardInputValue) => {
        const cleanParsedValue = valueManager.valueReducer
            ? valueManager.valueReducer(utils, lastValidDateValue, newDate)
            : newDate;
        onChange(cleanParsedValue, keyboardInputValue);
    }, [onChange, valueManager, lastValidDateValue, utils]);
    const inputProps = React__namespace.useMemo(() => ({
        onChange: handleInputChange,
        open: isOpen,
        value: rawValue,
        openPicker: () => setIsOpen(true),
    }), [handleInputChange, isOpen, setIsOpen, rawValue]);
    const pickerState = { pickerProps, inputProps, wrapperProps };
    React__namespace.useDebugValue(pickerState, () => ({
        MuiPickerState: {
            dateState,
            other: pickerState,
        },
    }));
    return pickerState;
};

const getDateSectionConfigFromFormatToken = (utils, formatToken) => {
    const config = utils.formatTokenMap[formatToken];
    if (config == null) {
        throw new Error([
            `MUI: The token "${formatToken}" is not supported by the Date and Time Pickers.`,
            'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.',
        ].join('\n'));
    }
    if (typeof config === 'string') {
        return {
            dateSectionName: config,
            contentType: config === 'meridiem' ? 'letter' : 'digit',
        };
    }
    return {
        dateSectionName: config.sectionName,
        contentType: config.contentType,
    };
};
const getDeltaFromKeyCode = (keyCode) => {
    switch (keyCode) {
        case 'ArrowUp':
            return 1;
        case 'ArrowDown':
            return -1;
        case 'PageUp':
            return 5;
        case 'PageDown':
            return -5;
        default:
            return 0;
    }
};
const adjustDateSectionValue = (utils, date, dateSectionName, keyCode) => {
    const delta = getDeltaFromKeyCode(keyCode);
    const isStart = keyCode === 'Home';
    const isEnd = keyCode === 'End';
    switch (dateSectionName) {
        case 'day': {
            if (isStart) {
                return utils.startOfMonth(date);
            }
            if (isEnd) {
                return utils.endOfMonth(date);
            }
            return utils.addDays(date, delta);
        }
        case 'month': {
            if (isStart) {
                return utils.startOfYear(date);
            }
            if (isEnd) {
                return utils.endOfYear(date);
            }
            return utils.addMonths(date, delta);
        }
        case 'year': {
            return utils.addYears(date, delta);
        }
        case 'meridiem': {
            return utils.addHours(date, (delta > 0 ? 1 : -1) * 12);
        }
        case 'hours': {
            if (isStart) {
                return utils.startOfDay(date);
            }
            if (isEnd) {
                return utils.endOfDay(date);
            }
            return utils.addHours(date, delta);
        }
        case 'minutes': {
            if (isStart) {
                return utils.setMinutes(date, 0);
            }
            if (isEnd) {
                return utils.setMinutes(date, 59);
            }
            return utils.addMinutes(date, delta);
        }
        case 'seconds': {
            if (isStart) {
                return utils.setSeconds(date, 0);
            }
            if (isEnd) {
                return utils.setSeconds(date, 59);
            }
            return utils.addSeconds(date, delta);
        }
        default: {
            return date;
        }
    }
};
const adjustInvalidDateSectionValue = (utils, section, keyCode) => {
    const today = utils.date();
    const delta = getDeltaFromKeyCode(keyCode);
    const isStart = keyCode === 'Home';
    const isEnd = keyCode === 'End';
    const shouldSetAbsolute = section.value === '' || isStart || isEnd;
    switch (section.dateSectionName) {
        case 'year': {
            if (section.value === '') {
                return utils.formatByString(today, section.formatValue);
            }
            return utils.formatByString(utils.setYear(today, Number(section.value) + delta), section.formatValue);
        }
        case 'month': {
            let newDate;
            if (shouldSetAbsolute) {
                if (delta > 0 || isEnd) {
                    newDate = utils.startOfYear(today);
                }
                else {
                    newDate = utils.endOfYear(today);
                }
            }
            else {
                newDate = utils.addMonths(utils.parse(section.value, section.formatValue), delta);
            }
            return utils.formatByString(newDate, section.formatValue);
        }
        case 'day': {
            let newDate;
            if (shouldSetAbsolute) {
                if (delta > 0 || isEnd) {
                    newDate = utils.startOfMonth(today);
                }
                else {
                    newDate = utils.endOfMonth(today);
                }
            }
            else {
                newDate = utils.addDays(utils.parse(section.value, section.formatValue), delta);
                if (!utils.isSameMonth(newDate, today)) {
                    if (delta > 0) {
                        newDate = utils.startOfMonth(today);
                    }
                    else {
                        newDate = utils.endOfMonth(today);
                    }
                }
            }
            return utils.formatByString(newDate, section.formatValue);
        }
        case 'meridiem': {
            const am = utils.formatByString(utils.startOfDay(today), section.formatValue);
            const pm = utils.formatByString(utils.endOfDay(today), section.formatValue);
            if (section.value === '') {
                if (delta > 0 || isEnd) {
                    return am;
                }
                return pm;
            }
            if (section.value === am) {
                return pm;
            }
            return am;
        }
        case 'hours': {
            let newDate;
            if (shouldSetAbsolute) {
                if (delta > 0 || isEnd) {
                    newDate = utils.startOfDay(today);
                }
                else {
                    newDate = utils.endOfDay(today);
                }
            }
            else {
                newDate = utils.addHours(utils.setHours(today, Number(section.value)), delta);
            }
            return utils.formatByString(newDate, section.formatValue);
        }
        case 'minutes': {
            let newDate;
            if (section.value === '') {
                // TODO: Add startOfHour and endOfHours to adapters to avoid hard-coding those values
                const newNumericValue = delta > 0 || isEnd ? 0 : 59;
                newDate = utils.setMinutes(today, newNumericValue);
            }
            else {
                newDate = utils.addMinutes(utils.setMinutes(today, Number(section.value)), delta);
            }
            return utils.formatByString(newDate, section.formatValue);
        }
        case 'seconds': {
            let newDate;
            if (section.value === '') {
                // TODO: Add startOfMinute and endOfMinute to adapters to avoid hard-coding those values
                const newNumericValue = delta > 0 || isEnd ? 0 : 59;
                newDate = utils.setSeconds(today, newNumericValue);
            }
            else {
                newDate = utils.addSeconds(utils.setSeconds(today, Number(section.value)), delta);
            }
            return utils.formatByString(newDate, section.formatValue);
        }
        default: {
            throw new Error(`Invalid date section name`);
        }
    }
};
const getSectionVisibleValue = (section, willBeRenderedInInput) => {
    const value = section.value || section.placeholder;
    // In the input, we add an empty character at the end of each section without trailing zeros.
    // This make sure that `onChange` will always be fired.
    // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),
    // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,
    // So the browser will not fire the input `onChange`.
    // Adding the ltr mark is not a problem because it's only for digit (which are always ltr)
    // The \u2068 and \u2069 are cleaned, but not the \u200e to notice that an update with same digit occures
    if (willBeRenderedInInput && section.contentType === 'digit' && !section.hasTrailingZeroes) {
        return `\u2068${value}\u200e\u2069`;
    }
    if (willBeRenderedInInput) {
        return `\u2068${value}\u2069`;
    }
    return value;
};
const cleanString = (dirtyString) => dirtyString.replace(/\u2066|\u2067|\u2068|\u2069/g, '');
const addPositionPropertiesToSections = (sections) => {
    let position = 0;
    let positionInInput = 1;
    const newSections = [];
    for (let i = 0; i < sections.length; i += 1) {
        const section = sections[i];
        const renderedValue = getSectionVisibleValue(section, true);
        const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;
        const sectionLength = cleanString(sectionStr).length;
        const sectionLengthInInput = sectionStr.length;
        // The ...InInput values consider the unicode characters but do include them in their indexes
        const cleanedValue = cleanString(renderedValue);
        const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;
        const endInInput = startInInput + cleanedValue.length;
        newSections.push(Object.assign(Object.assign({}, section), { start: position, end: position + sectionLength, startInInput,
            endInInput }));
        position += sectionLength;
        // Move position to the end of string associated to the current section
        positionInInput += sectionLengthInInput;
    }
    return newSections;
};
const getSectionPlaceholder = (utils, localeText, sectionConfig, currentTokenValue) => {
    switch (sectionConfig.dateSectionName) {
        case 'year': {
            return localeText.fieldYearPlaceholder({
                digitAmount: utils.formatByString(utils.date(), currentTokenValue).length,
            });
        }
        case 'month': {
            return localeText.fieldMonthPlaceholder({
                contentType: sectionConfig.contentType,
            });
        }
        case 'day': {
            return localeText.fieldDayPlaceholder();
        }
        case 'hours': {
            return localeText.fieldHoursPlaceholder();
        }
        case 'minutes': {
            return localeText.fieldMinutesPlaceholder();
        }
        case 'seconds': {
            return localeText.fieldSecondsPlaceholder();
        }
        case 'meridiem': {
            return localeText.fieldMeridiemPlaceholder();
        }
        default: {
            return currentTokenValue;
        }
    }
};
const getEscapedPartsFromExpandedFormat = (utils, expandedFormat) => {
    const escapedParts = [];
    const { start: startChar, end: endChar } = utils.escapedCharacters;
    const regExp = new RegExp(`(\\${startChar}[^\\${endChar}]*\\${endChar})+`, 'g');
    let match = null;
    // eslint-disable-next-line no-cond-assign
    while ((match = regExp.exec(expandedFormat))) {
        escapedParts.push({ start: match.index, end: regExp.lastIndex - 1 });
    }
    return escapedParts;
};
const splitFormatIntoSections = (utils, localeText, format, date) => {
    const expandedFormat = utils.expandFormat(format);
    const escapedParts = getEscapedPartsFromExpandedFormat(utils, expandedFormat);
    let currentTokenValue = '';
    let startSeparator = '';
    const sections = [];
    const commitCurrentToken = () => {
        if (currentTokenValue === '') {
            return;
        }
        const sectionConfig = getDateSectionConfigFromFormatToken(utils, currentTokenValue);
        const sectionValue = date == null ? '' : utils.formatByString(date, currentTokenValue);
        const hasTrailingZeroes = sectionConfig.contentType === 'digit' &&
            utils.formatByString(utils.parse('1', currentTokenValue), currentTokenValue).length > 1;
        sections.push(Object.assign(Object.assign({}, sectionConfig), { formatValue: currentTokenValue, value: sectionValue, placeholder: getSectionPlaceholder(utils, localeText, sectionConfig, currentTokenValue), hasTrailingZeroes, startSeparator: sections.length === 0 ? startSeparator : '', endSeparator: '', edited: false }));
        currentTokenValue = '';
    };
    for (let i = 0; i < expandedFormat.length; i += 1) {
        const escapedPartOfCurrentChar = escapedParts.find((escapeIndex) => escapeIndex.start <= i && escapeIndex.end >= i);
        const char = expandedFormat[i];
        const isEscapedChar = escapedPartOfCurrentChar != null;
        if (!isEscapedChar && char.match(/([A-Za-z]+)/)) {
            currentTokenValue += char;
        }
        else {
            // If we are on the opening or closing character of an escaped part of the format,
            // Then we ignore this character.
            const isEscapeBoundary = (isEscapedChar && (escapedPartOfCurrentChar === null || escapedPartOfCurrentChar === void 0 ? void 0 : escapedPartOfCurrentChar.start) === i) ||
                (escapedPartOfCurrentChar === null || escapedPartOfCurrentChar === void 0 ? void 0 : escapedPartOfCurrentChar.end) === i;
            if (!isEscapeBoundary) {
                commitCurrentToken();
                if (sections.length === 0) {
                    startSeparator += char;
                }
                else {
                    sections[sections.length - 1].endSeparator += char;
                }
            }
        }
    }
    commitCurrentToken();
    const cleanSections = sections.map((section) => {
        const cleanSeparator = (separator) => {
            let cleanedSeparator = separator;
            if (cleanedSeparator !== null && cleanedSeparator.includes(' ')) {
                cleanedSeparator = `\u2069${cleanedSeparator}\u2066`;
            }
            if (cleanedSeparator === '/') {
                cleanedSeparator = ' / ';
            }
            return cleanedSeparator;
        };
        section.startSeparator = cleanSeparator(section.startSeparator);
        section.endSeparator = cleanSeparator(section.endSeparator);
        return section;
    });
    return cleanSections;
};
/**
 * Some date libraries like `dayjs` don't support parsing from date with escaped characters.
 * To make sure that the parsing works, we are building a format and a date without any separator.
 */
const getDateFromDateSections = (utils, sections) => {
    const formatWithoutSeparator = sections.map((section) => section.formatValue).join(' ');
    const dateWithoutSeparatorStr = sections
        .map((section) => getSectionVisibleValue(section, false))
        .join(' ');
    return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);
};
const createDateStrForInputFromSections = (sections) => {
    const formattedArray = sections.map((section) => `${section.startSeparator}${getSectionVisibleValue(section, true)}${section.endSeparator}`);
    // \u2066: start left-to-right isolation
    // \u2067: start right-to-left isolation
    // \u2068: start first strong character isolation
    // \u2069: pop isolation
    // wrap into an isolated group such that separators can split the string in smaller ones by adding \u2069\u2068
    return `\u2066${formattedArray.join('')}\u2069`;
};
const getMonthsMatchingQuery = (utils, section, query) => {
    switch (section.dateSectionName) {
        case 'month': {
            const monthList = utils
                .getMonthArray(utils.date())
                .map((month) => utils.formatByString(month, section.formatValue));
            return monthList.filter((month) => month.toLowerCase().startsWith(query));
        }
        case 'meridiem': {
            const now = utils.date();
            return [utils.endOfDay(now), utils.startOfDay(now)]
                .map((date) => utils.formatByString(date, section.formatValue))
                .filter((meridiem) => meridiem.toLowerCase().startsWith(query));
        }
        default: {
            throw new Error(`MUI: The section ${section.dateSectionName} does not support letter edition`);
        }
    }
};
const getSectionBoundaries = (utils) => {
    const today = utils.date();
    const endOfYear = utils.endOfYear(today);
    const maxDaysInMonth = utils.getMonthArray(today).reduce((acc, month) => {
        const daysInMonth = utils.getDaysInMonth(month);
        return Math.max(acc, daysInMonth);
    }, 0);
    return {
        year: (currentDate, section) => ({
            minimum: 1,
            maximum: utils.formatByString(today, section.formatValue).length === 4 ? 9999 : 99,
        }),
        month: () => ({
            minimum: 1,
            // Assumption: All years have the same amount of months
            maximum: utils.getMonth(endOfYear) + 1,
        }),
        day: (currentDate) => ({
            minimum: 1,
            maximum: currentDate != null && utils.isValid(currentDate)
                ? utils.getDaysInMonth(currentDate)
                : maxDaysInMonth,
        }),
        hours: () => ({
            minimum: 0,
            // Assumption: All days have the same amount of hours
            maximum: utils.getHours(endOfYear),
        }),
        minutes: () => ({
            minimum: 0,
            // Assumption: All years have the same amount of minutes
            maximum: utils.getMinutes(endOfYear),
        }),
        seconds: () => ({
            minimum: 0,
            // Assumption: All years have the same amount of seconds
            maximum: utils.getSeconds(endOfYear),
        }),
        meridiem: () => ({
            minimum: 0,
            maximum: 0,
        }),
    };
};
const applySectionValueToDate = ({ utils, dateSectionName, date, getNumericSectionValue, getMeridiemSectionValue, }) => {
    if (dateSectionName === 'meridiem') {
        const isAM = getMeridiemSectionValue().toLowerCase() === 'am';
        const hours = utils.getHours(date);
        if (isAM && hours >= 12) {
            return utils.addHours(date, -12);
        }
        if (!isAM && hours < 12) {
            return utils.addHours(date, 12);
        }
        return date;
    }
    const adapterMethods = {
        seconds: {
            getter: utils.getSeconds,
            setter: utils.setSeconds,
        },
        minutes: {
            getter: utils.getMinutes,
            setter: utils.setMinutes,
        },
        hours: {
            getter: utils.getHours,
            setter: utils.setHours,
        },
        day: {
            getter: utils.getDate,
            setter: utils.setDate,
        },
        month: {
            getter: utils.getMonth,
            setter: utils.setMonth,
        },
        year: {
            getter: utils.getYear,
            setter: utils.setYear,
        },
    };
    const methods = adapterMethods[dateSectionName];
    if (!methods) {
        throw new Error(`MUI: The section name ${dateSectionName} can't be applied to a date`);
    }
    return methods.setter(date, getNumericSectionValue(methods.getter));
};
const cleanTrailingZeroInNumericSectionValue = (value, maximum) => {
    const maximumStr = maximum.toString();
    let cleanValue = value;
    // We remove the trailing zeros
    cleanValue = Number(cleanValue).toString();
    // We add enough trailing zeros to fill the section
    while (cleanValue.length < maximumStr.length) {
        cleanValue = `0${cleanValue}`;
    }
    return cleanValue;
};
let warnedOnceInvalidSection = false;
const validateSections = (sections, supportedSections) => {
    if (process.env.NODE_ENV !== 'production') {
        if (!warnedOnceInvalidSection) {
            const invalidSection = sections.find((section) => !supportedSections.includes(section.dateSectionName));
            if (invalidSection) {
                console.warn(`MUI: The field component you are using is not compatible with the "${invalidSection.dateSectionName} date section.`, `The supported date sections are ["${supportedSections.join('", "')}"]\`.`);
                warnedOnceInvalidSection = true;
            }
        }
    }
};
const mergeDateIntoReferenceDate = (utils, date, sections, referenceDate, shouldLimitToEditedSections) => {
    let mergedDate = referenceDate;
    sections.forEach((section) => {
        if (!shouldLimitToEditedSections || section.edited) {
            mergedDate = applySectionValueToDate({
                utils,
                date: mergedDate,
                dateSectionName: section.dateSectionName,
                getNumericSectionValue: (getter) => getter(date),
                getMeridiemSectionValue: () => (utils.getHours(mergedDate) < 12 ? 'AM' : 'PM'),
            });
        }
    });
    return mergedDate;
};
const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;
const clampDaySection = (utils, sections, boundaries) => {
    // We try to generate a valid date representing the start of the month of the invalid date typed by the user.
    const sectionsForStartOfMonth = sections.map((section) => {
        if (section.dateSectionName !== 'day') {
            return section;
        }
        const dayBoundaries = boundaries.day(null, section);
        return Object.assign(Object.assign({}, section), { value: section.hasTrailingZeroes
                ? cleanTrailingZeroInNumericSectionValue(dayBoundaries.minimum.toString(), dayBoundaries.maximum)
                : dayBoundaries.minimum.toString() });
    });
    const startOfMonth = getDateFromDateSections(utils, sectionsForStartOfMonth);
    // Even the start of the month is invalid, we probably have other invalid sections, the clamping failed.
    if (startOfMonth == null || !utils.isValid(startOfMonth)) {
        return null;
    }
    // The only invalid section was the day of the month, we replace its value with the maximum boundary for the correct month.
    return sections.map((section) => {
        if (section.dateSectionName !== 'day') {
            return section;
        }
        const dayBoundaries = boundaries.day(startOfMonth, section);
        if (Number(section.value) <= dayBoundaries.maximum) {
            return section;
        }
        return Object.assign(Object.assign({}, section), { value: dayBoundaries.maximum.toString() });
    });
};
const getSectionOrder = (sections, isRTL) => {
    const neighbors = {};
    if (!isRTL) {
        sections.forEach((_, index) => {
            const leftIndex = index === 0 ? null : index - 1;
            const rightIndex = index === sections.length - 1 ? null : index + 1;
            neighbors[index] = { leftIndex, rightIndex };
        });
        return { neighbors, startIndex: 0, endIndex: sections.length - 1 };
    }
    const rtl2ltr = {};
    const ltr2rtl = {};
    let groupedSectionsStart = 0;
    let groupedSectionsEnd = 0;
    let RTLIndex = sections.length - 1;
    while (RTLIndex >= 0) {
        groupedSectionsEnd = sections.findIndex(
        // eslint-disable-next-line @typescript-eslint/no-loop-func
        (section, index) => { var _a; return index >= groupedSectionsStart && ((_a = section.endSeparator) === null || _a === void 0 ? void 0 : _a.includes(' ')); });
        if (groupedSectionsEnd === -1) {
            groupedSectionsEnd = sections.length - 1;
        }
        for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {
            ltr2rtl[i] = RTLIndex;
            rtl2ltr[RTLIndex] = i;
            RTLIndex -= 1;
        }
        groupedSectionsStart = groupedSectionsEnd + 1;
    }
    sections.forEach((_, index) => {
        const rtlIndex = ltr2rtl[index];
        const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];
        const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];
        neighbors[index] = { leftIndex, rightIndex };
    });
    return { neighbors, startIndex: rtl2ltr[0], endIndex: rtl2ltr[sections.length - 1] };
};

const singleItemValueManager = {
    emptyValue: null,
    getTodayValue: (utils) => utils.date(),
    cleanValue: replaceInvalidDateByNull,
    areValuesEqual: (utils, a, b) => utils.isEqual(a, b),
    isSameError: (a, b) => a === b,
    defaultErrorState: null,
};
const singleItemFieldValueManager = {
    updateReferenceValue: (utils, value, prevReferenceValue) => value == null || !utils.isValid(value) ? prevReferenceValue : value,
    getSectionsFromValue: (utils, localeText, prevSections, date, format) => addPositionPropertiesToSections(splitFormatIntoSections(utils, localeText, format, date)),
    getValueStrFromSections: (sections) => createDateStrForInputFromSections(sections),
    getActiveDateSections: (sections) => sections,
    getActiveDateManager: (utils, state) => ({
        activeDate: state.value,
        referenceActiveDate: state.referenceValue,
        getNewValueFromNewActiveDate: (newActiveDate) => {
            return {
                value: newActiveDate,
                referenceValue: newActiveDate == null || !utils.isValid(newActiveDate)
                    ? state.referenceValue
                    : newActiveDate,
            };
        },
    }),
    parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue),
    hasError: (error) => error != null,
    getSectionOrder: (utils, localeText, format, isRTL) => getSectionOrder(splitFormatIntoSections(utils, localeText, format, null), isRTL),
};

/**
 *
 * Demos:
 *
 * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
 *
 * API:
 *
 * - [DesktopDatePicker API](https://mui.com/x/api/date-pickers/desktop-date-picker/)
 */
const DesktopDatePicker = React__namespace.forwardRef(function DesktopDatePicker(inProps, ref) {
    const props = useDatePickerDefaultizedProps(inProps, 'MuiDesktopDatePicker');
    const validationError = useDateValidation(props) !== null;
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, singleItemValueManager);
    const { onChange, value, components, componentsProps, localeText } = props, other = __rest(props, ["onChange", "value", "components", "componentsProps", "localeText"]);
    const AllDateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { components,
        componentsProps,
        ref,
        validationError });
    return (React__namespace.createElement(DesktopWrapper, Object.assign({}, wrapperProps, { DateInputProps: AllDateInputProps, KeyboardDateInputComponent: KeyboardDateInput, components: components, componentsProps: componentsProps, localeText: localeText }),
        React__namespace.createElement(CalendarOrClockPicker, Object.assign({}, pickerProps, { autoFocus: true, DateInputProps: AllDateInputProps, components: components, componentsProps: componentsProps }, other))));
});
DesktopDatePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {DateView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'day'
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['year', 'day']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

function getDialogContentUtilityClass(slot) {
  return generateUtilityClass('MuiDialogContent', slot);
}
generateUtilityClasses('MuiDialogContent', ['root', 'dividers']);

const dialogTitleClasses = generateUtilityClasses('MuiDialogTitle', ['root']);
var dialogTitleClasses$1 = dialogTitleClasses;

const _excluded$q = ["className", "dividers"];
const useUtilityClasses$z = ownerState => {
  const {
    classes,
    dividers
  } = ownerState;
  const slots = {
    root: ['root', dividers && 'dividers']
  };
  return composeClasses(slots, getDialogContentUtilityClass, classes);
};
const DialogContentRoot = styled$1('div', {
  name: 'MuiDialogContent',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.dividers && styles.dividers];
  }
})(({
  theme,
  ownerState
}) => _extends({
  flex: '1 1 auto',
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: 'touch',
  overflowY: 'auto',
  padding: '20px 24px'
}, ownerState.dividers ? {
  padding: '16px 24px',
  borderTop: `1px solid ${(theme.vars || theme).palette.divider}`,
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
} : {
  [`.${dialogTitleClasses$1.root} + &`]: {
    paddingTop: 0
  }
}));
const DialogContent = /*#__PURE__*/React__namespace.forwardRef(function DialogContent(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiDialogContent'
  });
  const {
      className,
      dividers = false
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$q);
  const ownerState = _extends({}, props, {
    dividers
  });
  const classes = useUtilityClasses$z(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(DialogContentRoot, _extends({
    className: clsx(classes.root, className),
    ownerState: ownerState,
    ref: ref
  }, other));
});
process.env.NODE_ENV !== "production" ? DialogContent.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * Display the top and bottom dividers.
   * @default false
   */
  dividers: propTypesExports.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object])
} : void 0;
var DialogContent$1 = DialogContent;

function getBackdropUtilityClass(slot) {
  return generateUtilityClass('MuiBackdrop', slot);
}
generateUtilityClasses('MuiBackdrop', ['root', 'invisible']);

const _excluded$p = ["children", "component", "components", "componentsProps", "className", "invisible", "open", "slotProps", "slots", "transitionDuration", "TransitionComponent"];
const useUtilityClasses$y = ownerState => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ['root', invisible && 'invisible']
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled$1('div', {
  name: 'MuiBackdrop',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.invisible && styles.invisible];
  }
})(({
  ownerState
}) => _extends({
  position: 'fixed',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: 'rgba(0, 0, 0, 0.5)',
  WebkitTapHighlightColor: 'transparent'
}, ownerState.invisible && {
  backgroundColor: 'transparent'
}));
const Backdrop = /*#__PURE__*/React__namespace.forwardRef(function Backdrop(inProps, ref) {
  var _slotProps$root, _ref, _slots$root;
  const props = useThemeProps({
    props: inProps,
    name: 'MuiBackdrop'
  });
  const {
      children,
      component = 'div',
      components = {},
      componentsProps = {},
      className,
      invisible = false,
      open,
      slotProps = {},
      slots = {},
      transitionDuration,
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Fade$1
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$p);
  const ownerState = _extends({}, props, {
    component,
    invisible
  });
  const classes = useUtilityClasses$y(ownerState);
  const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
  return /*#__PURE__*/jsxRuntime.jsx(TransitionComponent, _extends({
    in: open,
    timeout: transitionDuration
  }, other, {
    children: /*#__PURE__*/jsxRuntime.jsx(BackdropRoot, _extends({
      "aria-hidden": true
    }, rootSlotProps, {
      as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
      className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
      ownerState: _extends({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
      classes: classes,
      ref: ref,
      children: children
    }))
  }));
});
process.env.NODE_ENV !== "production" ? Backdrop.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: propTypesExports.shape({
    Root: propTypesExports.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: propTypesExports.shape({
    root: propTypesExports.object
  }),
  /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   * @default false
   */
  invisible: propTypesExports.bool,
  /**
   * If `true`, the component is shown.
   */
  open: propTypesExports.bool.isRequired,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: propTypesExports.shape({
    root: propTypesExports.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: propTypesExports.shape({
    root: propTypesExports.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.shape({
    appear: propTypesExports.number,
    enter: propTypesExports.number,
    exit: propTypesExports.number
  })])
} : void 0;
var Backdrop$1 = Backdrop;

const _excluded$o = ["BackdropComponent", "BackdropProps", "closeAfterTransition", "children", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "slotProps", "slots", "theme"];
const extendUtilityClasses = ownerState => {
  return ownerState.classes;
};
const ModalRoot = styled$1('div', {
  name: 'MuiModal',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, !ownerState.open && ownerState.exited && styles.hidden];
  }
})(({
  theme,
  ownerState
}) => _extends({
  position: 'fixed',
  zIndex: (theme.vars || theme).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ownerState.open && ownerState.exited && {
  visibility: 'hidden'
}));
const ModalBackdrop = styled$1(Backdrop$1, {
  name: 'MuiModal',
  slot: 'Backdrop',
  overridesResolver: (props, styles) => {
    return styles.backdrop;
  }
})({
  zIndex: -1
});

/**
 * Modal is a lower-level construct that is leveraged by the following components:
 *
 * - [Dialog](/material-ui/api/dialog/)
 * - [Drawer](/material-ui/api/drawer/)
 * - [Menu](/material-ui/api/menu/)
 * - [Popover](/material-ui/api/popover/)
 *
 * If you are creating a modal dialog, you probably want to use the [Dialog](/material-ui/api/dialog/) component
 * rather than directly using Modal.
 *
 * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
 */
const Modal = /*#__PURE__*/React__namespace.forwardRef(function Modal(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
  const props = useThemeProps({
    name: 'MuiModal',
    props: inProps
  });
  const {
      BackdropComponent = ModalBackdrop,
      BackdropProps,
      closeAfterTransition = false,
      children,
      component,
      components = {},
      componentsProps = {},
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableEscapeKeyDown = false,
      disablePortal = false,
      disableRestoreFocus = false,
      disableScrollLock = false,
      hideBackdrop = false,
      keepMounted = false,
      slotProps,
      slots,
      // eslint-disable-next-line react/prop-types
      theme
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$o);
  const [exited, setExited] = React__namespace.useState(true);
  const commonProps = {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  };
  const ownerState = _extends({}, props, commonProps, {
    exited
  });
  const classes = extendUtilityClasses(ownerState);
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
  const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
  return /*#__PURE__*/jsxRuntime.jsx(ModalUnstyled$1, _extends({
    slots: {
      root: RootSlot,
      backdrop: BackdropSlot
    },
    slotProps: {
      root: () => _extends({}, resolveComponentProps(rootSlotProps, ownerState), !isHostComponent(RootSlot) && {
        as: component,
        theme
      }),
      backdrop: () => _extends({}, BackdropProps, resolveComponentProps(backdropSlotProps, ownerState))
    },
    onTransitionEnter: () => setExited(false),
    onTransitionExited: () => setExited(true),
    ref: ref
  }, other, {
    classes: classes
  }, commonProps, {
    children: children
  }));
});
process.env.NODE_ENV !== "production" ? Modal.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: propTypesExports.elementType,
  /**
   * Props applied to the [`Backdrop`](/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead.
   */
  BackdropProps: propTypesExports.object,
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: propTypesExports.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: propTypesExports.shape({
    Backdrop: propTypesExports.elementType,
    Root: propTypesExports.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: propTypesExports.shape({
    backdrop: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object]),
    root: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, propTypesExports.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: propTypesExports.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: propTypesExports.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: propTypesExports.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: propTypesExports.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: propTypesExports.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: propTypesExports.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: propTypesExports.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: propTypesExports.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: propTypesExports.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: propTypesExports.func,
  /**
   * If `true`, the component is shown.
   */
  open: propTypesExports.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: propTypesExports.shape({
    backdrop: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object]),
    root: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: propTypesExports.shape({
    backdrop: propTypesExports.elementType,
    root: propTypesExports.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object])
} : void 0;
var Modal$1 = Modal;

function getDialogUtilityClass(slot) {
  return generateUtilityClass('MuiDialog', slot);
}
const dialogClasses = generateUtilityClasses('MuiDialog', ['root', 'scrollPaper', 'scrollBody', 'container', 'paper', 'paperScrollPaper', 'paperScrollBody', 'paperWidthFalse', 'paperWidthXs', 'paperWidthSm', 'paperWidthMd', 'paperWidthLg', 'paperWidthXl', 'paperFullWidth', 'paperFullScreen']);
var dialogClasses$1 = dialogClasses;

const DialogContext = /*#__PURE__*/React$4.createContext({});
if (process.env.NODE_ENV !== 'production') {
  DialogContext.displayName = 'DialogContext';
}
var DialogContext$1 = DialogContext;

const _excluded$n = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
const DialogBackdrop = styled$1(Backdrop$1, {
  name: 'MuiDialog',
  slot: 'Backdrop',
  overrides: (props, styles) => styles.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$x = ownerState => {
  const {
    classes,
    scroll,
    maxWidth,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ['root'],
    container: ['container', `scroll${capitalize(scroll)}`],
    paper: ['paper', `paperScroll${capitalize(scroll)}`, `paperWidth${capitalize(String(maxWidth))}`, fullWidth && 'paperFullWidth', fullScreen && 'paperFullScreen']
  };
  return composeClasses(slots, getDialogUtilityClass, classes);
};
const DialogRoot = styled$1(Modal$1, {
  name: 'MuiDialog',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({
  '@media print': {
    // Use !important to override the Modal inline-style.
    position: 'absolute !important'
  }
});
const DialogContainer = styled$1('div', {
  name: 'MuiDialog',
  slot: 'Container',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.container, styles[`scroll${capitalize(ownerState.scroll)}`]];
  }
})(({
  ownerState
}) => _extends({
  height: '100%',
  '@media print': {
    height: 'auto'
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, ownerState.scroll === 'paper' && {
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center'
}, ownerState.scroll === 'body' && {
  overflowY: 'auto',
  overflowX: 'hidden',
  textAlign: 'center',
  '&:after': {
    content: '""',
    display: 'inline-block',
    verticalAlign: 'middle',
    height: '100%',
    width: '0'
  }
}));
const DialogPaper = styled$1(Paper$1, {
  name: 'MuiDialog',
  slot: 'Paper',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.paper, styles[`scrollPaper${capitalize(ownerState.scroll)}`], styles[`paperWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles.paperFullWidth, ownerState.fullScreen && styles.paperFullScreen];
  }
})(({
  theme,
  ownerState
}) => _extends({
  margin: 32,
  position: 'relative',
  overflowY: 'auto',
  // Fix IE11 issue, to remove at some point.
  '@media print': {
    overflowY: 'visible',
    boxShadow: 'none'
  }
}, ownerState.scroll === 'paper' && {
  display: 'flex',
  flexDirection: 'column',
  maxHeight: 'calc(100% - 64px)'
}, ownerState.scroll === 'body' && {
  display: 'inline-block',
  verticalAlign: 'middle',
  textAlign: 'left' // 'initial' doesn't work on IE11
}, !ownerState.maxWidth && {
  maxWidth: 'calc(100% - 64px)'
}, ownerState.maxWidth === 'xs' && {
  maxWidth: theme.breakpoints.unit === 'px' ? Math.max(theme.breakpoints.values.xs, 444) : `${theme.breakpoints.values.xs}${theme.breakpoints.unit}`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: 'calc(100% - 64px)'
    }
  }
}, ownerState.maxWidth && ownerState.maxWidth !== 'xs' && {
  maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme.breakpoints.down(theme.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
      maxWidth: 'calc(100% - 64px)'
    }
  }
}, ownerState.fullWidth && {
  width: 'calc(100% - 64px)'
}, ownerState.fullScreen && {
  margin: 0,
  width: '100%',
  maxWidth: '100%',
  height: '100%',
  maxHeight: 'none',
  borderRadius: 0,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    margin: 0,
    maxWidth: '100%'
  }
}));

/**
 * Dialogs are overlaid modal paper based components with a backdrop.
 */
const Dialog = /*#__PURE__*/React__namespace.forwardRef(function Dialog(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiDialog'
  });
  const theme = useTheme();
  const defaultTransitionDuration = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
      'aria-describedby': ariaDescribedby,
      'aria-labelledby': ariaLabelledbyProp,
      BackdropComponent,
      BackdropProps,
      children,
      className,
      disableEscapeKeyDown = false,
      fullScreen = false,
      fullWidth = false,
      maxWidth = 'sm',
      onBackdropClick,
      onClose,
      open,
      PaperComponent = Paper$1,
      PaperProps = {},
      scroll = 'paper',
      TransitionComponent = Fade$1,
      transitionDuration = defaultTransitionDuration,
      TransitionProps
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$n);
  const ownerState = _extends({}, props, {
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth,
    scroll
  });
  const classes = useUtilityClasses$x(ownerState);
  const backdropClick = React__namespace.useRef();
  const handleMouseDown = event => {
    // We don't want to close the dialog when clicking the dialog content.
    // Make sure the event starts and ends on the same DOM element.
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleBackdropClick = event => {
    // Ignore the events not coming from the "backdrop".
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, 'backdropClick');
    }
  };
  const ariaLabelledby = useId(ariaLabelledbyProp);
  const dialogContextValue = React__namespace.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  return /*#__PURE__*/jsxRuntime.jsx(DialogRoot, _extends({
    className: clsx(classes.root, className),
    closeAfterTransition: true,
    components: {
      Backdrop: DialogBackdrop
    },
    componentsProps: {
      backdrop: _extends({
        transitionDuration,
        as: BackdropComponent
      }, BackdropProps)
    },
    disableEscapeKeyDown: disableEscapeKeyDown,
    onClose: onClose,
    open: open,
    ref: ref,
    onClick: handleBackdropClick,
    ownerState: ownerState
  }, other, {
    children: /*#__PURE__*/jsxRuntime.jsx(TransitionComponent, _extends({
      appear: true,
      in: open,
      timeout: transitionDuration,
      role: "presentation"
    }, TransitionProps, {
      children: /*#__PURE__*/jsxRuntime.jsx(DialogContainer, {
        className: clsx(classes.container),
        onMouseDown: handleMouseDown,
        ownerState: ownerState,
        children: /*#__PURE__*/jsxRuntime.jsx(DialogPaper, _extends({
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby
        }, PaperProps, {
          className: clsx(classes.paper, PaperProps.className),
          ownerState: ownerState,
          children: /*#__PURE__*/jsxRuntime.jsx(DialogContext$1.Provider, {
            value: dialogContextValue,
            children: children
          })
        }))
      })
    }))
  }));
});
process.env.NODE_ENV !== "production" ? Dialog.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The id(s) of the element(s) that describe the dialog.
   */
  'aria-describedby': propTypesExports.string,
  /**
   * The id(s) of the element(s) that label the dialog.
   */
  'aria-labelledby': propTypesExports.string,
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: propTypesExports.elementType,
  /**
   * @ignore
   */
  BackdropProps: propTypesExports.object,
  /**
   * Dialog children, usually the included sub-components.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: propTypesExports.bool,
  /**
   * If `true`, the dialog is full-screen.
   * @default false
   */
  fullScreen: propTypesExports.bool,
  /**
   * If `true`, the dialog stretches to `maxWidth`.
   *
   * Notice that the dialog width grow is limited by the default margin.
   * @default false
   */
  fullWidth: propTypesExports.bool,
  /**
   * Determine the max-width of the dialog.
   * The dialog width grows with the size of the screen.
   * Set to `false` to disable `maxWidth`.
   * @default 'sm'
   */
  maxWidth: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['xs', 'sm', 'md', 'lg', 'xl', false]), propTypesExports.string]),
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: propTypesExports.func,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: propTypesExports.func,
  /**
   * If `true`, the component is shown.
   */
  open: propTypesExports.bool.isRequired,
  /**
   * The component used to render the body of the dialog.
   * @default Paper
   */
  PaperComponent: propTypesExports.elementType,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   * @default {}
   */
  PaperProps: propTypesExports.object,
  /**
   * Determine the container for scrolling the dialog.
   * @default 'paper'
   */
  scroll: propTypesExports.oneOf(['body', 'paper']),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   */
  TransitionComponent: propTypesExports.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  transitionDuration: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.shape({
    appear: propTypesExports.number,
    enter: propTypesExports.number,
    exit: propTypesExports.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   */
  TransitionProps: propTypesExports.object
} : void 0;
var MuiDialog = Dialog;

const PickersModalDialogRoot = styled$1(MuiDialog)({
    [`& .${dialogClasses$1.container}`]: {
        outline: 0,
    },
    [`& .${dialogClasses$1.paper}`]: {
        outline: 0,
        minWidth: DIALOG_WIDTH,
    },
});
const PickersModalDialogContent = styled$1(DialogContent$1)({
    '&:first-of-type': {
        padding: 0,
    },
});
function PickersModalDialog(props) {
    var _a, _b, _c;
    const { children, onAccept, onClear, onDismiss, onCancel, onSetToday, open, components, componentsProps, } = props;
    const ActionBar = (_a = components === null || components === void 0 ? void 0 : components.ActionBar) !== null && _a !== void 0 ? _a : PickersActionBar;
    const actionBarProps = useSlotProps({
        elementType: ActionBar,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.actionBar,
        additionalProps: {
            onAccept,
            onClear,
            onCancel,
            onSetToday,
            actions: ['cancel', 'accept'],
        },
        ownerState: { wrapperVariant: 'mobile' },
    });
    const Dialog = (_b = components === null || components === void 0 ? void 0 : components.Dialog) !== null && _b !== void 0 ? _b : PickersModalDialogRoot;
    const Transition = (_c = components === null || components === void 0 ? void 0 : components.MobileTransition) !== null && _c !== void 0 ? _c : Fade$1;
    return (React__namespace.createElement(Dialog, Object.assign({ open: open, onClose: onDismiss }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.dialog, { TransitionComponent: Transition, TransitionProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.mobileTransition, PaperComponent: components === null || components === void 0 ? void 0 : components.MobilePaper, PaperProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.mobilePaper }),
        React__namespace.createElement(PickersModalDialogContent, null, children),
        React__namespace.createElement(ActionBar, Object.assign({}, actionBarProps))));
}

// TODO v6: Drop with the legacy pickers
function MobileWrapper(props) {
    const { children, DateInputProps, onAccept, onClear, onDismiss, onCancel, onSetToday, open, PureDateInputComponent, components, componentsProps, localeText } = props, other = __rest(props, ["children", "DateInputProps", "onAccept", "onClear", "onDismiss", "onCancel", "onSetToday", "open", "PureDateInputComponent", "components", "componentsProps", "localeText"]);
    return (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: "mobile" },
            React__namespace.createElement(PureDateInputComponent, Object.assign({ components: components }, other, DateInputProps)),
            React__namespace.createElement(PickersModalDialog, { onAccept: onAccept, onClear: onClear, onDismiss: onDismiss, onCancel: onCancel, onSetToday: onSetToday, open: open, components: components, componentsProps: componentsProps }, children))));
}

// TODO v6: Drop with the legacy pickers
const PureDateInput = React__namespace.forwardRef(function PureDateInput(props, ref) {
    const { disabled, getOpenDialogAriaText: getOpenDialogAriaTextProp, inputFormat, InputProps, inputRef, label, openPicker: onOpen, value, renderInput, TextFieldProps = {}, validationError, className, } = props;
    const localeText = useLocaleText();
    // The prop can not be deprecated
    // Default is "Choose date, ...", but time pickers override it with "Choose time, ..."
    const getOpenDialogAriaText = getOpenDialogAriaTextProp !== null && getOpenDialogAriaTextProp !== void 0 ? getOpenDialogAriaTextProp : localeText.openDatePickerDialogue;
    const utils = useUtils();
    const PureDateInputProps = React__namespace.useMemo(() => (Object.assign(Object.assign({}, InputProps), { readOnly: true })), [InputProps]);
    const inputValue = getDisplayDate(utils, value, inputFormat);
    const handleOnClick = useEventCallback$2((event) => {
        event.stopPropagation();
        onOpen();
    });
    return renderInput(Object.assign(Object.assign(Object.assign({ label,
        disabled,
        ref,
        inputRef, error: validationError, InputProps: PureDateInputProps, className }, (!props.readOnly && !props.disabled && { onClick: handleOnClick })), { inputProps: Object.assign(Object.assign({ disabled, readOnly: true, 'aria-readonly': true, 'aria-label': getOpenDialogAriaText(value, utils), value: inputValue }, (!props.readOnly && { onClick: handleOnClick })), { onKeyDown: onSpaceOrEnter(onOpen) }) }), TextFieldProps));
});

/**
 *
 * Demos:
 *
 * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
 *
 * API:
 *
 * - [MobileDatePicker API](https://mui.com/x/api/date-pickers/mobile-date-picker/)
 */
const MobileDatePicker = React__namespace.forwardRef(function MobileDatePicker(inProps, ref) {
    const props = useDatePickerDefaultizedProps(inProps, 'MuiMobileDatePicker');
    const validationError = useDateValidation(props) !== null;
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, singleItemValueManager);
    // Note that we are passing down all the value without spread.
    // It saves us >1kb gzip and make any prop available automatically on any level down.
    const { value, onChange, components, componentsProps, localeText } = props, other = __rest(props, ["value", "onChange", "components", "componentsProps", "localeText"]);
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { components,
        componentsProps,
        ref,
        validationError });
    return (React__namespace.createElement(MobileWrapper, Object.assign({}, other, wrapperProps, { DateInputProps: DateInputProps, PureDateInputComponent: PureDateInput, components: components, componentsProps: componentsProps, localeText: localeText }),
        React__namespace.createElement(CalendarOrClockPicker, Object.assign({}, pickerProps, { autoFocus: true, DateInputProps: DateInputProps, components: components, componentsProps: componentsProps }, other))));
});
MobileDatePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {DateView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'day'
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['year', 'day']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

/**
 *
 * Demos:
 *
 * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
 * - [Pickers](https://mui.com/x/react-date-pickers/)
 *
 * API:
 *
 * - [DatePicker API](https://mui.com/x/api/date-pickers/date-picker/)
 */
const DatePicker = React__namespace.forwardRef(function DatePicker(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiDatePicker' });
    const { desktopModeMediaQuery = '@media (pointer: fine)' } = props, other = __rest(props, ["desktopModeMediaQuery"]);
    // defaults to `true` in environments where `window.matchMedia` would not be available (i.e. test/jsdom)
    const isDesktop = useMediaQuery(desktopModeMediaQuery, { defaultMatches: true });
    if (isDesktop) {
        return React__namespace.createElement(DesktopDatePicker, Object.assign({ ref: ref }, other));
    }
    return React__namespace.createElement(MobileDatePicker, Object.assign({ ref: ref }, other));
});
DatePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * CSS media query when `Mobile` mode will be changed to `Desktop`.
     * @default '@media (pointer: fine)'
     * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
     */
    desktopModeMediaQuery: propTypesExports.string,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {DateView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'day'
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['year', 'day']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

function getPickersToolbarTextUtilityClass(slot) {
    return generateUtilityClass('MuiPickersToolbarText', slot);
}
const pickersToolbarTextClasses = generateUtilityClasses('MuiPickersToolbarText', [
    'root',
    'selected',
]);

const useUtilityClasses$w = (ownerState) => {
    const { classes, selected } = ownerState;
    const slots = {
        root: ['root', selected && 'selected'],
    };
    return composeClasses(slots, getPickersToolbarTextUtilityClass, classes);
};
const PickersToolbarTextRoot = styled$1(Typography$1, {
    name: 'MuiPickersToolbarText',
    slot: 'Root',
    overridesResolver: (_, styles) => [
        styles.root,
        { [`&.${pickersToolbarTextClasses.selected}`]: styles.selected },
    ],
})(({ theme }) => ({
    transition: theme.transitions.create('color'),
    color: (theme.vars || theme).palette.text.secondary,
    [`&.${pickersToolbarTextClasses.selected}`]: {
        color: (theme.vars || theme).palette.text.primary,
    },
}));
const PickersToolbarText = React__namespace.forwardRef(function PickersToolbarText(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiPickersToolbarText' });
    const { className, selected, value } = props, other = __rest(props, ["className", "selected", "value"]);
    const classes = useUtilityClasses$w(props);
    return (React__namespace.createElement(PickersToolbarTextRoot, Object.assign({ ref: ref, className: clsx(className, classes.root), component: "span" }, other), value));
});

const useUtilityClasses$v = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
    };
    return composeClasses(slots, getPickersToolbarUtilityClass, classes);
};
const PickersToolbarButtonRoot = styled$1(Button$1, {
    name: 'MuiPickersToolbarButton',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})({
    padding: 0,
    minWidth: 16,
    textTransform: 'none',
});
const PickersToolbarButton = React__namespace.forwardRef(function PickersToolbarButton(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiPickersToolbarButton' });
    const { align, className, selected, typographyClassName, value, variant } = props, other = __rest(props, ["align", "className", "selected", "typographyClassName", "value", "variant"]);
    const classes = useUtilityClasses$v(props);
    return (React__namespace.createElement(PickersToolbarButtonRoot, Object.assign({ "data-mui-test": "toolbar-button", variant: "text", ref: ref, className: clsx(className, classes.root) }, other),
        React__namespace.createElement(PickersToolbarText, { align: align, className: typographyClassName, variant: variant, value: value, selected: selected })));
});

function getDateTimePickerToolbarUtilityClass(slot) {
    return generateUtilityClass('MuiDateTimePickerToolbar', slot);
}
const dateTimePickerToolbarClasses = generateUtilityClasses('MuiDateTimePickerToolbar', ['root', 'dateContainer', 'timeContainer', 'separator', 'timeLabelReverse']);

const useUtilityClasses$u = (ownerState) => {
    const { classes, theme } = ownerState;
    const slots = {
        root: ['root'],
        dateContainer: ['dateContainer'],
        timeContainer: ['timeContainer', theme.direction === 'rtl' && 'timeLabelReverse'],
        separator: ['separator'],
    };
    return composeClasses(slots, getDateTimePickerToolbarUtilityClass, classes);
};
const DateTimePickerToolbarRoot = styled$1(PickersToolbar, {
    name: 'MuiDateTimePickerToolbar',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})(({ theme }) => ({
    paddingLeft: 16,
    paddingRight: 16,
    justifyContent: 'space-around',
    position: 'relative',
    [`& .${pickersToolbarClasses.penIconButton}`]: Object.assign({ position: 'absolute', top: 8 }, (theme.direction === 'rtl' ? { left: 8 } : { right: 8 })),
}));
const DateTimePickerToolbarDateContainer = styled$1('div', {
    name: 'MuiDateTimePickerToolbar',
    slot: 'DateContainer',
    overridesResolver: (props, styles) => styles.dateContainer,
})({
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'flex-start',
});
const DateTimePickerToolbarTimeContainer = styled$1('div', {
    name: 'MuiDateTimePickerToolbar',
    slot: 'TimeContainer',
    overridesResolver: (props, styles) => styles.timeContainer,
})(({ theme }) => (Object.assign({ display: 'flex' }, (theme.direction === 'rtl' && {
    flexDirection: 'row-reverse',
}))));
const DateTimePickerToolbarSeparator = styled$1(PickersToolbarText, {
    name: 'MuiDateTimePickerToolbar',
    slot: 'Separator',
    overridesResolver: (props, styles) => styles.separator,
})({
    margin: '0 4px 0 2px',
    cursor: 'default',
});
/**
 * @ignore - internal component.
 */
function DateTimePickerToolbar(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiDateTimePickerToolbar' });
    const { ampm, value, isMobileKeyboardViewOpen, onChange, view, onViewChange, toggleMobileKeyboardView, toolbarFormat, toolbarPlaceholder = '', views } = props, other = __rest(props, ["ampm", "value", "isMobileKeyboardViewOpen", "onChange", "view", "onViewChange", "toggleMobileKeyboardView", "toolbarFormat", "toolbarPlaceholder", "views"]);
    const ownerState = props;
    const utils = useUtils();
    const localeText = useLocaleText();
    const theme = useTheme();
    const classes = useUtilityClasses$u(Object.assign(Object.assign({}, ownerState), { theme }));
    const formatHours = (time) => ampm ? utils.format(time, 'hours12h') : utils.format(time, 'hours24h');
    const dateText = React__namespace.useMemo(() => {
        if (!value) {
            return toolbarPlaceholder;
        }
        if (toolbarFormat) {
            return utils.formatByString(value, toolbarFormat);
        }
        return utils.format(value, 'shortDate');
    }, [value, toolbarFormat, toolbarPlaceholder, utils]);
    return (React__namespace.createElement(DateTimePickerToolbarRoot, Object.assign({ toolbarTitle: localeText.dateTimePickerToolbarTitle, isMobileKeyboardViewOpen: isMobileKeyboardViewOpen, toggleMobileKeyboardView: toggleMobileKeyboardView, className: classes.root }, other, { ownerState: ownerState }),
        React__namespace.createElement(DateTimePickerToolbarDateContainer, { className: classes.dateContainer, ownerState: ownerState },
            views.includes('year') && (React__namespace.createElement(PickersToolbarButton, { tabIndex: -1, variant: "subtitle1", "data-mui-test": "datetimepicker-toolbar-year", onClick: () => onViewChange('year'), selected: view === 'year', value: value ? utils.format(value, 'year') : '' })),
            views.includes('day') && (React__namespace.createElement(PickersToolbarButton, { tabIndex: -1, variant: "h4", "data-mui-test": "datetimepicker-toolbar-day", onClick: () => onViewChange('day'), selected: view === 'day', value: dateText }))),
        React__namespace.createElement(DateTimePickerToolbarTimeContainer, { className: classes.timeContainer, ownerState: ownerState },
            views.includes('hours') && (React__namespace.createElement(PickersToolbarButton, { variant: "h3", "data-mui-test": "hours", onClick: () => onViewChange('hours'), selected: view === 'hours', value: value ? formatHours(value) : '--' })),
            views.includes('minutes') && (React__namespace.createElement(React__namespace.Fragment, null,
                React__namespace.createElement(DateTimePickerToolbarSeparator, { variant: "h3", value: ":", className: classes.separator, ownerState: ownerState }),
                React__namespace.createElement(PickersToolbarButton, { variant: "h3", "data-mui-test": "minutes", onClick: () => onViewChange('minutes'), selected: view === 'minutes', value: value ? utils.format(value, 'minutes') : '--' }))),
            views.includes('seconds') && (React__namespace.createElement(React__namespace.Fragment, null,
                React__namespace.createElement(DateTimePickerToolbarSeparator, { variant: "h3", value: ":", className: classes.separator, ownerState: ownerState }),
                React__namespace.createElement(PickersToolbarButton, { variant: "h3", "data-mui-test": "seconds", onClick: () => onViewChange('seconds'), selected: view === 'seconds', value: value ? utils.format(value, 'seconds') : '--' }))))));
}

function getTabUtilityClass(slot) {
  return generateUtilityClass('MuiTab', slot);
}
const tabClasses = generateUtilityClasses('MuiTab', ['root', 'labelIcon', 'textColorInherit', 'textColorPrimary', 'textColorSecondary', 'selected', 'disabled', 'fullWidth', 'wrapped', 'iconWrapper']);
var tabClasses$1 = tabClasses;

const _excluded$m = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"];
const useUtilityClasses$t = ownerState => {
  const {
    classes,
    textColor,
    fullWidth,
    wrapped,
    icon,
    label,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ['root', icon && label && 'labelIcon', `textColor${capitalize(textColor)}`, fullWidth && 'fullWidth', wrapped && 'wrapped', selected && 'selected', disabled && 'disabled'],
    iconWrapper: ['iconWrapper']
  };
  return composeClasses(slots, getTabUtilityClass, classes);
};
const TabRoot = styled$1(ButtonBase$1, {
  name: 'MuiTab',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.label && ownerState.icon && styles.labelIcon, styles[`textColor${capitalize(ownerState.textColor)}`], ownerState.fullWidth && styles.fullWidth, ownerState.wrapped && styles.wrapped];
  }
})(({
  theme,
  ownerState
}) => _extends({}, theme.typography.button, {
  maxWidth: 360,
  minWidth: 90,
  position: 'relative',
  minHeight: 48,
  flexShrink: 0,
  padding: '12px 16px',
  overflow: 'hidden',
  whiteSpace: 'normal',
  textAlign: 'center'
}, ownerState.label && {
  flexDirection: ownerState.iconPosition === 'top' || ownerState.iconPosition === 'bottom' ? 'column' : 'row'
}, {
  lineHeight: 1.25
}, ownerState.icon && ownerState.label && {
  minHeight: 72,
  paddingTop: 9,
  paddingBottom: 9,
  [`& > .${tabClasses$1.iconWrapper}`]: _extends({}, ownerState.iconPosition === 'top' && {
    marginBottom: 6
  }, ownerState.iconPosition === 'bottom' && {
    marginTop: 6
  }, ownerState.iconPosition === 'start' && {
    marginRight: theme.spacing(1)
  }, ownerState.iconPosition === 'end' && {
    marginLeft: theme.spacing(1)
  })
}, ownerState.textColor === 'inherit' && {
  color: 'inherit',
  opacity: 0.6,
  // same opacity as theme.palette.text.secondary
  [`&.${tabClasses$1.selected}`]: {
    opacity: 1
  },
  [`&.${tabClasses$1.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  }
}, ownerState.textColor === 'primary' && {
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${tabClasses$1.selected}`]: {
    color: (theme.vars || theme).palette.primary.main
  },
  [`&.${tabClasses$1.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled
  }
}, ownerState.textColor === 'secondary' && {
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${tabClasses$1.selected}`]: {
    color: (theme.vars || theme).palette.secondary.main
  },
  [`&.${tabClasses$1.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled
  }
}, ownerState.fullWidth && {
  flexShrink: 1,
  flexGrow: 1,
  flexBasis: 0,
  maxWidth: 'none'
}, ownerState.wrapped && {
  fontSize: theme.typography.pxToRem(12)
}));
const Tab = /*#__PURE__*/React__namespace.forwardRef(function Tab(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiTab'
  });
  const {
      className,
      disabled = false,
      disableFocusRipple = false,
      // eslint-disable-next-line react/prop-types
      fullWidth,
      icon: iconProp,
      iconPosition = 'top',
      // eslint-disable-next-line react/prop-types
      indicator,
      label,
      onChange,
      onClick,
      onFocus,
      // eslint-disable-next-line react/prop-types
      selected,
      // eslint-disable-next-line react/prop-types
      selectionFollowsFocus,
      // eslint-disable-next-line react/prop-types
      textColor = 'inherit',
      value,
      wrapped = false
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$m);
  const ownerState = _extends({}, props, {
    disabled,
    disableFocusRipple,
    selected,
    icon: !!iconProp,
    iconPosition,
    label: !!label,
    fullWidth,
    textColor,
    wrapped
  });
  const classes = useUtilityClasses$t(ownerState);
  const icon = iconProp && label && /*#__PURE__*/React__namespace.isValidElement(iconProp) ? /*#__PURE__*/React__namespace.cloneElement(iconProp, {
    className: clsx(classes.iconWrapper, iconProp.props.className)
  }) : iconProp;
  const handleClick = event => {
    if (!selected && onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const handleFocus = event => {
    if (selectionFollowsFocus && !selected && onChange) {
      onChange(event, value);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  return /*#__PURE__*/jsxRuntime.jsxs(TabRoot, _extends({
    focusRipple: !disableFocusRipple,
    className: clsx(classes.root, className),
    ref: ref,
    role: "tab",
    "aria-selected": selected,
    disabled: disabled,
    onClick: handleClick,
    onFocus: handleFocus,
    ownerState: ownerState,
    tabIndex: selected ? 0 : -1
  }, other, {
    children: [iconPosition === 'top' || iconPosition === 'start' ? /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
      children: [icon, label]
    }) : /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
      children: [label, icon]
    }), indicator]
  }));
});
process.env.NODE_ENV !== "production" ? Tab.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop isn't supported.
   * Use the `component` prop if you need to change the children structure.
   */
  children: unsupportedProp,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: propTypesExports.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: propTypesExports.bool,
  /**
   * The icon to display.
   */
  icon: propTypesExports.oneOfType([propTypesExports.element, propTypesExports.string]),
  /**
   * The position of the icon relative to the label.
   * @default 'top'
   */
  iconPosition: propTypesExports.oneOf(['bottom', 'end', 'start', 'top']),
  /**
   * The label element.
   */
  label: propTypesExports.node,
  /**
   * @ignore
   */
  onChange: propTypesExports.func,
  /**
   * @ignore
   */
  onClick: propTypesExports.func,
  /**
   * @ignore
   */
  onFocus: propTypesExports.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * You can provide your own value. Otherwise, we fallback to the child position index.
   */
  value: propTypesExports.any,
  /**
   * Tab labels appear in a single row.
   * They can use a second line if needed.
   * @default false
   */
  wrapped: propTypesExports.bool
} : void 0;
var Tab$1 = Tab;

function easeInOutSin(time) {
  return (1 + Math.sin(Math.PI * time - Math.PI / 2)) / 2;
}
function animate(property, element, to, options = {}, cb = () => {}) {
  const {
    ease = easeInOutSin,
    duration = 300 // standard
  } = options;
  let start = null;
  const from = element[property];
  let cancelled = false;
  const cancel = () => {
    cancelled = true;
  };
  const step = timestamp => {
    if (cancelled) {
      cb(new Error('Animation cancelled'));
      return;
    }
    if (start === null) {
      start = timestamp;
    }
    const time = Math.min(1, (timestamp - start) / duration);
    element[property] = ease(time) * (to - from) + from;
    if (time >= 1) {
      requestAnimationFrame(() => {
        cb(null);
      });
      return;
    }
    requestAnimationFrame(step);
  };
  if (from === to) {
    cb(new Error('Element already at target position'));
    return cancel;
  }
  requestAnimationFrame(step);
  return cancel;
}

const _excluded$l = ["onChange"];
const styles = {
  width: 99,
  height: 99,
  position: 'absolute',
  top: -9999,
  overflow: 'scroll'
};

/**
 * @ignore - internal component.
 * The component originates from https://github.com/STORIS/react-scrollbar-size.
 * It has been moved into the core in order to minimize the bundle size.
 */
function ScrollbarSize(props) {
  const {
      onChange
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$l);
  const scrollbarHeight = React__namespace.useRef();
  const nodeRef = React__namespace.useRef(null);
  const setMeasurements = () => {
    scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
  };
  React__namespace.useEffect(() => {
    const handleResize = debounce$1(() => {
      const prevHeight = scrollbarHeight.current;
      setMeasurements();
      if (prevHeight !== scrollbarHeight.current) {
        onChange(scrollbarHeight.current);
      }
    });
    const containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener('resize', handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener('resize', handleResize);
    };
  }, [onChange]);
  React__namespace.useEffect(() => {
    setMeasurements();
    onChange(scrollbarHeight.current);
  }, [onChange]);
  return /*#__PURE__*/jsxRuntime.jsx("div", _extends({
    style: styles,
    ref: nodeRef
  }, other));
}
process.env.NODE_ENV !== "production" ? ScrollbarSize.propTypes = {
  onChange: propTypesExports.func.isRequired
} : void 0;

var KeyboardArrowLeft = createSvgIcon( /*#__PURE__*/jsxRuntime.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), 'KeyboardArrowLeft');

var KeyboardArrowRight = createSvgIcon( /*#__PURE__*/jsxRuntime.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), 'KeyboardArrowRight');

function getTabScrollButtonUtilityClass(slot) {
  return generateUtilityClass('MuiTabScrollButton', slot);
}
const tabScrollButtonClasses = generateUtilityClasses('MuiTabScrollButton', ['root', 'vertical', 'horizontal', 'disabled']);
var tabScrollButtonClasses$1 = tabScrollButtonClasses;

var _KeyboardArrowLeft, _KeyboardArrowRight;
const _excluded$k = ["className", "direction", "orientation", "disabled"];
const useUtilityClasses$s = ownerState => {
  const {
    classes,
    orientation,
    disabled
  } = ownerState;
  const slots = {
    root: ['root', orientation, disabled && 'disabled']
  };
  return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
};
const TabScrollButtonRoot = styled$1(ButtonBase$1, {
  name: 'MuiTabScrollButton',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.orientation && styles[ownerState.orientation]];
  }
})(({
  ownerState
}) => _extends({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${tabScrollButtonClasses$1.disabled}`]: {
    opacity: 0
  }
}, ownerState.orientation === 'vertical' && {
  width: '100%',
  height: 40,
  '& svg': {
    transform: `rotate(${ownerState.isRtl ? -90 : 90}deg)`
  }
}));
const TabScrollButton = /*#__PURE__*/React__namespace.forwardRef(function TabScrollButton(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiTabScrollButton'
  });
  const {
      className,
      direction
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$k);
  const theme = useTheme();
  const isRtl = theme.direction === 'rtl';
  const ownerState = _extends({
    isRtl
  }, props);
  const classes = useUtilityClasses$s(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(TabScrollButtonRoot, _extends({
    component: "div",
    className: clsx(classes.root, className),
    ref: ref,
    role: null,
    ownerState: ownerState,
    tabIndex: null
  }, other, {
    children: direction === 'left' ? _KeyboardArrowLeft || (_KeyboardArrowLeft = /*#__PURE__*/jsxRuntime.jsx(KeyboardArrowLeft, {
      fontSize: "small"
    })) : _KeyboardArrowRight || (_KeyboardArrowRight = /*#__PURE__*/jsxRuntime.jsx(KeyboardArrowRight, {
      fontSize: "small"
    }))
  }));
});
process.env.NODE_ENV !== "production" ? TabScrollButton.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The direction the button should indicate.
   */
  direction: propTypesExports.oneOf(['left', 'right']).isRequired,
  /**
   * If `true`, the component is disabled.
   */
  disabled: propTypesExports.bool,
  /**
   * The component orientation (layout flow direction).
   */
  orientation: propTypesExports.oneOf(['horizontal', 'vertical']).isRequired,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object])
} : void 0;
var TabScrollButton$1 = TabScrollButton;

function getTabsUtilityClass(slot) {
  return generateUtilityClass('MuiTabs', slot);
}
const tabsClasses = generateUtilityClasses('MuiTabs', ['root', 'vertical', 'flexContainer', 'flexContainerVertical', 'centered', 'scroller', 'fixed', 'scrollableX', 'scrollableY', 'hideScrollbar', 'scrollButtons', 'scrollButtonsHideMobile', 'indicator']);
var tabsClasses$1 = tabsClasses;

const _excluded$j = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"];
const nextItem$1 = (list, item) => {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return list.firstChild;
};
const previousItem$1 = (list, item) => {
  if (list === item) {
    return list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return list.lastChild;
};
const moveFocus$1 = (list, currentFocus, traversalFunction) => {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus);
  while (nextFocus) {
    // Prevent infinite loop.
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }

    // Same logic as useAutocomplete.js
    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';
    if (!nextFocus.hasAttribute('tabindex') || nextFocusDisabled) {
      // Move to the next element.
      nextFocus = traversalFunction(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
};
const useUtilityClasses$r = ownerState => {
  const {
    vertical,
    fixed,
    hideScrollbar,
    scrollableX,
    scrollableY,
    centered,
    scrollButtonsHideMobile,
    classes
  } = ownerState;
  const slots = {
    root: ['root', vertical && 'vertical'],
    scroller: ['scroller', fixed && 'fixed', hideScrollbar && 'hideScrollbar', scrollableX && 'scrollableX', scrollableY && 'scrollableY'],
    flexContainer: ['flexContainer', vertical && 'flexContainerVertical', centered && 'centered'],
    indicator: ['indicator'],
    scrollButtons: ['scrollButtons', scrollButtonsHideMobile && 'scrollButtonsHideMobile'],
    scrollableX: [scrollableX && 'scrollableX'],
    hideScrollbar: [hideScrollbar && 'hideScrollbar']
  };
  return composeClasses(slots, getTabsUtilityClass, classes);
};
const TabsRoot = styled$1('div', {
  name: 'MuiTabs',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${tabsClasses$1.scrollButtons}`]: styles.scrollButtons
    }, {
      [`& .${tabsClasses$1.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles.scrollButtonsHideMobile
    }, styles.root, ownerState.vertical && styles.vertical];
  }
})(({
  ownerState,
  theme
}) => _extends({
  overflow: 'hidden',
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: 'touch',
  display: 'flex'
}, ownerState.vertical && {
  flexDirection: 'column'
}, ownerState.scrollButtonsHideMobile && {
  [`& .${tabsClasses$1.scrollButtons}`]: {
    [theme.breakpoints.down('sm')]: {
      display: 'none'
    }
  }
}));
const TabsScroller = styled$1('div', {
  name: 'MuiTabs',
  slot: 'Scroller',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.scroller, ownerState.fixed && styles.fixed, ownerState.hideScrollbar && styles.hideScrollbar, ownerState.scrollableX && styles.scrollableX, ownerState.scrollableY && styles.scrollableY];
  }
})(({
  ownerState
}) => _extends({
  position: 'relative',
  display: 'inline-block',
  flex: '1 1 auto',
  whiteSpace: 'nowrap'
}, ownerState.fixed && {
  overflowX: 'hidden',
  width: '100%'
}, ownerState.hideScrollbar && {
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: 'none',
  // Firefox
  '&::-webkit-scrollbar': {
    display: 'none' // Safari + Chrome
  }
}, ownerState.scrollableX && {
  overflowX: 'auto',
  overflowY: 'hidden'
}, ownerState.scrollableY && {
  overflowY: 'auto',
  overflowX: 'hidden'
}));
const FlexContainer = styled$1('div', {
  name: 'MuiTabs',
  slot: 'FlexContainer',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.flexContainer, ownerState.vertical && styles.flexContainerVertical, ownerState.centered && styles.centered];
  }
})(({
  ownerState
}) => _extends({
  display: 'flex'
}, ownerState.vertical && {
  flexDirection: 'column'
}, ownerState.centered && {
  justifyContent: 'center'
}));
const TabsIndicator = styled$1('span', {
  name: 'MuiTabs',
  slot: 'Indicator',
  overridesResolver: (props, styles) => styles.indicator
})(({
  ownerState,
  theme
}) => _extends({
  position: 'absolute',
  height: 2,
  bottom: 0,
  width: '100%',
  transition: theme.transitions.create()
}, ownerState.indicatorColor === 'primary' && {
  backgroundColor: (theme.vars || theme).palette.primary.main
}, ownerState.indicatorColor === 'secondary' && {
  backgroundColor: (theme.vars || theme).palette.secondary.main
}, ownerState.vertical && {
  height: '100%',
  width: 2,
  right: 0
}));
const TabsScrollbarSize = styled$1(ScrollbarSize, {
  name: 'MuiTabs',
  slot: 'ScrollbarSize'
})({
  overflowX: 'auto',
  overflowY: 'hidden',
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: 'none',
  // Firefox
  '&::-webkit-scrollbar': {
    display: 'none' // Safari + Chrome
  }
});

const defaultIndicatorStyle = {};
let warnedOnceTabPresent = false;
const Tabs = /*#__PURE__*/React__namespace.forwardRef(function Tabs(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiTabs'
  });
  const theme = useTheme();
  const isRtl = theme.direction === 'rtl';
  const {
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy,
      action,
      centered = false,
      children: childrenProp,
      className,
      component = 'div',
      allowScrollButtonsMobile = false,
      indicatorColor = 'primary',
      onChange,
      orientation = 'horizontal',
      ScrollButtonComponent = TabScrollButton$1,
      scrollButtons = 'auto',
      selectionFollowsFocus,
      TabIndicatorProps = {},
      TabScrollButtonProps = {},
      textColor = 'primary',
      value,
      variant = 'standard',
      visibleScrollbar = false
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$j);
  const scrollable = variant === 'scrollable';
  const vertical = orientation === 'vertical';
  const scrollStart = vertical ? 'scrollTop' : 'scrollLeft';
  const start = vertical ? 'top' : 'left';
  const end = vertical ? 'bottom' : 'right';
  const clientSize = vertical ? 'clientHeight' : 'clientWidth';
  const size = vertical ? 'height' : 'width';
  const ownerState = _extends({}, props, {
    component,
    allowScrollButtonsMobile,
    indicatorColor,
    orientation,
    vertical,
    scrollButtons,
    textColor,
    variant,
    visibleScrollbar,
    fixed: !scrollable,
    hideScrollbar: scrollable && !visibleScrollbar,
    scrollableX: scrollable && !vertical,
    scrollableY: scrollable && vertical,
    centered: centered && !scrollable,
    scrollButtonsHideMobile: !allowScrollButtonsMobile
  });
  const classes = useUtilityClasses$r(ownerState);
  if (process.env.NODE_ENV !== 'production') {
    if (centered && scrollable) {
      console.error('MUI: You can not use the `centered={true}` and `variant="scrollable"` properties ' + 'at the same time on a `Tabs` component.');
    }
  }
  const [mounted, setMounted] = React__namespace.useState(false);
  const [indicatorStyle, setIndicatorStyle] = React__namespace.useState(defaultIndicatorStyle);
  const [displayScroll, setDisplayScroll] = React__namespace.useState({
    start: false,
    end: false
  });
  const [scrollerStyle, setScrollerStyle] = React__namespace.useState({
    overflow: 'hidden',
    scrollbarWidth: 0
  });
  const valueToIndex = new Map();
  const tabsRef = React__namespace.useRef(null);
  const tabListRef = React__namespace.useRef(null);
  const getTabsMeta = () => {
    const tabsNode = tabsRef.current;
    let tabsMeta;
    if (tabsNode) {
      const rect = tabsNode.getBoundingClientRect();
      // create a new object with ClientRect class props + scrollLeft
      tabsMeta = {
        clientWidth: tabsNode.clientWidth,
        scrollLeft: tabsNode.scrollLeft,
        scrollTop: tabsNode.scrollTop,
        scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, theme.direction),
        scrollWidth: tabsNode.scrollWidth,
        top: rect.top,
        bottom: rect.bottom,
        left: rect.left,
        right: rect.right
      };
    }
    let tabMeta;
    if (tabsNode && value !== false) {
      const children = tabListRef.current.children;
      if (children.length > 0) {
        const tab = children[valueToIndex.get(value)];
        if (process.env.NODE_ENV !== 'production') {
          if (!tab) {
            console.error([`MUI: The \`value\` provided to the Tabs component is invalid.`, `None of the Tabs' children match with "${value}".`, valueToIndex.keys ? `You can provide one of the following values: ${Array.from(valueToIndex.keys()).join(', ')}.` : null].join('\n'));
          }
        }
        tabMeta = tab ? tab.getBoundingClientRect() : null;
        if (process.env.NODE_ENV !== 'production') {
          if (process.env.NODE_ENV !== 'test' && !warnedOnceTabPresent && tabMeta && tabMeta.width === 0 && tabMeta.height === 0) {
            tabsMeta = null;
            console.error(['MUI: The `value` provided to the Tabs component is invalid.', `The Tab with this \`value\` ("${value}") is not part of the document layout.`, "Make sure the tab item is present in the document or that it's not `display: none`."].join('\n'));
            warnedOnceTabPresent = true;
          }
        }
      }
    }
    return {
      tabsMeta,
      tabMeta
    };
  };
  const updateIndicatorState = useEventCallback$2(() => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    let startValue = 0;
    let startIndicator;
    if (vertical) {
      startIndicator = 'top';
      if (tabMeta && tabsMeta) {
        startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
      }
    } else {
      startIndicator = isRtl ? 'right' : 'left';
      if (tabMeta && tabsMeta) {
        const correction = isRtl ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;
        startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + correction);
      }
    }
    const newIndicatorStyle = {
      [startIndicator]: startValue,
      // May be wrong until the font is loaded.
      [size]: tabMeta ? tabMeta[size] : 0
    };

    // IE11 support, replace with Number.isNaN
    // eslint-disable-next-line no-restricted-globals
    if (isNaN(indicatorStyle[startIndicator]) || isNaN(indicatorStyle[size])) {
      setIndicatorStyle(newIndicatorStyle);
    } else {
      const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
      const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
      if (dStart >= 1 || dSize >= 1) {
        setIndicatorStyle(newIndicatorStyle);
      }
    }
  });
  const scroll = (scrollValue, {
    animation = true
  } = {}) => {
    if (animation) {
      animate(scrollStart, tabsRef.current, scrollValue, {
        duration: theme.transitions.duration.standard
      });
    } else {
      tabsRef.current[scrollStart] = scrollValue;
    }
  };
  const moveTabsScroll = delta => {
    let scrollValue = tabsRef.current[scrollStart];
    if (vertical) {
      scrollValue += delta;
    } else {
      scrollValue += delta * (isRtl ? -1 : 1);
      // Fix for Edge
      scrollValue *= isRtl && detectScrollType() === 'reverse' ? -1 : 1;
    }
    scroll(scrollValue);
  };
  const getScrollSize = () => {
    const containerSize = tabsRef.current[clientSize];
    let totalSize = 0;
    const children = Array.from(tabListRef.current.children);
    for (let i = 0; i < children.length; i += 1) {
      const tab = children[i];
      if (totalSize + tab[clientSize] > containerSize) {
        // If the first item is longer than the container size, then only scroll
        // by the container size.
        if (i === 0) {
          totalSize = containerSize;
        }
        break;
      }
      totalSize += tab[clientSize];
    }
    return totalSize;
  };
  const handleStartScrollClick = () => {
    moveTabsScroll(-1 * getScrollSize());
  };
  const handleEndScrollClick = () => {
    moveTabsScroll(getScrollSize());
  };

  // TODO Remove <ScrollbarSize /> as browser support for hidding the scrollbar
  // with CSS improves.
  const handleScrollbarSizeChange = React__namespace.useCallback(scrollbarWidth => {
    setScrollerStyle({
      overflow: null,
      scrollbarWidth
    });
  }, []);
  const getConditionalElements = () => {
    const conditionalElements = {};
    conditionalElements.scrollbarSizeListener = scrollable ? /*#__PURE__*/jsxRuntime.jsx(TabsScrollbarSize, {
      onChange: handleScrollbarSizeChange,
      className: clsx(classes.scrollableX, classes.hideScrollbar)
    }) : null;
    const scrollButtonsActive = displayScroll.start || displayScroll.end;
    const showScrollButtons = scrollable && (scrollButtons === 'auto' && scrollButtonsActive || scrollButtons === true);
    conditionalElements.scrollButtonStart = showScrollButtons ? /*#__PURE__*/jsxRuntime.jsx(ScrollButtonComponent, _extends({
      orientation: orientation,
      direction: isRtl ? 'right' : 'left',
      onClick: handleStartScrollClick,
      disabled: !displayScroll.start
    }, TabScrollButtonProps, {
      className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
    })) : null;
    conditionalElements.scrollButtonEnd = showScrollButtons ? /*#__PURE__*/jsxRuntime.jsx(ScrollButtonComponent, _extends({
      orientation: orientation,
      direction: isRtl ? 'left' : 'right',
      onClick: handleEndScrollClick,
      disabled: !displayScroll.end
    }, TabScrollButtonProps, {
      className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
    })) : null;
    return conditionalElements;
  };
  const scrollSelectedIntoView = useEventCallback$2(animation => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    if (!tabMeta || !tabsMeta) {
      return;
    }
    if (tabMeta[start] < tabsMeta[start]) {
      // left side of button is out of view
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start] - tabsMeta[start]);
      scroll(nextScrollStart, {
        animation
      });
    } else if (tabMeta[end] > tabsMeta[end]) {
      // right side of button is out of view
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end] - tabsMeta[end]);
      scroll(nextScrollStart, {
        animation
      });
    }
  });
  const updateScrollButtonState = useEventCallback$2(() => {
    if (scrollable && scrollButtons !== false) {
      const {
        scrollTop,
        scrollHeight,
        clientHeight,
        scrollWidth,
        clientWidth
      } = tabsRef.current;
      let showStartScroll;
      let showEndScroll;
      if (vertical) {
        showStartScroll = scrollTop > 1;
        showEndScroll = scrollTop < scrollHeight - clientHeight - 1;
      } else {
        const scrollLeft = getNormalizedScrollLeft(tabsRef.current, theme.direction);
        // use 1 for the potential rounding error with browser zooms.
        showStartScroll = isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
        showEndScroll = !isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
      }
      if (showStartScroll !== displayScroll.start || showEndScroll !== displayScroll.end) {
        setDisplayScroll({
          start: showStartScroll,
          end: showEndScroll
        });
      }
    }
  });
  React__namespace.useEffect(() => {
    const handleResize = debounce$1(() => {
      // If the Tabs component is replaced by Suspense with a fallback, the last
      // ResizeObserver's handler that runs because of the change in the layout is trying to
      // access a dom node that is no longer there (as the fallback component is being shown instead).
      // See https://github.com/mui/material-ui/issues/33276
      // TODO: Add tests that will ensure the component is not failing when
      // replaced by Suspense with a fallback, once React is updated to version 18
      if (tabsRef.current) {
        updateIndicatorState();
        updateScrollButtonState();
      }
    });
    const win = ownerWindow(tabsRef.current);
    win.addEventListener('resize', handleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== 'undefined') {
      resizeObserver = new ResizeObserver(handleResize);
      Array.from(tabListRef.current.children).forEach(child => {
        resizeObserver.observe(child);
      });
    }
    return () => {
      handleResize.clear();
      win.removeEventListener('resize', handleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [updateIndicatorState, updateScrollButtonState]);
  const handleTabsScroll = React__namespace.useMemo(() => debounce$1(() => {
    updateScrollButtonState();
  }), [updateScrollButtonState]);
  React__namespace.useEffect(() => {
    return () => {
      handleTabsScroll.clear();
    };
  }, [handleTabsScroll]);
  React__namespace.useEffect(() => {
    setMounted(true);
  }, []);
  React__namespace.useEffect(() => {
    updateIndicatorState();
    updateScrollButtonState();
  });
  React__namespace.useEffect(() => {
    // Don't animate on the first render.
    scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
  }, [scrollSelectedIntoView, indicatorStyle]);
  React__namespace.useImperativeHandle(action, () => ({
    updateIndicator: updateIndicatorState,
    updateScrollButtons: updateScrollButtonState
  }), [updateIndicatorState, updateScrollButtonState]);
  const indicator = /*#__PURE__*/jsxRuntime.jsx(TabsIndicator, _extends({}, TabIndicatorProps, {
    className: clsx(classes.indicator, TabIndicatorProps.className),
    ownerState: ownerState,
    style: _extends({}, indicatorStyle, TabIndicatorProps.style)
  }));
  let childIndex = 0;
  const children = React__namespace.Children.map(childrenProp, child => {
    if (! /*#__PURE__*/React__namespace.isValidElement(child)) {
      return null;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (reactIsExports$1.isFragment(child)) {
        console.error(["MUI: The Tabs component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
      }
    }
    const childValue = child.props.value === undefined ? childIndex : child.props.value;
    valueToIndex.set(childValue, childIndex);
    const selected = childValue === value;
    childIndex += 1;
    return /*#__PURE__*/React__namespace.cloneElement(child, _extends({
      fullWidth: variant === 'fullWidth',
      indicator: selected && !mounted && indicator,
      selected,
      selectionFollowsFocus,
      onChange,
      textColor,
      value: childValue
    }, childIndex === 1 && value === false && !child.props.tabIndex ? {
      tabIndex: 0
    } : {}));
  });
  const handleKeyDown = event => {
    const list = tabListRef.current;
    const currentFocus = ownerDocument(list).activeElement;
    // Keyboard navigation assumes that [role="tab"] are siblings
    // though we might warn in the future about nested, interactive elements
    // as a a11y violation
    const role = currentFocus.getAttribute('role');
    if (role !== 'tab') {
      return;
    }
    let previousItemKey = orientation === 'horizontal' ? 'ArrowLeft' : 'ArrowUp';
    let nextItemKey = orientation === 'horizontal' ? 'ArrowRight' : 'ArrowDown';
    if (orientation === 'horizontal' && isRtl) {
      // swap previousItemKey with nextItemKey
      previousItemKey = 'ArrowRight';
      nextItemKey = 'ArrowLeft';
    }
    switch (event.key) {
      case previousItemKey:
        event.preventDefault();
        moveFocus$1(list, currentFocus, previousItem$1);
        break;
      case nextItemKey:
        event.preventDefault();
        moveFocus$1(list, currentFocus, nextItem$1);
        break;
      case 'Home':
        event.preventDefault();
        moveFocus$1(list, null, nextItem$1);
        break;
      case 'End':
        event.preventDefault();
        moveFocus$1(list, null, previousItem$1);
        break;
    }
  };
  const conditionalElements = getConditionalElements();
  return /*#__PURE__*/jsxRuntime.jsxs(TabsRoot, _extends({
    className: clsx(classes.root, className),
    ownerState: ownerState,
    ref: ref,
    as: component
  }, other, {
    children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /*#__PURE__*/jsxRuntime.jsxs(TabsScroller, {
      className: classes.scroller,
      ownerState: ownerState,
      style: {
        overflow: scrollerStyle.overflow,
        [vertical ? `margin${isRtl ? 'Left' : 'Right'}` : 'marginBottom']: visibleScrollbar ? undefined : -scrollerStyle.scrollbarWidth
      },
      ref: tabsRef,
      onScroll: handleTabsScroll,
      children: [/*#__PURE__*/jsxRuntime.jsx(FlexContainer, {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-orientation": orientation === 'vertical' ? 'vertical' : null,
        className: classes.flexContainer,
        ownerState: ownerState,
        onKeyDown: handleKeyDown,
        ref: tabListRef,
        role: "tablist",
        children: children
      }), mounted && indicator]
    }), conditionalElements.scrollButtonEnd]
  }));
});
process.env.NODE_ENV !== "production" ? Tabs.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when the component mounts.
   * This is useful when you want to trigger an action programmatically.
   * It supports two actions: `updateIndicator()` and `updateScrollButtons()`
   *
   * @param {object} actions This object contains all possible actions
   * that can be triggered programmatically.
   */
  action: refType$1,
  /**
   * If `true`, the scroll buttons aren't forced hidden on mobile.
   * By default the scroll buttons are hidden on mobile and takes precedence over `scrollButtons`.
   * @default false
   */
  allowScrollButtonsMobile: propTypesExports.bool,
  /**
   * The label for the Tabs as a string.
   */
  'aria-label': propTypesExports.string,
  /**
   * An id or list of ids separated by a space that label the Tabs.
   */
  'aria-labelledby': propTypesExports.string,
  /**
   * If `true`, the tabs are centered.
   * This prop is intended for large views.
   * @default false
   */
  centered: propTypesExports.bool,
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * Determines the color of the indicator.
   * @default 'primary'
   */
  indicatorColor: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['primary', 'secondary']), propTypesExports.string]),
  /**
   * Callback fired when the value changes.
   *
   * @param {React.SyntheticEvent} event The event source of the callback. **Warning**: This is a generic event not a change event.
   * @param {any} value We default to the index of the child (number)
   */
  onChange: propTypesExports.func,
  /**
   * The component orientation (layout flow direction).
   * @default 'horizontal'
   */
  orientation: propTypesExports.oneOf(['horizontal', 'vertical']),
  /**
   * The component used to render the scroll buttons.
   * @default TabScrollButton
   */
  ScrollButtonComponent: propTypesExports.elementType,
  /**
   * Determine behavior of scroll buttons when tabs are set to scroll:
   *
   * - `auto` will only present them when not all the items are visible.
   * - `true` will always present them.
   * - `false` will never present them.
   *
   * By default the scroll buttons are hidden on mobile.
   * This behavior can be disabled with `allowScrollButtonsMobile`.
   * @default 'auto'
   */
  scrollButtons: propTypesExports /* @typescript-to-proptypes-ignore */.oneOf(['auto', false, true]),
  /**
   * If `true` the selected tab changes on focus. Otherwise it only
   * changes on activation.
   */
  selectionFollowsFocus: propTypesExports.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Props applied to the tab indicator element.
   * @default  {}
   */
  TabIndicatorProps: propTypesExports.object,
  /**
   * Props applied to the [`TabScrollButton`](/material-ui/api/tab-scroll-button/) element.
   * @default {}
   */
  TabScrollButtonProps: propTypesExports.object,
  /**
   * Determines the color of the `Tab`.
   * @default 'primary'
   */
  textColor: propTypesExports.oneOf(['inherit', 'primary', 'secondary']),
  /**
   * The value of the currently selected `Tab`.
   * If you don't want any selected `Tab`, you can set this prop to `false`.
   */
  value: propTypesExports.any,
  /**
   * Determines additional display behavior of the tabs:
   *
   *  - `scrollable` will invoke scrolling properties and allow for horizontally
   *  scrolling (or swiping) of the tab bar.
   *  -`fullWidth` will make the tabs grow to use all the available space,
   *  which should be used for small views, like on mobile.
   *  - `standard` will render the default state.
   * @default 'standard'
   */
  variant: propTypesExports.oneOf(['fullWidth', 'scrollable', 'standard']),
  /**
   * If `true`, the scrollbar is visible. It can be useful when displaying
   * a long vertical list of tabs.
   * @default false
   */
  visibleScrollbar: propTypesExports.bool
} : void 0;
var Tabs$1 = Tabs;

function getDateTimePickerTabsUtilityClass(slot) {
    return generateUtilityClass('MuiDateTimePickerTabs', slot);
}
const dateTimePickerTabsClasses = generateUtilityClasses('MuiDateTimePickerTabs', ['root']);

const viewToTab = (view) => {
    if (['day', 'month', 'year'].includes(view)) {
        return 'date';
    }
    return 'time';
};
const tabToView = (tab) => {
    if (tab === 'date') {
        return 'day';
    }
    return 'hours';
};
const useUtilityClasses$q = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
    };
    return composeClasses(slots, getDateTimePickerTabsUtilityClass, classes);
};
const DateTimePickerTabsRoot = styled$1(Tabs$1, {
    name: 'MuiDateTimePickerTabs',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})(({ ownerState, theme }) => (Object.assign({ boxShadow: `0 -1px 0 0 inset ${(theme.vars || theme).palette.divider}` }, (ownerState.wrapperVariant === 'desktop' && {
    // TODO v6: Drop `order` with the legacy pickers
    order: 1,
    boxShadow: `0 1px 0 0 inset ${(theme.vars || theme).palette.divider}`,
    [`& .${tabsClasses$1.indicator}`]: {
        bottom: 'auto',
        top: 0,
    },
}))));
const DateTimePickerTabs = function DateTimePickerTabs(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiDateTimePickerTabs' });
    const { dateIcon = React__namespace.createElement(DateRange, null), onViewChange, timeIcon = React__namespace.createElement(Time, null), view, hidden = typeof window === 'undefined' || window.innerHeight < 667, } = props;
    const localeText = useLocaleText();
    const wrapperVariant = React__namespace.useContext(WrapperVariantContext);
    const ownerState = Object.assign(Object.assign({}, props), { wrapperVariant });
    const classes = useUtilityClasses$q(ownerState);
    const handleChange = (event, value) => {
        onViewChange(tabToView(value));
    };
    if (hidden) {
        return null;
    }
    return (React__namespace.createElement(DateTimePickerTabsRoot, { ownerState: ownerState, variant: "fullWidth", value: viewToTab(view), onChange: handleChange, className: classes.root },
        React__namespace.createElement(Tab$1, { value: "date", "aria-label": localeText.dateTableLabel, icon: React__namespace.createElement(React__namespace.Fragment, null, dateIcon) }),
        React__namespace.createElement(Tab$1, { value: "time", "aria-label": localeText.timeTableLabel, icon: React__namespace.createElement(React__namespace.Fragment, null, timeIcon) })));
};
DateTimePickerTabs.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Override or extend the styles applied to the component.
     */
    classes: propTypesExports.object,
    /**
     * Date tab icon.
     * @default DateRange
     */
    dateIcon: propTypesExports.node,
    /**
     * Toggles visibility of the tabs allowing view switching.
     * @default `window.innerHeight < 667` for `DesktopDateTimePicker` and `MobileDateTimePicker`, `displayStaticWrapperAs === 'desktop'` for `StaticDateTimePicker`
     */
    hidden: propTypesExports.bool,
    /**
     * Callback called when a tab is clicked
     * @template TView
     * @param {TView} view The view to open
     */
    onViewChange: propTypesExports.func.isRequired,
    /**
     * Time tab icon.
     * @default Time
     */
    timeIcon: propTypesExports.node,
    /**
     * Currently visible picker view.
     */
    view: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired,
};

function useDateTimePickerDefaultizedProps(props, name) {
    var _a, _b, _c, _d, _e, _f;
    // This is technically unsound if the type parameters appear in optional props.
    // Optional props can be filled by `useThemeProps` with types that don't match the type parameters.
    const themeProps = useThemeProps({
        props,
        name,
    });
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const ampm = (_a = themeProps.ampm) !== null && _a !== void 0 ? _a : utils.is12HourCycleInCurrentLocale();
    if (themeProps.orientation != null && themeProps.orientation !== 'portrait') {
        throw new Error('We are not supporting custom orientation for DateTimePicker yet :(');
    }
    const localeText = React__namespace.useMemo(() => {
        var _a;
        if (((_a = themeProps.localeText) === null || _a === void 0 ? void 0 : _a.toolbarTitle) == null) {
            return themeProps.localeText;
        }
        return Object.assign(Object.assign({}, themeProps.localeText), { dateTimePickerToolbarTitle: themeProps.localeText.toolbarTitle });
    }, [themeProps.localeText]);
    return Object.assign(Object.assign({ ampm, orientation: 'portrait', openTo: 'day', views: ['year', 'day', 'hours', 'minutes'], ampmInClock: true, acceptRegex: ampm ? /[\dap]/gi : /\d/gi, disableMaskedInput: false, inputFormat: ampm ? utils.formats.keyboardDateTime12h : utils.formats.keyboardDateTime24h, disableIgnoringDatePartForTimeValidation: Boolean(themeProps.minDateTime || themeProps.maxDateTime), disablePast: false, disableFuture: false }, themeProps), { minDate: applyDefaultDate(utils, (_b = themeProps.minDateTime) !== null && _b !== void 0 ? _b : themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, (_c = themeProps.maxDateTime) !== null && _c !== void 0 ? _c : themeProps.maxDate, defaultDates.maxDate), minTime: (_d = themeProps.minDateTime) !== null && _d !== void 0 ? _d : themeProps.minTime, maxTime: (_e = themeProps.maxDateTime) !== null && _e !== void 0 ? _e : themeProps.maxTime, localeText, components: Object.assign({ Toolbar: DateTimePickerToolbar, Tabs: DateTimePickerTabs }, themeProps.components), componentsProps: Object.assign(Object.assign({}, themeProps.componentsProps), { toolbar: Object.assign({ ampm, ampmInClock: themeProps.ampmInClock }, (_f = themeProps.componentsProps) === null || _f === void 0 ? void 0 : _f.toolbar) }) });
}

const validateTime = ({ adapter, value, props }) => {
    const { minTime, maxTime, minutesStep, shouldDisableTime, disableIgnoringDatePartForTimeValidation = false, disablePast, disableFuture, } = props;
    const now = adapter.utils.date();
    const date = adapter.utils.date(value);
    const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, adapter.utils);
    if (value === null) {
        return null;
    }
    switch (true) {
        case !adapter.utils.isValid(value):
            return 'invalidDate';
        case Boolean(minTime && isAfter(minTime, value)):
            return 'minTime';
        case Boolean(maxTime && isAfter(value, maxTime)):
            return 'maxTime';
        case Boolean(disableFuture && adapter.utils.isAfter(date, now)):
            return 'disableFuture';
        case Boolean(disablePast && adapter.utils.isBefore(date, now)):
            return 'disablePast';
        case Boolean(shouldDisableTime && shouldDisableTime(adapter.utils.getHours(value), 'hours')):
            return 'shouldDisableTime-hours';
        case Boolean(shouldDisableTime && shouldDisableTime(adapter.utils.getMinutes(value), 'minutes')):
            return 'shouldDisableTime-minutes';
        case Boolean(shouldDisableTime && shouldDisableTime(adapter.utils.getSeconds(value), 'seconds')):
            return 'shouldDisableTime-seconds';
        case Boolean(minutesStep && adapter.utils.getMinutes(value) % minutesStep !== 0):
            return 'minutesStep';
        default:
            return null;
    }
};
// TODO v6: Drop with the legacy pickers
const isSameTimeError = (a, b) => a === b;
// TODO v6: Drop with the legacy pickers
const useTimeValidation = (props) => useValidation(props, validateTime, isSameTimeError, null);

const validateDateTime = ({ props, value, adapter }) => {
    const dateValidationResult = validateDate({
        adapter,
        value,
        props,
    });
    if (dateValidationResult !== null) {
        return dateValidationResult;
    }
    return validateTime({
        adapter,
        value,
        props,
    });
};
// TODO v6: Drop with the legacy pickers
const isSameDateTimeError = (a, b) => a === b;
// TODO v6: Drop with the legacy pickers
function useDateTimeValidation(props) {
    return useValidation(props, validateDateTime, isSameDateTimeError, null);
}

/**
 *
 * Demos:
 *
 * - [Date Time Picker](https://mui.com/x/react-date-pickers/date-time-picker/)
 *
 * API:
 *
 * - [DesktopDateTimePicker API](https://mui.com/x/api/date-pickers/desktop-date-time-picker/)
 */
const DesktopDateTimePicker = React__namespace.forwardRef(function DesktopDateTimePicker(inProps, ref) {
    const props = useDateTimePickerDefaultizedProps(inProps, 'MuiDesktopDateTimePicker');
    const validationError = useDateTimeValidation(props) !== null;
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, singleItemValueManager);
    const { onChange, value, components, componentsProps, localeText } = props, other = __rest(props, ["onChange", "value", "components", "componentsProps", "localeText"]);
    const AllDateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { components,
        componentsProps,
        ref,
        validationError });
    return (React__namespace.createElement(DesktopWrapper, Object.assign({}, wrapperProps, { DateInputProps: AllDateInputProps, KeyboardDateInputComponent: KeyboardDateInput, components: components, componentsProps: componentsProps, localeText: localeText }),
        React__namespace.createElement(CalendarOrClockPicker, Object.assign({}, pickerProps, { autoFocus: true, DateInputProps: AllDateInputProps, components: components, componentsProps: componentsProps }, other))));
});
DesktopDateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Date tab icon.
     */
    dateRangeIcon: propTypesExports.node,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {DateOrTimeView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'day'
     */
    openTo: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * Time tab icon.
     */
    timeIcon: propTypesExports.node,
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['year', 'day', 'hours', 'minutes']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired),
};

/**
 *
 * Demos:
 *
 * - [Date Time Picker](https://mui.com/x/react-date-pickers/date-time-picker/)
 *
 * API:
 *
 * - [MobileDateTimePicker API](https://mui.com/x/api/date-pickers/mobile-date-time-picker/)
 */
const MobileDateTimePicker = React__namespace.forwardRef(function MobileDateTimePicker(inProps, ref) {
    const props = useDateTimePickerDefaultizedProps(inProps, 'MuiMobileDateTimePicker');
    const validationError = useDateTimeValidation(props) !== null;
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, singleItemValueManager);
    // Note that we are passing down all the value without spread.
    // It saves us >1kb gzip and make any prop available automatically on any level down.
    const { value, onChange, components, componentsProps, localeText } = props, other = __rest(props, ["value", "onChange", "components", "componentsProps", "localeText"]);
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { components,
        componentsProps,
        ref,
        validationError });
    return (React__namespace.createElement(MobileWrapper, Object.assign({}, other, wrapperProps, { DateInputProps: DateInputProps, PureDateInputComponent: PureDateInput, components: components, componentsProps: componentsProps, localeText: localeText }),
        React__namespace.createElement(CalendarOrClockPicker, Object.assign({}, pickerProps, { autoFocus: true, DateInputProps: DateInputProps, components: components, componentsProps: componentsProps }, other))));
});
MobileDateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Date tab icon.
     */
    dateRangeIcon: propTypesExports.node,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {DateOrTimeView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'day'
     */
    openTo: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * Time tab icon.
     */
    timeIcon: propTypesExports.node,
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['year', 'day', 'hours', 'minutes']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired),
};

/**
 *
 * Demos:
 *
 * - [Date Time Picker](https://mui.com/x/react-date-pickers/date-time-picker/)
 * - [Pickers](https://mui.com/x/react-date-pickers/)
 *
 * API:
 *
 * - [DateTimePicker API](https://mui.com/x/api/date-pickers/date-time-picker/)
 */
const DateTimePicker = React__namespace.forwardRef(function DateTimePicker(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiDateTimePicker' });
    const { desktopModeMediaQuery = '@media (pointer: fine)' } = props, other = __rest(props, ["desktopModeMediaQuery"]);
    // defaults to `true` in environments where `window.matchMedia` would not be available (i.e. test/jsdom)
    const isDesktop = useMediaQuery(desktopModeMediaQuery, { defaultMatches: true });
    if (isDesktop) {
        return React__namespace.createElement(DesktopDateTimePicker, Object.assign({ ref: ref }, other));
    }
    return React__namespace.createElement(MobileDateTimePicker, Object.assign({ ref: ref }, other));
});
DateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Date tab icon.
     */
    dateRangeIcon: propTypesExports.node,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * CSS media query when `Mobile` mode will be changed to `Desktop`.
     * @default '@media (pointer: fine)'
     * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
     */
    desktopModeMediaQuery: propTypesExports.string,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {DateOrTimeView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'day'
     */
    openTo: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * Time tab icon.
     */
    timeIcon: propTypesExports.node,
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['year', 'day', 'hours', 'minutes']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired),
};

function getTimePickerToolbarUtilityClass(slot) {
    return generateUtilityClass('MuiTimePickerToolbar', slot);
}
const timePickerToolbarClasses = generateUtilityClasses('MuiTimePickerToolbar', [
    'root',
    'separator',
    'hourMinuteLabel',
    'hourMinuteLabelLandscape',
    'hourMinuteLabelReverse',
    'ampmSelection',
    'ampmLandscape',
    'ampmLabel',
]);

const useUtilityClasses$p = (ownerState) => {
    const { theme, isLandscape, classes } = ownerState;
    const slots = {
        root: ['root'],
        separator: ['separator'],
        hourMinuteLabel: [
            'hourMinuteLabel',
            isLandscape && 'hourMinuteLabelLandscape',
            theme.direction === 'rtl' && 'hourMinuteLabelReverse',
        ],
        ampmSelection: ['ampmSelection', isLandscape && 'ampmLandscape'],
        ampmLabel: ['ampmLabel'],
    };
    return composeClasses(slots, getTimePickerToolbarUtilityClass, classes);
};
const TimePickerToolbarRoot = styled$1(PickersToolbar, {
    name: 'MuiTimePickerToolbar',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({
    [`& .${pickersToolbarClasses.penIconButtonLandscape}`]: {
        marginTop: 'auto',
    },
});
const TimePickerToolbarSeparator = styled$1(PickersToolbarText, {
    name: 'MuiTimePickerToolbar',
    slot: 'Separator',
    overridesResolver: (props, styles) => styles.separator,
})({
    outline: 0,
    margin: '0 4px 0 2px',
    cursor: 'default',
});
const TimePickerToolbarHourMinuteLabel = styled$1('div', {
    name: 'MuiTimePickerToolbar',
    slot: 'HourMinuteLabel',
    overridesResolver: (props, styles) => [
        {
            [`&.${timePickerToolbarClasses.hourMinuteLabelLandscape}`]: styles.hourMinuteLabelLandscape,
            [`&.${timePickerToolbarClasses.hourMinuteLabelReverse}`]: styles.hourMinuteLabelReverse,
        },
        styles.hourMinuteLabel,
    ],
})(({ theme, ownerState }) => (Object.assign(Object.assign({ display: 'flex', justifyContent: 'flex-end', alignItems: 'flex-end' }, (ownerState.isLandscape && {
    marginTop: 'auto',
})), (theme.direction === 'rtl' && {
    flexDirection: 'row-reverse',
}))));
const TimePickerToolbarAmPmSelection = styled$1('div', {
    name: 'MuiTimePickerToolbar',
    slot: 'AmPmSelection',
    overridesResolver: (props, styles) => [
        { [`.${timePickerToolbarClasses.ampmLabel}`]: styles.ampmLabel },
        { [`&.${timePickerToolbarClasses.ampmLandscape}`]: styles.ampmLandscape },
        styles.ampmSelection,
    ],
})(({ ownerState }) => (Object.assign(Object.assign({ display: 'flex', flexDirection: 'column', marginRight: 'auto', marginLeft: 12 }, (ownerState.isLandscape && {
    margin: '4px 0 auto',
    flexDirection: 'row',
    justifyContent: 'space-around',
    flexBasis: '100%',
})), { [`& .${timePickerToolbarClasses.ampmLabel}`]: {
        fontSize: 17,
    } })));
/**
 * @ignore - internal component.
 */
function TimePickerToolbar(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiTimePickerToolbar' });
    const { ampm, ampmInClock, value, isLandscape, isMobileKeyboardViewOpen, onChange, view, onViewChange, toggleMobileKeyboardView, views, disabled, readOnly } = props, other = __rest(props, ["ampm", "ampmInClock", "value", "isLandscape", "isMobileKeyboardViewOpen", "onChange", "view", "onViewChange", "toggleMobileKeyboardView", "views", "disabled", "readOnly"]);
    const utils = useUtils();
    const localeText = useLocaleText();
    const theme = useTheme();
    const showAmPmControl = Boolean(ampm && !ampmInClock);
    const { meridiemMode, handleMeridiemChange } = useMeridiemMode(value, ampm, onChange);
    const formatHours = (time) => ampm ? utils.format(time, 'hours12h') : utils.format(time, 'hours24h');
    const ownerState = props;
    const classes = useUtilityClasses$p(Object.assign(Object.assign({}, ownerState), { theme }));
    const separator = (React__namespace.createElement(TimePickerToolbarSeparator, { tabIndex: -1, value: ":", variant: "h3", selected: false, className: classes.separator }));
    return (React__namespace.createElement(TimePickerToolbarRoot, Object.assign({ viewType: "time", landscapeDirection: "row", toolbarTitle: localeText.timePickerToolbarTitle, isLandscape: isLandscape, isMobileKeyboardViewOpen: isMobileKeyboardViewOpen, toggleMobileKeyboardView: toggleMobileKeyboardView, ownerState: ownerState, className: classes.root }, other),
        React__namespace.createElement(TimePickerToolbarHourMinuteLabel, { className: classes.hourMinuteLabel, ownerState: ownerState },
            arrayIncludes(views, 'hours') && (React__namespace.createElement(PickersToolbarButton, { "data-mui-test": "hours", tabIndex: -1, variant: "h3", onClick: () => onViewChange('hours'), selected: view === 'hours', value: value ? formatHours(value) : '--' })),
            arrayIncludes(views, ['hours', 'minutes']) && separator,
            arrayIncludes(views, 'minutes') && (React__namespace.createElement(PickersToolbarButton, { "data-mui-test": "minutes", tabIndex: -1, variant: "h3", onClick: () => onViewChange('minutes'), selected: view === 'minutes', value: value ? utils.format(value, 'minutes') : '--' })),
            arrayIncludes(views, ['minutes', 'seconds']) && separator,
            arrayIncludes(views, 'seconds') && (React__namespace.createElement(PickersToolbarButton, { "data-mui-test": "seconds", variant: "h3", onClick: () => onViewChange('seconds'), selected: view === 'seconds', value: value ? utils.format(value, 'seconds') : '--' }))),
        showAmPmControl && (React__namespace.createElement(TimePickerToolbarAmPmSelection, { className: classes.ampmSelection, ownerState: ownerState },
            React__namespace.createElement(PickersToolbarButton, { disableRipple: true, variant: "subtitle2", "data-mui-test": "toolbar-am-btn", selected: meridiemMode === 'am', typographyClassName: classes.ampmLabel, value: utils.getMeridiemText('am'), onClick: readOnly ? undefined : () => handleMeridiemChange('am'), disabled: disabled }),
            React__namespace.createElement(PickersToolbarButton, { disableRipple: true, variant: "subtitle2", "data-mui-test": "toolbar-pm-btn", selected: meridiemMode === 'pm', typographyClassName: classes.ampmLabel, value: utils.getMeridiemText('pm'), onClick: readOnly ? undefined : () => handleMeridiemChange('pm'), disabled: disabled })))));
}

function useTimePickerDefaultizedProps(props, name) {
    var _a, _b;
    // This is technically unsound if the type parameters appear in optional props.
    // Optional props can be filled by `useThemeProps` with types that don't match the type parameters.
    const themeProps = useThemeProps({ props, name });
    const utils = useUtils();
    const localeTextFromContext = useLocaleText();
    const ampm = (_a = themeProps.ampm) !== null && _a !== void 0 ? _a : utils.is12HourCycleInCurrentLocale();
    const getOpenDialogAriaText = localeTextFromContext.openTimePickerDialogue;
    const localeText = React__namespace.useMemo(() => {
        var _a;
        if (((_a = themeProps.localeText) === null || _a === void 0 ? void 0 : _a.toolbarTitle) == null) {
            return themeProps.localeText;
        }
        return Object.assign(Object.assign({}, themeProps.localeText), { timePickerToolbarTitle: themeProps.localeText.toolbarTitle });
    }, [themeProps.localeText]);
    return Object.assign(Object.assign({ ampm, openTo: 'hours', views: ['hours', 'minutes'], acceptRegex: ampm ? /[\dapAP]/gi : /\d/gi, disableMaskedInput: false, disablePast: false, disableFuture: false, getOpenDialogAriaText, inputFormat: ampm ? utils.formats.fullTime12h : utils.formats.fullTime24h }, themeProps), { localeText, components: Object.assign({ OpenPickerIcon: Clock, Toolbar: TimePickerToolbar }, themeProps.components), componentsProps: Object.assign(Object.assign({}, themeProps.componentsProps), { toolbar: Object.assign({ ampm, ampmInClock: themeProps.ampmInClock }, (_b = themeProps.componentsProps) === null || _b === void 0 ? void 0 : _b.toolbar) }) });
}
// TODO v6: Drop with the legacy pickers
const timeValueManager = Object.assign(Object.assign({}, singleItemValueManager), { valueReducer: (utils, lastValidValue, newValue) => {
        if (!lastValidValue || !utils.isValid(newValue)) {
            return newValue;
        }
        return utils.mergeDateAndTime(lastValidValue, newValue);
    } });

/**
 *
 * Demos:
 *
 * - [Time Picker](https://mui.com/x/react-date-pickers/time-picker/)
 *
 * API:
 *
 * - [DesktopTimePicker API](https://mui.com/x/api/date-pickers/desktop-time-picker/)
 */
const DesktopTimePicker = React__namespace.forwardRef(function DesktopTimePicker(inProps, ref) {
    const props = useTimePickerDefaultizedProps(inProps, 'MuiDesktopTimePicker');
    const validationError = useTimeValidation(props) !== null;
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, timeValueManager);
    const { onChange, value, components, componentsProps, localeText } = props, other = __rest(props, ["onChange", "value", "components", "componentsProps", "localeText"]);
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { components,
        componentsProps,
        ref,
        validationError });
    return (React__namespace.createElement(DesktopWrapper, Object.assign({}, wrapperProps, { DateInputProps: DateInputProps, KeyboardDateInputComponent: KeyboardDateInput, components: components, componentsProps: componentsProps, localeText: localeText }),
        React__namespace.createElement(CalendarOrClockPicker, Object.assign({}, pickerProps, { autoFocus: true, DateInputProps: DateInputProps, components: components, componentsProps: componentsProps }, other))));
});
DesktopTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {TimeView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'hours'
     */
    openTo: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['hours', 'minutes']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['hours', 'minutes', 'seconds']).isRequired),
};

/**
 *
 * Demos:
 *
 * - [Time Picker](https://mui.com/x/react-date-pickers/time-picker/)
 *
 * API:
 *
 * - [MobileTimePicker API](https://mui.com/x/api/date-pickers/mobile-time-picker/)
 */
const MobileTimePicker = React__namespace.forwardRef(function MobileTimePicker(inProps, ref) {
    const props = useTimePickerDefaultizedProps(inProps, 'MuiMobileTimePicker');
    const validationError = useTimeValidation(props) !== null;
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, timeValueManager);
    // Note that we are passing down all the value without spread.
    // It saves us >1kb gzip and make any prop available automatically on any level down.
    const { value, onChange, components, componentsProps, localeText } = props, other = __rest(props, ["value", "onChange", "components", "componentsProps", "localeText"]);
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { components,
        componentsProps,
        ref,
        validationError });
    return (React__namespace.createElement(MobileWrapper, Object.assign({}, other, wrapperProps, { DateInputProps: DateInputProps, PureDateInputComponent: PureDateInput, components: components, componentsProps: componentsProps, localeText: localeText }),
        React__namespace.createElement(CalendarOrClockPicker, Object.assign({}, pickerProps, { autoFocus: true, DateInputProps: DateInputProps, components: components, componentsProps: componentsProps }, other))));
});
MobileTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {TimeView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'hours'
     */
    openTo: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['hours', 'minutes']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['hours', 'minutes', 'seconds']).isRequired),
};

function getStaticWrapperUtilityClass(slot) {
    return generateUtilityClass('MuiPickerStaticWrapper', slot);
}
generateUtilityClasses('MuiPickerStaticWrapper', ['root', 'content']);

const useUtilityClasses$o = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        content: ['content'],
    };
    return composeClasses(slots, getStaticWrapperUtilityClass, classes);
};
const PickerStaticWrapperRoot = styled$1('div', {
    name: 'MuiPickerStaticWrapper',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({
    display: 'flex',
    flexDirection: 'column',
});
const PickerStaticWrapperContent = styled$1('div', {
    name: 'MuiPickerStaticWrapper',
    slot: 'Content',
    overridesResolver: (props, styles) => styles.content,
})(({ theme }) => ({
    overflow: 'hidden',
    minWidth: DIALOG_WIDTH,
    display: 'flex',
    flexDirection: 'column',
    backgroundColor: (theme.vars || theme).palette.background.paper,
}));
// TODO v6: Drop with the legacy pickers
function PickerStaticWrapper(inProps) {
    var _a, _b;
    const props = useThemeProps({ props: inProps, name: 'MuiPickerStaticWrapper' });
    const { displayStaticWrapperAs = 'mobile', onAccept, onClear, onCancel, onSetToday, children, onDismiss, open, components, componentsProps, localeText, className } = props, other = __rest(props, ["displayStaticWrapperAs", "onAccept", "onClear", "onCancel", "onSetToday", "children", "onDismiss", "open", "components", "componentsProps", "localeText", "className"]);
    const classes = useUtilityClasses$o(props);
    const ActionBar = (_a = components === null || components === void 0 ? void 0 : components.ActionBar) !== null && _a !== void 0 ? _a : PickersActionBar;
    const actionBarProps = useSlotProps({
        elementType: ActionBar,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.actionBar,
        additionalProps: {
            onAccept,
            onClear,
            onCancel,
            onSetToday,
            actions: displayStaticWrapperAs === 'desktop'
                ? []
                : ['cancel', 'accept'],
        },
        ownerState: { wrapperVariant: displayStaticWrapperAs },
    });
    const PaperContent = (_b = components === null || components === void 0 ? void 0 : components.PaperContent) !== null && _b !== void 0 ? _b : React__namespace.Fragment;
    return (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: displayStaticWrapperAs },
            React__namespace.createElement(PickerStaticWrapperRoot, Object.assign({ className: clsx(classes.root, className) }, other),
                React__namespace.createElement(PickerStaticWrapperContent, { className: classes.content },
                    React__namespace.createElement(PaperContent, Object.assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.paperContent), children)),
                React__namespace.createElement(ActionBar, Object.assign({}, actionBarProps))))));
}
PickerStaticWrapper.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    autoFocus: propTypesExports.bool,
    children: propTypesExports.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: propTypesExports.object,
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Force static wrapper inner components to be rendered in mobile or desktop mode.
     * @default "mobile"
     */
    displayStaticWrapperAs: propTypesExports.oneOf(['desktop', 'mobile']),
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    onAccept: propTypesExports.func.isRequired,
    onCancel: propTypesExports.func.isRequired,
    onClear: propTypesExports.func.isRequired,
    onDismiss: propTypesExports.func.isRequired,
    onSetToday: propTypesExports.func.isRequired,
    open: propTypesExports.bool.isRequired,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
};

/**
 *
 * Demos:
 *
 * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
 *
 * API:
 *
 * - [StaticDatePicker API](https://mui.com/x/api/date-pickers/static-date-picker/)
 */
const StaticDatePicker = React__namespace.forwardRef(function StaticDatePicker(inProps, ref) {
    const props = useDatePickerDefaultizedProps(inProps, 'MuiStaticDatePicker');
    // Note that we are passing down all the value without spread.
    // It saves us >1kb gzip and make any prop available automatically on any level down.
    const { value, onChange, displayStaticWrapperAs, components, componentsProps, localeText, sx, className } = props, other = __rest(props, ["value", "onChange", "displayStaticWrapperAs", "components", "componentsProps", "localeText", "sx", "className"]);
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, singleItemValueManager);
    const validationError = useDateValidation(props) !== null;
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { ref, validationError, components });
    return (React__namespace.createElement(PickerStaticWrapper, Object.assign({ displayStaticWrapperAs: displayStaticWrapperAs, components: components, componentsProps: componentsProps, localeText: localeText, sx: sx, className: className }, wrapperProps),
        React__namespace.createElement(CalendarOrClockPicker, Object.assign({}, pickerProps, { DateInputProps: DateInputProps, components: components, componentsProps: componentsProps }, other))));
});
StaticDatePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    autoFocus: propTypesExports.bool,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Force static wrapper inner components to be rendered in mobile or desktop mode.
     * @default "mobile"
     */
    displayStaticWrapperAs: propTypesExports.oneOf(['desktop', 'mobile']),
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {DateView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'day'
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['year', 'day']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

/**
 *
 * Demos:
 *
 * - [Date Time Picker](https://mui.com/x/react-date-pickers/date-time-picker/)
 *
 * API:
 *
 * - [StaticDateTimePicker API](https://mui.com/x/api/date-pickers/static-date-time-picker/)
 */
const StaticDateTimePicker = React__namespace.forwardRef(function StaticDateTimePicker(inProps, ref) {
    const props = useDateTimePickerDefaultizedProps(inProps, 'MuiStaticDateTimePicker');
    // Note that we are passing down all the value without spread.
    // It saves us >1kb gzip and make any prop available automatically on any level down.
    const { displayStaticWrapperAs, onChange, value, components, componentsProps: providedComponentsProps, localeText, sx, className } = props, other = __rest(props, ["displayStaticWrapperAs", "onChange", "value", "components", "componentsProps", "localeText", "sx", "className"]);
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, singleItemValueManager);
    const validationError = useDateTimeValidation(props) !== null;
    const componentsProps = Object.assign(Object.assign({}, providedComponentsProps), { tabs: Object.assign({ hidden: displayStaticWrapperAs === 'desktop' }, providedComponentsProps === null || providedComponentsProps === void 0 ? void 0 : providedComponentsProps.tabs) });
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { ref,
        validationError,
        components,
        componentsProps });
    return (React__namespace.createElement(PickerStaticWrapper, Object.assign({ displayStaticWrapperAs: displayStaticWrapperAs, components: components, componentsProps: componentsProps, localeText: localeText, sx: sx, className: className }, wrapperProps),
        React__namespace.createElement(CalendarOrClockPicker, Object.assign({}, pickerProps, { DateInputProps: DateInputProps, components: components, componentsProps: componentsProps }, other))));
});
StaticDateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    autoFocus: propTypesExports.bool,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Date tab icon.
     */
    dateRangeIcon: propTypesExports.node,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Force static wrapper inner components to be rendered in mobile or desktop mode.
     * @default "mobile"
     */
    displayStaticWrapperAs: propTypesExports.oneOf(['desktop', 'mobile']),
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {DateOrTimeView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'day'
     */
    openTo: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * Time tab icon.
     */
    timeIcon: propTypesExports.node,
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['year', 'day', 'hours', 'minutes']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired),
};

/**
 *
 * Demos:
 *
 * - [Time Picker](https://mui.com/x/react-date-pickers/time-picker/)
 *
 * API:
 *
 * - [StaticTimePicker API](https://mui.com/x/api/date-pickers/static-time-picker/)
 */
const StaticTimePicker = React__namespace.forwardRef(function StaticTimePicker(inProps, ref) {
    const props = useTimePickerDefaultizedProps(inProps, 'MuiStaticTimePicker');
    const { displayStaticWrapperAs, onChange, value, components, componentsProps, localeText, sx, className } = props, other = __rest(props, ["displayStaticWrapperAs", "onChange", "value", "components", "componentsProps", "localeText", "sx", "className"]);
    const validationError = useTimeValidation(props) !== null;
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, timeValueManager);
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { ref,
        validationError,
        components,
        componentsProps });
    return (React__namespace.createElement(PickerStaticWrapper, Object.assign({ displayStaticWrapperAs: displayStaticWrapperAs, components: components, componentsProps: componentsProps, localeText: localeText, sx: sx, className: className }, wrapperProps),
        React__namespace.createElement(CalendarOrClockPicker, Object.assign({}, pickerProps, { DateInputProps: DateInputProps, components: components, componentsProps: componentsProps }, other))));
});
StaticTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    autoFocus: propTypesExports.bool,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Force static wrapper inner components to be rendered in mobile or desktop mode.
     * @default "mobile"
     */
    displayStaticWrapperAs: propTypesExports.oneOf(['desktop', 'mobile']),
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {TimeView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'hours'
     */
    openTo: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['hours', 'minutes']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['hours', 'minutes', 'seconds']).isRequired),
};

/**
 *
 * Demos:
 *
 * - [Pickers](https://mui.com/x/react-date-pickers/)
 * - [Time Picker](https://mui.com/x/react-date-pickers/time-picker/)
 *
 * API:
 *
 * - [TimePicker API](https://mui.com/x/api/date-pickers/time-picker/)
 */
const TimePicker = React__namespace.forwardRef(function TimePicker(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiTimePicker' });
    const { desktopModeMediaQuery = '@media (pointer: fine)' } = props, other = __rest(props, ["desktopModeMediaQuery"]);
    // defaults to `true` in environments where `window.matchMedia` would not be available (i.e. test/jsdom)
    const isDesktop = useMediaQuery(desktopModeMediaQuery, { defaultMatches: true });
    if (isDesktop) {
        return React__namespace.createElement(DesktopTimePicker, Object.assign({ ref: ref }, other));
    }
    return React__namespace.createElement(MobileTimePicker, Object.assign({ ref: ref }, other));
});
TimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * CSS media query when `Mobile` mode will be changed to `Desktop`.
     * @default '@media (pointer: fine)'
     * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
     */
    desktopModeMediaQuery: propTypesExports.string,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date) changes @DateIOType.
     * @template TValue
     * @param {TValue} value The new value.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @param {TimeView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * First view to show.
     * Must be a valid option from `views` list
     * @default 'hours'
     */
    openTo: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `props` argument of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props) that you need to forward.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example ```jsx
     * renderInput={props => <TextField {...props} />}
     * ````
     * @param {MuiTextFieldPropsType} props The props of the input.
     * @returns {React.ReactNode} The node to render as the input.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The value of the picker.
     */
    value: propTypesExports.any,
    /**
     * Array of views to show.
     * @default ['hours', 'minutes']
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['hours', 'minutes', 'seconds']).isRequired),
};

const nlNLPickers = {
    // Calendar navigation
    previousMonth: 'Vorige maand',
    nextMonth: 'Volgende maand',
    // View navigation
    openPreviousView: 'open vorige view',
    openNextView: 'open volgende view',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'jaarweergave is geopend, schakel over naar kalenderweergave'
        : 'kalenderweergave is geopend, switch naar jaarweergave',
    // inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
    // DateRange placeholders
    start: 'Start',
    end: 'Einde',
    // Action bar
    cancelButtonLabel: 'Annuleren',
    clearButtonLabel: 'Resetten',
    okButtonLabel: 'OK',
    todayButtonLabel: 'Vandaag',
    // Toolbar titles
    // datePickerToolbarTitle: 'Select date',
    // dateTimePickerToolbarTitle: 'Select date & time',
    // timePickerToolbarTitle: 'Select time',
    // dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Selecteer ${view}. ${time === null
        ? 'Geen tijd geselecteerd'
        : `Geselecteerde tijd is ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} uren`,
    minutesClockNumberText: (minutes) => `${minutes} minuten`,
    secondsClockNumberText: (seconds) => `${seconds} seconden`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Kies datum, geselecteerde datum is ${utils.format(value, 'fullDate')}`
        : 'Kies datum',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Kies tijd, geselecteerde tijd is ${utils.format(value, 'fullTime')}`
        : 'Kies tijd',
    // Table labels
    timeTableLabel: 'kies tijd',
    dateTableLabel: 'kies datum',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const nlNL = getPickersLocalization(nlNLPickers);

const plPLPickers = {
    // Calendar navigation
    previousMonth: 'Poprzedni miesic',
    nextMonth: 'Nastpny miesic',
    // View navigation
    openPreviousView: 'otwrz poprzedni widok',
    openNextView: 'otwrz nastpny widok',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'otwarty jest widok roku, przecz na widok kalendarza'
        : 'otwarty jest widok kalendarza, przecz na widok roku',
    // inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
    // DateRange placeholders
    start: 'Pocztek',
    end: 'Koniec',
    // Action bar
    cancelButtonLabel: 'Anuluj',
    clearButtonLabel: 'Wyczy',
    okButtonLabel: 'Zatwierd',
    todayButtonLabel: 'Dzisiaj',
    // Toolbar titles
    // datePickerToolbarTitle: 'Select date',
    // dateTimePickerToolbarTitle: 'Select date & time',
    // timePickerToolbarTitle: 'Select time',
    // dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null ? 'Nie wybrano czasu' : `Wybrany czas to ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} godzin`,
    minutesClockNumberText: (minutes) => `${minutes} minut`,
    secondsClockNumberText: (seconds) => `${seconds} sekund`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value != null && utils.isValid(value)
        ? `Wybierz dat, obecnie wybrana data to ${utils.format(value, 'fullDate')}`
        : 'Wybierz dat',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Wybierz czas, obecnie wybrany czas to ${utils.format(value, 'fullTime')}`
        : 'Wybierz czas',
    // Table labels
    timeTableLabel: 'wybierz czas',
    dateTableLabel: 'wybierz dat',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const plPL = getPickersLocalization(plPLPickers);

const ptBRPickers = {
    // Calendar navigation
    previousMonth: 'Ms anterior',
    nextMonth: 'Prximo ms',
    // View navigation
    openPreviousView: 'Abrir prxima seleo',
    openNextView: 'Abrir seleo anterior',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'Seleo de ano est aberta, alternando para seleo de calendrio'
        : 'Seleo de calendrios est aberta, alternando para seleo de ano',
    // inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
    // DateRange placeholders
    start: 'Incio',
    end: 'Fim',
    // Action bar
    cancelButtonLabel: 'Cancelar',
    clearButtonLabel: 'Limpar',
    okButtonLabel: 'OK',
    todayButtonLabel: 'Hoje',
    // Toolbar titles
    // datePickerToolbarTitle: 'Select date',
    // dateTimePickerToolbarTitle: 'Select date & time',
    // timePickerToolbarTitle: 'Select time',
    // dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Selecione ${view}. ${time === null
        ? 'Hora no selecionada'
        : `Selecionado a hora ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} horas`,
    minutesClockNumberText: (minutes) => `${minutes} minutos`,
    secondsClockNumberText: (seconds) => `${seconds} segundos`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Escolha uma data, data selecionada ${utils.format(value, 'fullDate')}`
        : 'Escolha uma data',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Escolha uma hora, hora selecionada ${utils.format(value, 'fullTime')}`
        : 'Escolha uma hora',
    // Table labels
    timeTableLabel: 'escolha uma hora',
    dateTableLabel: 'escolha uma data',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const ptBR = getPickersLocalization(ptBRPickers);

const trTRPickers = {
    // Calendar navigation
    previousMonth: 'nceki ay',
    nextMonth: 'Sonraki ay',
    // View navigation
    openPreviousView: 'sonraki grnm',
    openNextView: 'nceki grnm',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'yl grnm ak, takvim grnmne ge'
        : 'takvim grnm ak, yl grnmne ge',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `metin girii grnm ak, uraya gidin: ${viewType} grnm`
        : `${viewType} grnm ak, metin girii grnmne gidin`,
    // DateRange placeholders
    start: 'Balang',
    end: 'Biti',
    // Action bar
    cancelButtonLabel: 'iptal',
    clearButtonLabel: 'Temizle',
    okButtonLabel: 'Tamam',
    todayButtonLabel: 'Bugn',
    // Toolbar titles
    datePickerToolbarTitle: 'Tarih Se',
    dateTimePickerToolbarTitle: 'Tarih & Saat se',
    timePickerToolbarTitle: 'Saat se',
    dateRangePickerToolbarTitle: 'Tarih aral sein',
    // Clock labels
    clockLabelText: (view, time, adapter) => `${view} se.  ${time === null ? 'Zaman seilmedi' : `Seilen zaman: ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} saat`,
    minutesClockNumberText: (minutes) => `${minutes} dakika`,
    secondsClockNumberText: (seconds) => `${seconds} saniye`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Tarih sein, seilen tarih: ${utils.format(value, 'fullDate')}`
        : 'Tarih se',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Saat sein, seilen saat: ${utils.format(value, 'fullTime')}`
        : 'Saat se',
    // Table labels
    timeTableLabel: 'saat se',
    dateTableLabel: 'tarih se',
    // Field section placeholders
    fieldYearPlaceholder: (params) => 'Y'.repeat(params.digitAmount),
    fieldMonthPlaceholder: (params) => (params.contentType === 'letter' ? 'AAA' : 'AA'),
    fieldDayPlaceholder: () => 'GG',
    fieldHoursPlaceholder: () => 'ss',
    fieldMinutesPlaceholder: () => 'dd',
    fieldSecondsPlaceholder: () => 'ss',
    fieldMeridiemPlaceholder: () => 'aa',
};
const trTR = getPickersLocalization(trTRPickers);

// maps TimeView to its translation
const timeViews$1 = {
    hours: 'Stunden',
    minutes: 'Minuten',
    seconds: 'Sekunden',
};
// maps PickersToolbar["viewType"] to its translation
const pickerViews$1 = {
    date: 'Kalenderansicht',
    time: 'Uhransicht',
};
const deDEPickers = {
    // Calendar navigation
    previousMonth: 'Letzter Monat',
    nextMonth: 'Nchster Monat',
    // View navigation
    openPreviousView: 'Letzte Ansicht ffnen',
    openNextView: 'Nchste Ansicht ffnen',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'Jahresansicht ist geffnet, zur Kalenderansicht wechseln'
        : 'Kalenderansicht ist geffnet, zur Jahresansicht wechseln',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `Texteingabeansicht ist geffnet, zur ${pickerViews$1[viewType]} wechseln`
        : `${pickerViews$1[viewType]} ist geffnet, zur Texteingabeansicht wechseln`,
    // DateRange placeholders
    start: 'Beginn',
    end: 'Ende',
    // Action bar
    cancelButtonLabel: 'Abbrechen',
    clearButtonLabel: 'Lschen',
    okButtonLabel: 'OK',
    todayButtonLabel: 'Heute',
    // Toolbar titles
    datePickerToolbarTitle: 'Datum auswhlen',
    dateTimePickerToolbarTitle: 'Datum & Uhrzeit auswhlen',
    timePickerToolbarTitle: 'Uhrzeit auswhlen',
    dateRangePickerToolbarTitle: 'Datumsbereich auswhlen',
    // Clock labels
    clockLabelText: (view, time, adapter) => {
        var _a;
        return `${(_a = timeViews$1[view]) !== null && _a !== void 0 ? _a : view} auswhlen. ${time === null
            ? 'Keine Uhrzeit ausgewhlt'
            : `Gewhlte Uhrzeit ist ${adapter.format(time, 'fullTime')}`}`;
    },
    hoursClockNumberText: (hours) => `${hours} ${timeViews$1.hours}`,
    minutesClockNumberText: (minutes) => `${minutes} ${timeViews$1.minutes}`,
    secondsClockNumberText: (seconds) => `${seconds}  ${timeViews$1.seconds}`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Datum auswhlen, gewhltes Datum ist ${utils.format(value, 'fullDate')}`
        : 'Datum auswhlen',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Uhrzeit auswhlen, gewhlte Uhrzeit ist ${utils.format(value, 'fullTime')}`
        : 'Uhrzeit auswhlen',
    // Table labels
    timeTableLabel: 'Uhrzeit auswhlen',
    dateTableLabel: 'Datum auswhlen',
    // Field section placeholders
    fieldYearPlaceholder: (params) => 'J'.repeat(params.digitAmount),
    fieldMonthPlaceholder: (params) => (params.contentType === 'letter' ? 'MMMM' : 'MM'),
    fieldDayPlaceholder: () => 'TT',
    fieldHoursPlaceholder: () => 'ss',
    fieldMinutesPlaceholder: () => 'mm',
    fieldSecondsPlaceholder: () => 'ss',
    fieldMeridiemPlaceholder: () => 'aa',
};
const deDE = getPickersLocalization(deDEPickers);

const views$5 = {
    hours: 'las horas',
    minutes: 'los minutos',
    seconds: 'los segundos',
};
const esESPickers = {
    // Calendar navigation
    previousMonth: 'ltimo mes',
    nextMonth: 'Prximo mes',
    // View navigation
    openPreviousView: 'abrir la ltima vista',
    openNextView: 'abrir la siguiente vista',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'la vista del ao est abierta, cambie a la vista de calendario'
        : 'la vista de calendario est abierta, cambie a la vista del ao',
    // inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
    // DateRange placeholders
    start: 'Empezar',
    end: 'Terminar',
    // Action bar
    cancelButtonLabel: 'Cancelar',
    clearButtonLabel: 'Limpia',
    okButtonLabel: 'OK',
    todayButtonLabel: 'Hoy',
    // Toolbar titles
    // datePickerToolbarTitle: 'Select date',
    // dateTimePickerToolbarTitle: 'Select date & time',
    // timePickerToolbarTitle: 'Select time',
    // dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Seleccione ${views$5[view]}. ${time === null
        ? 'Sin tiempo seleccionado'
        : `El tiempo seleccionado es ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} horas`,
    minutesClockNumberText: (minutes) => `${minutes} minutos`,
    secondsClockNumberText: (seconds) => `${seconds} segundos`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Elige la fecha, la fecha elegida es ${utils.format(value, 'fullDate')}`
        : 'Elige la fecha',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Elige la hora, la hora elegido es ${utils.format(value, 'fullTime')}`
        : 'Elige la hora',
    // Table labels
    timeTableLabel: 'elige la fecha',
    dateTableLabel: 'elige la hora',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const esES = getPickersLocalization(esESPickers);

const faIRPickers = {
    // Calendar navigation
    previousMonth: ' ',
    nextMonth: ' ',
    // View navigation
    openPreviousView: ' ',
    openNextView: ' ',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? '       '
        : '       ',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `        ${viewType}`
        : ` ${viewType}       `,
    // DateRange placeholders
    start: '',
    end: '',
    // Action bar
    cancelButtonLabel: '',
    clearButtonLabel: ' ',
    okButtonLabel: '',
    todayButtonLabel: '',
    // Toolbar titles
    datePickerToolbarTitle: '   ',
    dateTimePickerToolbarTitle: '     ',
    timePickerToolbarTitle: '   ',
    dateRangePickerToolbarTitle: '    ',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null
        ? '    '
        : `  ${adapter.format(time, 'fullTime')}  `}`,
    hoursClockNumberText: (hours) => `${hours}  `,
    minutesClockNumberText: (minutes) => `${minutes}  `,
    secondsClockNumberText: (seconds) => `${seconds}  `,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `       ${utils.format(value, 'fullDate')}  `
        : '   ',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `       ${utils.format(value, 'fullTime')}  `
        : '   ',
    // Table labels
    timeTableLabel: ' ',
    dateTableLabel: ' ',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const faIR = getPickersLocalization(faIRPickers);

const views$4 = {
    hours: 'tunnit',
    minutes: 'minuutit',
    seconds: 'sekuntit',
};
const viewTranslation$1 = {
    date: 'kalenteri',
    time: 'kello',
};
const fiFIPickers = {
    // Calendar navigation
    previousMonth: 'Edellinen kuukausi',
    nextMonth: 'Seuraava kuukausi',
    // View navigation
    openPreviousView: 'avaa edellinen kuukausi',
    openNextView: 'avaa seuraava kuukausi',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'vuosinkym on auki, vaihda kalenterinkymn'
        : 'kalenterinkym on auki, vaihda vuosinkymn',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `tekstikentt on auki, mene ${viewTranslation$1[viewType]}nkymn`
        : `${viewTranslation$1[viewType]}nkym on auki, mene tekstikenttn`,
    // DateRange placeholders
    start: 'Alku',
    end: 'Loppu',
    // Action bar
    cancelButtonLabel: 'Peruuta',
    clearButtonLabel: 'Tyhjenn',
    okButtonLabel: 'OK',
    todayButtonLabel: 'Tnn',
    // Toolbar titles
    datePickerToolbarTitle: 'Valitse piv',
    dateTimePickerToolbarTitle: 'Valitse piv ja aika',
    timePickerToolbarTitle: 'Valitse aika',
    dateRangePickerToolbarTitle: 'Valitse aikavli',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Valitse ${views$4[view]}. ${time === null ? 'Ei aikaa valittuna' : `Valittu aika on ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} tuntia`,
    minutesClockNumberText: (minutes) => `${minutes} minuuttia`,
    secondsClockNumberText: (seconds) => `${seconds} sekunttia`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Valitse piv, valittu piv on ${utils.format(value, 'fullDate')}`
        : 'Valitse piv',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Valitse aika, valittu aika on ${utils.format(value, 'fullTime')}`
        : 'Valitse aika',
    // Table labels
    timeTableLabel: 'valitse aika',
    dateTableLabel: 'valitse piv',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const fiFI = getPickersLocalization(fiFIPickers);

const views$3 = {
    hours: 'heures',
    minutes: 'minutes',
    seconds: 'secondes',
};
const viewTranslation = {
    date: 'calendrier',
    time: 'horloge',
};
const frFRPickers = {
    // Calendar navigation
    previousMonth: 'Mois prcdent',
    nextMonth: 'Mois suivant',
    // View navigation
    openPreviousView: 'Ouvrir la vue prcdente',
    openNextView: 'Ouvrir la vue suivante',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'La vue anne est ouverte, ouvrir la vue calendrier'
        : 'La vue calendrier est ouverte, ouvrir la vue anne',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `passer du champ text au ${viewTranslation[viewType]}`
        : `passer du ${viewTranslation[viewType]} au champ text`,
    // DateRange placeholders
    start: 'Dbut',
    end: 'Fin',
    // Action bar
    cancelButtonLabel: 'Annuler',
    clearButtonLabel: 'Vider',
    okButtonLabel: 'OK',
    todayButtonLabel: "Aujourd'hui",
    // Toolbar titles
    // datePickerToolbarTitle: 'Select date',
    // dateTimePickerToolbarTitle: 'Select date & time',
    // timePickerToolbarTitle: 'Select time',
    // dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Choix des ${views$3[view]}. ${time === null
        ? 'Aucune heure choisie'
        : `L'heure choisie est ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} heures`,
    minutesClockNumberText: (minutes) => `${minutes} minutes`,
    secondsClockNumberText: (seconds) => `${seconds} secondes`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Choisir la date, la date slectionne est ${utils.format(value, 'fullDate')}`
        : 'Choisir la date',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Choisir l'heure, l'heure slectionne est ${utils.format(value, 'fullTime')}`
        : "Choisir l'heure",
    // Table labels
    timeTableLabel: "choix de l'heure",
    dateTableLabel: 'choix de la date',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const frFR = getPickersLocalization(frFRPickers);

const nbNOPickers = {
    // Calendar navigation
    previousMonth: 'Forrige mned',
    nextMonth: 'Neste mned',
    // View navigation
    openPreviousView: 'pne forrige visning',
    openNextView: 'pne neste visning',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'rsvisning er pen, bytt til kalendervisning'
        : 'kalendervisning er pen, bytt til rsvisning',
    // inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
    // DateRange placeholders
    start: 'Start',
    end: 'Slutt',
    // Action bar
    cancelButtonLabel: 'Avbryt',
    clearButtonLabel: 'Fjern',
    okButtonLabel: 'OK',
    todayButtonLabel: 'I dag',
    // Toolbar titles
    // datePickerToolbarTitle: 'Select date',
    // dateTimePickerToolbarTitle: 'Select date & time',
    // timePickerToolbarTitle: 'Select time',
    // dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Velg ${view}. ${time === null ? 'Ingen tid valgt' : `Valgt tid er ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} timer`,
    minutesClockNumberText: (minutes) => `${minutes} minutter`,
    secondsClockNumberText: (seconds) => `${seconds} sekunder`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Velg dato, valgt dato er ${utils.format(value, 'fullDate')}`
        : 'Velg dato',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Velg tid, valgt tid er ${utils.format(value, 'fullTime')}`
        : 'Velg tid',
    // Table labels
    timeTableLabel: 'velg tid',
    dateTableLabel: 'velg dato',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const nbNO = getPickersLocalization(nbNOPickers);

const svSEPickers = {
    // Calendar navigation
    previousMonth: 'Fregende mnad',
    nextMonth: 'Nsta mnad',
    // View navigation
    openPreviousView: 'ppna fregende vy',
    openNextView: 'ppna nsta vy',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'rsvyn r ppen, byt till kalendervy'
        : 'kalendervyn r ppen, byt till rsvy',
    // inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
    // DateRange placeholders
    start: 'Start',
    end: 'Slut',
    // Action bar
    cancelButtonLabel: 'Avbryt',
    clearButtonLabel: 'Rensa',
    okButtonLabel: 'OK',
    todayButtonLabel: 'Idag',
    // Toolbar titles
    // datePickerToolbarTitle: 'Select date',
    // dateTimePickerToolbarTitle: 'Select date & time',
    // timePickerToolbarTitle: 'Select time',
    // dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null ? 'Ingen tid vald' : `Vald tid r ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} timmar`,
    minutesClockNumberText: (minutes) => `${minutes} minuter`,
    secondsClockNumberText: (seconds) => `${seconds} sekunder`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Vlj datum, valt datum r ${utils.format(value, 'fullDate')}`
        : 'Vlj datum',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Vlj tid, vald tid r ${utils.format(value, 'fullTime')}`
        : 'Vlj tid',
    // Table labels
    timeTableLabel: 'vlj tid',
    dateTableLabel: 'vlj datum',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const svSE = getPickersLocalization(svSEPickers);

const views$2 = {
    hours: 'le ore',
    minutes: 'i minuti',
    seconds: 'i secondi',
};
const itITPickers = {
    // Calendar navigation
    previousMonth: 'Mese precedente',
    nextMonth: 'Mese successivo',
    // View navigation
    openPreviousView: 'apri la vista precedente',
    openNextView: 'apri la vista successiva',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? "la vista dell'anno  aperta, passare alla vista del calendario"
        : "la vista dell'calendario  aperta, passare alla vista dell'anno",
    // inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
    // DateRange placeholders
    start: 'Inizio',
    end: 'Fine',
    // Action bar
    cancelButtonLabel: 'Cancellare',
    clearButtonLabel: 'Sgomberare',
    okButtonLabel: 'OK',
    todayButtonLabel: 'Oggi',
    // Toolbar titles
    // datePickerToolbarTitle: 'Select date',
    // dateTimePickerToolbarTitle: 'Select date & time',
    // timePickerToolbarTitle: 'Select time',
    // dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Seleziona ${views$2[view]}. ${time === null
        ? 'Nessun orario selezionato'
        : `L'ora selezionata  ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} ore`,
    minutesClockNumberText: (minutes) => `${minutes} minuti`,
    secondsClockNumberText: (seconds) => `${seconds} secondi`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Scegli la data, la data selezionata  ${utils.format(value, 'fullDate')}`
        : 'Scegli la data',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Scegli l'ora, l'ora selezionata  ${utils.format(value, 'fullTime')}`
        : "Scegli l'ora",
    // Table labels
    timeTableLabel: 'scegli un ora',
    dateTableLabel: 'scegli una data',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const itIT = getPickersLocalization(itITPickers);

const views$1 = {
    hours: '',
    minutes: '',
    seconds: '',
};
const zhCNPickers = {
    // Calendar navigation
    previousMonth: '',
    nextMonth: '',
    // View navigation
    openPreviousView: '',
    openNextView: '',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year' ? '' : '',
    // inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`,
    // DateRange placeholders
    start: '',
    end: '',
    // Action bar
    cancelButtonLabel: '',
    clearButtonLabel: '',
    okButtonLabel: '',
    todayButtonLabel: '',
    // Toolbar titles
    // datePickerToolbarTitle: 'Select date',
    // dateTimePickerToolbarTitle: 'Select date & time',
    // timePickerToolbarTitle: 'Select time',
    // dateRangePickerToolbarTitle: 'Select date range',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Select ${views$1[view]}. ${time === null ? '' : `${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours}`,
    minutesClockNumberText: (minutes) => `${minutes}`,
    secondsClockNumberText: (seconds) => `${seconds}`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `${utils.format(value, 'fullDate')}`
        : '',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `${utils.format(value, 'fullTime')}`
        : '',
    // Table labels
    timeTableLabel: '',
    dateTableLabel: '',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const zhCN = getPickersLocalization(zhCNPickers);

const views = {
    hours: '',
    minutes: '',
    seconds: '',
};
const koKRPickers = {
    // Calendar navigation
    previousMonth: ' ',
    nextMonth: ' ',
    // View navigation
    openPreviousView: '  ',
    openNextView: '  ',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? '     '
        : '     ',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `   ${viewType}  `
        : `${viewType}     `,
    // DateRange placeholders
    start: '',
    end: '',
    // Action bar
    cancelButtonLabel: '',
    clearButtonLabel: '',
    okButtonLabel: '',
    todayButtonLabel: '',
    // Toolbar titles
    datePickerToolbarTitle: ' ',
    dateTimePickerToolbarTitle: ' &  ',
    timePickerToolbarTitle: ' ',
    dateRangePickerToolbarTitle: '  ',
    // Clock labels
    clockLabelText: (view, time, adapter) => `${views[view]} . ${time === null
        ? '  .'
        : `   ${adapter.format(time, 'fullTime')}.`}`,
    hoursClockNumberText: (hours) => `${hours}`,
    minutesClockNumberText: (minutes) => `${minutes}`,
    secondsClockNumberText: (seconds) => `${seconds}`,
    // Calendar labels
    calendarWeekNumberHeaderLabel: ' ',
    calendarWeekNumberHeaderText: '#',
    calendarWeekNumberAriaLabelText: (weekNumber) => `${weekNumber} `,
    calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? ` .    ${utils.format(value, 'fullDate')}.`
        : ' ',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? ` .    ${utils.format(value, 'fullTime')}.`
        : ' ',
    // Table labels
    timeTableLabel: ' ',
    dateTableLabel: ' ',
    // Field section placeholders
    fieldYearPlaceholder: (params) => 'Y'.repeat(params.digitAmount),
    fieldMonthPlaceholder: (params) => (params.contentType === 'letter' ? 'MMMM' : 'MM'),
    fieldDayPlaceholder: () => 'DD',
    fieldHoursPlaceholder: () => 'hh',
    fieldMinutesPlaceholder: () => 'mm',
    fieldSecondsPlaceholder: () => 'ss',
    fieldMeridiemPlaceholder: () => 'aa',
};
const koKR = getPickersLocalization(koKRPickers);

const isISPickers = {
    // Calendar navigation
    previousMonth: 'Fyrri mnuur',
    nextMonth: 'Nsti mnuur',
    // View navigation
    openPreviousView: 'opna fyrri skoun',
    openNextView: 'opna nstu skoun',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? 'rsskoun er opin, skipta yfir  dagatalsskoun'
        : 'dagatalsskoun er opin, skipta yfir  rsskoun',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => {
        const viewTypeTranslated = viewType === 'date' ? 'dagatals' : 'klukku';
        return isKeyboardInputOpen
            ? `textainnslttur er opinn, fara  ${viewTypeTranslated}skoun`
            : `${viewTypeTranslated}skoun er opin, opna fyrir textainnsltt`;
    },
    // DateRange placeholders
    start: 'Upphaf',
    end: 'Endir',
    // Action bar
    cancelButtonLabel: 'Htta vi',
    clearButtonLabel: 'Hreinsa',
    okButtonLabel: 'OK',
    todayButtonLabel: ' dag',
    // Toolbar titles
    datePickerToolbarTitle: 'Velja dagsetningu',
    dateTimePickerToolbarTitle: 'Velja dagsetningu og tma',
    timePickerToolbarTitle: 'Velja tma',
    dateRangePickerToolbarTitle: 'Velja tmabil',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null ? 'Enginn tmi valinn' : `Valinn tmi er ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} klukkustundir`,
    minutesClockNumberText: (minutes) => `${minutes} mntur`,
    secondsClockNumberText: (seconds) => `${seconds} sekndur`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Velja dagsetningu, valin dagsetning er ${utils.format(value, 'fullDate')}`
        : 'Velja dagsetningu',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `Velja tma, valinn tmi er ${utils.format(value, 'fullTime')}`
        : 'Velja tma',
    // Table labels
    timeTableLabel: 'velja tma',
    dateTableLabel: 'velja dagsetningu',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const isIS = getPickersLocalization(isISPickers);

// maps TimeView to its translation
const timeViews = {
    hours: '',
    minutes: '',
    seconds: '',
};
// maps PickersToolbar["viewType"] to its translation
const pickerViews = {
    date: '',
    time: '',
};
const jaJPPickers = {
    // Calendar navigation
    previousMonth: '',
    nextMonth: '',
    // View navigation
    openPreviousView: '',
    openNextView: '',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? ''
        : '',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `${pickerViews[viewType]}`
        : `${pickerViews[viewType]}`,
    // DateRange placeholders
    start: '',
    end: '',
    // Action bar
    cancelButtonLabel: '',
    clearButtonLabel: '',
    okButtonLabel: '',
    todayButtonLabel: '',
    // Toolbar titles
    datePickerToolbarTitle: '',
    dateTimePickerToolbarTitle: '',
    timePickerToolbarTitle: '',
    dateRangePickerToolbarTitle: '',
    // Clock labels
    clockLabelText: (view, time, adapter) => {
        var _a;
        return `${(_a = timeViews[view]) !== null && _a !== void 0 ? _a : view} ${time === null
            ? ''
            : ` ${adapter.format(time, 'fullTime')} `}`;
    },
    hoursClockNumberText: (hours) => `${hours} ${timeViews.hours}`,
    minutesClockNumberText: (minutes) => `${minutes} ${timeViews.minutes}`,
    secondsClockNumberText: (seconds) => `${seconds} ${timeViews.seconds}`,
    // Calendar labels
    // calendarWeekNumberHeaderLabel: 'Week number',
    // calendarWeekNumberHeaderText: '#',
    // calendarWeekNumberAriaLabelText: weekNumber => `Week ${weekNumber}`,
    // calendarWeekNumberText: weekNumber => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? ` ${utils.format(value, 'fullDate')} `
        : '',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? ` ${utils.format(value, 'fullTime')} `
        : '',
    // Table labels
    timeTableLabel: '',
    dateTableLabel: '',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const jaJP = getPickersLocalization(jaJPPickers);

const ukUAPickers = {
    // Calendar navigation
    previousMonth: ' ',
    nextMonth: ' ',
    // View navigation
    openPreviousView: '  ',
    openNextView: '  ',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? '  ,    '
        : '  ,    ',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `  ,    ${viewType} `
        : `${viewType}   ,    `,
    // DateRange placeholders
    start: '',
    end: '',
    // Action bar
    cancelButtonLabel: '',
    clearButtonLabel: '',
    okButtonLabel: 'OK',
    todayButtonLabel: '',
    // Toolbar titles
    datePickerToolbarTitle: ' ',
    dateTimePickerToolbarTitle: '   ',
    timePickerToolbarTitle: ' ',
    dateRangePickerToolbarTitle: '  ',
    // Clock labels
    clockLabelText: (view, time, adapter) => `Select ${view}. ${time === null ? '  ' : `  ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} `,
    minutesClockNumberText: (minutes) => `${minutes} `,
    secondsClockNumberText: (seconds) => `${seconds} `,
    // Calendar labels
    calendarWeekNumberHeaderLabel: ' ',
    calendarWeekNumberHeaderText: '#',
    calendarWeekNumberAriaLabelText: (weekNumber) => ` ${weekNumber}`,
    calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? ` ,    ${utils.format(value, 'fullDate')}`
        : ' ',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? ` ,    ${utils.format(value, 'fullTime')}`
        : ' ',
    // Table labels
    timeTableLabel: ' ',
    dateTableLabel: ' ',
    // Field section placeholders
    fieldYearPlaceholder: (params) => 'Y'.repeat(params.digitAmount),
    fieldMonthPlaceholder: (params) => (params.contentType === 'letter' ? 'MMMM' : 'MM'),
    fieldDayPlaceholder: () => 'DD',
    fieldHoursPlaceholder: () => 'hh',
    fieldMinutesPlaceholder: () => 'mm',
    fieldSecondsPlaceholder: () => 'ss',
    fieldMeridiemPlaceholder: () => 'aa',
};
const ukUA = getPickersLocalization(ukUAPickers);

const urPKPickers = {
    // Calendar navigation
    previousMonth: ' ',
    nextMonth: ' ',
    // View navigation
    openPreviousView: '  ',
    openNextView: '  ',
    calendarViewSwitchingButtonAriaLabel: (view) => view === 'year'
        ? '        '
        : '        ',
    inputModeToggleButtonAriaLabel: (isKeyboardInputOpen, viewType) => isKeyboardInputOpen
        ? `    ${viewType}  `
        : `${viewType}      `,
    // DateRange placeholders
    start: '',
    end: '',
    // Action bar
    cancelButtonLabel: '',
    clearButtonLabel: '',
    okButtonLabel: '',
    todayButtonLabel: '',
    // Toolbar titles
    datePickerToolbarTitle: '  ',
    dateTimePickerToolbarTitle: '    ',
    timePickerToolbarTitle: '  ',
    dateRangePickerToolbarTitle: '    ',
    // Clock labels
    clockLabelText: (view, time, adapter) => `${view}   ${time === null ? '   ' : `   ${adapter.format(time, 'fullTime')}`}`,
    hoursClockNumberText: (hours) => `${hours} `,
    minutesClockNumberText: (minutes) => `${minutes} `,
    secondsClockNumberText: (seconds) => `${seconds} `,
    // Calendar labels
    calendarWeekNumberHeaderLabel: ' ',
    calendarWeekNumberHeaderText: '',
    calendarWeekNumberAriaLabelText: (weekNumber) => ` ${weekNumber}`,
    calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
    // Open picker labels
    openDatePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `       ${utils.format(value, 'fullDate')}`
        : '  ',
    openTimePickerDialogue: (value, utils) => value !== null && utils.isValid(value)
        ? `       ${utils.format(value, 'fullTime')}`
        : '  ',
    // Table labels
    timeTableLabel: '  ',
    dateTableLabel: '  ',
    // Field section placeholders
    // fieldYearPlaceholder: params => 'Y'.repeat(params.digitAmount),
    // fieldMonthPlaceholder: params => params.contentType === 'letter' ? 'MMMM' : 'MM',
    // fieldDayPlaceholder: () => 'DD',
    // fieldHoursPlaceholder: () => 'hh',
    // fieldMinutesPlaceholder: () => 'mm',
    // fieldSecondsPlaceholder: () => 'ss',
    // fieldMeridiemPlaceholder: () => 'aa',
};
const urPK = getPickersLocalization(urPKPickers);

function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state) => {
    acc[state] = props[state];
    if (muiFormControl) {
      if (typeof props[state] === 'undefined') {
        acc[state] = muiFormControl[state];
      }
    }
    return acc;
  }, {});
}

function GlobalStyles(props) {
  return /*#__PURE__*/jsxRuntime.jsx(GlobalStyles$1, _extends({}, props, {
    defaultTheme: defaultTheme$1
  }));
}
process.env.NODE_ENV !== "production" ? GlobalStyles.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The styles you want to apply globally.
   */
  styles: propTypesExports.oneOfType([propTypesExports.func, propTypesExports.number, propTypesExports.object, propTypesExports.shape({
    __emotion_styles: propTypesExports.any.isRequired
  }), propTypesExports.string, propTypesExports.bool])
} : void 0;

// Supports determination of isControlled().
// Controlled input accepts its current value as a prop.
//
// @see https://facebook.github.io/react/docs/forms.html#controlled-components
// @param value
// @returns {boolean} true if string (including '') or number (including zero)
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}

// Determine if field is empty or filled.
// Response determines if label is presented above field or as placeholder.
//
// @param obj
// @param SSR
// @returns {boolean} False when not present or empty string.
//                    True when any number or string with length.
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== '' || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== '');
}

// Determine if an Input is adorned on start.
// It's corresponding to the left with LTR.
//
// @param obj
// @returns {boolean} False when no adornments.
//                    True when adorned at the start.
function isAdornedStart(obj) {
  return obj.startAdornment;
}

function getInputBaseUtilityClass(slot) {
  return generateUtilityClass('MuiInputBase', slot);
}
const inputBaseClasses = generateUtilityClasses('MuiInputBase', ['root', 'formControl', 'focused', 'disabled', 'adornedStart', 'adornedEnd', 'error', 'sizeSmall', 'multiline', 'colorSecondary', 'fullWidth', 'hiddenLabel', 'readOnly', 'input', 'inputSizeSmall', 'inputMultiline', 'inputTypeSearch', 'inputAdornedStart', 'inputAdornedEnd', 'inputHiddenLabel']);
var inputBaseClasses$1 = inputBaseClasses;

const _excluded$i = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
const rootOverridesResolver = (props, styles) => {
  const {
    ownerState
  } = props;
  return [styles.root, ownerState.formControl && styles.formControl, ownerState.startAdornment && styles.adornedStart, ownerState.endAdornment && styles.adornedEnd, ownerState.error && styles.error, ownerState.size === 'small' && styles.sizeSmall, ownerState.multiline && styles.multiline, ownerState.color && styles[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles.fullWidth, ownerState.hiddenLabel && styles.hiddenLabel];
};
const inputOverridesResolver = (props, styles) => {
  const {
    ownerState
  } = props;
  return [styles.input, ownerState.size === 'small' && styles.inputSizeSmall, ownerState.multiline && styles.inputMultiline, ownerState.type === 'search' && styles.inputTypeSearch, ownerState.startAdornment && styles.inputAdornedStart, ownerState.endAdornment && styles.inputAdornedEnd, ownerState.hiddenLabel && styles.inputHiddenLabel];
};
const useUtilityClasses$n = ownerState => {
  const {
    classes,
    color,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size,
    startAdornment,
    type
  } = ownerState;
  const slots = {
    root: ['root', `color${capitalize(color)}`, disabled && 'disabled', error && 'error', fullWidth && 'fullWidth', focused && 'focused', formControl && 'formControl', size === 'small' && 'sizeSmall', multiline && 'multiline', startAdornment && 'adornedStart', endAdornment && 'adornedEnd', hiddenLabel && 'hiddenLabel', readOnly && 'readOnly'],
    input: ['input', disabled && 'disabled', type === 'search' && 'inputTypeSearch', multiline && 'inputMultiline', size === 'small' && 'inputSizeSmall', hiddenLabel && 'inputHiddenLabel', startAdornment && 'inputAdornedStart', endAdornment && 'inputAdornedEnd', readOnly && 'readOnly']
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes);
};
const InputBaseRoot = styled$1('div', {
  name: 'MuiInputBase',
  slot: 'Root',
  overridesResolver: rootOverridesResolver
})(({
  theme,
  ownerState
}) => _extends({}, theme.typography.body1, {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: '1.4375em',
  // 23px
  boxSizing: 'border-box',
  // Prevent padding issue with fullWidth.
  position: 'relative',
  cursor: 'text',
  display: 'inline-flex',
  alignItems: 'center',
  [`&.${inputBaseClasses$1.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled,
    cursor: 'default'
  }
}, ownerState.multiline && _extends({
  padding: '4px 0 5px'
}, ownerState.size === 'small' && {
  paddingTop: 1
}), ownerState.fullWidth && {
  width: '100%'
}));
const InputBaseComponent = styled$1('input', {
  name: 'MuiInputBase',
  slot: 'Input',
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => {
  const light = theme.palette.mode === 'light';
  const placeholder = _extends({
    color: 'currentColor'
  }, theme.vars ? {
    opacity: theme.vars.opacity.inputPlaceholder
  } : {
    opacity: light ? 0.42 : 0.5
  }, {
    transition: theme.transitions.create('opacity', {
      duration: theme.transitions.duration.shorter
    })
  });
  const placeholderHidden = {
    opacity: '0 !important'
  };
  const placeholderVisible = theme.vars ? {
    opacity: theme.vars.opacity.inputPlaceholder
  } : {
    opacity: light ? 0.42 : 0.5
  };
  return _extends({
    font: 'inherit',
    letterSpacing: 'inherit',
    color: 'currentColor',
    padding: '4px 0 5px',
    border: 0,
    boxSizing: 'content-box',
    background: 'none',
    height: '1.4375em',
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: 'transparent',
    display: 'block',
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: '100%',
    // Fix IE11 width issue
    animationName: 'mui-auto-fill-cancel',
    animationDuration: '10ms',
    '&::-webkit-input-placeholder': placeholder,
    '&::-moz-placeholder': placeholder,
    // Firefox 19+
    '&:-ms-input-placeholder': placeholder,
    // IE11
    '&::-ms-input-placeholder': placeholder,
    // Edge
    '&:focus': {
      outline: 0
    },
    // Reset Firefox invalid required input style
    '&:invalid': {
      boxShadow: 'none'
    },
    '&::-webkit-search-decoration': {
      // Remove the padding when type=search.
      WebkitAppearance: 'none'
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
      '&::-webkit-input-placeholder': placeholderHidden,
      '&::-moz-placeholder': placeholderHidden,
      // Firefox 19+
      '&:-ms-input-placeholder': placeholderHidden,
      // IE11
      '&::-ms-input-placeholder': placeholderHidden,
      // Edge
      '&:focus::-webkit-input-placeholder': placeholderVisible,
      '&:focus::-moz-placeholder': placeholderVisible,
      // Firefox 19+
      '&:focus:-ms-input-placeholder': placeholderVisible,
      // IE11
      '&:focus::-ms-input-placeholder': placeholderVisible // Edge
    },

    [`&.${inputBaseClasses$1.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme.vars || theme).palette.text.disabled // Fix opacity Safari bug
    },

    '&:-webkit-autofill': {
      animationDuration: '5000s',
      animationName: 'mui-auto-fill'
    }
  }, ownerState.size === 'small' && {
    paddingTop: 1
  }, ownerState.multiline && {
    height: 'auto',
    resize: 'none',
    padding: 0,
    paddingTop: 0
  }, ownerState.type === 'search' && {
    // Improve type search style.
    MozAppearance: 'textfield'
  });
});
const inputGlobalStyles = /*#__PURE__*/jsxRuntime.jsx(GlobalStyles, {
  styles: {
    '@keyframes mui-auto-fill': {
      from: {
        display: 'block'
      }
    },
    '@keyframes mui-auto-fill-cancel': {
      from: {
        display: 'block'
      }
    }
  }
});

/**
 * `InputBase` contains as few styles as possible.
 * It aims to be a simple building block for creating an input.
 * It contains a load of style reset and some state logic.
 */
const InputBase = /*#__PURE__*/React__namespace.forwardRef(function InputBase(inProps, ref) {
  var _slotProps$input;
  const props = useThemeProps({
    props: inProps,
    name: 'MuiInputBase'
  });
  const {
      'aria-describedby': ariaDescribedby,
      autoComplete,
      autoFocus,
      className,
      components = {},
      componentsProps = {},
      defaultValue,
      disabled,
      disableInjectingGlobalStyles,
      endAdornment,
      fullWidth = false,
      id,
      inputComponent = 'input',
      inputProps: inputPropsProp = {},
      inputRef: inputRefProp,
      maxRows,
      minRows,
      multiline = false,
      name,
      onBlur,
      onChange,
      onClick,
      onFocus,
      onKeyDown,
      onKeyUp,
      placeholder,
      readOnly,
      renderSuffix,
      rows,
      slotProps = {},
      slots = {},
      startAdornment,
      type = 'text',
      value: valueProp
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$i);
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = React__namespace.useRef(value != null);
  const inputRef = React__namespace.useRef();
  const handleInputRefWarning = React__namespace.useCallback(instance => {
    if (process.env.NODE_ENV !== 'production') {
      if (instance && instance.nodeName !== 'INPUT' && !instance.focus) {
        console.error(['MUI: You have provided a `inputComponent` to the input component', 'that does not correctly handle the `ref` prop.', 'Make sure the `ref` prop is called with a HTMLInputElement.'].join('\n'));
      }
    }
  }, []);
  const handleInputRef = useForkRef$2(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = React__namespace.useState(false);
  const muiFormControl = useFormControl();
  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__namespace.useEffect(() => {
      if (muiFormControl) {
        return muiFormControl.registerEffect();
      }
      return undefined;
    }, [muiFormControl]);
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ['color', 'disabled', 'error', 'hiddenLabel', 'size', 'required', 'filled']
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;

  // The blur won't fire when the disabled state is set on a focused input.
  // We need to book keep the focused state manually.
  React__namespace.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = React__namespace.useCallback(obj => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect$3(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = event => {
    // Fix a bug with IE11 where the focus/blur events are triggered
    // while the component is disabled.
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = event => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  const handleChange = (event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Expected valid input target. Did you use a custom \`inputComponent\` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info.` : formatMuiErrorMessage(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }

    // Perform in the willUpdate
    if (onChange) {
      onChange(event, ...args);
    }
  };

  // Check the input state on mount, in case it was filled by the user
  // or auto filled by the browser before the hydration (for SSR).
  React__namespace.useEffect(() => {
    checkDirty(inputRef.current);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const handleClick = event => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === 'input') {
    if (rows) {
      if (process.env.NODE_ENV !== 'production') {
        if (minRows || maxRows) {
          console.warn('MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set.');
        }
      }
      inputProps = _extends({
        type: undefined,
        minRows: rows,
        maxRows: rows
      }, inputProps);
    } else {
      inputProps = _extends({
        type: undefined,
        maxRows,
        minRows
      }, inputProps);
    }
    InputComponent = TextareaAutosize$1;
  }
  const handleAutoFill = event => {
    // Provide a fake value as Chrome might not let you access it for security reasons.
    checkDirty(event.animationName === 'mui-auto-fill-cancel' ? inputRef.current : {
      value: 'x'
    });
  };
  React__namespace.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = _extends({}, props, {
    color: fcs.color || 'primary',
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type
  });
  const classes = useUtilityClasses$n(ownerState);
  const Root = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input = slots.input || components.Input || InputBaseComponent;
  inputProps = _extends({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
  return /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
    children: [!disableInjectingGlobalStyles && inputGlobalStyles, /*#__PURE__*/jsxRuntime.jsxs(Root, _extends({}, rootProps, !isHostComponent(Root) && {
      ownerState: _extends({}, ownerState, rootProps.ownerState)
    }, {
      ref: ref,
      onClick: handleClick
    }, other, {
      className: clsx(classes.root, rootProps.className, className),
      children: [startAdornment, /*#__PURE__*/jsxRuntime.jsx(FormControlContext$1.Provider, {
        value: null,
        children: /*#__PURE__*/jsxRuntime.jsx(Input, _extends({
          ownerState: ownerState,
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete: autoComplete,
          autoFocus: autoFocus,
          defaultValue: defaultValue,
          disabled: fcs.disabled,
          id: id,
          onAnimationStart: handleAutoFill,
          name: name,
          placeholder: placeholder,
          readOnly: readOnly,
          required: fcs.required,
          rows: rows,
          value: value,
          onKeyDown: onKeyDown,
          onKeyUp: onKeyUp,
          type: type
        }, inputProps, !isHostComponent(Input) && {
          as: InputComponent,
          ownerState: _extends({}, ownerState, inputProps.ownerState)
        }, {
          ref: handleInputRef,
          className: clsx(classes.input, inputProps.className),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        }))
      }), endAdornment, renderSuffix ? renderSuffix(_extends({}, fcs, {
        startAdornment
      })) : null]
    }))]
  });
});
process.env.NODE_ENV !== "production" ? InputBase.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  'aria-describedby': propTypesExports.string,
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: propTypesExports.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: propTypesExports.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['primary', 'secondary', 'error', 'info', 'success', 'warning']), propTypesExports.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: propTypesExports.shape({
    Input: propTypesExports.elementType,
    Root: propTypesExports.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: propTypesExports.shape({
    input: propTypesExports.object,
    root: propTypesExports.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypesExports.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, GlobalStyles for the auto-fill keyframes will not be injected/removed on mount/unmount. Make sure to inject them at the top of your application.
   * This option is intended to help with boosting the initial rendering performance if you are loading a big amount of Input components at once.
   * @default false
   */
  disableInjectingGlobalStyles: propTypesExports.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: propTypesExports.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: propTypesExports.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: propTypesExports.bool,
  /**
   * The id of the `input` element.
   */
  id: propTypesExports.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: elementTypeAcceptingRef$1,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: propTypesExports.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: propTypesExports.oneOf(['dense', 'none']),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: propTypesExports.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: propTypesExports.string,
  /**
   * Callback fired when the `input` is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */
  onBlur: propTypesExports.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: propTypesExports.func,
  /**
   * @ignore
   */
  onClick: propTypesExports.func,
  /**
   * @ignore
   */
  onFocus: propTypesExports.func,
  /**
   * Callback fired when the `input` doesn't satisfy its constraints.
   */
  onInvalid: propTypesExports.func,
  /**
   * @ignore
   */
  onKeyDown: propTypesExports.func,
  /**
   * @ignore
   */
  onKeyUp: propTypesExports.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: propTypesExports.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: propTypesExports.bool,
  /**
   * @ignore
   */
  renderSuffix: propTypesExports.func,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: propTypesExports.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * The size of the component.
   */
  size: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['medium', 'small']), propTypesExports.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: propTypesExports.shape({
    input: propTypesExports.object,
    root: propTypesExports.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: propTypesExports.shape({
    input: propTypesExports.elementType,
    root: propTypesExports.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: propTypesExports.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: propTypesExports.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: propTypesExports.any
} : void 0;
var InputBase$1 = InputBase;

function getInputUtilityClass(slot) {
  return generateUtilityClass('MuiInput', slot);
}
const inputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses('MuiInput', ['root', 'underline', 'input']));
var inputClasses$1 = inputClasses;

const _excluded$h = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$m = ownerState => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ['root', !disableUnderline && 'underline'],
    input: ['input']
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
  return _extends({}, classes, composedClasses);
};
const InputRoot = styled$1(InputBaseRoot, {
  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
  name: 'MuiInput',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles), !ownerState.disableUnderline && styles.underline];
  }
})(({
  theme,
  ownerState
}) => {
  const light = theme.palette.mode === 'light';
  let bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
  if (theme.vars) {
    bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
  }
  return _extends({
    position: 'relative'
  }, ownerState.formControl && {
    'label + &': {
      marginTop: 16
    }
  }, !ownerState.disableUnderline && {
    '&:after': {
      borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: 'absolute',
      right: 0,
      transform: 'scaleX(0)',
      transition: theme.transitions.create('transform', {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      pointerEvents: 'none' // Transparent to the hover style.
    },

    [`&.${inputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: 'scaleX(1) translateX(0)'
    },
    [`&.${inputClasses$1.error}`]: {
      '&:before, &:after': {
        borderBottomColor: (theme.vars || theme).palette.error.main
      },
      '&:focus-within:after': {
        transform: 'scaleX(1)' // error is always underlined in red
      }
    },

    '&:before': {
      borderBottom: `1px solid ${bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: 'absolute',
      right: 0,
      transition: theme.transitions.create('border-bottom-color', {
        duration: theme.transitions.duration.shorter
      }),
      pointerEvents: 'none' // Transparent to the hover style.
    },

    [`&:hover:not(.${inputClasses$1.disabled}, .${inputClasses$1.error}):before`]: {
      borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        borderBottom: `1px solid ${bottomLineColor}`
      }
    },
    [`&.${inputClasses$1.disabled}:before`]: {
      borderBottomStyle: 'dotted'
    }
  });
});
const InputInput = styled$1(InputBaseComponent, {
  name: 'MuiInput',
  slot: 'Input',
  overridesResolver: inputOverridesResolver
})({});
const Input = /*#__PURE__*/React__namespace.forwardRef(function Input(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: 'MuiInput'
  });
  const {
      disableUnderline,
      components = {},
      componentsProps: componentsPropsProp,
      fullWidth = false,
      inputComponent = 'input',
      multiline = false,
      slotProps,
      slots = {},
      type = 'text'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$h);
  const classes = useUtilityClasses$m(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
  return /*#__PURE__*/jsxRuntime.jsx(InputBase$1, _extends({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth: fullWidth,
    inputComponent: inputComponent,
    multiline: multiline,
    ref: ref,
    type: type
  }, other, {
    classes: classes
  }));
});
process.env.NODE_ENV !== "production" ? Input.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: propTypesExports.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: propTypesExports.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['primary', 'secondary']), propTypesExports.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: propTypesExports.shape({
    Input: propTypesExports.elementType,
    Root: propTypesExports.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: propTypesExports.shape({
    input: propTypesExports.object,
    root: propTypesExports.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypesExports.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the `input` will not have an underline.
   */
  disableUnderline: propTypesExports.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: propTypesExports.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: propTypesExports.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: propTypesExports.bool,
  /**
   * The id of the `input` element.
   */
  id: propTypesExports.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: propTypesExports.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: propTypesExports.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: propTypesExports.oneOf(['dense', 'none']),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: propTypesExports.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: propTypesExports.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: propTypesExports.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: propTypesExports.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: propTypesExports.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: propTypesExports.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: propTypesExports.shape({
    input: propTypesExports.object,
    root: propTypesExports.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: propTypesExports.shape({
    input: propTypesExports.elementType,
    root: propTypesExports.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: propTypesExports.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: propTypesExports.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: propTypesExports.any
} : void 0;
Input.muiName = 'Input';
var Input$1 = Input;

function getFilledInputUtilityClass(slot) {
  return generateUtilityClass('MuiFilledInput', slot);
}
const filledInputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses('MuiFilledInput', ['root', 'underline', 'input']));
var filledInputClasses$1 = filledInputClasses;

const _excluded$g = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$l = ownerState => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ['root', !disableUnderline && 'underline'],
    input: ['input']
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
  return _extends({}, classes, composedClasses);
};
const FilledInputRoot = styled$1(InputBaseRoot, {
  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
  name: 'MuiFilledInput',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles), !ownerState.disableUnderline && styles.underline];
  }
})(({
  theme,
  ownerState
}) => {
  var _palette;
  const light = theme.palette.mode === 'light';
  const bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
  const backgroundColor = light ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.09)';
  const hoverBackground = light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.13)';
  const disabledBackground = light ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)';
  return _extends({
    position: 'relative',
    backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor,
    borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
    borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create('background-color', {
      duration: theme.transitions.duration.shorter,
      easing: theme.transitions.easing.easeOut
    }),
    '&:hover': {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor
      }
    },
    [`&.${filledInputClasses$1.focused}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor
    },
    [`&.${filledInputClasses$1.disabled}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
    }
  }, !ownerState.disableUnderline && {
    '&:after': {
      borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || 'primary']) == null ? void 0 : _palette.main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: 'absolute',
      right: 0,
      transform: 'scaleX(0)',
      transition: theme.transitions.create('transform', {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      pointerEvents: 'none' // Transparent to the hover style.
    },

    [`&.${filledInputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: 'scaleX(1) translateX(0)'
    },
    [`&.${filledInputClasses$1.error}`]: {
      '&:before, &:after': {
        borderBottomColor: (theme.vars || theme).palette.error.main
      },
      '&:focus-within:after': {
        transform: 'scaleX(1)' // error is always underlined in red
      }
    },

    '&:before': {
      borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: 'absolute',
      right: 0,
      transition: theme.transitions.create('border-bottom-color', {
        duration: theme.transitions.duration.shorter
      }),
      pointerEvents: 'none' // Transparent to the hover style.
    },

    [`&:hover:not(.${filledInputClasses$1.disabled}, .${filledInputClasses$1.error}):before`]: {
      borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
    },
    [`&.${filledInputClasses$1.disabled}:before`]: {
      borderBottomStyle: 'dotted'
    }
  }, ownerState.startAdornment && {
    paddingLeft: 12
  }, ownerState.endAdornment && {
    paddingRight: 12
  }, ownerState.multiline && _extends({
    padding: '25px 12px 8px'
  }, ownerState.size === 'small' && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }));
});
const FilledInputInput = styled$1(InputBaseComponent, {
  name: 'MuiFilledInput',
  slot: 'Input',
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => _extends({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !theme.vars && {
  '&:-webkit-autofill': {
    WebkitBoxShadow: theme.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset',
    WebkitTextFillColor: theme.palette.mode === 'light' ? null : '#fff',
    caretColor: theme.palette.mode === 'light' ? null : '#fff',
    borderTopLeftRadius: 'inherit',
    borderTopRightRadius: 'inherit'
  }
}, theme.vars && {
  '&:-webkit-autofill': {
    borderTopLeftRadius: 'inherit',
    borderTopRightRadius: 'inherit'
  },
  [theme.getColorSchemeSelector('dark')]: {
    '&:-webkit-autofill': {
      WebkitBoxShadow: '0 0 0 100px #266798 inset',
      WebkitTextFillColor: '#fff',
      caretColor: '#fff'
    }
  }
}, ownerState.size === 'small' && {
  paddingTop: 21,
  paddingBottom: 4
}, ownerState.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, ownerState.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}, ownerState.hiddenLabel && ownerState.size === 'small' && {
  paddingTop: 8,
  paddingBottom: 9
}));
const FilledInput = /*#__PURE__*/React__namespace.forwardRef(function FilledInput(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: 'MuiFilledInput'
  });
  const {
      components = {},
      componentsProps: componentsPropsProp,
      fullWidth = false,
      // declare here to prevent spreading to DOM
      inputComponent = 'input',
      multiline = false,
      slotProps,
      slots = {},
      type = 'text'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$g);
  const ownerState = _extends({}, props, {
    fullWidth,
    inputComponent,
    multiline,
    type
  });
  const classes = useUtilityClasses$l(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
  return /*#__PURE__*/jsxRuntime.jsx(InputBase$1, _extends({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    componentsProps: componentsProps,
    fullWidth: fullWidth,
    inputComponent: inputComponent,
    multiline: multiline,
    ref: ref,
    type: type
  }, other, {
    classes: classes
  }));
});
process.env.NODE_ENV !== "production" ? FilledInput.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: propTypesExports.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: propTypesExports.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['primary', 'secondary']), propTypesExports.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: propTypesExports.shape({
    Input: propTypesExports.elementType,
    Root: propTypesExports.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: propTypesExports.shape({
    input: propTypesExports.object,
    root: propTypesExports.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypesExports.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the input will not have an underline.
   */
  disableUnderline: propTypesExports.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: propTypesExports.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: propTypesExports.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: propTypesExports.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: propTypesExports.bool,
  /**
   * The id of the `input` element.
   */
  id: propTypesExports.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: propTypesExports.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: propTypesExports.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: propTypesExports.oneOf(['dense', 'none']),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: propTypesExports.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: propTypesExports.string,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: propTypesExports.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: propTypesExports.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: propTypesExports.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: propTypesExports.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: propTypesExports.shape({
    input: propTypesExports.object,
    root: propTypesExports.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: propTypesExports.shape({
    input: propTypesExports.elementType,
    root: propTypesExports.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: propTypesExports.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: propTypesExports.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: propTypesExports.any
} : void 0;
FilledInput.muiName = 'Input';
var FilledInput$1 = FilledInput;

var _span$2;
const _excluded$f = ["children", "classes", "className", "label", "notched"];
const NotchedOutlineRoot$1 = styled$1('fieldset')({
  textAlign: 'left',
  position: 'absolute',
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: '0 8px',
  pointerEvents: 'none',
  borderRadius: 'inherit',
  borderStyle: 'solid',
  borderWidth: 1,
  overflow: 'hidden',
  minWidth: '0%'
});
const NotchedOutlineLegend = styled$1('legend')(({
  ownerState,
  theme
}) => _extends({
  float: 'unset',
  // Fix conflict with bootstrap
  width: 'auto',
  // Fix conflict with bootstrap
  overflow: 'hidden'
}, !ownerState.withLabel && {
  padding: 0,
  lineHeight: '11px',
  // sync with `height` in `legend` styles
  transition: theme.transitions.create('width', {
    duration: 150,
    easing: theme.transitions.easing.easeOut
  })
}, ownerState.withLabel && _extends({
  display: 'block',
  // Fix conflict with normalize.css and sanitize.css
  padding: 0,
  height: 11,
  // sync with `lineHeight` in `legend` styles
  fontSize: '0.75em',
  visibility: 'hidden',
  maxWidth: 0.01,
  transition: theme.transitions.create('max-width', {
    duration: 50,
    easing: theme.transitions.easing.easeOut
  }),
  whiteSpace: 'nowrap',
  '& > span': {
    paddingLeft: 5,
    paddingRight: 5,
    display: 'inline-block',
    opacity: 0,
    visibility: 'visible'
  }
}, ownerState.notched && {
  maxWidth: '100%',
  transition: theme.transitions.create('max-width', {
    duration: 100,
    easing: theme.transitions.easing.easeOut,
    delay: 50
  })
})));

/**
 * @ignore - internal component.
 */
function NotchedOutline(props) {
  const {
      className,
      label,
      notched
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$f);
  const withLabel = label != null && label !== '';
  const ownerState = _extends({}, props, {
    notched,
    withLabel
  });
  return /*#__PURE__*/jsxRuntime.jsx(NotchedOutlineRoot$1, _extends({
    "aria-hidden": true,
    className: className,
    ownerState: ownerState
  }, other, {
    children: /*#__PURE__*/jsxRuntime.jsx(NotchedOutlineLegend, {
      ownerState: ownerState,
      children: withLabel ? /*#__PURE__*/jsxRuntime.jsx("span", {
        children: label
      }) : // notranslate needed while Google Translate will not fix zero-width space issue
      _span$2 || (_span$2 = /*#__PURE__*/jsxRuntime.jsx("span", {
        className: "notranslate",
        children: "\u200B"
      }))
    })
  }));
}
process.env.NODE_ENV !== "production" ? NotchedOutline.propTypes = {
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The label.
   */
  label: propTypesExports.node,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: propTypesExports.bool.isRequired,
  /**
   * @ignore
   */
  style: propTypesExports.object
} : void 0;

function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass('MuiOutlinedInput', slot);
}
const outlinedInputClasses = _extends({}, inputBaseClasses$1, generateUtilityClasses('MuiOutlinedInput', ['root', 'notchedOutline', 'input']));
var outlinedInputClasses$1 = outlinedInputClasses;

const _excluded$e = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
const useUtilityClasses$k = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    notchedOutline: ['notchedOutline'],
    input: ['input']
  };
  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
  return _extends({}, classes, composedClasses);
};
const OutlinedInputRoot = styled$1(InputBaseRoot, {
  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
  name: 'MuiOutlinedInput',
  slot: 'Root',
  overridesResolver: rootOverridesResolver
})(({
  theme,
  ownerState
}) => {
  const borderColor = theme.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
  return _extends({
    position: 'relative',
    borderRadius: (theme.vars || theme).shape.borderRadius,
    [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    '@media (hover: none)': {
      [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor
      }
    },
    [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette[ownerState.color].main,
      borderWidth: 2
    },
    [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.error.main
    },
    [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.action.disabled
    }
  }, ownerState.startAdornment && {
    paddingLeft: 14
  }, ownerState.endAdornment && {
    paddingRight: 14
  }, ownerState.multiline && _extends({
    padding: '16.5px 14px'
  }, ownerState.size === 'small' && {
    padding: '8.5px 14px'
  }));
});
const NotchedOutlineRoot = styled$1(NotchedOutline, {
  name: 'MuiOutlinedInput',
  slot: 'NotchedOutline',
  overridesResolver: (props, styles) => styles.notchedOutline
})(({
  theme
}) => {
  const borderColor = theme.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
  return {
    borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor
  };
});
const OutlinedInputInput = styled$1(InputBaseComponent, {
  name: 'MuiOutlinedInput',
  slot: 'Input',
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => _extends({
  padding: '16.5px 14px'
}, !theme.vars && {
  '&:-webkit-autofill': {
    WebkitBoxShadow: theme.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset',
    WebkitTextFillColor: theme.palette.mode === 'light' ? null : '#fff',
    caretColor: theme.palette.mode === 'light' ? null : '#fff',
    borderRadius: 'inherit'
  }
}, theme.vars && {
  '&:-webkit-autofill': {
    borderRadius: 'inherit'
  },
  [theme.getColorSchemeSelector('dark')]: {
    '&:-webkit-autofill': {
      WebkitBoxShadow: '0 0 0 100px #266798 inset',
      WebkitTextFillColor: '#fff',
      caretColor: '#fff'
    }
  }
}, ownerState.size === 'small' && {
  padding: '8.5px 14px'
}, ownerState.multiline && {
  padding: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}));
const OutlinedInput = /*#__PURE__*/React__namespace.forwardRef(function OutlinedInput(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
  const props = useThemeProps({
    props: inProps,
    name: 'MuiOutlinedInput'
  });
  const {
      components = {},
      fullWidth = false,
      inputComponent = 'input',
      label,
      multiline = false,
      notched,
      slots = {},
      type = 'text'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$e);
  const classes = useUtilityClasses$k(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ['required']
  });
  const ownerState = _extends({}, props, {
    color: fcs.color || 'primary',
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type
  });
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
  return /*#__PURE__*/jsxRuntime.jsx(InputBase$1, _extends({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    renderSuffix: state => /*#__PURE__*/jsxRuntime.jsx(NotchedOutlineRoot, {
      ownerState: ownerState,
      className: classes.notchedOutline,
      label: label != null && label !== '' && fcs.required ? _React$Fragment || (_React$Fragment = /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
        children: [label, "\xA0", '*']
      })) : label,
      notched: typeof notched !== 'undefined' ? notched : Boolean(state.startAdornment || state.filled || state.focused)
    }),
    fullWidth: fullWidth,
    inputComponent: inputComponent,
    multiline: multiline,
    ref: ref,
    type: type
  }, other, {
    classes: _extends({}, classes, {
      notchedOutline: null
    })
  }));
});
process.env.NODE_ENV !== "production" ? OutlinedInput.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: propTypesExports.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: propTypesExports.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['primary', 'secondary']), propTypesExports.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: propTypesExports.shape({
    Input: propTypesExports.elementType,
    Root: propTypesExports.elementType
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypesExports.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: propTypesExports.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: propTypesExports.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: propTypesExports.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: propTypesExports.bool,
  /**
   * The id of the `input` element.
   */
  id: propTypesExports.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: propTypesExports.elementType,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: propTypesExports.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,
  /**
   * The label of the `input`. It is only used for layout. The actual labelling
   * is handled by `InputLabel`.
   */
  label: propTypesExports.node,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: propTypesExports.oneOf(['dense', 'none']),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: propTypesExports.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: propTypesExports.string,
  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: propTypesExports.bool,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: propTypesExports.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: propTypesExports.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: propTypesExports.bool,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: propTypesExports.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: propTypesExports.shape({
    input: propTypesExports.elementType,
    root: propTypesExports.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: propTypesExports.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: propTypesExports.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: propTypesExports.any
} : void 0;
OutlinedInput.muiName = 'Input';
var OutlinedInput$1 = OutlinedInput;

function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass('MuiFormLabel', slot);
}
const formLabelClasses = generateUtilityClasses('MuiFormLabel', ['root', 'colorSecondary', 'focused', 'disabled', 'error', 'filled', 'required', 'asterisk']);
var formLabelClasses$1 = formLabelClasses;

const _excluded$d = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
const useUtilityClasses$j = ownerState => {
  const {
    classes,
    color,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ['root', `color${capitalize(color)}`, disabled && 'disabled', error && 'error', filled && 'filled', focused && 'focused', required && 'required'],
    asterisk: ['asterisk', error && 'error']
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes);
};
const FormLabelRoot = styled$1('label', {
  name: 'MuiFormLabel',
  slot: 'Root',
  overridesResolver: ({
    ownerState
  }, styles) => {
    return _extends({}, styles.root, ownerState.color === 'secondary' && styles.colorSecondary, ownerState.filled && styles.filled);
  }
})(({
  theme,
  ownerState
}) => _extends({
  color: (theme.vars || theme).palette.text.secondary
}, theme.typography.body1, {
  lineHeight: '1.4375em',
  padding: 0,
  position: 'relative',
  [`&.${formLabelClasses$1.focused}`]: {
    color: (theme.vars || theme).palette[ownerState.color].main
  },
  [`&.${formLabelClasses$1.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled
  },
  [`&.${formLabelClasses$1.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
}));
const AsteriskComponent = styled$1('span', {
  name: 'MuiFormLabel',
  slot: 'Asterisk',
  overridesResolver: (props, styles) => styles.asterisk
})(({
  theme
}) => ({
  [`&.${formLabelClasses$1.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
}));
const FormLabel = /*#__PURE__*/React__namespace.forwardRef(function FormLabel(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiFormLabel'
  });
  const {
      children,
      className,
      component = 'label'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$d);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ['color', 'required', 'focused', 'disabled', 'error', 'filled']
  });
  const ownerState = _extends({}, props, {
    color: fcs.color || 'primary',
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$j(ownerState);
  return /*#__PURE__*/jsxRuntime.jsxs(FormLabelRoot, _extends({
    as: component,
    ownerState: ownerState,
    className: clsx(classes.root, className),
    ref: ref
  }, other, {
    children: [children, fcs.required && /*#__PURE__*/jsxRuntime.jsxs(AsteriskComponent, {
      ownerState: ownerState,
      "aria-hidden": true,
      className: classes.asterisk,
      children: ["\u2009", '*']
    })]
  }));
});
process.env.NODE_ENV !== "production" ? FormLabel.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['error', 'info', 'primary', 'secondary', 'success', 'warning']), propTypesExports.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * If `true`, the label should be displayed in a disabled state.
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: propTypesExports.bool,
  /**
   * If `true`, the label should use filled classes key.
   */
  filled: propTypesExports.bool,
  /**
   * If `true`, the input of this label is focused (used by `FormGroup` components).
   */
  focused: propTypesExports.bool,
  /**
   * If `true`, the label will indicate that the `input` is required.
   */
  required: propTypesExports.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object])
} : void 0;
var FormLabel$1 = FormLabel;

function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass('MuiInputLabel', slot);
}
generateUtilityClasses('MuiInputLabel', ['root', 'focused', 'disabled', 'error', 'required', 'asterisk', 'formControl', 'sizeSmall', 'shrink', 'animated', 'standard', 'filled', 'outlined']);

const _excluded$c = ["disableAnimation", "margin", "shrink", "variant", "className"];
const useUtilityClasses$i = ownerState => {
  const {
    classes,
    formControl,
    size,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ['root', formControl && 'formControl', !disableAnimation && 'animated', shrink && 'shrink', size === 'small' && 'sizeSmall', variant],
    asterisk: [required && 'asterisk']
  };
  const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
  return _extends({}, classes, composedClasses);
};
const InputLabelRoot = styled$1(FormLabel$1, {
  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
  name: 'MuiInputLabel',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses$1.asterisk}`]: styles.asterisk
    }, styles.root, ownerState.formControl && styles.formControl, ownerState.size === 'small' && styles.sizeSmall, ownerState.shrink && styles.shrink, !ownerState.disableAnimation && styles.animated, styles[ownerState.variant]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  display: 'block',
  transformOrigin: 'top left',
  whiteSpace: 'nowrap',
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  maxWidth: '100%'
}, ownerState.formControl && {
  position: 'absolute',
  left: 0,
  top: 0,
  // slight alteration to spec spacing to match visual spec result
  transform: 'translate(0, 20px) scale(1)'
}, ownerState.size === 'small' && {
  // Compensation for the `Input.inputSizeSmall` style.
  transform: 'translate(0, 17px) scale(1)'
}, ownerState.shrink && {
  transform: 'translate(0, -1.5px) scale(0.75)',
  transformOrigin: 'top left',
  maxWidth: '133%'
}, !ownerState.disableAnimation && {
  transition: theme.transitions.create(['color', 'transform', 'max-width'], {
    duration: theme.transitions.duration.shorter,
    easing: theme.transitions.easing.easeOut
  })
}, ownerState.variant === 'filled' && _extends({
  // Chrome's autofill feature gives the input field a yellow background.
  // Since the input field is behind the label in the HTML tree,
  // the input field is drawn last and hides the label with an opaque background color.
  // zIndex: 1 will raise the label above opaque background-colors of input.
  zIndex: 1,
  pointerEvents: 'none',
  transform: 'translate(12px, 16px) scale(1)',
  maxWidth: 'calc(100% - 24px)'
}, ownerState.size === 'small' && {
  transform: 'translate(12px, 13px) scale(1)'
}, ownerState.shrink && _extends({
  userSelect: 'none',
  pointerEvents: 'auto',
  transform: 'translate(12px, 7px) scale(0.75)',
  maxWidth: 'calc(133% - 24px)'
}, ownerState.size === 'small' && {
  transform: 'translate(12px, 4px) scale(0.75)'
})), ownerState.variant === 'outlined' && _extends({
  // see comment above on filled.zIndex
  zIndex: 1,
  pointerEvents: 'none',
  transform: 'translate(14px, 16px) scale(1)',
  maxWidth: 'calc(100% - 24px)'
}, ownerState.size === 'small' && {
  transform: 'translate(14px, 9px) scale(1)'
}, ownerState.shrink && {
  userSelect: 'none',
  pointerEvents: 'auto',
  maxWidth: 'calc(133% - 24px)',
  transform: 'translate(14px, -9px) scale(0.75)'
})));
const InputLabel = /*#__PURE__*/React__namespace.forwardRef(function InputLabel(inProps, ref) {
  const props = useThemeProps({
    name: 'MuiInputLabel',
    props: inProps
  });
  const {
      disableAnimation = false,
      shrink: shrinkProp,
      className
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$c);
  const muiFormControl = useFormControl();
  let shrink = shrinkProp;
  if (typeof shrink === 'undefined' && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ['size', 'variant', 'required']
  });
  const ownerState = _extends({}, props, {
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required
  });
  const classes = useUtilityClasses$i(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(InputLabelRoot, _extends({
    "data-shrink": shrink,
    ownerState: ownerState,
    ref: ref,
    className: clsx(classes.root, className)
  }, other, {
    classes: classes
  }));
});
process.env.NODE_ENV !== "production" ? InputLabel.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['error', 'info', 'primary', 'secondary', 'success', 'warning']), propTypesExports.string]),
  /**
   * If `true`, the transition animation is disabled.
   * @default false
   */
  disableAnimation: propTypesExports.bool,
  /**
   * If `true`, the component is disabled.
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the label is displayed in an error state.
   */
  error: propTypesExports.bool,
  /**
   * If `true`, the `input` of this label is focused.
   */
  focused: propTypesExports.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: propTypesExports.oneOf(['dense']),
  /**
   * if `true`, the label will indicate that the `input` is required.
   */
  required: propTypesExports.bool,
  /**
   * If `true`, the label is shrunk.
   */
  shrink: propTypesExports.bool,
  /**
   * The size of the component.
   * @default 'normal'
   */
  size: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['normal', 'small']), propTypesExports.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The variant to use.
   */
  variant: propTypesExports.oneOf(['filled', 'outlined', 'standard'])
} : void 0;
var InputLabel$1 = InputLabel;

function getFormControlUtilityClasses(slot) {
  return generateUtilityClass('MuiFormControl', slot);
}
generateUtilityClasses('MuiFormControl', ['root', 'marginNone', 'marginNormal', 'marginDense', 'fullWidth', 'disabled']);

const _excluded$b = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
const useUtilityClasses$h = ownerState => {
  const {
    classes,
    margin,
    fullWidth
  } = ownerState;
  const slots = {
    root: ['root', margin !== 'none' && `margin${capitalize(margin)}`, fullWidth && 'fullWidth']
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes);
};
const FormControlRoot = styled$1('div', {
  name: 'MuiFormControl',
  slot: 'Root',
  overridesResolver: ({
    ownerState
  }, styles) => {
    return _extends({}, styles.root, styles[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles.fullWidth);
  }
})(({
  ownerState
}) => _extends({
  display: 'inline-flex',
  flexDirection: 'column',
  position: 'relative',
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: 'top'
}, ownerState.margin === 'normal' && {
  marginTop: 16,
  marginBottom: 8
}, ownerState.margin === 'dense' && {
  marginTop: 8,
  marginBottom: 4
}, ownerState.fullWidth && {
  width: '100%'
}));

/**
 * Provides context such as filled/focused/error/required for form inputs.
 * Relying on the context provides high flexibility and ensures that the state always stays
 * consistent across the children of the `FormControl`.
 * This context is used by the following components:
 *
 *  - FormLabel
 *  - FormHelperText
 *  - Input
 *  - InputLabel
 *
 * You can find one composition example below and more going to [the demos](/material-ui/react-text-field/#components).
 *
 * ```jsx
 * <FormControl>
 *   <InputLabel htmlFor="my-input">Email address</InputLabel>
 *   <Input id="my-input" aria-describedby="my-helper-text" />
 *   <FormHelperText id="my-helper-text">We'll never share your email.</FormHelperText>
 * </FormControl>
 * ```
 *
 *  Only one `InputBase` can be used within a FormControl because it creates visual inconsistencies.
 * For instance, only one input can be focused at the same time, the state shouldn't be shared.
 */
const FormControl = /*#__PURE__*/React__namespace.forwardRef(function FormControl(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiFormControl'
  });
  const {
      children,
      className,
      color = 'primary',
      component = 'div',
      disabled = false,
      error = false,
      focused: visuallyFocused,
      fullWidth = false,
      hiddenLabel = false,
      margin = 'none',
      required = false,
      size = 'medium',
      variant = 'outlined'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$b);
  const ownerState = _extends({}, props, {
    color,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin,
    required,
    size,
    variant
  });
  const classes = useUtilityClasses$h(ownerState);
  const [adornedStart, setAdornedStart] = React__namespace.useState(() => {
    // We need to iterate through the children and find the Input in order
    // to fully support server-side rendering.
    let initialAdornedStart = false;
    if (children) {
      React__namespace.Children.forEach(children, child => {
        if (!isMuiElement(child, ['Input', 'Select'])) {
          return;
        }
        const input = isMuiElement(child, ['Select']) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  });
  const [filled, setFilled] = React__namespace.useState(() => {
    // We need to iterate through the children and find the Input in order
    // to fully support server-side rendering.
    let initialFilled = false;
    if (children) {
      React__namespace.Children.forEach(children, child => {
        if (!isMuiElement(child, ['Input', 'Select'])) {
          return;
        }
        if (isFilled(child.props, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  });
  const [focusedState, setFocused] = React__namespace.useState(false);
  if (disabled && focusedState) {
    setFocused(false);
  }
  const focused = visuallyFocused !== undefined && !disabled ? visuallyFocused : focusedState;
  let registerEffect;
  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const registeredInput = React__namespace.useRef(false);
    registerEffect = () => {
      if (registeredInput.current) {
        console.error(['MUI: There are multiple `InputBase` components inside a FormControl.', 'This creates visual inconsistencies, only use one `InputBase`.'].join('\n'));
      }
      registeredInput.current = true;
      return () => {
        registeredInput.current = false;
      };
    };
  }
  const childContext = React__namespace.useMemo(() => {
    return {
      adornedStart,
      setAdornedStart,
      color,
      disabled,
      error,
      filled,
      focused,
      fullWidth,
      hiddenLabel,
      size,
      onBlur: () => {
        setFocused(false);
      },
      onEmpty: () => {
        setFilled(false);
      },
      onFilled: () => {
        setFilled(true);
      },
      onFocus: () => {
        setFocused(true);
      },
      registerEffect,
      required,
      variant
    };
  }, [adornedStart, color, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size, variant]);
  return /*#__PURE__*/jsxRuntime.jsx(FormControlContext$1.Provider, {
    value: childContext,
    children: /*#__PURE__*/jsxRuntime.jsx(FormControlRoot, _extends({
      as: component,
      ownerState: ownerState,
      className: clsx(classes.root, className),
      ref: ref
    }, other, {
      children: children
    }))
  });
});
process.env.NODE_ENV !== "production" ? FormControl.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['primary', 'secondary', 'error', 'info', 'success', 'warning']), propTypesExports.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * If `true`, the label, input and helper text should be displayed in a disabled state.
   * @default false
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: propTypesExports.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: propTypesExports.bool,
  /**
   * If `true`, the component will take up the full width of its container.
   * @default false
   */
  fullWidth: propTypesExports.bool,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: propTypesExports.bool,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: propTypesExports.oneOf(['dense', 'none', 'normal']),
  /**
   * If `true`, the label will indicate that the `input` is required.
   * @default false
   */
  required: propTypesExports.bool,
  /**
   * The size of the component.
   * @default 'medium'
   */
  size: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['medium', 'small']), propTypesExports.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: propTypesExports.oneOf(['filled', 'outlined', 'standard'])
} : void 0;
var FormControl$1 = FormControl;

function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass('MuiFormHelperText', slot);
}
const formHelperTextClasses = generateUtilityClasses('MuiFormHelperText', ['root', 'error', 'disabled', 'sizeSmall', 'sizeMedium', 'contained', 'focused', 'filled', 'required']);
var formHelperTextClasses$1 = formHelperTextClasses;

var _span$1;
const _excluded$a = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
const useUtilityClasses$g = ownerState => {
  const {
    classes,
    contained,
    size,
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', error && 'error', size && `size${capitalize(size)}`, contained && 'contained', focused && 'focused', filled && 'filled', required && 'required']
  };
  return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
};
const FormHelperTextRoot = styled$1('p', {
  name: 'MuiFormHelperText',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.size && styles[`size${capitalize(ownerState.size)}`], ownerState.contained && styles.contained, ownerState.filled && styles.filled];
  }
})(({
  theme,
  ownerState
}) => _extends({
  color: (theme.vars || theme).palette.text.secondary
}, theme.typography.caption, {
  textAlign: 'left',
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses$1.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled
  },
  [`&.${formHelperTextClasses$1.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
}, ownerState.size === 'small' && {
  marginTop: 4
}, ownerState.contained && {
  marginLeft: 14,
  marginRight: 14
}));
const FormHelperText = /*#__PURE__*/React__namespace.forwardRef(function FormHelperText(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiFormHelperText'
  });
  const {
      children,
      className,
      component = 'p'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$a);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ['variant', 'size', 'disabled', 'error', 'filled', 'focused', 'required']
  });
  const ownerState = _extends({}, props, {
    component,
    contained: fcs.variant === 'filled' || fcs.variant === 'outlined',
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$g(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(FormHelperTextRoot, _extends({
    as: component,
    ownerState: ownerState,
    className: clsx(classes.root, className),
    ref: ref
  }, other, {
    children: children === ' ' ? // notranslate needed while Google Translate will not fix zero-width space issue
    _span$1 || (_span$1 = /*#__PURE__*/jsxRuntime.jsx("span", {
      className: "notranslate",
      children: "\u200B"
    })) : children
  }));
});
process.env.NODE_ENV !== "production" ? FormHelperText.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   *
   * If `' '` is provided, the component reserves one line height for displaying a future message.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * If `true`, the helper text should be displayed in a disabled state.
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, helper text should be displayed in an error state.
   */
  error: propTypesExports.bool,
  /**
   * If `true`, the helper text should use filled classes key.
   */
  filled: propTypesExports.bool,
  /**
   * If `true`, the helper text should use focused classes key.
   */
  focused: propTypesExports.bool,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: propTypesExports.oneOf(['dense']),
  /**
   * If `true`, the helper text should use required classes key.
   */
  required: propTypesExports.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The variant to use.
   */
  variant: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['filled', 'outlined', 'standard']), propTypesExports.string])
} : void 0;
var FormHelperText$1 = FormHelperText;

/**
 * @ignore - internal component.
 */
const ListContext = /*#__PURE__*/React__namespace.createContext({});
if (process.env.NODE_ENV !== 'production') {
  ListContext.displayName = 'ListContext';
}
var ListContext$1 = ListContext;

function getListUtilityClass(slot) {
  return generateUtilityClass('MuiList', slot);
}
generateUtilityClasses('MuiList', ['root', 'padding', 'dense', 'subheader']);

const _excluded$9 = ["children", "className", "component", "dense", "disablePadding", "subheader"];
const useUtilityClasses$f = ownerState => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ['root', !disablePadding && 'padding', dense && 'dense', subheader && 'subheader']
  };
  return composeClasses(slots, getListUtilityClass, classes);
};
const ListRoot = styled$1('ul', {
  name: 'MuiList',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, !ownerState.disablePadding && styles.padding, ownerState.dense && styles.dense, ownerState.subheader && styles.subheader];
  }
})(({
  ownerState
}) => _extends({
  listStyle: 'none',
  margin: 0,
  padding: 0,
  position: 'relative'
}, !ownerState.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.subheader && {
  paddingTop: 0
}));
const List = /*#__PURE__*/React__namespace.forwardRef(function List(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiList'
  });
  const {
      children,
      className,
      component = 'ul',
      dense = false,
      disablePadding = false,
      subheader
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$9);
  const context = React__namespace.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = _extends({}, props, {
    component,
    dense,
    disablePadding
  });
  const classes = useUtilityClasses$f(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(ListContext$1.Provider, {
    value: context,
    children: /*#__PURE__*/jsxRuntime.jsxs(ListRoot, _extends({
      as: component,
      className: clsx(classes.root, className),
      ref: ref,
      ownerState: ownerState
    }, other, {
      children: [subheader, children]
    }))
  });
});
process.env.NODE_ENV !== "production" ? List.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: propTypesExports.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: propTypesExports.bool,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: propTypesExports.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object])
} : void 0;
var List$1 = List;

const _excluded$8 = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === undefined) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === undefined) {
    // jsdom doesn't support innerText
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.indexOf(textCriteria.keys.join('')) === 0;
}
function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    // Prevent infinite loop.
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }

    // Same logic as useAutocomplete.js
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';
    if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      // Move to the next element.
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}

/**
 * A permanently displayed menu following https://www.w3.org/WAI/ARIA/apg/patterns/menubutton/.
 * It's exposed to help customization of the [`Menu`](/material-ui/api/menu/) component if you
 * use it separately you need to move focus into the component manually. Once
 * the focus is placed inside the component it is fully keyboard accessible.
 */
const MenuList = /*#__PURE__*/React__namespace.forwardRef(function MenuList(props, ref) {
  const {
      // private
      // eslint-disable-next-line react/prop-types
      actions,
      autoFocus = false,
      autoFocusItem = false,
      children,
      className,
      disabledItemsFocusable = false,
      disableListWrap = false,
      onKeyDown,
      variant = 'selectedMenu'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$8);
  const listRef = React__namespace.useRef(null);
  const textCriteriaRef = React__namespace.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect$3(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  React__namespace.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, theme) => {
      // Let's ignore that piece of logic if users are already overriding the width
      // of the menu.
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
        listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown = event => {
    const list = listRef.current;
    const key = event.key;
    /**
     * @type {Element} - will always be defined since we are in a keydown handler
     * attached to an element. A keydown event is either dispatched to the activeElement
     * or document.body or document.documentElement. Only the first case will
     * trigger this specific handler.
     */
    const currentFocus = ownerDocument(list).activeElement;
    if (key === 'ArrowDown') {
      // Prevent scroll of the page
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === 'ArrowUp') {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key === 'Home') {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === 'End') {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        // Reset
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef$2(listRef, ref);

  /**
   * the index of the item should receive focus
   * in a `variant="selectedMenu"` it's the first `selected` item
   * otherwise it's the very first item.
   */
  let activeItemIndex = -1;
  // since we inject focus related props into children we have to do a lookahead
  // to check if there is a `selected` item. We're looking for the last `selected`
  // item and use the first valid item as a fallback
  React__namespace.Children.forEach(children, (child, index) => {
    if (! /*#__PURE__*/React__namespace.isValidElement(child)) {
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (reactIsExports$1.isFragment(child)) {
        console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
      }
    }
    if (!child.props.disabled) {
      if (variant === 'selectedMenu' && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  const items = React__namespace.Children.map(children, (child, index) => {
    if (index === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {
        newChildProps.tabIndex = 0;
      }
      return /*#__PURE__*/React__namespace.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /*#__PURE__*/jsxRuntime.jsx(List$1, _extends({
    role: "menu",
    ref: handleRef,
    className: className,
    onKeyDown: handleKeyDown,
    tabIndex: autoFocus ? 0 : -1
  }, other, {
    children: items
  }));
});
process.env.NODE_ENV !== "production" ? MenuList.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   * @default false
   */
  autoFocus: propTypesExports.bool,
  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   * @default false
   */
  autoFocusItem: propTypesExports.bool,
  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: propTypesExports.node,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: propTypesExports.bool,
  /**
   * If `true`, the menu items will not wrap focus.
   * @default false
   */
  disableListWrap: propTypesExports.bool,
  /**
   * @ignore
   */
  onKeyDown: propTypesExports.func,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   * @default 'selectedMenu'
   */
  variant: propTypesExports.oneOf(['menu', 'selectedMenu'])
} : void 0;
var MenuList$1 = MenuList;

function getPopoverUtilityClass(slot) {
  return generateUtilityClass('MuiPopover', slot);
}
generateUtilityClasses('MuiPopover', ['root', 'paper']);

const _excluded$7 = ["onEntering"],
  _excluded2$1 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"];
function getOffsetTop(rect, vertical) {
  let offset = 0;
  if (typeof vertical === 'number') {
    offset = vertical;
  } else if (vertical === 'center') {
    offset = rect.height / 2;
  } else if (vertical === 'bottom') {
    offset = rect.height;
  }
  return offset;
}
function getOffsetLeft(rect, horizontal) {
  let offset = 0;
  if (typeof horizontal === 'number') {
    offset = horizontal;
  } else if (horizontal === 'center') {
    offset = rect.width / 2;
  } else if (horizontal === 'right') {
    offset = rect.width;
  }
  return offset;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map(n => typeof n === 'number' ? `${n}px` : n).join(' ');
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
}
const useUtilityClasses$e = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    paper: ['paper']
  };
  return composeClasses(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled$1(Modal$1, {
  name: 'MuiPopover',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({});
const PopoverPaper = styled$1(Paper$1, {
  name: 'MuiPopover',
  slot: 'Paper',
  overridesResolver: (props, styles) => styles.paper
})({
  position: 'absolute',
  overflowY: 'auto',
  overflowX: 'hidden',
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: 'calc(100% - 32px)',
  maxHeight: 'calc(100% - 32px)',
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /*#__PURE__*/React__namespace.forwardRef(function Popover(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPopover'
  });
  const {
      action,
      anchorEl,
      anchorOrigin = {
        vertical: 'top',
        horizontal: 'left'
      },
      anchorPosition,
      anchorReference = 'anchorEl',
      children,
      className,
      container: containerProp,
      elevation = 8,
      marginThreshold = 16,
      open,
      PaperProps = {},
      transformOrigin = {
        vertical: 'top',
        horizontal: 'left'
      },
      TransitionComponent = Grow$1,
      transitionDuration: transitionDurationProp = 'auto',
      TransitionProps: {
        onEntering
      } = {}
    } = props,
    TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$7),
    other = _objectWithoutPropertiesLoose(props, _excluded2$1);
  const paperRef = React__namespace.useRef();
  const handlePaperRef = useForkRef$2(paperRef, PaperProps.ref);
  const ownerState = _extends({}, props, {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    PaperProps,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  });
  const classes = useUtilityClasses$e(ownerState);

  // Returns the top/left offset of the position
  // to attach to on the anchor element (or body if none is provided)
  const getAnchorOffset = React__namespace.useCallback(() => {
    if (anchorReference === 'anchorPosition') {
      if (process.env.NODE_ENV !== 'production') {
        if (!anchorPosition) {
          console.error('MUI: You need to provide a `anchorPosition` prop when using ' + '<Popover anchorReference="anchorPosition" />.');
        }
      }
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);

    // If an anchor element wasn't provided, just use the parent body element of this Popover
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    if (process.env.NODE_ENV !== 'production') {
      const box = anchorElement.getBoundingClientRect();
      if (process.env.NODE_ENV !== 'test' && box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
        console.warn(['MUI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
      }
    }
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);

  // Returns the base transform origin using the element
  const getTransformOrigin = React__namespace.useCallback(elemRect => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = React__namespace.useCallback(element => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };

    // Get the transform origin point on the element itself
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === 'none') {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }

    // Get the offset of the anchoring element
    const anchorOffset = getAnchorOffset();

    // Calculate element positioning
    let top = anchorOffset.top - elemTransformOrigin.vertical;
    let left = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom = top + elemRect.height;
    const right = left + elemRect.width;

    // Use the parent window of the anchorEl if provided
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));

    // Window thresholds taking required margin into account
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;

    // Check if the vertical axis needs shifting
    if (top < marginThreshold) {
      const diff = top - marginThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (bottom > heightThreshold) {
      const diff = bottom - heightThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (elemRect.height > heightThreshold && elemRect.height && heightThreshold) {
        console.error(['MUI: The popover component is too tall.', `Some part of it can not be seen on the screen (${elemRect.height - heightThreshold}px).`, 'Please consider adding a `max-height` to improve the user-experience.'].join('\n'));
      }
    }

    // Check if the horizontal axis needs shifting
    if (left < marginThreshold) {
      const diff = left - marginThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right > widthThreshold) {
      const diff = right - widthThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top)}px`,
      left: `${Math.round(left)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = React__namespace.useState(open);
  const setPositioningStyles = React__namespace.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  const handleEntering = (element, isAppearing) => {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  React__namespace.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  React__namespace.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  React__namespace.useEffect(() => {
    if (!open) {
      return undefined;
    }
    const handleResize = debounce$1(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(anchorEl);
    containerWindow.addEventListener('resize', handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener('resize', handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  if (transitionDurationProp === 'auto' && !TransitionComponent.muiSupportAuto) {
    transitionDuration = undefined;
  }

  // If the container prop is provided, use that
  // If the anchorEl prop is provided, use its parent body element as the container
  // If neither are provided let the Modal take care of choosing the container
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : undefined);
  return /*#__PURE__*/jsxRuntime.jsx(PopoverRoot, _extends({
    BackdropProps: {
      invisible: true
    },
    className: clsx(classes.root, className),
    container: container,
    open: open,
    ref: ref,
    ownerState: ownerState
  }, other, {
    children: /*#__PURE__*/jsxRuntime.jsx(TransitionComponent, _extends({
      appear: true,
      in: open,
      onEntering: handleEntering,
      onExited: handleExited,
      timeout: transitionDuration
    }, TransitionProps, {
      children: /*#__PURE__*/jsxRuntime.jsx(PopoverPaper, _extends({
        elevation: elevation
      }, PaperProps, {
        ref: handlePaperRef,
        className: clsx(classes.paper, PaperProps.className)
      }, isPositioned ? undefined : {
        style: _extends({}, PaperProps.style, {
          opacity: 0
        })
      }, {
        ownerState: ownerState,
        children: children
      }))
    }))
  }));
});
process.env.NODE_ENV !== "production" ? Popover.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */
  action: refType$1,
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the popover.
   */
  anchorEl: chainPropTypes(propTypesExports.oneOfType([HTMLElementType, propTypesExports.func]), props => {
    if (props.open && (!props.anchorReference || props.anchorReference === 'anchorEl')) {
      const resolvedAnchorEl = resolveAnchorEl(props.anchorEl);
      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        const box = resolvedAnchorEl.getBoundingClientRect();
        if (process.env.NODE_ENV !== 'test' && box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          return new Error(['MUI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      } else {
        return new Error(['MUI: The `anchorEl` prop provided to the component is invalid.', `It should be an Element instance but it's \`${resolvedAnchorEl}\` instead.`].join('\n'));
      }
    }
    return null;
  }),
  /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  anchorOrigin: propTypesExports.shape({
    horizontal: propTypesExports.oneOfType([propTypesExports.oneOf(['center', 'left', 'right']), propTypesExports.number]).isRequired,
    vertical: propTypesExports.oneOfType([propTypesExports.oneOf(['bottom', 'center', 'top']), propTypesExports.number]).isRequired
  }),
  /**
   * This is the position that may be used to set the position of the popover.
   * The coordinates are relative to the application's client area.
   */
  anchorPosition: propTypesExports.shape({
    left: propTypesExports.number.isRequired,
    top: propTypesExports.number.isRequired
  }),
  /**
   * This determines which anchor prop to refer to when setting
   * the position of the popover.
   * @default 'anchorEl'
   */
  anchorReference: propTypesExports.oneOf(['anchorEl', 'anchorPosition', 'none']),
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * An HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, propTypesExports.func]),
  /**
   * The elevation of the popover.
   * @default 8
   */
  elevation: integerPropType,
  /**
   * Specifies how close to the edge of the window the popover can appear.
   * @default 16
   */
  marginThreshold: propTypesExports.number,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   */
  onClose: propTypesExports.func,
  /**
   * If `true`, the component is shown.
   */
  open: propTypesExports.bool.isRequired,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   * @default {}
   */
  PaperProps: propTypesExports /* @typescript-to-proptypes-ignore */.shape({
    component: elementTypeAcceptingRef$1
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  transformOrigin: propTypesExports.shape({
    horizontal: propTypesExports.oneOfType([propTypesExports.oneOf(['center', 'left', 'right']), propTypesExports.number]).isRequired,
    vertical: propTypesExports.oneOfType([propTypesExports.oneOf(['bottom', 'center', 'top']), propTypesExports.number]).isRequired
  }),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Grow
   */
  TransitionComponent: propTypesExports.elementType,
  /**
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  transitionDuration: propTypesExports.oneOfType([propTypesExports.oneOf(['auto']), propTypesExports.number, propTypesExports.shape({
    appear: propTypesExports.number,
    enter: propTypesExports.number,
    exit: propTypesExports.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: propTypesExports.object
} : void 0;
var Popover$1 = Popover;

function getMenuUtilityClass(slot) {
  return generateUtilityClass('MuiMenu', slot);
}
generateUtilityClasses('MuiMenu', ['root', 'paper', 'list']);

const _excluded$6 = ["onEntering"],
  _excluded2 = ["autoFocus", "children", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"];
const RTL_ORIGIN = {
  vertical: 'top',
  horizontal: 'right'
};
const LTR_ORIGIN = {
  vertical: 'top',
  horizontal: 'left'
};
const useUtilityClasses$d = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root'],
    paper: ['paper'],
    list: ['list']
  };
  return composeClasses(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled$1(Popover$1, {
  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
  name: 'MuiMenu',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({});
const MenuPaper = styled$1(Paper$1, {
  name: 'MuiMenu',
  slot: 'Paper',
  overridesResolver: (props, styles) => styles.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tapable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: 'calc(100% - 96px)',
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: 'touch'
});
const MenuMenuList = styled$1(MenuList$1, {
  name: 'MuiMenu',
  slot: 'List',
  overridesResolver: (props, styles) => styles.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /*#__PURE__*/React__namespace.forwardRef(function Menu(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiMenu'
  });
  const {
      autoFocus = true,
      children,
      disableAutoFocusItem = false,
      MenuListProps = {},
      onClose,
      open,
      PaperProps = {},
      PopoverClasses,
      transitionDuration = 'auto',
      TransitionProps: {
        onEntering
      } = {},
      variant = 'selectedMenu'
    } = props,
    TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$6),
    other = _objectWithoutPropertiesLoose(props, _excluded2);
  const theme = useTheme();
  const isRtl = theme.direction === 'rtl';
  const ownerState = _extends({}, props, {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  });
  const classes = useUtilityClasses$d(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = React__namespace.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = event => {
    if (event.key === 'Tab') {
      event.preventDefault();
      if (onClose) {
        onClose(event, 'tabKeyDown');
      }
    }
  };

  /**
   * the index of the item should receive focus
   * in a `variant="selectedMenu"` it's the first `selected` item
   * otherwise it's the very first item.
   */
  let activeItemIndex = -1;
  // since we inject focus related props into children we have to do a lookahead
  // to check if there is a `selected` item. We're looking for the last `selected`
  // item and use the first valid item as a fallback
  React__namespace.Children.map(children, (child, index) => {
    if (! /*#__PURE__*/React__namespace.isValidElement(child)) {
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (reactIsExports$1.isFragment(child)) {
        console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
      }
    }
    if (!child.props.disabled) {
      if (variant === 'selectedMenu' && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  return /*#__PURE__*/jsxRuntime.jsx(MenuRoot, _extends({
    onClose: onClose,
    anchorOrigin: {
      vertical: 'bottom',
      horizontal: isRtl ? 'right' : 'left'
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    PaperProps: _extends({
      component: MenuPaper
    }, PaperProps, {
      classes: _extends({}, PaperProps.classes, {
        root: classes.paper
      })
    }),
    className: classes.root,
    open: open,
    ref: ref,
    transitionDuration: transitionDuration,
    TransitionProps: _extends({
      onEntering: handleEntering
    }, TransitionProps),
    ownerState: ownerState
  }, other, {
    classes: PopoverClasses,
    children: /*#__PURE__*/jsxRuntime.jsx(MenuMenuList, _extends({
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem: autoFocusItem,
      variant: variant
    }, MenuListProps, {
      className: clsx(classes.list, MenuListProps.className),
      children: children
    }))
  }));
});
process.env.NODE_ENV !== "production" ? Menu.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the menu.
   */
  anchorEl: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([HTMLElementType, propTypesExports.func]),
  /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   * @default true
   */
  autoFocus: propTypesExports.bool,
  /**
   * Menu contents, normally `MenuItem`s.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   * @default false
   */
  disableAutoFocusItem: propTypesExports.bool,
  /**
   * Props applied to the [`MenuList`](/material-ui/api/menu-list/) element.
   * @default {}
   */
  MenuListProps: propTypesExports.object,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */
  onClose: propTypesExports.func,
  /**
   * If `true`, the component is shown.
   */
  open: propTypesExports.bool.isRequired,
  /**
   * @ignore
   */
  PaperProps: propTypesExports.object,
  /**
   * `classes` prop applied to the [`Popover`](/material-ui/api/popover/) element.
   */
  PopoverClasses: propTypesExports.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The length of the transition in `ms`, or 'auto'
   * @default 'auto'
   */
  transitionDuration: propTypesExports.oneOfType([propTypesExports.oneOf(['auto']), propTypesExports.number, propTypesExports.shape({
    appear: propTypesExports.number,
    enter: propTypesExports.number,
    exit: propTypesExports.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: propTypesExports.object,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus.
   * @default 'selectedMenu'
   */
  variant: propTypesExports.oneOf(['menu', 'selectedMenu'])
} : void 0;
var Menu$1 = Menu;

function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass('MuiNativeSelect', slot);
}
const nativeSelectClasses = generateUtilityClasses('MuiNativeSelect', ['root', 'select', 'multiple', 'filled', 'outlined', 'standard', 'disabled', 'icon', 'iconOpen', 'iconFilled', 'iconOutlined', 'iconStandard', 'nativeInput']);
var nativeSelectClasses$1 = nativeSelectClasses;

const _excluded$5 = ["className", "disabled", "IconComponent", "inputRef", "variant"];
const useUtilityClasses$c = ownerState => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open
  } = ownerState;
  const slots = {
    select: ['select', variant, disabled && 'disabled', multiple && 'multiple'],
    icon: ['icon', `icon${capitalize(variant)}`, open && 'iconOpen', disabled && 'disabled']
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes);
};
const nativeSelectSelectStyles = ({
  ownerState,
  theme
}) => _extends({
  MozAppearance: 'none',
  // Reset
  WebkitAppearance: 'none',
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: 'none',
  borderRadius: 0,
  // Reset
  cursor: 'pointer',
  '&:focus': _extends({}, theme.vars ? {
    backgroundColor: `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.05)`
  } : {
    backgroundColor: theme.palette.mode === 'light' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
  }, {
    borderRadius: 0 // Reset Chrome style
  }),

  // Remove IE11 arrow
  '&::-ms-expand': {
    display: 'none'
  },
  [`&.${nativeSelectClasses$1.disabled}`]: {
    cursor: 'default'
  },
  '&[multiple]': {
    height: 'auto'
  },
  '&:not([multiple]) option, &:not([multiple]) optgroup': {
    backgroundColor: (theme.vars || theme).palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  '&&&': {
    paddingRight: 24,
    minWidth: 16 // So it doesn't collapse.
  }
}, ownerState.variant === 'filled' && {
  '&&&': {
    paddingRight: 32
  }
}, ownerState.variant === 'outlined' && {
  borderRadius: (theme.vars || theme).shape.borderRadius,
  '&:focus': {
    borderRadius: (theme.vars || theme).shape.borderRadius // Reset the reset for Chrome style
  },

  '&&&': {
    paddingRight: 32
  }
});
const NativeSelectSelect = styled$1('select', {
  name: 'MuiNativeSelect',
  slot: 'Select',
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.select, styles[ownerState.variant], {
      [`&.${nativeSelectClasses$1.multiple}`]: styles.multiple
    }];
  }
})(nativeSelectSelectStyles);
const nativeSelectIconStyles = ({
  ownerState,
  theme
}) => _extends({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: 'absolute',
  right: 0,
  top: 'calc(50% - .5em)',
  // Center vertically, height is 1em
  pointerEvents: 'none',
  // Don't block pointer events on the select under the icon.
  color: (theme.vars || theme).palette.action.active,
  [`&.${nativeSelectClasses$1.disabled}`]: {
    color: (theme.vars || theme).palette.action.disabled
  }
}, ownerState.open && {
  transform: 'rotate(180deg)'
}, ownerState.variant === 'filled' && {
  right: 7
}, ownerState.variant === 'outlined' && {
  right: 7
});
const NativeSelectIcon = styled$1('svg', {
  name: 'MuiNativeSelect',
  slot: 'Icon',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.icon, ownerState.variant && styles[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles.iconOpen];
  }
})(nativeSelectIconStyles);

/**
 * @ignore - internal component.
 */
const NativeSelectInput = /*#__PURE__*/React__namespace.forwardRef(function NativeSelectInput(props, ref) {
  const {
      className,
      disabled,
      IconComponent,
      inputRef,
      variant = 'standard'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$5);
  const ownerState = _extends({}, props, {
    disabled,
    variant
  });
  const classes = useUtilityClasses$c(ownerState);
  return /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(NativeSelectSelect, _extends({
      ownerState: ownerState,
      className: clsx(classes.select, className),
      disabled: disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /*#__PURE__*/jsxRuntime.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState: ownerState,
      className: classes.icon
    })]
  });
});
process.env.NODE_ENV !== "production" ? NativeSelectInput.propTypes = {
  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: propTypesExports.object,
  /**
   * The CSS class name of the select element.
   */
  className: propTypesExports.string,
  /**
   * If `true`, the select is disabled.
   */
  disabled: propTypesExports.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: propTypesExports.elementType.isRequired,
  /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */
  inputRef: refType$1,
  /**
   * @ignore
   */
  multiple: propTypesExports.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: propTypesExports.string,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: propTypesExports.func,
  /**
   * The input value.
   */
  value: propTypesExports.any,
  /**
   * The variant to use.
   */
  variant: propTypesExports.oneOf(['standard', 'outlined', 'filled'])
} : void 0;
var NativeSelectInput$1 = NativeSelectInput;

function getSelectUtilityClasses(slot) {
  return generateUtilityClass('MuiSelect', slot);
}
const selectClasses = generateUtilityClasses('MuiSelect', ['select', 'multiple', 'filled', 'outlined', 'standard', 'disabled', 'focused', 'icon', 'iconOpen', 'iconFilled', 'iconOutlined', 'iconStandard', 'nativeInput']);
var selectClasses$1 = selectClasses;

var _span;
const _excluded$4 = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
const SelectSelect = styled$1('div', {
  name: 'MuiSelect',
  slot: 'Select',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [
    // Win specificity over the input base
    {
      [`&.${selectClasses$1.select}`]: styles.select
    }, {
      [`&.${selectClasses$1.select}`]: styles[ownerState.variant]
    }, {
      [`&.${selectClasses$1.multiple}`]: styles.multiple
    }];
  }
})(nativeSelectSelectStyles, {
  // Win specificity over the input base
  [`&.${selectClasses$1.select}`]: {
    height: 'auto',
    // Resets for multiple select with chips
    minHeight: '1.4375em',
    // Required for select\text-field height consistency
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    overflow: 'hidden'
  }
});
const SelectIcon = styled$1('svg', {
  name: 'MuiSelect',
  slot: 'Icon',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.icon, ownerState.variant && styles[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles.iconOpen];
  }
})(nativeSelectIconStyles);
const SelectNativeInput = styled$1('input', {
  shouldForwardProp: prop => slotShouldForwardProp(prop) && prop !== 'classes',
  name: 'MuiSelect',
  slot: 'NativeInput',
  overridesResolver: (props, styles) => styles.nativeInput
})({
  bottom: 0,
  left: 0,
  position: 'absolute',
  opacity: 0,
  pointerEvents: 'none',
  width: '100%',
  boxSizing: 'border-box'
});
function areEqualValues(a, b) {
  if (typeof b === 'object' && b !== null) {
    return a === b;
  }

  // The value could be a number, the DOM will stringify it anyway.
  return String(a) === String(b);
}
function isEmpty(display) {
  return display == null || typeof display === 'string' && !display.trim();
}
const useUtilityClasses$b = ownerState => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open
  } = ownerState;
  const slots = {
    select: ['select', variant, disabled && 'disabled', multiple && 'multiple'],
    icon: ['icon', `icon${capitalize(variant)}`, open && 'iconOpen', disabled && 'disabled'],
    nativeInput: ['nativeInput']
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
};

/**
 * @ignore - internal component.
 */
const SelectInput = /*#__PURE__*/React__namespace.forwardRef(function SelectInput(props, ref) {
  const {
      'aria-describedby': ariaDescribedby,
      'aria-label': ariaLabel,
      autoFocus,
      autoWidth,
      children,
      className,
      defaultOpen,
      defaultValue,
      disabled,
      displayEmpty,
      IconComponent,
      inputRef: inputRefProp,
      labelId,
      MenuProps = {},
      multiple,
      name,
      onBlur,
      onChange,
      onClose,
      onFocus,
      onOpen,
      open: openProp,
      readOnly,
      renderValue,
      SelectDisplayProps = {},
      tabIndex: tabIndexProp,
      value: valueProp,
      variant = 'standard'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$4);
  const [value, setValueState] = useControlled$2({
    controlled: valueProp,
    default: defaultValue,
    name: 'Select'
  });
  const [openState, setOpenState] = useControlled$2({
    controlled: openProp,
    default: defaultOpen,
    name: 'Select'
  });
  const inputRef = React__namespace.useRef(null);
  const displayRef = React__namespace.useRef(null);
  const [displayNode, setDisplayNode] = React__namespace.useState(null);
  const {
    current: isOpenControlled
  } = React__namespace.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = React__namespace.useState();
  const handleRef = useForkRef$2(ref, inputRefProp);
  const handleDisplayRef = React__namespace.useCallback(node => {
    displayRef.current = node;
    if (node) {
      setDisplayNode(node);
    }
  }, []);
  const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
  React__namespace.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);

  // Resize menu on `defaultOpen` automatic toggle.
  React__namespace.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      displayRef.current.focus();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [displayNode, autoWidth]);
  // `isOpenControlled` is ignored because the component should never switch between controlled and uncontrolled modes.
  // `defaultOpen` and `openState` are ignored to avoid unnecessary callbacks.
  React__namespace.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  React__namespace.useEffect(() => {
    if (!labelId) {
      return undefined;
    }
    const label = ownerDocument(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };
      label.addEventListener('click', handler);
      return () => {
        label.removeEventListener('click', handler);
      };
    }
    return undefined;
  }, [labelId]);
  const update = (open, event) => {
    if (open) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      setOpenState(open);
    }
  };
  const handleMouseDown = event => {
    // Ignore everything but left-click
    if (event.button !== 0) {
      return;
    }
    // Hijack the default focus behavior.
    event.preventDefault();
    displayRef.current.focus();
    update(true, event);
  };
  const handleClose = event => {
    update(false, event);
  };
  const childrenArray = React__namespace.Children.toArray(children);

  // Support autofill.
  const handleChange = event => {
    const index = childrenArray.map(child => child.props.value).indexOf(event.target.value);
    if (index === -1) {
      return;
    }
    const child = childrenArray[index];
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  };
  const handleItemClick = child => event => {
    let newValue;

    // We use the tabindex attribute to signal the available options.
    if (!event.currentTarget.hasAttribute('tabindex')) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        // Redefine target to allow name and value to be read.
        // This allows seamless integration with the most popular form libraries.
        // https://github.com/mui/material-ui/issues/13485#issuecomment-676048492
        // Clone the event to not override `target` of the original event.
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, 'target', {
          writable: true,
          value: {
            value: newValue,
            name
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update(false, event);
    }
  };
  const handleKeyDown = event => {
    if (!readOnly) {
      const validKeys = [' ', 'ArrowUp', 'ArrowDown',
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/example-index/combobox/combobox-select-only.html
      'Enter'];
      if (validKeys.indexOf(event.key) !== -1) {
        event.preventDefault();
        update(true, event);
      }
    }
  };
  const open = displayNode !== null && openState;
  const handleBlur = event => {
    // if open event.stopImmediatePropagation
    if (!open && onBlur) {
      // Preact support, target is read only property on a native event.
      Object.defineProperty(event, 'target', {
        writable: true,
        value: {
          value,
          name
        }
      });
      onBlur(event);
    }
  };
  delete other['aria-invalid'];
  let display;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  let foundMatch = false;

  // No need to display any value if the field is empty.
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child, index, arr) => {
    var _arr$, _arr$$props, _arr$2, _arr$2$props;
    if (! /*#__PURE__*/React__namespace.isValidElement(child)) {
      return null;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (reactIsExports$1.isFragment(child)) {
        console.error(["MUI: The Select component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
      }
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The \`value\` prop must be an array when using the \`Select\` component with \`multiple\`.` : formatMuiErrorMessage(2));
      }
      selected = value.some(v => areEqualValues(v, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    if (selected) {
      foundMatch = true;
    }
    if (child.props.value === undefined) {
      return /*#__PURE__*/React__namespace.cloneElement(child, {
        'aria-readonly': true,
        role: 'option'
      });
    }
    const isFirstSelectableElement = () => {
      if (value) {
        return selected;
      }
      const firstSelectableElement = arr.find(item => {
        var _item$props;
        return (item == null ? void 0 : (_item$props = item.props) == null ? void 0 : _item$props.value) !== undefined && item.props.disabled !== true;
      });
      if (child === firstSelectableElement) {
        return true;
      }
      return selected;
    };
    return /*#__PURE__*/React__namespace.cloneElement(child, {
      'aria-selected': selected ? 'true' : 'false',
      onClick: handleItemClick(child),
      onKeyUp: event => {
        if (event.key === ' ') {
          // otherwise our MenuItems dispatches a click event
          // it's not behavior of the native <option> and causes
          // the select to close immediately since we open on space keydown
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: 'option',
      selected: ((_arr$ = arr[0]) == null ? void 0 : (_arr$$props = _arr$.props) == null ? void 0 : _arr$$props.value) === undefined || ((_arr$2 = arr[0]) == null ? void 0 : (_arr$2$props = _arr$2.props) == null ? void 0 : _arr$2$props.disabled) === true ? isFirstSelectableElement() : selected,
      value: undefined,
      // The value is most likely not a valid HTML attribute.
      'data-value': child.props.value // Instead, we provide it as a data attribute.
    });
  });

  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__namespace.useEffect(() => {
      if (!foundMatch && !multiple && value !== '') {
        const values = childrenArray.map(child => child.props.value);
        console.warn([`MUI: You have provided an out-of-range value \`${value}\` for the select ${name ? `(name="${name}") ` : ''}component.`, "Consider providing a value that matches one of the available options or ''.", `The available values are ${values.filter(x => x != null).map(x => `\`${x}\``).join(', ') || '""'}.`].join('\n'));
      }
    }, [foundMatch, childrenArray, multiple, name, value]);
  }
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display = null;
      } else {
        display = displayMultiple.reduce((output, child, index) => {
          output.push(child);
          if (index < displayMultiple.length - 1) {
            output.push(', ');
          }
          return output;
        }, []);
      }
    } else {
      display = displaySingle;
    }
  }

  // Avoid performing a layout computation in the render method.
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = anchorElement.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== 'undefined') {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : undefined);
  const ownerState = _extends({}, props, {
    variant,
    value,
    open
  });
  const classes = useUtilityClasses$b(ownerState);
  return /*#__PURE__*/jsxRuntime.jsxs(React__namespace.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(SelectSelect, _extends({
      ref: handleDisplayRef,
      tabIndex: tabIndex,
      role: "button",
      "aria-disabled": disabled ? 'true' : undefined,
      "aria-expanded": open ? 'true' : 'false',
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(' ') || undefined,
      "aria-describedby": ariaDescribedby,
      onKeyDown: handleKeyDown,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus: onFocus
    }, SelectDisplayProps, {
      ownerState: ownerState,
      className: clsx(SelectDisplayProps.className, classes.select, className)
      // The id is required for proper a11y
      ,
      id: buttonId,
      children: isEmpty(display) ? // notranslate needed while Google Translate will not fix zero-width space issue
      _span || (_span = /*#__PURE__*/jsxRuntime.jsx("span", {
        className: "notranslate",
        children: "\u200B"
      })) : display
    })), /*#__PURE__*/jsxRuntime.jsx(SelectNativeInput, _extends({
      value: Array.isArray(value) ? value.join(',') : value,
      name: name,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled: disabled,
      className: classes.nativeInput,
      autoFocus: autoFocus,
      ownerState: ownerState
    }, other)), /*#__PURE__*/jsxRuntime.jsx(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState: ownerState
    }), /*#__PURE__*/jsxRuntime.jsx(Menu$1, _extends({
      id: `menu-${name || ''}`,
      anchorEl: anchorElement,
      open: open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: 'bottom',
        horizontal: 'center'
      },
      transformOrigin: {
        vertical: 'top',
        horizontal: 'center'
      }
    }, MenuProps, {
      MenuListProps: _extends({
        'aria-labelledby': labelId,
        role: 'listbox',
        disableListWrap: true
      }, MenuProps.MenuListProps),
      PaperProps: _extends({}, MenuProps.PaperProps, {
        style: _extends({
          minWidth: menuMinWidth
        }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
      }),
      children: items
    }))]
  });
});
process.env.NODE_ENV !== "production" ? SelectInput.propTypes = {
  /**
   * @ignore
   */
  'aria-describedby': propTypesExports.string,
  /**
   * @ignore
   */
  'aria-label': propTypesExports.string,
  /**
   * @ignore
   */
  autoFocus: propTypesExports.bool,
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: propTypesExports.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: propTypesExports.object,
  /**
   * The CSS class name of the select element.
   */
  className: propTypesExports.string,
  /**
   * If `true`, the component is toggled on mount. Use when the component open state is not controlled.
   * You can only use it when the `native` prop is `false` (default).
   */
  defaultOpen: propTypesExports.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypesExports.any,
  /**
   * If `true`, the select is disabled.
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the selected item is displayed even if its value is empty.
   */
  displayEmpty: propTypesExports.bool,
  /**
   * The icon that displays the arrow.
   */
  IconComponent: propTypesExports.elementType.isRequired,
  /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */
  inputRef: refType$1,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: propTypesExports.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: propTypesExports.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: propTypesExports.bool,
  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: propTypesExports.string,
  /**
   * @ignore
   */
  onBlur: propTypesExports.func,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */
  onChange: propTypesExports.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: propTypesExports.func,
  /**
   * @ignore
   */
  onFocus: propTypesExports.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: propTypesExports.func,
  /**
   * If `true`, the component is shown.
   */
  open: propTypesExports.bool,
  /**
   * @ignore
   */
  readOnly: propTypesExports.bool,
  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: propTypesExports.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: propTypesExports.object,
  /**
   * @ignore
   */
  tabIndex: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * @ignore
   */
  type: propTypesExports.any,
  /**
   * The input value.
   */
  value: propTypesExports.any,
  /**
   * The variant to use.
   */
  variant: propTypesExports.oneOf(['standard', 'outlined', 'filled'])
} : void 0;
var SelectInput$1 = SelectInput;

var ArrowDropDownIcon = createSvgIcon( /*#__PURE__*/jsxRuntime.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), 'ArrowDropDown');

var _StyledInput, _StyledFilledInput;
const _excluded$3 = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"];
const useUtilityClasses$a = ownerState => {
  const {
    classes
  } = ownerState;
  return classes;
};
const styledRootConfig = {
  name: 'MuiSelect',
  overridesResolver: (props, styles) => styles.root,
  shouldForwardProp: prop => rootShouldForwardProp(prop) && prop !== 'variant',
  slot: 'Root'
};
const StyledInput = styled$1(Input$1, styledRootConfig)('');
const StyledOutlinedInput = styled$1(OutlinedInput$1, styledRootConfig)('');
const StyledFilledInput = styled$1(FilledInput$1, styledRootConfig)('');
const Select = /*#__PURE__*/React__namespace.forwardRef(function Select(inProps, ref) {
  const props = useThemeProps({
    name: 'MuiSelect',
    props: inProps
  });
  const {
      autoWidth = false,
      children,
      classes: classesProp = {},
      className,
      defaultOpen = false,
      displayEmpty = false,
      IconComponent = ArrowDropDownIcon,
      id,
      input,
      inputProps,
      label,
      labelId,
      MenuProps,
      multiple = false,
      native = false,
      onClose,
      onOpen,
      open,
      renderValue,
      SelectDisplayProps,
      variant: variantProp = 'outlined'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$3);
  const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ['variant']
  });
  const variant = fcs.variant || variantProp;
  const InputComponent = input || {
    standard: _StyledInput || (_StyledInput = /*#__PURE__*/jsxRuntime.jsx(StyledInput, {})),
    outlined: /*#__PURE__*/jsxRuntime.jsx(StyledOutlinedInput, {
      label: label
    }),
    filled: _StyledFilledInput || (_StyledFilledInput = /*#__PURE__*/jsxRuntime.jsx(StyledFilledInput, {}))
  }[variant];
  const ownerState = _extends({}, props, {
    variant,
    classes: classesProp
  });
  const classes = useUtilityClasses$a(ownerState);
  const inputComponentRef = useForkRef$2(ref, InputComponent.ref);
  return /*#__PURE__*/jsxRuntime.jsx(React__namespace.Fragment, {
    children: /*#__PURE__*/React__namespace.cloneElement(InputComponent, _extends({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: _extends({
        children,
        IconComponent,
        variant,
        type: undefined,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple
      }, native ? {
        id
      } : {
        autoWidth,
        defaultOpen,
        displayEmpty,
        labelId,
        MenuProps,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps: _extends({
          id
        }, SelectDisplayProps)
      }, inputProps, {
        classes: inputProps ? deepmerge(classes, inputProps.classes) : classes
      }, input ? input.props.inputProps : {})
    }, multiple && native && variant === 'outlined' ? {
      notched: true
    } : {}, {
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className)
    }, !input && {
      variant
    }, other))
  });
});
process.env.NODE_ENV !== "production" ? Select.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   * @default false
   */
  autoWidth: propTypesExports.bool,
  /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * The `MenuItem` elements **must** be direct descendants when `native` is false.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   * @default {}
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * If `true`, the component is initially open. Use when the component open state is not controlled (i.e. the `open` prop is not defined).
   * You can only use it when the `native` prop is `false` (default).
   * @default false
   */
  defaultOpen: propTypesExports.bool,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypesExports.any,
  /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function can be passed to the `renderValue` prop which
   * returns the value to be displayed when no items are selected.
   *
   *  When using this prop, make sure the label doesn't overlap with the empty displayed value.
   * The label should either be hidden or forced to a shrunk state.
   * @default false
   */
  displayEmpty: propTypesExports.bool,
  /**
   * The icon that displays the arrow.
   * @default ArrowDropDownIcon
   */
  IconComponent: propTypesExports.elementType,
  /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */
  id: propTypesExports.string,
  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: propTypesExports.element,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */
  inputProps: propTypesExports.object,
  /**
   * See [OutlinedInput#label](/material-ui/api/outlined-input/#props)
   */
  label: propTypesExports.node,
  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: propTypesExports.string,
  /**
   * Props applied to the [`Menu`](/material-ui/api/menu/) element.
   */
  MenuProps: propTypesExports.object,
  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   * @default false
   */
  multiple: propTypesExports.bool,
  /**
   * If `true`, the component uses a native `select` element.
   * @default false
   */
  native: propTypesExports.bool,
  /**
   * Callback fired when a menu item is selected.
   *
   * @param {SelectChangeEvent<T>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event, not a change event, unless the change event is caused by browser autofill.
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */
  onChange: propTypesExports.func,
  /**
   * Callback fired when the component requests to be closed.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select collapes).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: propTypesExports.func,
  /**
   * Callback fired when the component requests to be opened.
   * Use it in either controlled (see the `open` prop), or uncontrolled mode (to detect when the Select expands).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: propTypesExports.func,
  /**
   * If `true`, the component is shown.
   * You can only use it when the `native` prop is `false` (default).
   */
  open: propTypesExports.bool,
  /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: propTypesExports.func,
  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: propTypesExports.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The `input` value. Providing an empty string will select no options.
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */
  value: propTypesExports.oneOfType([propTypesExports.oneOf(['']), propTypesExports.any]),
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: propTypesExports.oneOf(['filled', 'outlined', 'standard'])
} : void 0;
Select.muiName = 'Select';
var Select$1 = Select;

function getTextFieldUtilityClass(slot) {
  return generateUtilityClass('MuiTextField', slot);
}
generateUtilityClasses('MuiTextField', ['root']);

const _excluded$2 = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
const variantComponent = {
  standard: Input$1,
  filled: FilledInput$1,
  outlined: OutlinedInput$1
};
const useUtilityClasses$9 = ownerState => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ['root']
  };
  return composeClasses(slots, getTextFieldUtilityClass, classes);
};
const TextFieldRoot = styled$1(FormControl$1, {
  name: 'MuiTextField',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({});

/**
 * The `TextField` is a convenience wrapper for the most common cases (80%).
 * It cannot be all things to all people, otherwise the API would grow out of control.
 *
 * ## Advanced Configuration
 *
 * It's important to understand that the text field is a simple abstraction
 * on top of the following components:
 *
 * - [FormControl](/material-ui/api/form-control/)
 * - [InputLabel](/material-ui/api/input-label/)
 * - [FilledInput](/material-ui/api/filled-input/)
 * - [OutlinedInput](/material-ui/api/outlined-input/)
 * - [Input](/material-ui/api/input/)
 * - [FormHelperText](/material-ui/api/form-helper-text/)
 *
 * If you wish to alter the props applied to the `input` element, you can do so as follows:
 *
 * ```jsx
 * const inputProps = {
 *   step: 300,
 * };
 *
 * return <TextField id="time" type="time" inputProps={inputProps} />;
 * ```
 *
 * For advanced cases, please look at the source of TextField by clicking on the
 * "Edit this page" button above. Consider either:
 *
 * - using the upper case props for passing values directly to the components
 * - using the underlying components directly as shown in the demos
 */
const TextField = /*#__PURE__*/React__namespace.forwardRef(function TextField(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiTextField'
  });
  const {
      autoComplete,
      autoFocus = false,
      children,
      className,
      color = 'primary',
      defaultValue,
      disabled = false,
      error = false,
      FormHelperTextProps,
      fullWidth = false,
      helperText,
      id: idOverride,
      InputLabelProps,
      inputProps,
      InputProps,
      inputRef,
      label,
      maxRows,
      minRows,
      multiline = false,
      name,
      onBlur,
      onChange,
      onFocus,
      placeholder,
      required = false,
      rows,
      select = false,
      SelectProps,
      type,
      value,
      variant = 'outlined'
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$2);
  const ownerState = _extends({}, props, {
    autoFocus,
    color,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select,
    variant
  });
  const classes = useUtilityClasses$9(ownerState);
  if (process.env.NODE_ENV !== 'production') {
    if (select && !children) {
      console.error('MUI: `children` must be passed when using the `TextField` component with `select`.');
    }
  }
  const InputMore = {};
  if (variant === 'outlined') {
    if (InputLabelProps && typeof InputLabelProps.shrink !== 'undefined') {
      InputMore.notched = InputLabelProps.shrink;
    }
    InputMore.label = label;
  }
  if (select) {
    // unset defaults from textbox inputs
    if (!SelectProps || !SelectProps.native) {
      InputMore.id = undefined;
    }
    InputMore['aria-describedby'] = undefined;
  }
  const id = useId(idOverride);
  const helperTextId = helperText && id ? `${id}-helper-text` : undefined;
  const inputLabelId = label && id ? `${id}-label` : undefined;
  const InputComponent = variantComponent[variant];
  const InputElement = /*#__PURE__*/jsxRuntime.jsx(InputComponent, _extends({
    "aria-describedby": helperTextId,
    autoComplete: autoComplete,
    autoFocus: autoFocus,
    defaultValue: defaultValue,
    fullWidth: fullWidth,
    multiline: multiline,
    name: name,
    rows: rows,
    maxRows: maxRows,
    minRows: minRows,
    type: type,
    value: value,
    id: id,
    inputRef: inputRef,
    onBlur: onBlur,
    onChange: onChange,
    onFocus: onFocus,
    placeholder: placeholder,
    inputProps: inputProps
  }, InputMore, InputProps));
  return /*#__PURE__*/jsxRuntime.jsxs(TextFieldRoot, _extends({
    className: clsx(classes.root, className),
    disabled: disabled,
    error: error,
    fullWidth: fullWidth,
    ref: ref,
    required: required,
    color: color,
    variant: variant,
    ownerState: ownerState
  }, other, {
    children: [label != null && label !== '' && /*#__PURE__*/jsxRuntime.jsx(InputLabel$1, _extends({
      htmlFor: id,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), select ? /*#__PURE__*/jsxRuntime.jsx(Select$1, _extends({
      "aria-describedby": helperTextId,
      id: id,
      labelId: inputLabelId,
      value: value,
      input: InputElement
    }, SelectProps, {
      children: children
    })) : InputElement, helperText && /*#__PURE__*/jsxRuntime.jsx(FormHelperText$1, _extends({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
});
process.env.NODE_ENV !== "production" ? TextField.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: propTypesExports.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: propTypesExports.bool,
  /**
   * @ignore
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['primary', 'secondary', 'error', 'info', 'success', 'warning']), propTypesExports.string]),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypesExports.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: propTypesExports.bool,
  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: propTypesExports.bool,
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: propTypesExports.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: propTypesExports.bool,
  /**
   * The helper text content.
   */
  helperText: propTypesExports.node,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: propTypesExports.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: propTypesExports.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: propTypesExports.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: propTypesExports.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,
  /**
   * The label content.
   */
  label: propTypesExports.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: propTypesExports.oneOf(['dense', 'none', 'normal']),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * If `true`, a `textarea` element is rendered instead of an input.
   * @default false
   */
  multiline: propTypesExports.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: propTypesExports.string,
  /**
   * @ignore
   */
  onBlur: propTypesExports.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: propTypesExports.func,
  /**
   * @ignore
   */
  onFocus: propTypesExports.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: propTypesExports.string,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: propTypesExports.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * Render a [`Select`](/material-ui/api/select/) element while passing the Input element to `Select` as `input` parameter.
   * If this option is set you must pass the options of the select as children.
   * @default false
   */
  select: propTypesExports.bool,
  /**
   * Props applied to the [`Select`](/material-ui/api/select/) element.
   */
  SelectProps: propTypesExports.object,
  /**
   * The size of the component.
   */
  size: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['medium', 'small']), propTypesExports.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */
  type: propTypesExports /* @typescript-to-proptypes-ignore */.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: propTypesExports.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: propTypesExports.oneOf(['filled', 'outlined', 'standard'])
} : void 0;
var TextField$1 = TextField;

var useForkRef$1 = {};

var setRef = {};

var hasRequiredSetRef;

function requireSetRef () {
	if (hasRequiredSetRef) return setRef;
	hasRequiredSetRef = 1;

	Object.defineProperty(setRef, "__esModule", {
	  value: true
	});
	setRef.default = setRef$1;
	/**
	 * TODO v5: consider making it private
	 *
	 * passes {value} to {ref}
	 *
	 * WARNING: Be sure to only call this inside a callback that is passed as a ref.
	 * Otherwise, make sure to cleanup the previous {ref} if it changes. See
	 * https://github.com/mui/material-ui/issues/13539
	 *
	 * Useful if you want to expose the ref of an inner component to the public API
	 * while still using it inside the component.
	 * @param ref A ref callback or ref object. If anything falsy, this is a no-op.
	 */
	function setRef$1(ref, value) {
	  if (typeof ref === 'function') {
	    ref(value);
	  } else if (ref) {
	    ref.current = value;
	  }
	}
	return setRef;
}

var _interopRequireDefault = require$$0;
Object.defineProperty(useForkRef$1, "__esModule", {
  value: true
});
var _default$1 = useForkRef$1.default = useForkRef;
var React$1 = _interopRequireWildcard$1(React$4);
var _setRef = _interopRequireDefault(requireSetRef());
function _getRequireWildcardCache$1(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache$1 = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard$1(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache$1(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function useForkRef(...refs) {
  /**
   * This will create a new function if the refs passed to this hook change and are all defined.
   * This means react will call the old forkRef with `null` and the new forkRef
   * with the ref. Cleanup naturally emerges from this behavior.
   */
  return React$1.useMemo(() => {
    if (refs.every(ref => ref == null)) {
      return null;
    }
    return instance => {
      refs.forEach(ref => {
        (0, _setRef.default)(ref, instance);
      });
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, refs);
}

var useControlled$1 = {};

Object.defineProperty(useControlled$1, "__esModule", {
  value: true
});
var _default = useControlled$1.default = useControlled;
var React = _interopRequireWildcard(React$4);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */

function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = 'value'
}) {
  // isControlled is ignored in the hook dependency lists as it should never change.
  const {
    current: isControlled
  } = React.useRef(controlled !== undefined);
  const [valueState, setValue] = React.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  if (process.env.NODE_ENV !== 'production') {
    React.useEffect(() => {
      if (isControlled !== (controlled !== undefined)) {
        console.error([`MUI: A component is changing the ${isControlled ? '' : 'un'}controlled ${state} state of ${name} to be ${isControlled ? 'un' : ''}controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', `Decide between using a controlled or uncontrolled ${name} ` + 'element for the lifetime of the component.', "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'].join('\n'));
      }
    }, [state, name, controlled]);
    const {
      current: defaultValue
    } = React.useRef(defaultProp);
    React.useEffect(() => {
      if (!isControlled && defaultValue !== defaultProp) {
        console.error([`MUI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. ` + `To suppress this warning opt to use a controlled ${name}.`].join('\n'));
      }
    }, [JSON.stringify(defaultProp)]);
  }
  const setValueIfUncontrolled = React.useCallback(newValue => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}

const useFieldState = (params) => {
    var _a;
    const utils = useUtils();
    const localeText = useLocaleText();
    const adapter = useLocalizationContext();
    const theme = useTheme();
    const isRTL = theme.direction === 'rtl';
    const { valueManager, fieldValueManager, supportedDateSections, validator, internalProps, internalProps: { value: valueProp, defaultValue, onChange, format, selectedSections: selectedSectionsProp, onSelectedSectionsChange, }, } = params;
    const firstDefaultValue = React__namespace.useRef(defaultValue);
    const valueFromTheOutside = (_a = valueProp !== null && valueProp !== void 0 ? valueProp : firstDefaultValue.current) !== null && _a !== void 0 ? _a : valueManager.emptyValue;
    const boundaries = React__namespace.useMemo(() => getSectionBoundaries(utils), [utils]);
    const [sectionOrder, setSectionOrder] = React__namespace.useState(() => fieldValueManager.getSectionOrder(utils, localeText, format, isRTL));
    React__namespace.useEffect(() => {
        setSectionOrder(fieldValueManager.getSectionOrder(utils, localeText, format, isRTL));
    }, [fieldValueManager, format, isRTL, localeText, utils]);
    const [state, setState] = React__namespace.useState(() => {
        const sections = fieldValueManager.getSectionsFromValue(utils, localeText, null, valueFromTheOutside, format);
        validateSections(sections, supportedDateSections);
        return {
            sections,
            value: valueFromTheOutside,
            referenceValue: fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, valueManager.getTodayValue(utils)),
            tempValueStrAndroid: null,
        };
    });
    const [selectedSections, innerSetSelectedSections] = _default({
        controlled: selectedSectionsProp,
        default: null,
        name: 'useField',
        state: 'selectedSectionIndexes',
    });
    const setSelectedSections = (newSelectedSections) => {
        innerSetSelectedSections(newSelectedSections);
        onSelectedSectionsChange === null || onSelectedSectionsChange === void 0 ? void 0 : onSelectedSectionsChange(newSelectedSections);
        setState((prevState) => (Object.assign(Object.assign({}, prevState), { selectedSectionQuery: null })));
    };
    const selectedSectionIndexes = React__namespace.useMemo(() => {
        if (selectedSections == null) {
            return null;
        }
        if (selectedSections === 'all') {
            return {
                startIndex: 0,
                endIndex: state.sections.length - 1,
                shouldSelectBoundarySelectors: true,
            };
        }
        if (typeof selectedSections === 'number') {
            return { startIndex: selectedSections, endIndex: selectedSections };
        }
        if (typeof selectedSections === 'string') {
            const selectedSectionIndex = state.sections.findIndex((section) => section.dateSectionName === selectedSections);
            return { startIndex: selectedSectionIndex, endIndex: selectedSectionIndex };
        }
        return selectedSections;
    }, [selectedSections, state.sections]);
    const publishValue = ({ value, referenceValue, }) => {
        const newSections = fieldValueManager.getSectionsFromValue(utils, localeText, state.sections, value, format);
        setState((prevState) => (Object.assign(Object.assign({}, prevState), { sections: newSections, value,
            referenceValue, tempValueStrAndroid: null })));
        if (onChange) {
            const context = {
                validationError: validator({ adapter, value, props: Object.assign(Object.assign({}, internalProps), { value }) }),
            };
            onChange(value, context);
        }
    };
    const setSectionValue = (sectionIndex, newSectionValue) => {
        const newSections = [...state.sections];
        newSections[sectionIndex] = Object.assign(Object.assign({}, newSections[sectionIndex]), { value: newSectionValue, edited: true });
        return addPositionPropertiesToSections(newSections);
    };
    const clearValue = () => publishValue({
        value: valueManager.emptyValue,
        referenceValue: state.referenceValue,
    });
    const clearActiveSection = () => {
        if (selectedSectionIndexes == null) {
            return undefined;
        }
        const activeSection = state.sections[selectedSectionIndexes.startIndex];
        const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);
        const newSections = setSectionValue(selectedSectionIndexes.startIndex, '');
        return setState((prevState) => (Object.assign(Object.assign(Object.assign({}, prevState), { sections: newSections }), activeDateManager.getNewValueFromNewActiveDate(null))));
    };
    const updateValueFromValueStr = (valueStr) => {
        const parseDateStr = (dateStr, referenceDate) => {
            const date = utils.parse(dateStr, format);
            if (date == null || !utils.isValid(date)) {
                return null;
            }
            const sections = splitFormatIntoSections(utils, localeText, format, date);
            return mergeDateIntoReferenceDate(utils, date, sections, referenceDate, false);
        };
        const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);
        const newReferenceValue = fieldValueManager.updateReferenceValue(utils, newValue, state.referenceValue);
        publishValue({
            value: newValue,
            referenceValue: newReferenceValue,
        });
    };
    const updateSectionValue = ({ activeSection, setSectionValueOnDate, setSectionValueOnSections, }) => {
        const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);
        if (selectedSectionIndexes &&
            selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
            setSelectedSections(selectedSectionIndexes.startIndex);
        }
        if (activeDateManager.activeDate != null && utils.isValid(activeDateManager.activeDate)) {
            const newDate = setSectionValueOnDate(activeDateManager.activeDate, boundaries);
            return publishValue(activeDateManager.getNewValueFromNewActiveDate(newDate));
        }
        // The date is not valid, we have to update the section value rather than date itself.
        const newSectionValue = setSectionValueOnSections(boundaries);
        const newSections = setSectionValue(selectedSectionIndexes.startIndex, newSectionValue);
        const activeDateSections = fieldValueManager.getActiveDateSections(newSections, activeSection);
        let newDate = getDateFromDateSections(utils, activeDateSections);
        // When all the sections are filled but the date is invalid, it can be because the month has fewer days than asked.
        // We can try to set the day to the maximum boundary.
        if (!utils.isValid(newDate) &&
            activeDateSections.every((section) => section.value !== '') &&
            activeDateSections.some((section) => section.dateSectionName === 'day')) {
            const cleanSections = clampDaySection(utils, activeDateSections, boundaries);
            if (cleanSections != null) {
                newDate = getDateFromDateSections(utils, cleanSections);
            }
        }
        if (newDate != null && utils.isValid(newDate)) {
            const mergedDate = mergeDateIntoReferenceDate(utils, newDate, activeDateSections, activeDateManager.referenceActiveDate, true);
            return publishValue(activeDateManager.getNewValueFromNewActiveDate(mergedDate));
        }
        return setState((prevState) => (Object.assign(Object.assign(Object.assign({}, prevState), { sections: newSections, tempValueStrAndroid: null }), activeDateManager.getNewValueFromNewActiveDate(newDate))));
    };
    const setTempAndroidValueStr = (tempValueStrAndroid) => setState((prev) => (Object.assign(Object.assign({}, prev), { tempValueStrAndroid })));
    React__namespace.useEffect(() => {
        if (!valueManager.areValuesEqual(utils, state.value, valueFromTheOutside)) {
            const sections = fieldValueManager.getSectionsFromValue(utils, localeText, state.sections, valueFromTheOutside, format);
            setState((prevState) => (Object.assign(Object.assign({}, prevState), { value: valueFromTheOutside, referenceValue: fieldValueManager.updateReferenceValue(utils, valueFromTheOutside, prevState.referenceValue), sections })));
        }
    }, [valueFromTheOutside]); // eslint-disable-line react-hooks/exhaustive-deps
    React__namespace.useEffect(() => {
        const sections = fieldValueManager.getSectionsFromValue(utils, localeText, state.sections, state.value, format);
        validateSections(sections, supportedDateSections);
        setState((prevState) => (Object.assign(Object.assign({}, prevState), { sections })));
    }, [format, utils.locale]); // eslint-disable-line react-hooks/exhaustive-deps
    return {
        state,
        selectedSectionIndexes,
        setSelectedSections,
        clearValue,
        clearActiveSection,
        updateSectionValue,
        updateValueFromValueStr,
        setTempAndroidValueStr,
        sectionOrder,
    };
};

const useField = (params) => {
    const utils = useUtils();
    if (!utils.formatTokenMap) {
        throw new Error('This adapter is not compatible with the field components');
    }
    const queryRef = React__namespace.useRef(null);
    const { state, selectedSectionIndexes, setSelectedSections, clearValue, clearActiveSection, updateSectionValue, updateValueFromValueStr, setTempAndroidValueStr, sectionOrder, } = useFieldState(params);
    const { inputRef: inputRefProp, internalProps, internalProps: { readOnly = false } } = params, _a = params.forwardedProps, { onClick, onKeyDown, onFocus, onBlur, onMouseUp } = _a, otherForwardedProps = __rest(_a, ["onClick", "onKeyDown", "onFocus", "onBlur", "onMouseUp"]), { fieldValueManager, valueManager, validator } = params;
    const inputRef = React__namespace.useRef(null);
    const handleRef = _default$1(inputRefProp, inputRef);
    const focusTimeoutRef = React__namespace.useRef(undefined);
    const syncSelectionFromDOM = () => {
        var _a;
        const browserStartIndex = (_a = inputRef.current.selectionStart) !== null && _a !== void 0 ? _a : 0;
        const nextSectionIndex = browserStartIndex <= state.sections[0].startInInput
            ? 1 // Special case if browser index is in invisible characters at the beginning.
            : state.sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
        const sectionIndex = nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;
        setSelectedSections(sectionIndex);
    };
    const handleInputClick = _default$2((...args) => {
        onClick === null || onClick === void 0 ? void 0 : onClick(...args);
        syncSelectionFromDOM();
    });
    const handleInputMouseUp = _default$2((event) => {
        onMouseUp === null || onMouseUp === void 0 ? void 0 : onMouseUp(event);
        // Without this, the browser will remove the selected when clicking inside an already-selected section.
        event.preventDefault();
    });
    const handleInputFocus = _default$2((...args) => {
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(...args);
        // The ref is guaranteed to be resolved that this point.
        const input = inputRef.current;
        clearTimeout(focusTimeoutRef.current);
        focusTimeoutRef.current = setTimeout(() => {
            // The ref changed, the component got remounted, the focus event is no longer relevant.
            if (!input || input !== inputRef.current) {
                return;
            }
            if (selectedSectionIndexes != null) {
                return;
            }
            if (Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {
                setSelectedSections('all');
            }
            else {
                syncSelectionFromDOM();
            }
        });
    });
    const handleInputBlur = _default$2((...args) => {
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(...args);
        setSelectedSections(null);
    });
    const handleInputPaste = _default$2((event) => {
        if (readOnly) {
            event.preventDefault();
            return;
        }
        const pastedValue = event.clipboardData.getData('text');
        if (selectedSectionIndexes &&
            selectedSectionIndexes.startIndex === selectedSectionIndexes.endIndex) {
            const activeSection = state.sections[selectedSectionIndexes.startIndex];
            const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
            const digitsOnly = /^[0-9]+$/.test(pastedValue);
            const isValidPastedValue = (activeSection.contentType === 'letter' && lettersOnly) ||
                (activeSection.contentType === 'digit' && digitsOnly);
            if (isValidPastedValue) {
                // Early return to let the paste update section, value
                return;
            }
            if (lettersOnly || digitsOnly) {
                // The pasted value correspond to a single section but not the expected type
                // skip the modification
                event.preventDefault();
                return;
            }
        }
        event.preventDefault();
        updateValueFromValueStr(pastedValue);
    });
    const handleInputChange = _default$2((event) => {
        if (readOnly) {
            return;
        }
        const valueStr = cleanString(event.target.value);
        // If no section is selected, we just try to parse the new value
        // This line is mostly triggered by imperative code / application tests.
        if (selectedSectionIndexes == null) {
            updateValueFromValueStr(valueStr);
            return;
        }
        const prevValueStr = cleanString(fieldValueManager.getValueStrFromSections(state.sections));
        let startOfDiffIndex = -1;
        let endOfDiffIndex = -1;
        for (let i = 0; i < prevValueStr.length; i += 1) {
            if (startOfDiffIndex === -1 && prevValueStr[i] !== valueStr[i]) {
                startOfDiffIndex = i;
            }
            if (endOfDiffIndex === -1 &&
                prevValueStr[prevValueStr.length - i - 1] !== valueStr[valueStr.length - i - 1]) {
                endOfDiffIndex = i;
            }
        }
        const activeSection = state.sections[selectedSectionIndexes.startIndex];
        const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start ||
            prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;
        if (hasDiffOutsideOfActiveSection) {
            // TODO: Support if the new date is valid
            return;
        }
        // The active section being selected, the browser has replaced its value with the key pressed by the user.
        const activeSectionEndRelativeToNewValue = valueStr.length -
            prevValueStr.length +
            activeSection.end -
            cleanString(activeSection.endSeparator || '').length;
        const keyPressed = valueStr.slice(activeSection.start, activeSectionEndRelativeToNewValue);
        if (isAndroid() && keyPressed.length === 0) {
            setTempAndroidValueStr(valueStr);
            return;
        }
        const isNumericValue = !Number.isNaN(Number(keyPressed));
        if (isNumericValue) {
            const getNewSectionValueStr = (date, boundaries) => {
                const sectionBoundaries = boundaries[activeSection.dateSectionName](date, activeSection);
                // Remove the trailing `0` (`01` => `1`)
                let newSectionValue = Number(`${activeSection.value}${keyPressed}`).toString();
                while (newSectionValue.length > 0 && Number(newSectionValue) > sectionBoundaries.maximum) {
                    newSectionValue = newSectionValue.slice(1);
                }
                // In the unlikely scenario where max < 9, we could type a single digit that already exceeds the maximum.
                if (newSectionValue.length === 0) {
                    newSectionValue = sectionBoundaries.minimum.toString();
                }
                if (!activeSection.hasTrailingZeroes) {
                    return newSectionValue;
                }
                return cleanTrailingZeroInNumericSectionValue(newSectionValue, sectionBoundaries.maximum);
            };
            updateSectionValue({
                activeSection,
                setSectionValueOnDate: (activeDate, boundaries) => {
                    // TODO: Support digit editing for months displayed in full letter
                    if (activeSection.contentType === 'letter') {
                        return activeDate;
                    }
                    return applySectionValueToDate({
                        utils,
                        dateSectionName: activeSection.dateSectionName,
                        date: activeDate,
                        getNumericSectionValue: (getter) => {
                            const sectionValueStr = getNewSectionValueStr(activeDate, boundaries);
                            // We can't parse the day on the current date, otherwise we might try to parse `31` on a 30-days month.
                            // So we take for granted that for days, the digit rendered is always 1-indexed, just like the digit stored in the date.
                            if (activeSection.dateSectionName === 'day') {
                                return Number(sectionValueStr);
                            }
                            // The month is stored as 0-indexed in the date (0 = January, 1 = February, ...).
                            // But it is often rendered as 1-indexed in the input (1 = January, 2 = February, ...).
                            // This parsing makes sure that we store the digit according to the date index and not the input index.
                            const sectionDate = utils.parse(sectionValueStr, activeSection.formatValue);
                            return getter(sectionDate);
                        },
                        // Meridiem is not compatible with digit editing, this line should never be called.
                        getMeridiemSectionValue: () => '',
                    });
                },
                setSectionValueOnSections: (boundaries) => {
                    // TODO: Support digit editing for months displayed in full letter
                    if (activeSection.contentType === 'letter') {
                        return activeSection.value;
                    }
                    return getNewSectionValueStr(null, boundaries);
                },
            });
        }
        // TODO: Improve condition
        else if (['/', ' ', '-'].includes(keyPressed)) {
            if (selectedSectionIndexes.startIndex < state.sections.length - 1) {
                setSelectedSections(selectedSectionIndexes.startIndex + 1);
            }
        }
        else {
            const getNewSectionValueStr = () => {
                var _a;
                if (activeSection.contentType === 'digit') {
                    return activeSection.value;
                }
                const newQuery = keyPressed.toLowerCase();
                const currentQuery = ((_a = queryRef.current) === null || _a === void 0 ? void 0 : _a.dateSectionName) === activeSection.dateSectionName
                    ? queryRef.current.value
                    : '';
                const concatenatedQuery = `${currentQuery}${newQuery}`;
                const matchingMonthsWithConcatenatedQuery = getMonthsMatchingQuery(utils, activeSection, concatenatedQuery);
                if (matchingMonthsWithConcatenatedQuery.length > 0) {
                    queryRef.current = {
                        dateSectionName: activeSection.dateSectionName,
                        value: concatenatedQuery,
                    };
                    return matchingMonthsWithConcatenatedQuery[0];
                }
                const matchingMonthsWithNewQuery = getMonthsMatchingQuery(utils, activeSection, newQuery);
                if (matchingMonthsWithNewQuery.length > 0) {
                    queryRef.current = {
                        dateSectionName: activeSection.dateSectionName,
                        value: newQuery,
                    };
                    return matchingMonthsWithNewQuery[0];
                }
                return activeSection.value;
            };
            updateSectionValue({
                activeSection,
                setSectionValueOnDate: (activeDate) => applySectionValueToDate({
                    utils,
                    dateSectionName: activeSection.dateSectionName,
                    date: activeDate,
                    getNumericSectionValue: (getter) => {
                        const sectionValueStr = getNewSectionValueStr();
                        const sectionDate = utils.parse(sectionValueStr, activeSection.formatValue);
                        return getter(sectionDate);
                    },
                    getMeridiemSectionValue: getNewSectionValueStr,
                }),
                setSectionValueOnSections: () => getNewSectionValueStr(),
            });
        }
    });
    const handleInputKeyDown = _default$2((event) => {
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
        // eslint-disable-next-line default-case
        switch (true) {
            // Select all
            case event.key === 'a' && (event.ctrlKey || event.metaKey): {
                // prevent default to make sure that the next line "select all" while updating
                // the internal state at the same time.
                event.preventDefault();
                setSelectedSections('all');
                break;
            }
            // Move selection to next section
            case event.key === 'ArrowRight': {
                event.preventDefault();
                if (selectedSectionIndexes == null) {
                    setSelectedSections(sectionOrder.startIndex);
                }
                else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
                    setSelectedSections(selectedSectionIndexes.endIndex);
                }
                else {
                    const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].rightIndex;
                    if (nextSectionIndex !== null) {
                        setSelectedSections(nextSectionIndex);
                    }
                }
                break;
            }
            // Move selection to previous section
            case event.key === 'ArrowLeft': {
                event.preventDefault();
                if (selectedSectionIndexes == null) {
                    setSelectedSections(sectionOrder.endIndex);
                }
                else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
                    setSelectedSections(selectedSectionIndexes.startIndex);
                }
                else {
                    const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].leftIndex;
                    if (nextSectionIndex !== null) {
                        setSelectedSections(nextSectionIndex);
                    }
                }
                break;
            }
            // Reset the value of the selected section
            case ['Backspace', 'Delete'].includes(event.key): {
                event.preventDefault();
                if (readOnly) {
                    break;
                }
                if (selectedSectionIndexes == null ||
                    (selectedSectionIndexes.startIndex === 0 &&
                        selectedSectionIndexes.endIndex === state.sections.length - 1)) {
                    clearValue();
                }
                else {
                    clearActiveSection();
                }
                break;
            }
            // Increment / decrement the selected section value
            case ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key): {
                event.preventDefault();
                if (readOnly || selectedSectionIndexes == null) {
                    break;
                }
                const activeSection = state.sections[selectedSectionIndexes.startIndex];
                updateSectionValue({
                    activeSection,
                    setSectionValueOnDate: (activeDate) => adjustDateSectionValue(utils, activeDate, activeSection.dateSectionName, event.key),
                    setSectionValueOnSections: () => adjustInvalidDateSectionValue(utils, activeSection, event.key),
                });
                break;
            }
        }
    });
    default_1(() => {
        if (selectedSectionIndexes == null) {
            return;
        }
        const firstSelectedSection = state.sections[selectedSectionIndexes.startIndex];
        const lastSelectedSection = state.sections[selectedSectionIndexes.endIndex];
        let selectionStart = firstSelectedSection.startInInput;
        let selectionEnd = lastSelectedSection.endInInput;
        if (selectedSectionIndexes.shouldSelectBoundarySelectors) {
            selectionStart -= firstSelectedSection.startSeparator.length;
            selectionEnd += lastSelectedSection.endSeparator.length;
        }
        if (selectionStart !== inputRef.current.selectionStart ||
            selectionEnd !== inputRef.current.selectionEnd) {
            inputRef.current.setSelectionRange(selectionStart, selectionEnd);
        }
    });
    const validationError = useValidation(Object.assign(Object.assign({}, internalProps), { value: state.value }), validator, valueManager.isSameError, valueManager.defaultErrorState);
    const inputError = React__namespace.useMemo(() => fieldValueManager.hasError(validationError), [fieldValueManager, validationError]);
    React__namespace.useEffect(() => {
        // Select the right section when focused on mount (`autoFocus = true` on the input)
        if (inputRef.current && inputRef.current === document.activeElement) {
            setSelectedSections('all');
        }
        return () => window.clearTimeout(focusTimeoutRef.current);
    }, []); // eslint-disable-line react-hooks/exhaustive-deps
    const valueStr = React__namespace.useMemo(() => { var _a; return (_a = state.tempValueStrAndroid) !== null && _a !== void 0 ? _a : fieldValueManager.getValueStrFromSections(state.sections); }, [state.sections, fieldValueManager, state.tempValueStrAndroid]);
    const inputMode = React__namespace.useMemo(() => {
        if (selectedSectionIndexes == null) {
            return 'text';
        }
        if (state.sections[selectedSectionIndexes.startIndex].contentType === 'letter') {
            return 'text';
        }
        return 'tel';
    }, [selectedSectionIndexes, state.sections]);
    return Object.assign(Object.assign({}, otherForwardedProps), { value: valueStr, inputMode,
        readOnly, onClick: handleInputClick, onFocus: handleInputFocus, onBlur: handleInputBlur, onPaste: handleInputPaste, onChange: handleInputChange, onKeyDown: handleInputKeyDown, onMouseUp: handleInputMouseUp, error: inputError, ref: handleRef });
};

const useDefaultizedDateField = (props) => {
    var _a, _b, _c;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    return Object.assign(Object.assign({}, props), { disablePast: (_a = props.disablePast) !== null && _a !== void 0 ? _a : false, disableFuture: (_b = props.disableFuture) !== null && _b !== void 0 ? _b : false, format: (_c = props.format) !== null && _c !== void 0 ? _c : utils.formats.keyboardDate, minDate: applyDefaultDate(utils, props.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, props.maxDate, defaultDates.maxDate) });
};
const useDateField = ({ props, inputRef, }) => {
    const _a = useDefaultizedDateField(props), { value, defaultValue, format, onChange, readOnly, onError, shouldDisableDate, shouldDisableMonth, shouldDisableYear, minDate, maxDate, disableFuture, disablePast, selectedSections, onSelectedSectionsChange } = _a, other = __rest(_a, ["value", "defaultValue", "format", "onChange", "readOnly", "onError", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "minDate", "maxDate", "disableFuture", "disablePast", "selectedSections", "onSelectedSectionsChange"]);
    return useField({
        inputRef,
        forwardedProps: other,
        internalProps: {
            value,
            defaultValue,
            format,
            onChange,
            readOnly,
            onError,
            shouldDisableDate,
            shouldDisableMonth,
            shouldDisableYear,
            minDate,
            maxDate,
            disableFuture,
            disablePast,
            selectedSections,
            onSelectedSectionsChange,
        },
        valueManager: singleItemValueManager,
        fieldValueManager: singleItemFieldValueManager,
        validator: validateDate,
        supportedDateSections: ['year', 'month', 'day'],
    });
};

const DateField = React__namespace.forwardRef(function DateField(inProps, ref) {
    var _a;
    const themeProps = useThemeProps({
        props: inProps,
        name: 'MuiDateField',
    });
    const { components, componentsProps } = themeProps, other = __rest(themeProps, ["components", "componentsProps"]);
    const ownerState = themeProps;
    const Input = (_a = components === null || components === void 0 ? void 0 : components.Input) !== null && _a !== void 0 ? _a : TextField$1;
    const _b = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        externalForwardedProps: other,
        ownerState,
    }), { inputRef: externalInputRef } = _b, inputProps = __rest(_b, ["inputRef"]);
    const _c = useDateField({
        props: inputProps,
        inputRef: externalInputRef,
    }), { ref: inputRef, onPaste, inputMode, readOnly } = _c, fieldProps = __rest(_c, ["ref", "onPaste", "inputMode", "readOnly"]);
    return (React__namespace.createElement(Input, Object.assign({ ref: ref }, fieldProps, { inputProps: Object.assign(Object.assign({}, fieldProps.inputProps), { ref: inputRef, onPaste, inputMode, readOnly }) })));
});
DateField.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the `input` element is focused during the first mount.
     * @default false
     */
    autoFocus: propTypesExports.bool,
    className: propTypesExports.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
     * @default 'primary'
     */
    color: propTypesExports.oneOf(['error', 'info', 'primary', 'secondary', 'success', 'warning']),
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value. Use when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the component is displayed in focused state.
     */
    focused: propTypesExports.bool,
    /**
     * Format of the date when rendered in the input(s).
     */
    format: propTypesExports.string,
    /**
     * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
     */
    FormHelperTextProps: propTypesExports.object,
    /**
     * If `true`, the input will take up the full width of its container.
     * @default false
     */
    fullWidth: propTypesExports.bool,
    /**
     * The helper text content.
     */
    helperText: propTypesExports.node,
    /**
     * If `true`, the label is hidden.
     * This is used to increase density for a `FilledInput`.
     * Be sure to add `aria-label` to the `input` element.
     * @default false
     */
    hiddenLabel: propTypesExports.bool,
    /**
     * The id of the `input` element.
     * Use this prop to make `label` and `helperText` accessible for screen readers.
     */
    id: propTypesExports.string,
    /**
     * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
     * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
     */
    InputLabelProps: propTypesExports.object,
    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: propTypesExports.object,
    /**
     * Props applied to the Input element.
     * It will be a [`FilledInput`](/material-ui/api/filled-input/),
     * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
     * component depending on the `variant` prop value.
     */
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.any.isRequired,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
     * @default 'none'
     */
    margin: propTypesExports.oneOf(['dense', 'none', 'normal']),
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Name attribute of the `input` element.
     */
    name: propTypesExports.string,
    onBlur: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * @template TValue, TError
     * @param {TError} error The new error.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    onFocus: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * If `true`, the label is displayed as required and the `input` element is required.
     * @default false
     */
    required: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * The size of the component.
     */
    size: propTypesExports.oneOf(['medium', 'small']),
    style: propTypesExports.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The variant to use.
     * @default 'outlined'
     */
    variant: propTypesExports.oneOf(['filled', 'outlined', 'standard']),
};

const useDefaultizedTimeField = (props) => {
    var _a, _b, _c, _d;
    const utils = useUtils();
    const ampm = (_a = props.ampm) !== null && _a !== void 0 ? _a : utils.is12HourCycleInCurrentLocale();
    const defaultFormat = ampm ? utils.formats.fullTime12h : utils.formats.fullTime24h;
    return Object.assign(Object.assign({}, props), { disablePast: (_b = props.disablePast) !== null && _b !== void 0 ? _b : false, disableFuture: (_c = props.disableFuture) !== null && _c !== void 0 ? _c : false, format: (_d = props.format) !== null && _d !== void 0 ? _d : defaultFormat });
};
const useTimeField = ({ props, inputRef, }) => {
    const _a = useDefaultizedTimeField(props), { value, defaultValue, format, onChange, readOnly, onError, disableFuture, disablePast, minTime, maxTime, minutesStep, shouldDisableTime, disableIgnoringDatePartForTimeValidation, selectedSections, onSelectedSectionsChange, ampm } = _a, other = __rest(_a, ["value", "defaultValue", "format", "onChange", "readOnly", "onError", "disableFuture", "disablePast", "minTime", "maxTime", "minutesStep", "shouldDisableTime", "disableIgnoringDatePartForTimeValidation", "selectedSections", "onSelectedSectionsChange", "ampm"]);
    return useField({
        inputRef,
        forwardedProps: other,
        internalProps: {
            value,
            defaultValue,
            format,
            onChange,
            readOnly,
            onError,
            disableFuture,
            disablePast,
            minTime,
            maxTime,
            minutesStep,
            shouldDisableTime,
            disableIgnoringDatePartForTimeValidation,
            selectedSections,
            onSelectedSectionsChange,
            ampm,
        },
        valueManager: singleItemValueManager,
        fieldValueManager: singleItemFieldValueManager,
        validator: validateTime,
        supportedDateSections: ['hours', 'minutes', 'seconds', 'meridiem'],
    });
};

const TimeField = React__namespace.forwardRef(function TimeField(inProps, ref) {
    var _a;
    const themeProps = useThemeProps({
        props: inProps,
        name: 'MuiTimeField',
    });
    const { components, componentsProps } = themeProps, other = __rest(themeProps, ["components", "componentsProps"]);
    const ownerState = themeProps;
    const Input = (_a = components === null || components === void 0 ? void 0 : components.Input) !== null && _a !== void 0 ? _a : TextField$1;
    const _b = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        externalForwardedProps: other,
        ownerState,
    }), { inputRef: externalInputRef } = _b, inputProps = __rest(_b, ["inputRef"]);
    const _c = useTimeField({
        props: inputProps,
        inputRef: externalInputRef,
    }), { ref: inputRef, onPaste, inputMode, readOnly } = _c, fieldProps = __rest(_c, ["ref", "onPaste", "inputMode", "readOnly"]);
    return (React__namespace.createElement(Input, Object.assign({ ref: ref }, fieldProps, { inputProps: Object.assign(Object.assign({}, fieldProps.inputProps), { ref: inputRef, onPaste, inputMode, readOnly }) })));
});
TimeField.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * If `true`, the `input` element is focused during the first mount.
     * @default false
     */
    autoFocus: propTypesExports.bool,
    className: propTypesExports.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
     * @default 'primary'
     */
    color: propTypesExports.oneOf(['error', 'info', 'primary', 'secondary', 'success', 'warning']),
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value. Use when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the component is displayed in focused state.
     */
    focused: propTypesExports.bool,
    /**
     * Format of the date when rendered in the input(s).
     */
    format: propTypesExports.string,
    /**
     * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
     */
    FormHelperTextProps: propTypesExports.object,
    /**
     * If `true`, the input will take up the full width of its container.
     * @default false
     */
    fullWidth: propTypesExports.bool,
    /**
     * The helper text content.
     */
    helperText: propTypesExports.node,
    /**
     * If `true`, the label is hidden.
     * This is used to increase density for a `FilledInput`.
     * Be sure to add `aria-label` to the `input` element.
     * @default false
     */
    hiddenLabel: propTypesExports.bool,
    /**
     * The id of the `input` element.
     * Use this prop to make `label` and `helperText` accessible for screen readers.
     */
    id: propTypesExports.string,
    /**
     * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
     * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
     */
    InputLabelProps: propTypesExports.object,
    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: propTypesExports.object,
    /**
     * Props applied to the Input element.
     * It will be a [`FilledInput`](/material-ui/api/filled-input/),
     * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
     * component depending on the `variant` prop value.
     */
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.any.isRequired,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
     * @default 'none'
     */
    margin: propTypesExports.oneOf(['dense', 'none', 'normal']),
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Name attribute of the `input` element.
     */
    name: propTypesExports.string,
    onBlur: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * @template TValue, TError
     * @param {TError} error The new error.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    onFocus: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * If `true`, the label is displayed as required and the `input` element is required.
     * @default false
     */
    required: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * The size of the component.
     */
    size: propTypesExports.oneOf(['medium', 'small']),
    style: propTypesExports.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The variant to use.
     * @default 'outlined'
     */
    variant: propTypesExports.oneOf(['filled', 'outlined', 'standard']),
};

const useDefaultizedDateTimeField = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const ampm = (_a = props.ampm) !== null && _a !== void 0 ? _a : utils.is12HourCycleInCurrentLocale();
    const defaultFormat = ampm
        ? utils.formats.keyboardDateTime12h
        : utils.formats.keyboardDateTime24h;
    return Object.assign(Object.assign({}, props), { disablePast: (_b = props.disablePast) !== null && _b !== void 0 ? _b : false, disableFuture: (_c = props.disableFuture) !== null && _c !== void 0 ? _c : false, format: (_d = props.format) !== null && _d !== void 0 ? _d : defaultFormat, disableIgnoringDatePartForTimeValidation: Boolean(props.minDateTime || props.maxDateTime), minDate: applyDefaultDate(utils, (_e = props.minDateTime) !== null && _e !== void 0 ? _e : props.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, (_f = props.maxDateTime) !== null && _f !== void 0 ? _f : props.maxDate, defaultDates.maxDate), minTime: (_g = props.minDateTime) !== null && _g !== void 0 ? _g : props.minTime, maxTime: (_h = props.maxDateTime) !== null && _h !== void 0 ? _h : props.maxTime });
};
const useDateTimeField = ({ props, inputRef, }) => {
    const _a = useDefaultizedDateTimeField(props), { value, defaultValue, format, onChange, readOnly, onError, shouldDisableDate, shouldDisableMonth, shouldDisableYear, minDate, maxDate, disableFuture, disablePast, minTime, maxTime, minDateTime, maxDateTime, minutesStep, disableIgnoringDatePartForTimeValidation, shouldDisableTime, selectedSections, onSelectedSectionsChange, ampm } = _a, other = __rest(_a, ["value", "defaultValue", "format", "onChange", "readOnly", "onError", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "minDate", "maxDate", "disableFuture", "disablePast", "minTime", "maxTime", "minDateTime", "maxDateTime", "minutesStep", "disableIgnoringDatePartForTimeValidation", "shouldDisableTime", "selectedSections", "onSelectedSectionsChange", "ampm"]);
    return useField({
        inputRef,
        forwardedProps: other,
        internalProps: {
            value,
            defaultValue,
            format,
            onChange,
            readOnly,
            onError,
            shouldDisableDate,
            shouldDisableMonth,
            shouldDisableYear,
            minDate,
            maxDate,
            disableFuture,
            disablePast,
            minTime,
            maxTime,
            minutesStep,
            shouldDisableTime,
            disableIgnoringDatePartForTimeValidation,
            selectedSections,
            onSelectedSectionsChange,
            ampm,
        },
        valueManager: singleItemValueManager,
        fieldValueManager: singleItemFieldValueManager,
        validator: validateDateTime,
        supportedDateSections: ['year', 'month', 'day', 'hours', 'minutes', 'seconds', 'meridiem'],
    });
};

const DateTimeField = React__namespace.forwardRef(function DateTimeField(inProps, ref) {
    var _a;
    const themeProps = useThemeProps({
        props: inProps,
        name: 'MuiDateTimeField',
    });
    const { components, componentsProps } = themeProps, other = __rest(themeProps, ["components", "componentsProps"]);
    const ownerState = themeProps;
    const Input = (_a = components === null || components === void 0 ? void 0 : components.Input) !== null && _a !== void 0 ? _a : TextField$1;
    const _b = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        externalForwardedProps: other,
        ownerState,
    }), { inputRef: externalInputRef } = _b, inputProps = __rest(_b, ["inputRef"]);
    const _c = useDateTimeField({
        props: inputProps,
        inputRef: externalInputRef,
    }), { ref: inputRef, onPaste, inputMode, readOnly } = _c, fieldProps = __rest(_c, ["ref", "onPaste", "inputMode", "readOnly"]);
    return (React__namespace.createElement(Input, Object.assign({ ref: ref }, fieldProps, { inputProps: Object.assign(Object.assign({}, fieldProps.inputProps), { ref: inputRef, onPaste, inputMode, readOnly }) })));
});
DateTimeField.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * If `true`, the `input` element is focused during the first mount.
     * @default false
     */
    autoFocus: propTypesExports.bool,
    className: propTypesExports.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
     * @default 'primary'
     */
    color: propTypesExports.oneOf(['error', 'info', 'primary', 'secondary', 'success', 'warning']),
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value. Use when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the component is displayed in focused state.
     */
    focused: propTypesExports.bool,
    /**
     * Format of the date when rendered in the input(s).
     */
    format: propTypesExports.string,
    /**
     * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
     */
    FormHelperTextProps: propTypesExports.object,
    /**
     * If `true`, the input will take up the full width of its container.
     * @default false
     */
    fullWidth: propTypesExports.bool,
    /**
     * The helper text content.
     */
    helperText: propTypesExports.node,
    /**
     * If `true`, the label is hidden.
     * This is used to increase density for a `FilledInput`.
     * Be sure to add `aria-label` to the `input` element.
     * @default false
     */
    hiddenLabel: propTypesExports.bool,
    /**
     * The id of the `input` element.
     * Use this prop to make `label` and `helperText` accessible for screen readers.
     */
    id: propTypesExports.string,
    /**
     * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
     * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
     */
    InputLabelProps: propTypesExports.object,
    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: propTypesExports.object,
    /**
     * Props applied to the Input element.
     * It will be a [`FilledInput`](/material-ui/api/filled-input/),
     * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
     * component depending on the `variant` prop value.
     */
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.any.isRequired,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
     * @default 'none'
     */
    margin: propTypesExports.oneOf(['dense', 'none', 'normal']),
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Name attribute of the `input` element.
     */
    name: propTypesExports.string,
    onBlur: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * @template TValue, TError
     * @param {TError} error The new error.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    onFocus: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * If `true`, the label is displayed as required and the `input` element is required.
     * @default false
     */
    required: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * The size of the component.
     */
    size: propTypesExports.oneOf(['medium', 'small']),
    style: propTypesExports.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The variant to use.
     * @default 'outlined'
     */
    variant: propTypesExports.oneOf(['filled', 'outlined', 'standard']),
};

function getSkeletonUtilityClass(slot) {
  return generateUtilityClass('MuiSkeleton', slot);
}
generateUtilityClasses('MuiSkeleton', ['root', 'text', 'rectangular', 'rounded', 'circular', 'pulse', 'wave', 'withChildren', 'fitContent', 'heightAuto']);

const _excluded$1 = ["animation", "className", "component", "height", "style", "variant", "width"];
let _ = t => t,
  _t,
  _t2,
  _t3,
  _t4;
const useUtilityClasses$8 = ownerState => {
  const {
    classes,
    variant,
    animation,
    hasChildren,
    width,
    height
  } = ownerState;
  const slots = {
    root: ['root', variant, animation, hasChildren && 'withChildren', hasChildren && !width && 'fitContent', hasChildren && !height && 'heightAuto']
  };
  return composeClasses(slots, getSkeletonUtilityClass, classes);
};
const pulseKeyframe = keyframes(_t || (_t = _`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`));
const waveKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`));
const SkeletonRoot = styled$1('span', {
  name: 'MuiSkeleton',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.variant], ownerState.animation !== false && styles[ownerState.animation], ownerState.hasChildren && styles.withChildren, ownerState.hasChildren && !ownerState.width && styles.fitContent, ownerState.hasChildren && !ownerState.height && styles.heightAuto];
  }
})(({
  theme,
  ownerState
}) => {
  const radiusUnit = getUnit(theme.shape.borderRadius) || 'px';
  const radiusValue = toUnitless(theme.shape.borderRadius);
  return _extends({
    display: 'block',
    // Create a "on paper" color with sufficient contrast retaining the color
    backgroundColor: theme.vars ? theme.vars.palette.Skeleton.bg : alpha(theme.palette.text.primary, theme.palette.mode === 'light' ? 0.11 : 0.13),
    height: '1.2em'
  }, ownerState.variant === 'text' && {
    marginTop: 0,
    marginBottom: 0,
    height: 'auto',
    transformOrigin: '0 55%',
    transform: 'scale(1, 0.60)',
    borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
    '&:empty:before': {
      content: '"\\00a0"'
    }
  }, ownerState.variant === 'circular' && {
    borderRadius: '50%'
  }, ownerState.variant === 'rounded' && {
    borderRadius: (theme.vars || theme).shape.borderRadius
  }, ownerState.hasChildren && {
    '& > *': {
      visibility: 'hidden'
    }
  }, ownerState.hasChildren && !ownerState.width && {
    maxWidth: 'fit-content'
  }, ownerState.hasChildren && !ownerState.height && {
    height: 'auto'
  });
}, ({
  ownerState
}) => ownerState.animation === 'pulse' && css(_t3 || (_t3 = _`
      animation: ${0} 1.5s ease-in-out 0.5s infinite;
    `), pulseKeyframe), ({
  ownerState,
  theme
}) => ownerState.animation === 'wave' && css(_t4 || (_t4 = _`
      position: relative;
      overflow: hidden;

      /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
      -webkit-mask-image: -webkit-radial-gradient(white, black);

      &::after {
        animation: ${0} 1.6s linear 0.5s infinite;
        background: linear-gradient(
          90deg,
          transparent,
          ${0},
          transparent
        );
        content: '';
        position: absolute;
        transform: translateX(-100%); /* Avoid flash during server-side hydration */
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
      }
    `), waveKeyframe, (theme.vars || theme).palette.action.hover));
const Skeleton = /*#__PURE__*/React__namespace.forwardRef(function Skeleton(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiSkeleton'
  });
  const {
      animation = 'pulse',
      className,
      component = 'span',
      height,
      style,
      variant = 'text',
      width
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded$1);
  const ownerState = _extends({}, props, {
    animation,
    component,
    variant,
    hasChildren: Boolean(other.children)
  });
  const classes = useUtilityClasses$8(ownerState);
  return /*#__PURE__*/jsxRuntime.jsx(SkeletonRoot, _extends({
    as: component,
    ref: ref,
    className: clsx(classes.root, className),
    ownerState: ownerState
  }, other, {
    style: _extends({
      width,
      height
    }, style)
  }));
});
process.env.NODE_ENV !== "production" ? Skeleton.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The animation.
   * If `false` the animation effect is disabled.
   * @default 'pulse'
   */
  animation: propTypesExports.oneOf(['pulse', 'wave', false]),
  /**
   * Optional children to infer width and height from.
   */
  children: propTypesExports.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypesExports.object,
  /**
   * @ignore
   */
  className: propTypesExports.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * Height of the skeleton.
   * Useful when you don't want to adapt the skeleton to a text element but for instance a card.
   */
  height: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string]),
  /**
   * @ignore
   */
  style: propTypesExports.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object]),
  /**
   * The type of content that will be rendered.
   * @default 'text'
   */
  variant: propTypesExports /* @typescript-to-proptypes-ignore */.oneOfType([propTypesExports.oneOf(['circular', 'rectangular', 'rounded', 'text']), propTypesExports.string]),
  /**
   * Width of the skeleton.
   * Useful when the skeleton is inside an inline element with no width of its own.
   */
  width: propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string])
} : void 0;
var Skeleton$1 = Skeleton;

const getDayCalendarSkeletonUtilityClass = (slot) => generateUtilityClass('MuiDayCalendarSkeleton', slot);
const dayCalendarSkeletonClasses = generateUtilityClasses('MuiDayCalendarSkeleton', ['root', 'week', 'daySkeleton']);

const useUtilityClasses$7 = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        week: ['week'],
        daySkeleton: ['daySkeleton'],
    };
    return composeClasses(slots, getDayCalendarSkeletonUtilityClass, classes);
};
const DayCalendarSkeletonRoot = styled$1('div', {
    name: 'MuiDayCalendarSkeleton',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({
    alignSelf: 'start',
});
const DayCalendarSkeletonWeek = styled$1('div', {
    name: 'MuiDayCalendarSkeleton',
    slot: 'Week',
    overridesResolver: (props, styles) => styles.week,
})({
    margin: `${DAY_MARGIN}px 0`,
    display: 'flex',
    justifyContent: 'center',
});
const DayCalendarSkeletonDay = styled$1(Skeleton$1, {
    name: 'MuiDayCalendarSkeleton',
    slot: 'DaySkeleton',
    overridesResolver: (props, styles) => styles.daySkeleton,
})(({ ownerState }) => (Object.assign({ margin: `0 ${DAY_MARGIN}px` }, (ownerState.day === 0 && {
    visibility: 'hidden',
}))));
DayCalendarSkeletonDay.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    ownerState: propTypesExports.shape({
        day: propTypesExports.number.isRequired,
    }).isRequired,
};
const monthMap = [
    [0, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 1, 0, 0, 0],
];
/**
 *
 * Demos:
 *
 * - [Date Picker](https://mui.com/x/react-date-pickers/date-picker/)
 *
 * API:
 *
 * - [CalendarPickerSkeleton API](https://mui.com/x/api/date-pickers/calendar-picker-skeleton/)
 */
function DayCalendarSkeleton(inProps) {
    const props = useThemeProps({
        props: inProps,
        name: 'MuiDayCalendarSkeleton',
    });
    const { className } = props, other = __rest(props, ["className"]);
    const classes = useUtilityClasses$7(other);
    return (React__namespace.createElement(DayCalendarSkeletonRoot, Object.assign({ className: clsx(classes.root, className) }, other), monthMap.map((week, index) => (React__namespace.createElement(DayCalendarSkeletonWeek, { key: index, className: classes.week }, week.map((day, index2) => (React__namespace.createElement(DayCalendarSkeletonDay, { key: index2, variant: "circular", width: DAY_SIZE, height: DAY_SIZE, className: classes.daySkeleton, ownerState: { day } }))))))));
}
DayCalendarSkeleton.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Override or extend the styles applied to the component.
     */
    classes: propTypesExports.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
};

const getDatePickerFieldFormat = (utils, { format, views }) => {
    if (format != null) {
        return format;
    }
    if (isYearOnlyView(views)) {
        return utils.formats.year;
    }
    if (isYearAndMonthViews(views)) {
        return utils.formats.monthAndYear;
    }
    return undefined;
};
function useNextDatePickerDefaultizedProps(props, name) {
    var _a, _b;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
        props,
        name,
    });
    const localeText = React__namespace.useMemo(() => {
        var _a;
        if (((_a = themeProps.localeText) === null || _a === void 0 ? void 0 : _a.toolbarTitle) == null) {
            return themeProps.localeText;
        }
        return Object.assign(Object.assign({}, themeProps.localeText), { datePickerToolbarTitle: themeProps.localeText.toolbarTitle });
    }, [themeProps.localeText]);
    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeProps), { localeText }), applyDefaultViewProps({
        views: themeProps.views,
        openTo: themeProps.openTo,
        defaultViews: ['year', 'day'],
        defaultOpenTo: 'day',
    })), { disableFuture: (_a = themeProps.disableFuture) !== null && _a !== void 0 ? _a : false, disablePast: (_b = themeProps.disablePast) !== null && _b !== void 0 ? _b : false, minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate), components: Object.assign({ Toolbar: DatePickerToolbar }, themeProps.components) });
}

function DesktopTooltipWrapper(props) {
    const { children, DateInputProps, KeyboardDateInputComponent, open, onClear, onDismiss, onCancel, onAccept, onSetToday, components, componentsProps, localeText, } = props;
    const inputContainerRef = React__namespace.useRef(null);
    const popperRef = React__namespace.useRef(null);
    const handleBlur = () => {
        executeInTheNextEventLoopTick(() => {
            var _a, _b;
            if (((_a = inputContainerRef.current) === null || _a === void 0 ? void 0 : _a.contains(getActiveElement(document))) ||
                ((_b = popperRef.current) === null || _b === void 0 ? void 0 : _b.contains(getActiveElement(document)))) {
                return;
            }
            onDismiss();
        });
    };
    const inputComponentRef = useForkRef$2(DateInputProps.ref, inputContainerRef);
    return (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: "desktop" },
            React__namespace.createElement(KeyboardDateInputComponent, Object.assign({}, DateInputProps, { ref: inputComponentRef, onBlur: handleBlur })),
            React__namespace.createElement(PickersPopper, { role: "tooltip", open: open, containerRef: popperRef, anchorEl: inputContainerRef.current, onBlur: handleBlur, onDismiss: onDismiss, onClear: onClear, onCancel: onCancel, onAccept: onAccept, onSetToday: onSetToday, components: components, componentsProps: componentsProps }, children))));
}

generateUtilityClasses('MuiPickersToolbarButton', [
    'root',
]);

/**
 * Manage the value lifecycle of all the pickers.
 */
const usePickerValue = ({ props, valueManager, wrapperVariant, validator, }) => {
    const { onAccept: onAcceptProp, onChange, value: inValue, defaultValue, closeOnSelect, selectedSections: selectedSectionsProp, onSelectedSectionsChange, } = props;
    const utils = useUtils();
    const adapter = useLocalizationContext();
    const [rawValue, setValue] = useControlled$2({
        controlled: inValue,
        default: defaultValue !== null && defaultValue !== void 0 ? defaultValue : valueManager.emptyValue,
        name: 'usePickerValue',
        state: 'value',
    });
    const value = React__namespace.useMemo(() => valueManager.cleanValue(utils, rawValue), [valueManager, utils, rawValue]);
    const [selectedSections, setSelectedSections] = useControlled$2({
        controlled: selectedSectionsProp,
        default: null,
        name: 'usePickerValue',
        state: 'selectedSections',
    });
    const { isOpen, setIsOpen } = useOpenState(props);
    const [dateState, setDateState] = React__namespace.useState(() => ({
        committed: value,
        draft: value,
        resetFallback: value,
    }));
    useValidation(Object.assign(Object.assign({}, props), { value }), validator, valueManager.isSameError, valueManager.defaultErrorState);
    const setDate = _default$2((params) => {
        setDateState((prev) => {
            switch (params.action) {
                case 'setAll':
                case 'acceptAndClose': {
                    return { draft: params.value, committed: params.value, resetFallback: params.value };
                }
                case 'setCommitted': {
                    return Object.assign(Object.assign({}, prev), { draft: params.value, committed: params.value });
                }
                case 'setDraft': {
                    return Object.assign(Object.assign({}, prev), { draft: params.value });
                }
                default: {
                    return prev;
                }
            }
        });
        if (params.forceOnChangeCall ||
            (!params.skipOnChangeCall &&
                !valueManager.areValuesEqual(utils, dateState.committed, params.value))) {
            setValue(params.value);
            if (onChange) {
                const context = {
                    validationError: params.contextFromField == null
                        ? validator({
                            adapter,
                            value: params.value,
                            props: Object.assign(Object.assign({}, props), { value: params.value }),
                        })
                        : params.contextFromField.validationError,
                };
                onChange(params.value, context);
            }
        }
        if (params.action === 'acceptAndClose') {
            setIsOpen(false);
            if (onAcceptProp &&
                !valueManager.areValuesEqual(utils, dateState.resetFallback, params.value)) {
                onAcceptProp(params.value);
            }
        }
    });
    React__namespace.useEffect(() => {
        if (isOpen) {
            // Update all dates in state to equal the current prop value
            setDate({ action: 'setAll', value, skipOnChangeCall: true });
        }
    }, [isOpen]); // eslint-disable-line react-hooks/exhaustive-deps
    // Set the draft and committed date to equal the new prop value.
    if (!valueManager.areValuesEqual(utils, dateState.committed, value)) {
        setDate({ action: 'setCommitted', value, skipOnChangeCall: true });
    }
    const handleClear = _default$2(() => {
        // Reset all date in state to the empty value and close picker.
        setDate({
            value: valueManager.emptyValue,
            action: 'acceptAndClose',
            // force `onChange` in cases like input (value) === `Invalid date`
            forceOnChangeCall: !valueManager.areValuesEqual(utils, value, valueManager.emptyValue),
        });
    });
    const handleAccept = _default$2(() => {
        // Set all date in state to equal the current draft value and close picker.
        setDate({
            value: dateState.draft,
            action: 'acceptAndClose',
            // force `onChange` in cases like input (value) === `Invalid date`
            forceOnChangeCall: !valueManager.areValuesEqual(utils, dateState.committed, dateState.draft),
        });
    });
    const handleDismiss = _default$2(() => {
        // Set all dates in state to equal the last committed date.
        // e.g. Reset the state to the last committed value.
        setDate({ value: dateState.committed, action: 'acceptAndClose' });
    });
    const handleCancel = _default$2(() => {
        // Set all dates in state to equal the last accepted date and close picker.
        // e.g. Reset the state to the last accepted value
        setDate({ value: dateState.resetFallback, action: 'acceptAndClose' });
    });
    const handleSetToday = _default$2(() => {
        // Set all dates in state to equal today and close picker.
        setDate({ value: valueManager.getTodayValue(utils), action: 'acceptAndClose' });
    });
    const handleOpen = _default$2(() => setIsOpen(true));
    const handleClose = _default$2(() => setIsOpen(false));
    const handleChange = _default$2((newDate, selectionState = 'partial') => {
        switch (selectionState) {
            case 'shallow': {
                // Update the `draft` state but do not fire `onChange`
                return setDate({ action: 'setDraft', value: newDate, skipOnChangeCall: true });
            }
            case 'partial': {
                // Update the `draft` state and fire `onChange`
                return setDate({ action: 'setDraft', value: newDate });
            }
            case 'finish': {
                if (closeOnSelect !== null && closeOnSelect !== void 0 ? closeOnSelect : wrapperVariant === 'desktop') {
                    // Set all dates in state to equal the new date and close picker.
                    return setDate({ value: newDate, action: 'acceptAndClose' });
                }
                // Updates the `committed` state and fire `onChange`
                return setDate({ value: newDate, action: 'setCommitted' });
            }
            default: {
                throw new Error('MUI: Invalid selectionState passed to `onDateChange`');
            }
        }
    });
    const handleChangeAndCommit = _default$2((newValue, contextFromField) => setDate({ action: 'setCommitted', value: newValue, contextFromField }));
    const handleFieldSelectedSectionsChange = _default$2((newSelectedSections) => {
        setSelectedSections(newSelectedSections);
        onSelectedSectionsChange === null || onSelectedSectionsChange === void 0 ? void 0 : onSelectedSectionsChange(newSelectedSections);
    });
    const actions = {
        onClear: handleClear,
        onAccept: handleAccept,
        onDismiss: handleDismiss,
        onCancel: handleCancel,
        onSetToday: handleSetToday,
        onOpen: handleOpen,
        onClose: handleClose,
    };
    const fieldResponse = {
        value: dateState.draft,
        onChange: handleChangeAndCommit,
        selectedSections,
        onSelectedSectionsChange: handleFieldSelectedSectionsChange,
    };
    const viewResponse = {
        value: dateState.draft,
        onChange: handleChange,
        onClose: handleClose,
        open: isOpen,
        onSelectedSectionsChange: handleFieldSelectedSectionsChange,
    };
    const layoutResponse = Object.assign(Object.assign({}, actions), { value: dateState.draft, onChange: handleChangeAndCommit });
    return {
        open: isOpen,
        fieldProps: fieldResponse,
        viewProps: viewResponse,
        layoutProps: layoutResponse,
        actions,
    };
};

/**
 * Manage the views of all the pickers:
 * - Handles the view switch
 * - Handles the switch between UI views and field views
 * - Handles the focus management when switching views
 */
const usePickerViews = ({ props, propsFromPickerValue, additionalViewProps, inputRef, autoFocusView, }) => {
    const { onChange, open, onSelectedSectionsChange, onClose } = propsFromPickerValue;
    const { views, openTo, onViewChange, disableOpenPicker, viewRenderers } = props;
    const { view, setView, focusedView, setFocusedView, setValueAndGoToNextView } = useViews({
        view: undefined,
        views,
        openTo,
        onChange,
        onViewChange,
        autoFocus: autoFocusView,
    });
    const { hasUIView, viewModeLookup } = React__namespace.useMemo(() => views.reduce((acc, viewForReduce) => {
        let viewMode;
        if (disableOpenPicker) {
            viewMode = 'field';
        }
        else if (viewRenderers[viewForReduce] != null) {
            viewMode = 'UI';
        }
        else {
            viewMode = 'field';
        }
        acc.viewModeLookup[viewForReduce] = viewMode;
        if (viewMode === 'UI') {
            acc.hasUIView = true;
        }
        return acc;
    }, { hasUIView: false, viewModeLookup: {} }), [disableOpenPicker, viewRenderers, views]);
    const currentViewMode = viewModeLookup[view];
    const shouldRestoreFocus = _default$2(() => currentViewMode === 'UI');
    const [popperView, setPopperView] = React__namespace.useState(currentViewMode === 'UI' ? view : null);
    if (popperView !== view && viewModeLookup[view] === 'UI') {
        setPopperView(view);
    }
    default_1(() => {
        if (currentViewMode === 'field' && open) {
            onClose();
            onSelectedSectionsChange('hours');
            setTimeout(() => {
                inputRef === null || inputRef === void 0 ? void 0 : inputRef.current.focus();
            });
        }
    }, [view]); // eslint-disable-line react-hooks/exhaustive-deps
    default_1(() => {
        if (!open) {
            return;
        }
        if (currentViewMode === 'field' && popperView != null) {
            setView(popperView);
        }
    }, [open]); // eslint-disable-line react-hooks/exhaustive-deps
    const layoutProps = {
        views,
        view: popperView,
        onViewChange: setView,
    };
    return {
        hasUIView,
        shouldRestoreFocus,
        layoutProps,
        renderCurrentView: () => {
            if (popperView == null) {
                return null;
            }
            const renderer = viewRenderers[popperView];
            if (renderer == null) {
                return null;
            }
            return renderer(Object.assign(Object.assign(Object.assign(Object.assign({}, props), additionalViewProps), propsFromPickerValue), { views, onChange: setValueAndGoToNextView, view: popperView, onViewChange: setView, focusedView, onFocusedViewChange: setFocusedView }));
        },
    };
};

/**
 * Prepare the props for the view layout (managed by `PickersLayout`)
 */
const usePickerLayoutProps = ({ props, propsFromPickerValue, propsFromPickerViews, wrapperVariant, }) => {
    const { orientation } = props;
    const isLandscape = useIsLandscape(propsFromPickerViews.views, orientation);
    const layoutProps = Object.assign(Object.assign(Object.assign({}, propsFromPickerViews), propsFromPickerValue), { isLandscape,
        wrapperVariant, disabled: props.disabled, readOnly: props.readOnly, showToolbar: props.showToolbar });
    return { layoutProps };
};

const usePicker = ({ props, valueManager, wrapperVariant, inputRef, additionalViewProps, validator, autoFocusView, }) => {
    const pickerValueResponse = usePickerValue({
        props,
        valueManager,
        wrapperVariant,
        validator,
    });
    const pickerViewsResponse = usePickerViews({
        props,
        inputRef,
        additionalViewProps,
        autoFocusView,
        propsFromPickerValue: pickerValueResponse.viewProps,
    });
    const pickerLayoutResponse = usePickerLayoutProps({
        props,
        wrapperVariant,
        propsFromPickerValue: pickerValueResponse.layoutProps,
        propsFromPickerViews: pickerViewsResponse.layoutProps,
    });
    return {
        // Picker value
        open: pickerValueResponse.open,
        actions: pickerValueResponse.actions,
        fieldProps: pickerValueResponse.fieldProps,
        // Picker views
        renderCurrentView: pickerViewsResponse.renderCurrentView,
        hasUIView: pickerViewsResponse.hasUIView,
        shouldRestoreFocus: pickerViewsResponse.shouldRestoreFocus,
        // Picker layout
        layoutProps: pickerLayoutResponse.layoutProps,
    };
};

function getPickersLayoutUtilityClass(slot) {
    return generateUtilityClass('MuiPickersLayout', slot);
}
const pickersLayoutClasses = generateUtilityClasses('MuiPickersLayout', ['root', 'landscape', 'contentWrapper', 'toolbar', 'actionBar']);

function toolbarHasView(toolbarProps) {
    return toolbarProps.view !== null;
}
// TODO: Remove this functions. It get introduced to mark `value` prop in PickersLayoutProps as not required.
// The true type should be
// - For pickers value: TDate | null
// - For rangepickers value: [TDate | null, TDate | null]
function toolbarHasValue(toolbarProps) {
    return toolbarProps.value !== undefined;
}
const useUtilityClasses$6 = (ownerState) => {
    const { classes, isLandscape } = ownerState;
    const slots = {
        root: ['root', isLandscape && 'landscape'],
        contentWrapper: ['contentWrapper'],
        toolbar: ['toolbar'],
        actionBar: ['actionBar'],
        tabs: ['tabs'],
        landscape: ['landscape'],
    };
    return composeClasses(slots, getPickersLayoutUtilityClass, classes);
};
const usePickerLayout = (props) => {
    var _a;
    const { wrapperVariant, onAccept, onClear, onCancel, onSetToday, view, views, onViewChange, value, onChange, isLandscape, disabled, readOnly, showToolbar, children, components, componentsProps, } = props;
    const classes = useUtilityClasses$6(props);
    // Action bar
    const ActionBar = (_a = components === null || components === void 0 ? void 0 : components.ActionBar) !== null && _a !== void 0 ? _a : PickersActionBar;
    const actionBarProps = useSlotProps({
        elementType: ActionBar,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.actionBar,
        additionalProps: {
            onAccept,
            onClear,
            onCancel,
            onSetToday,
            actions: wrapperVariant === 'desktop' ? [] : ['cancel', 'accept'],
            className: classes.actionBar,
        },
        ownerState: Object.assign(Object.assign({}, props), { wrapperVariant }),
    });
    const actionBar = React__namespace.createElement(ActionBar, Object.assign({}, actionBarProps));
    // Toolbar
    const shouldRenderToolbar = showToolbar !== null && showToolbar !== void 0 ? showToolbar : wrapperVariant !== 'desktop';
    const Toolbar = components === null || components === void 0 ? void 0 : components.Toolbar;
    const toolbarProps = useSlotProps({
        elementType: Toolbar,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.toolbar,
        additionalProps: {
            isLandscape,
            onChange,
            value,
            view,
            onViewChange,
            views,
            disabled,
            readOnly,
            className: classes.toolbar,
        },
        ownerState: Object.assign(Object.assign({}, props), { wrapperVariant }),
    });
    const toolbar = toolbarHasView(toolbarProps) &&
        toolbarHasValue(toolbarProps) &&
        shouldRenderToolbar &&
        !!Toolbar ? (React__namespace.createElement(Toolbar, Object.assign({}, toolbarProps))) : null;
    // Content
    const content = children;
    // Tabs
    const Tabs = components === null || components === void 0 ? void 0 : components.Tabs;
    const tabs = view && Tabs ? (React__namespace.createElement(Tabs, Object.assign({ view: view, onViewChange: onViewChange }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.tabs))) : null;
    return {
        toolbar,
        content,
        tabs,
        actionBar,
    };
};

const useUtilityClasses$5 = (ownerState) => {
    const { isLandscape, classes } = ownerState;
    const slots = {
        root: ['root', isLandscape && 'landscape'],
        contentWrapper: ['contentWrapper'],
    };
    return composeClasses(slots, getPickersLayoutUtilityClass, classes);
};
const PickersLayoutRoot = styled$1('div', {
    name: 'MuiPickersLayout',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})(({ theme, ownerState }) => ({
    display: 'grid',
    gridAutoColumns: 'max-content auto max-content',
    gridAutoRows: 'max-content auto max-content',
    [`& .${pickersLayoutClasses.toolbar}`]: ownerState.isLandscape
        ? {
            gridColumn: theme.direction === 'rtl' ? 3 : 1,
            gridRow: '1 / 3',
        }
        : { gridColumn: '1 / 4', gridRow: 1 },
    [`& .${pickersLayoutClasses.actionBar}`]: { gridColumn: '1 / 4', gridRow: 3 },
}));
PickersLayoutRoot.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    as: propTypesExports.elementType,
    ownerState: propTypesExports.shape({
        isLandscape: propTypesExports.bool.isRequired,
    }).isRequired,
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
};
const PickersLayoutContentWrapper = styled$1('div', {
    name: 'MuiPickersLayout',
    slot: 'ContentWrapper',
    overridesResolver: (props, styles) => styles.contentWrapper,
})({
    gridColumn: 2,
    gridRow: 2,
    display: 'flex',
    flexDirection: 'column',
});
const PickersLayout = function PickersLayout(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiPickersLayout' });
    const { toolbar, content, tabs, actionBar } = usePickerLayout(props);
    const { sx, className, ref } = props;
    const ownerState = props;
    const classes = useUtilityClasses$5(ownerState);
    return (React__namespace.createElement(PickersLayoutRoot, { sx: sx, className: clsx(className, classes.root), ownerState: ownerState, ref: ref },
        toolbar,
        React__namespace.createElement(PickersLayoutContentWrapper, { className: classes.contentWrapper },
            tabs,
            content),
        actionBar));
};
PickersLayout.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    children: propTypesExports.node,
    classes: propTypesExports.object,
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    disabled: propTypesExports.bool,
    isLandscape: propTypesExports.bool.isRequired,
    onAccept: propTypesExports.func.isRequired,
    onCancel: propTypesExports.func.isRequired,
    onChange: propTypesExports.func.isRequired,
    onClear: propTypesExports.func.isRequired,
    onClose: propTypesExports.func.isRequired,
    onDismiss: propTypesExports.func.isRequired,
    onOpen: propTypesExports.func.isRequired,
    onSetToday: propTypesExports.func.isRequired,
    onViewChange: propTypesExports.func.isRequired,
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    showToolbar: propTypesExports.bool,
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    value: propTypesExports.any,
    view: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired).isRequired,
    wrapperVariant: propTypesExports.oneOf(['desktop', 'mobile']),
};

const PickerStaticLayout$1 = styled$1(PickersLayout)(({ theme }) => ({
    overflow: 'hidden',
    minWidth: DIALOG_WIDTH,
    backgroundColor: (theme.vars || theme).palette.background.paper,
}));
/**
 * Hook managing all the single-date static pickers:
 * - StaticDatePicker
 * - StaticDateTimePicker
 * - StaticTimePicker
 */
const useStaticPicker = ({ props, valueManager, validator, ref, }) => {
    var _a;
    const { localeText, components, componentsProps, displayStaticWrapperAs, autoFocus } = props;
    const { layoutProps, renderCurrentView } = usePicker({
        props,
        valueManager,
        validator,
        autoFocusView: autoFocus !== null && autoFocus !== void 0 ? autoFocus : false,
        additionalViewProps: {},
        wrapperVariant: displayStaticWrapperAs,
    });
    const Layout = (_a = components === null || components === void 0 ? void 0 : components.Layout) !== null && _a !== void 0 ? _a : PickerStaticLayout$1;
    const renderPicker = () => (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: displayStaticWrapperAs },
            React__namespace.createElement(Layout, Object.assign({}, layoutProps, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.layout, { components: components, componentsProps: componentsProps, ref: ref }), renderCurrentView()))));
    return { renderPicker };
};

const VALIDATION_PROP_NAMES = [
    'disablePast',
    'disableFuture',
    'minDate',
    'maxDate',
    'minTime',
    'maxTime',
    'minDateTime',
    'maxDateTime',
    'shouldDisableDate',
    'shouldDisableMonth',
    'shouldDisableYear',
    'shouldDisableTime',
    'minuteStep',
];
/**
 * Extract the validation props for the props received by a component.
 * Limit the risk of forgetting some of them and reduce the bundle size.
 */
const extractValidationProps = (props) => VALIDATION_PROP_NAMES.reduce((extractedProps, propName) => {
    if (props.hasOwnProperty(propName)) {
        extractedProps[propName] = props[propName];
    }
    return extractedProps;
}, {});

/**
 * Hook managing all the single-date desktop pickers:
 * - DesktopDatePicker
 * - DesktopDateTimePicker
 * - DesktopTimePicker
 */
const useDesktopPicker = ({ props, valueManager, getOpenDialogAriaText, validator, }) => {
    var _a, _b, _c;
    const { components, componentsProps, className, format, readOnly, disabled, autoFocus, localeText, } = props;
    const utils = useUtils();
    const inputRef = React__namespace.useRef(null);
    const { open, actions, hasUIView, layoutProps, renderCurrentView, shouldRestoreFocus, fieldProps: pickerFieldProps, } = usePicker({
        props,
        inputRef,
        valueManager,
        validator,
        autoFocusView: true,
        additionalViewProps: {},
        wrapperVariant: 'desktop',
    });
    const Field = components.Field;
    const fieldProps = useSlotProps({
        elementType: Field,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.field,
        additionalProps: Object.assign(Object.assign({}, pickerFieldProps), { readOnly,
            disabled,
            className,
            format, autoFocus: autoFocus && !props.open }),
        ownerState: props,
    });
    const InputAdornment = (_a = components.InputAdornment) !== null && _a !== void 0 ? _a : MuiInputAdornment;
    const inputAdornmentProps = useSlotProps({
        elementType: InputAdornment,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputAdornment,
        additionalProps: {
            position: 'end',
        },
        ownerState: props,
    });
    const OpenPickerButton = (_b = components.OpenPickerButton) !== null && _b !== void 0 ? _b : IconButton$1;
    const _d = useSlotProps({
        elementType: OpenPickerButton,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.openPickerButton,
        additionalProps: {
            disabled: disabled || readOnly,
            onClick: actions.onOpen,
            'aria-label': getOpenDialogAriaText(pickerFieldProps.value, utils),
            edge: inputAdornmentProps.position,
        },
        ownerState: props,
    }), openPickerButtonProps = __rest(_d, ["ownerState"]);
    const OpenPickerIcon = components.OpenPickerIcon;
    const componentsForField = Object.assign(Object.assign({}, fieldProps.components), { Input: components.Input });
    const componentsPropsForField = Object.assign(Object.assign({}, fieldProps.componentsProps), { input: (ownerState) => {
            var _a;
            const externalInputProps = resolveComponentProps(componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input, ownerState);
            const inputPropsPassedByField = resolveComponentProps((_a = fieldProps.componentsProps) === null || _a === void 0 ? void 0 : _a.input, ownerState);
            return Object.assign(Object.assign(Object.assign({}, inputPropsPassedByField), externalInputProps), { InputProps: Object.assign(Object.assign({ [`${inputAdornmentProps.position}Adornment`]: hasUIView ? (React__namespace.createElement(InputAdornment, Object.assign({}, inputAdornmentProps),
                        React__namespace.createElement(OpenPickerButton, Object.assign({}, openPickerButtonProps),
                            React__namespace.createElement(OpenPickerIcon, Object.assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.openPickerIcon))))) : undefined }, inputPropsPassedByField === null || inputPropsPassedByField === void 0 ? void 0 : inputPropsPassedByField.InputProps), externalInputProps === null || externalInputProps === void 0 ? void 0 : externalInputProps.InputProps) });
        } });
    const Layout = (_c = components === null || components === void 0 ? void 0 : components.Layout) !== null && _c !== void 0 ? _c : PickersLayout;
    const handleInputRef = _default$1(inputRef, fieldProps.inputRef);
    const renderPicker = () => (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: "desktop" },
            React__namespace.createElement(Field, Object.assign({}, fieldProps, { components: componentsForField, componentsProps: componentsPropsForField, inputRef: handleInputRef })),
            React__namespace.createElement(PickersPopper, Object.assign({ role: "dialog", anchorEl: inputRef.current }, actions, { open: open, components: Object.assign(Object.assign({}, components), { 
                    // Avoids to render 2 action bar, will be removed once `PickersPopper` stop displaying the action bar.
                    ActionBar: () => null }), componentsProps: Object.assign(Object.assign({}, componentsProps), { actionBar: undefined }), shouldRestoreFocus: shouldRestoreFocus }),
                React__namespace.createElement(Layout, Object.assign({}, layoutProps, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.layout, { components: components, componentsProps: componentsProps }), renderCurrentView())))));
    return { renderPicker };
};

const isDatePickerView$1 = (view) => view === 'year' || view === 'month' || view === 'day';
const renderDateViewCalendar = (props) => (React__namespace.createElement(DateCalendar, Object.assign({}, props, { view: props.view, views: props.views.filter(isDatePickerView$1), focusedView: props.focusedView })));

const DesktopNextDatePicker = React__namespace.forwardRef(function DesktopNextDatePicker(inProps, ref) {
    var _a;
    const localeText = useLocaleText();
    const utils = useUtils();
    // Props with the default values common to all date pickers
    const _b = useNextDatePickerDefaultizedProps(inProps, 'MuiDesktopNextDatePicker'), { className, sx } = _b, defaultizedProps = __rest(_b, ["className", "sx"]);
    const viewRenderers = Object.assign({ day: renderDateViewCalendar, month: renderDateViewCalendar, year: renderDateViewCalendar }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the desktop variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { viewRenderers, format: getDatePickerFieldFormat(utils, defaultizedProps), showToolbar: (_a = defaultizedProps.showToolbar) !== null && _a !== void 0 ? _a : false, components: Object.assign({ OpenPickerIcon: Calendar, Field: DateField }, defaultizedProps.components), componentsProps: Object.assign(Object.assign({}, defaultizedProps.componentsProps), { field: (ownerState) => {
                var _a;
                return (Object.assign(Object.assign(Object.assign({}, resolveComponentProps((_a = defaultizedProps.componentsProps) === null || _a === void 0 ? void 0 : _a.field, ownerState)), extractValidationProps(defaultizedProps)), { ref,
                    className,
                    sx, inputRef: defaultizedProps.inputRef, label: defaultizedProps.label }));
            } }) });
    const { renderPicker } = useDesktopPicker({
        props,
        valueManager: singleItemValueManager,
        getOpenDialogAriaText: localeText.openDatePickerDialogue,
        validator: validateDate,
    });
    return renderPicker();
});
DesktopNextDatePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
        month: propTypesExports.func,
        year: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

/**
 * Hook managing all the single-date mobile pickers:
 * - MobileDatePicker
 * - MobileDateTimePicker
 * - MobileTimePicker
 */
const useMobilePicker = ({ props, valueManager, getOpenDialogAriaText, validator, }) => {
    var _a;
    const { components, componentsProps, className, format, readOnly, disabled, localeText } = props;
    const utils = useUtils();
    const inputRef = React__namespace.useRef(null);
    const { open, actions, layoutProps, renderCurrentView, fieldProps: pickerFieldProps, } = usePicker({
        props,
        inputRef,
        valueManager,
        validator,
        autoFocusView: true,
        additionalViewProps: {},
        wrapperVariant: 'mobile',
    });
    const Field = components.Field;
    const fieldProps = useSlotProps({
        elementType: Field,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.field,
        additionalProps: Object.assign(Object.assign({}, pickerFieldProps), { readOnly: readOnly !== null && readOnly !== void 0 ? readOnly : true, disabled,
            className,
            format }),
        ownerState: props,
    });
    const componentsPropsForField = Object.assign(Object.assign({}, fieldProps.componentsProps), { input: (ownerState) => {
            var _a;
            const externalInputProps = resolveComponentProps(componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input, ownerState);
            const inputPropsPassedByField = resolveComponentProps((_a = fieldProps.componentsProps) === null || _a === void 0 ? void 0 : _a.input, ownerState);
            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, inputPropsPassedByField), externalInputProps), { disabled }), (!(disabled || readOnly) && {
                onClick: actions.onOpen,
                onKeyDown: onSpaceOrEnter(actions.onOpen),
            })), { inputProps: Object.assign(Object.assign({ 'aria-label': getOpenDialogAriaText(pickerFieldProps.value, utils) }, inputPropsPassedByField === null || inputPropsPassedByField === void 0 ? void 0 : inputPropsPassedByField.inputProps), externalInputProps === null || externalInputProps === void 0 ? void 0 : externalInputProps.inputProps) });
        } });
    const componentsForField = Object.assign(Object.assign({}, fieldProps.components), { Input: components.Input });
    const Layout = (_a = components === null || components === void 0 ? void 0 : components.Layout) !== null && _a !== void 0 ? _a : PickersLayout;
    const handleInputRef = _default$1(inputRef, fieldProps.inputRef);
    const renderPicker = () => (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: "mobile" },
            React__namespace.createElement(Field, Object.assign({}, fieldProps, { components: componentsForField, componentsProps: componentsPropsForField, inputRef: handleInputRef })),
            React__namespace.createElement(PickersModalDialog, Object.assign({}, actions, { open: open, components: Object.assign(Object.assign({}, components), { 
                    // Avoids to render 2 action bar, will be removed once `PickersModalDialog` stop displaying the action bar.
                    ActionBar: () => null }), componentsProps: Object.assign(Object.assign({}, componentsProps), { actionBar: undefined }) }),
                React__namespace.createElement(Layout, Object.assign({}, layoutProps, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.layout, { components: components, componentsProps: componentsProps }), renderCurrentView())))));
    return { renderPicker };
};

const MobileNextDatePicker = React__namespace.forwardRef(function MobileNextDatePicker(inProps, ref) {
    var _a;
    const localeText = useLocaleText();
    const utils = useUtils();
    // Props with the default values common to all date pickers
    const _b = useNextDatePickerDefaultizedProps(inProps, 'MuiMobileNextDatePicker'), { className, sx } = _b, defaultizedProps = __rest(_b, ["className", "sx"]);
    const viewRenderers = Object.assign({ day: renderDateViewCalendar, month: renderDateViewCalendar, year: renderDateViewCalendar }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the mobile variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { viewRenderers, format: getDatePickerFieldFormat(utils, defaultizedProps), showToolbar: (_a = defaultizedProps.showToolbar) !== null && _a !== void 0 ? _a : true, components: Object.assign({ Field: DateField }, defaultizedProps.components), componentsProps: Object.assign(Object.assign({}, defaultizedProps.componentsProps), { field: (ownerState) => {
                var _a;
                return (Object.assign(Object.assign(Object.assign({}, resolveComponentProps((_a = defaultizedProps.componentsProps) === null || _a === void 0 ? void 0 : _a.field, ownerState)), extractValidationProps(defaultizedProps)), { ref,
                    className,
                    sx, inputRef: defaultizedProps.inputRef, label: defaultizedProps.label }));
            } }) });
    const { renderPicker } = useMobilePicker({
        props,
        valueManager: singleItemValueManager,
        getOpenDialogAriaText: localeText.openDatePickerDialogue,
        validator: validateDate,
    });
    return renderPicker();
});
MobileNextDatePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
        month: propTypesExports.func,
        year: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

const NextDatePicker = React__namespace.forwardRef(function NextDatePicker(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiNextDatePicker' });
    const { desktopModeMediaQuery = '@media (pointer: fine)' } = props, other = __rest(props, ["desktopModeMediaQuery"]);
    // defaults to `true` in environments where `window.matchMedia` would not be available (i.e. test/jsdom)
    const isDesktop = useMediaQuery(desktopModeMediaQuery, { defaultMatches: true });
    if (isDesktop) {
        return React__namespace.createElement(DesktopNextDatePicker, Object.assign({ ref: ref }, other));
    }
    return React__namespace.createElement(MobileNextDatePicker, Object.assign({ ref: ref }, other));
});
NextDatePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * CSS media query when `Mobile` mode will be changed to `Desktop`.
     * @default '@media (pointer: fine)'
     * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
     */
    desktopModeMediaQuery: propTypesExports.string,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
        month: propTypesExports.func,
        year: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

const StaticNextDatePicker = React__namespace.forwardRef(function StaticNextDatePicker(inProps, ref) {
    var _a, _b;
    const defaultizedProps = useNextDatePickerDefaultizedProps(inProps, 'MuiStaticNextDatePicker');
    const displayStaticWrapperAs = (_a = defaultizedProps.displayStaticWrapperAs) !== null && _a !== void 0 ? _a : 'mobile';
    const viewRenderers = Object.assign({ day: renderDateViewCalendar, month: renderDateViewCalendar, year: renderDateViewCalendar }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the static variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { viewRenderers,
        displayStaticWrapperAs, showToolbar: (_b = defaultizedProps.showToolbar) !== null && _b !== void 0 ? _b : displayStaticWrapperAs === 'mobile' });
    const { renderPicker } = useStaticPicker({
        props,
        valueManager: singleItemValueManager,
        validator: validateDate,
        ref,
    });
    return renderPicker();
});
StaticNextDatePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Force static wrapper inner components to be rendered in mobile or desktop mode.
     * @default "mobile"
     */
    displayStaticWrapperAs: propTypesExports.oneOf(['desktop', 'mobile']),
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
        month: propTypesExports.func,
        year: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

function useNextTimePickerDefaultizedProps(props, name) {
    var _a, _b, _c, _d;
    const utils = useUtils();
    const themeProps = useThemeProps({
        props,
        name,
    });
    const ampm = (_a = themeProps.ampm) !== null && _a !== void 0 ? _a : utils.is12HourCycleInCurrentLocale();
    const localeText = React__namespace.useMemo(() => {
        var _a;
        if (((_a = themeProps.localeText) === null || _a === void 0 ? void 0 : _a.toolbarTitle) == null) {
            return themeProps.localeText;
        }
        return Object.assign(Object.assign({}, themeProps.localeText), { timePickerToolbarTitle: themeProps.localeText.toolbarTitle });
    }, [themeProps.localeText]);
    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeProps), { ampm,
        localeText }), applyDefaultViewProps({
        views: themeProps.views,
        openTo: themeProps.openTo,
        defaultViews: ['hours', 'minutes'],
        defaultOpenTo: 'hours',
    })), { disableFuture: (_b = themeProps.disableFuture) !== null && _b !== void 0 ? _b : false, disablePast: (_c = themeProps.disablePast) !== null && _c !== void 0 ? _c : false, components: Object.assign({ Toolbar: TimePickerToolbar }, themeProps.components), componentsProps: Object.assign(Object.assign({}, themeProps.componentsProps), { toolbar: Object.assign({ ampm, ampmInClock: themeProps.ampmInClock }, (_d = themeProps.componentsProps) === null || _d === void 0 ? void 0 : _d.toolbar) }) });
}

const DesktopNextTimePicker = React__namespace.forwardRef(function DesktopNextTimePicker(inProps, ref) {
    var _a;
    const localeText = useLocaleText();
    // Props with the default values common to all time pickers
    const _b = useNextTimePickerDefaultizedProps(inProps, 'MuiDesktopNextTimePicker'), { className, sx } = _b, defaultizedProps = __rest(_b, ["className", "sx"]);
    const viewRenderers = Object.assign({ hours: null, minutes: null, seconds: null }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the desktop variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { viewRenderers, showToolbar: (_a = defaultizedProps.showToolbar) !== null && _a !== void 0 ? _a : false, components: Object.assign({ Field: TimeField, OpenPickerIcon: Clock }, defaultizedProps.components), componentsProps: Object.assign(Object.assign({}, defaultizedProps.componentsProps), { field: (ownerState) => {
                var _a;
                return (Object.assign(Object.assign(Object.assign({}, resolveComponentProps((_a = defaultizedProps.componentsProps) === null || _a === void 0 ? void 0 : _a.field, ownerState)), extractValidationProps(defaultizedProps)), { ref,
                    className,
                    sx, inputRef: defaultizedProps.inputRef, label: defaultizedProps.label, ampm: defaultizedProps.ampm }));
            } }) });
    const { renderPicker } = useDesktopPicker({
        props,
        valueManager: singleItemValueManager,
        getOpenDialogAriaText: localeText.openTimePickerDialogue,
        validator: validateTime,
    });
    return renderPicker();
});
DesktopNextTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        hours: propTypesExports.func,
        minutes: propTypesExports.func,
        seconds: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['hours', 'minutes', 'seconds']).isRequired),
};

const isTimePickerView = (view) => view === 'hours' || view === 'minutes' || view === 'seconds';
const renderTimeViewClock = (props) => (React__namespace.createElement(TimeClock, Object.assign({}, props, { views: props.views.filter(isTimePickerView), view: props.view, 
    // We don't want to pass this prop to the views because it can cause proptypes warnings
    openTo: undefined, 
    // TODO: Remove when `TimeClock` will support `focusedView`
    autoFocus: true })));

const MobileNextTimePicker = React__namespace.forwardRef(function MobileNextTimePicker(inProps, ref) {
    var _a;
    const localeText = useLocaleText();
    // Props with the default values common to all time pickers
    const _b = useNextTimePickerDefaultizedProps(inProps, 'MuiMobileNextTimePicker'), { className, sx } = _b, defaultizedProps = __rest(_b, ["className", "sx"]);
    const viewRenderers = Object.assign({ hours: renderTimeViewClock, minutes: renderTimeViewClock, seconds: renderTimeViewClock }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the mobile variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { viewRenderers, showToolbar: (_a = defaultizedProps.showToolbar) !== null && _a !== void 0 ? _a : true, components: Object.assign({ Field: TimeField }, defaultizedProps.components), componentsProps: Object.assign(Object.assign({}, defaultizedProps.componentsProps), { field: (ownerState) => {
                var _a;
                return (Object.assign(Object.assign(Object.assign({}, resolveComponentProps((_a = defaultizedProps.componentsProps) === null || _a === void 0 ? void 0 : _a.field, ownerState)), extractValidationProps(defaultizedProps)), { ref,
                    className,
                    sx, inputRef: defaultizedProps.inputRef, label: defaultizedProps.label, ampm: defaultizedProps.ampm }));
            } }) });
    const { renderPicker } = useMobilePicker({
        props,
        valueManager: singleItemValueManager,
        getOpenDialogAriaText: localeText.openTimePickerDialogue,
        validator: validateTime,
    });
    return renderPicker();
});
MobileNextTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        hours: propTypesExports.func,
        minutes: propTypesExports.func,
        seconds: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['hours', 'minutes', 'seconds']).isRequired),
};

const NextTimePicker = React__namespace.forwardRef(function NextTimePicker(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiNextTimePicker' });
    const { desktopModeMediaQuery = '@media (pointer: fine)' } = props, other = __rest(props, ["desktopModeMediaQuery"]);
    // defaults to `true` in environments where `window.matchMedia` would not be available (i.e. test/jsdom)
    const isDesktop = useMediaQuery(desktopModeMediaQuery, { defaultMatches: true });
    if (isDesktop) {
        return React__namespace.createElement(DesktopNextTimePicker, Object.assign({ ref: ref }, other));
    }
    return React__namespace.createElement(MobileNextTimePicker, Object.assign({ ref: ref }, other));
});
NextTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * CSS media query when `Mobile` mode will be changed to `Desktop`.
     * @default '@media (pointer: fine)'
     * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
     */
    desktopModeMediaQuery: propTypesExports.string,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        hours: propTypesExports.func,
        minutes: propTypesExports.func,
        seconds: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['hours', 'minutes', 'seconds']).isRequired),
};

const StaticNextTimePicker = React__namespace.forwardRef(function StaticNextTimePicker(inProps, ref) {
    var _a, _b;
    const defaultizedProps = useNextTimePickerDefaultizedProps(inProps, 'MuiStaticNextTimePicker');
    const displayStaticWrapperAs = (_a = defaultizedProps.displayStaticWrapperAs) !== null && _a !== void 0 ? _a : 'mobile';
    const viewRenderers = Object.assign({ hours: renderTimeViewClock, minutes: renderTimeViewClock, seconds: renderTimeViewClock }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the static variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { viewRenderers,
        displayStaticWrapperAs, showToolbar: (_b = defaultizedProps.showToolbar) !== null && _b !== void 0 ? _b : displayStaticWrapperAs === 'mobile' });
    const { renderPicker } = useStaticPicker({
        props,
        valueManager: singleItemValueManager,
        ref,
        validator: validateTime,
    });
    return renderPicker();
});
StaticNextTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Force static wrapper inner components to be rendered in mobile or desktop mode.
     * @default "mobile"
     */
    displayStaticWrapperAs: propTypesExports.oneOf(['desktop', 'mobile']),
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['hours', 'minutes', 'seconds']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        hours: propTypesExports.func,
        minutes: propTypesExports.func,
        seconds: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['hours', 'minutes', 'seconds']).isRequired),
};

function useNextDateTimePickerDefaultizedProps(props, name) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
        props,
        name,
    });
    const ampm = (_a = themeProps.ampm) !== null && _a !== void 0 ? _a : utils.is12HourCycleInCurrentLocale();
    const localeText = React__namespace.useMemo(() => {
        var _a;
        if (((_a = themeProps.localeText) === null || _a === void 0 ? void 0 : _a.toolbarTitle) == null) {
            return themeProps.localeText;
        }
        return Object.assign(Object.assign({}, themeProps.localeText), { dateTimePickerToolbarTitle: themeProps.localeText.toolbarTitle });
    }, [themeProps.localeText]);
    return Object.assign(Object.assign(Object.assign({}, themeProps), applyDefaultViewProps({
        views: themeProps.views,
        openTo: themeProps.openTo,
        defaultViews: ['year', 'day', 'hours', 'minutes'],
        defaultOpenTo: 'day',
    })), { ampm,
        localeText, orientation: (_b = themeProps.orientation) !== null && _b !== void 0 ? _b : 'portrait', ampmInClock: (_c = themeProps.ampmInClock) !== null && _c !== void 0 ? _c : true, 
        // TODO: Remove from public API
        disableIgnoringDatePartForTimeValidation: (_d = themeProps.disableIgnoringDatePartForTimeValidation) !== null && _d !== void 0 ? _d : Boolean(themeProps.minDateTime || themeProps.maxDateTime), disableFuture: (_e = themeProps.disableFuture) !== null && _e !== void 0 ? _e : false, disablePast: (_f = themeProps.disablePast) !== null && _f !== void 0 ? _f : false, minDate: applyDefaultDate(utils, (_g = themeProps.minDateTime) !== null && _g !== void 0 ? _g : themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, (_h = themeProps.maxDateTime) !== null && _h !== void 0 ? _h : themeProps.maxDate, defaultDates.maxDate), minTime: (_j = themeProps.minDateTime) !== null && _j !== void 0 ? _j : themeProps.minTime, maxTime: (_k = themeProps.maxDateTime) !== null && _k !== void 0 ? _k : themeProps.maxTime, components: Object.assign({ Toolbar: DateTimePickerToolbar, Tabs: DateTimePickerTabs }, themeProps.components), componentsProps: Object.assign(Object.assign({}, themeProps.componentsProps), { toolbar: Object.assign({ ampm, ampmInClock: themeProps.ampmInClock }, (_l = themeProps.componentsProps) === null || _l === void 0 ? void 0 : _l.toolbar) }) });
}

const DesktopNextDateTimePicker = React__namespace.forwardRef(function DesktopNextDateTimePicker(inProps, ref) {
    var _a;
    const localeText = useLocaleText();
    // Props with the default values common to all date time pickers
    const _b = useNextDateTimePickerDefaultizedProps(inProps, 'MuiDesktopNextDateTimePicker'), { className, sx } = _b, defaultizedProps = __rest(_b, ["className", "sx"]);
    const viewRenderers = Object.assign({ day: renderDateViewCalendar, month: renderDateViewCalendar, year: renderDateViewCalendar, hours: null, minutes: null, seconds: null }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the desktop variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { viewRenderers, showToolbar: (_a = defaultizedProps.showToolbar) !== null && _a !== void 0 ? _a : false, components: Object.assign({ Field: DateTimeField, OpenPickerIcon: Calendar }, defaultizedProps.components), componentsProps: Object.assign(Object.assign({}, defaultizedProps.componentsProps), { field: (ownerState) => {
                var _a;
                return (Object.assign(Object.assign(Object.assign({}, resolveComponentProps((_a = defaultizedProps.componentsProps) === null || _a === void 0 ? void 0 : _a.field, ownerState)), extractValidationProps(defaultizedProps)), { ref,
                    className,
                    sx, inputRef: defaultizedProps.inputRef, label: defaultizedProps.label, ampm: defaultizedProps.ampm }));
            } }) });
    const { renderPicker } = useDesktopPicker({
        props,
        valueManager: singleItemValueManager,
        getOpenDialogAriaText: localeText.openDatePickerDialogue,
        validator: validateDateTime,
    });
    return renderPicker();
});
DesktopNextDateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
        hours: propTypesExports.func,
        minutes: propTypesExports.func,
        month: propTypesExports.func,
        seconds: propTypesExports.func,
        year: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired),
};

const MobileNextDateTimePicker = React__namespace.forwardRef(function MobileNextDateTimePicker(inProps, ref) {
    var _a;
    const localeText = useLocaleText();
    // Props with the default values common to all date time pickers
    const _b = useNextDateTimePickerDefaultizedProps(inProps, 'MuiMobileNextDateTimePicker'), { className, sx } = _b, defaultizedProps = __rest(_b, ["className", "sx"]);
    const viewRenderers = Object.assign({ day: renderDateViewCalendar, month: renderDateViewCalendar, year: renderDateViewCalendar, hours: renderTimeViewClock, minutes: renderTimeViewClock, seconds: renderTimeViewClock }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the mobile variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { viewRenderers, showToolbar: (_a = defaultizedProps.showToolbar) !== null && _a !== void 0 ? _a : true, components: Object.assign({ Field: DateTimeField }, defaultizedProps.components), componentsProps: Object.assign(Object.assign({}, defaultizedProps.componentsProps), { field: (ownerState) => {
                var _a;
                return (Object.assign(Object.assign(Object.assign({}, resolveComponentProps((_a = defaultizedProps.componentsProps) === null || _a === void 0 ? void 0 : _a.field, ownerState)), extractValidationProps(defaultizedProps)), { ref,
                    className,
                    sx, inputRef: defaultizedProps.inputRef, label: defaultizedProps.label, ampm: defaultizedProps.ampm }));
            } }) });
    const { renderPicker } = useMobilePicker({
        props,
        valueManager: singleItemValueManager,
        getOpenDialogAriaText: localeText.openDatePickerDialogue,
        validator: validateDateTime,
    });
    return renderPicker();
});
MobileNextDateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
        hours: propTypesExports.func,
        minutes: propTypesExports.func,
        month: propTypesExports.func,
        seconds: propTypesExports.func,
        year: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired),
};

const NextDateTimePicker = React__namespace.forwardRef(function NextDateTimePicker(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiNextDateTimePicker' });
    const { desktopModeMediaQuery = '@media (pointer: fine)' } = props, other = __rest(props, ["desktopModeMediaQuery"]);
    // defaults to `true` in environments where `window.matchMedia` would not be available (i.e. test/jsdom)
    const isDesktop = useMediaQuery(desktopModeMediaQuery, { defaultMatches: true });
    if (isDesktop) {
        return React__namespace.createElement(DesktopNextDateTimePicker, Object.assign({ ref: ref }, other));
    }
    return React__namespace.createElement(MobileNextDateTimePicker, Object.assign({ ref: ref }, other));
});
NextDateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * CSS media query when `Mobile` mode will be changed to `Desktop`.
     * @default '@media (pointer: fine)'
     * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
     */
    desktopModeMediaQuery: propTypesExports.string,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
        hours: propTypesExports.func,
        minutes: propTypesExports.func,
        month: propTypesExports.func,
        seconds: propTypesExports.func,
        year: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired),
};

const StaticNextDateTimePicker = React__namespace.forwardRef(function StaticNextDateTimePicker(inProps, ref) {
    var _a, _b, _c;
    const defaultizedProps = useNextDateTimePickerDefaultizedProps(inProps, 'MuiStaticNextDateTimePicker');
    const displayStaticWrapperAs = (_a = defaultizedProps.displayStaticWrapperAs) !== null && _a !== void 0 ? _a : 'mobile';
    const viewRenderers = Object.assign({ day: renderDateViewCalendar, month: renderDateViewCalendar, year: renderDateViewCalendar, hours: renderTimeViewClock, minutes: renderTimeViewClock, seconds: renderTimeViewClock }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the static variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { viewRenderers,
        displayStaticWrapperAs, showToolbar: (_b = defaultizedProps.showToolbar) !== null && _b !== void 0 ? _b : displayStaticWrapperAs === 'mobile', componentsProps: Object.assign(Object.assign({}, defaultizedProps.componentsProps), { tabs: Object.assign({ hidden: displayStaticWrapperAs === 'desktop' }, (_c = defaultizedProps.componentsProps) === null || _c === void 0 ? void 0 : _c.tabs) }) });
    const { renderPicker } = useStaticPicker({
        props,
        valueManager: singleItemValueManager,
        ref,
        validator: validateDateTime,
    });
    return renderPicker();
});
StaticNextDateTimePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    /**
     * Display ampm controls under the clock (instead of in the toolbar).
     * @default false
     */
    ampmInClock: propTypesExports.bool,
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.any,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Force static wrapper inner components to be rendered in mobile or desktop mode.
     * @default "mobile"
     */
    displayStaticWrapperAs: propTypesExports.oneOf(['desktop', 'mobile']),
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired on view change.
     * @template TView
     * @param {TView} view The new view.
     */
    onViewChange: propTypesExports.func,
    /**
     * Callback firing on year change @DateIOType.
     * @template TDate
     * @param {TDate} year The new year.
     */
    onYearChange: propTypesExports.func,
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Force rendering in particular orientation.
     */
    orientation: propTypesExports.oneOf(['landscape', 'portrait']),
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Disable specific date.
     * @template TDate
     * @param {TDate} day The date to test.
     * @returns {boolean} If `true` the date will be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.any,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
        hours: propTypesExports.func,
        minutes: propTypesExports.func,
        month: propTypesExports.func,
        seconds: propTypesExports.func,
        year: propTypesExports.func,
    }),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'hours', 'minutes', 'month', 'seconds', 'year']).isRequired),
};

const isRangeValid = (utils, range) => {
    return Boolean(range && range[0] && range[1] && !utils.isBefore(range[1], range[0]));
};
const isWithinRange = (utils, day, range) => {
    return isRangeValid(utils, range) && utils.isWithinRange(day, range);
};
const isStartOfRange = (utils, day, range) => {
    return isRangeValid(utils, range) && utils.isSameDay(day, range[0]);
};
const isEndOfRange = (utils, day, range) => {
    return isRangeValid(utils, range) && utils.isSameDay(day, range[1]);
};

function calculateRangeChange({ utils, range, newDate: selectedDate, rangePosition, allowRangeFlip = false, }) {
    const [start, end] = range;
    if (rangePosition === 'start') {
        const truthyResult = allowRangeFlip
            ? { nextSelection: 'start', newRange: [end, selectedDate] }
            : { nextSelection: 'end', newRange: [selectedDate, null] };
        return Boolean(end) && utils.isAfter(selectedDate, end)
            ? truthyResult
            : { nextSelection: 'end', newRange: [selectedDate, end] };
    }
    const truthyResult = allowRangeFlip
        ? { nextSelection: 'end', newRange: [selectedDate, start] }
        : { nextSelection: 'end', newRange: [selectedDate, null] };
    return Boolean(start) && utils.isBefore(selectedDate, start)
        ? truthyResult
        : { nextSelection: 'start', newRange: [start, selectedDate] };
}
function calculateRangePreview(options) {
    if (options.newDate == null) {
        return [null, null];
    }
    const [start, end] = options.range;
    const { newRange } = calculateRangeChange(options);
    if (!start || !end) {
        return newRange;
    }
    const [previewStart, previewEnd] = newRange;
    return options.rangePosition === 'end' ? [end, previewEnd] : [previewStart, start];
}

const getDateRangeCalendarUtilityClass = (slot) => generateUtilityClass('MuiDateRangeCalendar', slot);
const dateRangeCalendarClasses = generateUtilityClasses('MuiDateRangeCalendar', ['root', 'monthContainer', 'dayDragging']);

function getDateRangePickerDayUtilityClass(slot) {
    return generateUtilityClass('MuiDateRangePickerDay', slot);
}
const dateRangePickerDayClasses = generateUtilityClasses('MuiDateRangePickerDay', [
    'root',
    'rangeIntervalDayHighlight',
    'rangeIntervalDayHighlightStart',
    'rangeIntervalDayHighlightEnd',
    'rangeIntervalPreview',
    'rangeIntervalDayPreview',
    'rangeIntervalDayPreviewStart',
    'rangeIntervalDayPreviewEnd',
    'day',
    'dayOutsideRangeInterval',
    'dayInsideRangeInterval',
    'notSelectedDate',
]);

const useUtilityClasses$4 = (ownerState) => {
    const { isHighlighting, outsideCurrentMonth, isStartOfHighlighting, isStartOfMonth, isEndOfHighlighting, isEndOfMonth, isPreviewing, isStartOfPreviewing, isEndOfPreviewing, selected, classes, } = ownerState;
    const slots = {
        root: [
            'root',
            isHighlighting && !outsideCurrentMonth && 'rangeIntervalDayHighlight',
            (isStartOfHighlighting || isStartOfMonth) && 'rangeIntervalDayHighlightStart',
            (isEndOfHighlighting || isEndOfMonth) && 'rangeIntervalDayHighlightEnd',
        ],
        rangeIntervalPreview: [
            'rangeIntervalPreview',
            isPreviewing && !outsideCurrentMonth && 'rangeIntervalDayPreview',
            (isStartOfPreviewing || isStartOfMonth) && 'rangeIntervalDayPreviewStart',
            (isEndOfPreviewing || isEndOfMonth) && 'rangeIntervalDayPreviewEnd',
        ],
        day: [
            'day',
            !selected && 'notSelectedDate',
            !isHighlighting && 'dayOutsideRangeInterval',
            !selected && isHighlighting && 'dayInsideRangeInterval',
        ],
    };
    return composeClasses(slots, getDateRangePickerDayUtilityClass, classes);
};
const endBorderStyle = {
    borderTopRightRadius: '50%',
    borderBottomRightRadius: '50%',
};
const startBorderStyle = {
    borderTopLeftRadius: '50%',
    borderBottomLeftRadius: '50%',
};
const DateRangePickerDayRoot = styled$1('div', {
    name: 'MuiDateRangePickerDay',
    slot: 'Root',
    overridesResolver: (_, styles) => [
        {
            [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlight}`]: styles.rangeIntervalDayHighlight,
        },
        {
            [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlightStart}`]: styles.rangeIntervalDayHighlightStart,
        },
        {
            [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlightEnd}`]: styles.rangeIntervalDayHighlightEnd,
        },
        styles.root,
    ],
})(({ theme, ownerState }) => (Object.assign(Object.assign(Object.assign({ [`&:first-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: Object.assign(Object.assign({}, startBorderStyle), { borderLeftColor: (theme.vars || theme).palette.divider }), [`&:last-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: Object.assign(Object.assign({}, endBorderStyle), { borderRightColor: (theme.vars || theme).palette.divider }) }, (ownerState.isHighlighting &&
    !ownerState.outsideCurrentMonth && {
    borderRadius: 0,
    color: (theme.vars || theme).palette.primary.contrastText,
    backgroundColor: theme.vars
        ? `rgba(${theme.vars.palette.primary.lightChannel} / 0.6)`
        : alpha(theme.palette.primary.light, 0.6),
    '&:first-of-type': startBorderStyle,
    '&:last-of-type': endBorderStyle,
})), ((ownerState.isStartOfHighlighting || ownerState.isStartOfMonth) && Object.assign(Object.assign({}, startBorderStyle), { paddingLeft: 0 }))), ((ownerState.isEndOfHighlighting || ownerState.isEndOfMonth) && Object.assign(Object.assign({}, endBorderStyle), { paddingRight: 0 })))));
DateRangePickerDayRoot.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    ownerState: propTypesExports.object.isRequired,
};
const DateRangePickerDayRangeIntervalPreview = styled$1('div', {
    name: 'MuiDateRangePickerDay',
    slot: 'RangeIntervalPreview',
    overridesResolver: (_, styles) => [
        { [`&.${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: styles.rangeIntervalDayPreview },
        {
            [`&.${dateRangePickerDayClasses.rangeIntervalDayPreviewStart}`]: styles.rangeIntervalDayPreviewStart,
        },
        {
            [`&.${dateRangePickerDayClasses.rangeIntervalDayPreviewEnd}`]: styles.rangeIntervalDayPreviewEnd,
        },
        styles.rangeIntervalPreview,
    ],
})(({ theme, ownerState }) => (Object.assign({ 
    // replace default day component margin with transparent border to avoid jumping on preview
    border: '2px solid transparent' }, (ownerState.isPreviewing &&
    !ownerState.outsideCurrentMonth && Object.assign(Object.assign({ borderRadius: 0, border: `2px dashed ${(theme.vars || theme).palette.divider}`, borderLeftColor: 'transparent', borderRightColor: 'transparent' }, ((ownerState.isStartOfPreviewing || ownerState.isStartOfMonth) && Object.assign({ borderLeftColor: (theme.vars || theme).palette.divider }, startBorderStyle))), ((ownerState.isEndOfPreviewing || ownerState.isEndOfMonth) && Object.assign({ borderRightColor: (theme.vars || theme).palette.divider }, endBorderStyle)))))));
DateRangePickerDayRangeIntervalPreview.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    ownerState: propTypesExports.object.isRequired,
};
const DateRangePickerDayDay = styled$1(PickersDay, {
    name: 'MuiDateRangePickerDay',
    slot: 'Day',
    overridesResolver: (_, styles) => [
        { [`&.${dateRangePickerDayClasses.dayInsideRangeInterval}`]: styles.dayInsideRangeInterval },
        { [`&.${dateRangePickerDayClasses.dayOutsideRangeInterval}`]: styles.dayOutsideRangeInterval },
        { [`&.${dateRangePickerDayClasses.notSelectedDate}`]: styles.notSelectedDate },
        styles.day,
    ],
})(({ theme, ownerState }) => (Object.assign(Object.assign(Object.assign(Object.assign({ 
    // Required to overlap preview border
    transform: 'scale(1.1)', '& > *': {
        transform: 'scale(0.9)',
    } }, (!ownerState.selected && {
    backgroundColor: 'transparent',
})), (!ownerState.selected &&
    ownerState.isHighlighting && {
    color: theme.palette.getContrastText(alpha(theme.palette.primary.light, 0.6)),
})), (ownerState.draggable && {
    cursor: 'grab',
})), (ownerState.draggable && {
    touchAction: 'none',
}))));
const DateRangePickerDayRaw = React__namespace.forwardRef(function DateRangePickerDay(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiDateRangePickerDay' });
    const { className, day, outsideCurrentMonth, isEndOfHighlighting, isEndOfPreviewing, isHighlighting, isPreviewing, isStartOfHighlighting, isStartOfPreviewing, selected = false, isVisuallySelected, sx, draggable } = props, other = __rest(props, ["className", "day", "outsideCurrentMonth", "isEndOfHighlighting", "isEndOfPreviewing", "isHighlighting", "isPreviewing", "isStartOfHighlighting", "isStartOfPreviewing", "selected", "isVisuallySelected", "sx", "draggable"]);
    const utils = useUtils();
    const isEndOfMonth = utils.isSameDay(day, utils.endOfMonth(day));
    const isStartOfMonth = utils.isSameDay(day, utils.startOfMonth(day));
    const shouldRenderHighlight = isHighlighting && !outsideCurrentMonth;
    const shouldRenderPreview = isPreviewing && !outsideCurrentMonth;
    const ownerState = Object.assign(Object.assign({}, props), { selected,
        isStartOfMonth,
        isEndOfMonth,
        draggable });
    const classes = useUtilityClasses$4(ownerState);
    return (React__namespace.createElement(DateRangePickerDayRoot, { "data-mui-test": shouldRenderHighlight ? 'DateRangeHighlight' : undefined, className: clsx(classes.root, className), ownerState: ownerState, sx: sx },
        React__namespace.createElement(DateRangePickerDayRangeIntervalPreview, { "data-mui-test": shouldRenderPreview ? 'DateRangePreview' : undefined, className: classes.rangeIntervalPreview, ownerState: ownerState },
            React__namespace.createElement(DateRangePickerDayDay, Object.assign({}, other, { ref: ref, disableMargin: true, day: day, selected: isVisuallySelected, outsideCurrentMonth: outsideCurrentMonth, "data-mui-test": "DateRangePickerDay", className: classes.day, ownerState: ownerState, draggable: draggable })))));
});
DateRangePickerDayRaw.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * A ref for imperative actions.
     * It currently only supports `focusVisible()` action.
     */
    action: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.shape({
                focusVisible: propTypesExports.func.isRequired,
            }),
        }),
    ]),
    /**
     * If `true`, the ripples are centered.
     * They won't start at the cursor interaction position.
     * @default false
     */
    centerRipple: propTypesExports.bool,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: propTypesExports.object,
    className: propTypesExports.string,
    /**
     * The date to show.
     */
    day: propTypesExports.any.isRequired,
    /**
     * If `true`, renders as disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * If `true`, days are rendering without margin. Useful for displaying linked range of days.
     * @default false
     */
    disableMargin: propTypesExports.bool,
    /**
     * If `true`, the ripple effect is disabled.
     *
     *  Without a ripple there is no styling for :focus-visible by default. Be sure
     * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
     * @default false
     */
    disableRipple: propTypesExports.bool,
    /**
     * If `true`, the touch ripple effect is disabled.
     * @default false
     */
    disableTouchRipple: propTypesExports.bool,
    /**
     * If `true`, the base button will have a keyboard focus ripple.
     * @default false
     */
    focusRipple: propTypesExports.bool,
    /**
     * This prop can help identify which element has keyboard focus.
     * The class name will be applied when the element gains the focus through keyboard interaction.
     * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
     * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
     * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
     * if needed.
     */
    focusVisibleClassName: propTypesExports.string,
    isAnimating: propTypesExports.bool,
    /**
     * Set to `true` if the `day` is the end of a highlighted date range.
     */
    isEndOfHighlighting: propTypesExports.bool.isRequired,
    /**
     * Set to `true` if the `day` is the start of a previewing date range.
     */
    isEndOfPreviewing: propTypesExports.bool.isRequired,
    /**
     * Set to `true` if the `day` is in a highlighted date range.
     */
    isHighlighting: propTypesExports.bool.isRequired,
    /**
     * Set to `true` if the `day` is in a preview date range.
     */
    isPreviewing: propTypesExports.bool.isRequired,
    /**
     * Set to `true` if the `day` is the start of a highlighted date range.
     */
    isStartOfHighlighting: propTypesExports.bool.isRequired,
    /**
     * Set to `true` if the `day` is the end of a previewing date range.
     */
    isStartOfPreviewing: propTypesExports.bool.isRequired,
    /**
     * Indicates if the day should be visually selected.
     */
    isVisuallySelected: propTypesExports.bool,
    onDaySelect: propTypesExports.func.isRequired,
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible: propTypesExports.func,
    onMouseEnter: propTypesExports.func,
    /**
     * If `true`, day is outside of month and will be hidden.
     */
    outsideCurrentMonth: propTypesExports.bool.isRequired,
    /**
     * If `true`, renders as selected.
     * @default false
     */
    selected: propTypesExports.bool,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    style: propTypesExports.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * @default 0
     */
    tabIndex: propTypesExports.number,
    /**
     * If `true`, renders as today date.
     * @default false
     */
    today: propTypesExports.bool,
    /**
     * Props applied to the `TouchRipple` element.
     */
    TouchRippleProps: propTypesExports.object,
    /**
     * A ref that points to the `TouchRipple` element.
     */
    touchRippleRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.shape({
                pulsate: propTypesExports.func.isRequired,
                start: propTypesExports.func.isRequired,
                stop: propTypesExports.func.isRequired,
            }),
        }),
    ]),
};
/**
 *
 * Demos:
 *
 * - [Date Range Picker](https://mui.com/x/react-date-pickers/date-range-picker/)
 *
 * API:
 *
 * - [DateRangePickerDay API](https://mui.com/x/api/date-pickers/date-range-picker-day/)
 */
const DateRangePickerDay = React__namespace.memo(DateRangePickerDayRaw);

const splitDateRangeSections = (sections) => {
    const startDateSections = [];
    const endDateSections = [];
    sections.forEach((section) => {
        if (section.dateName === 'start') {
            startDateSections.push(section);
        }
        else {
            endDateSections.push(section);
        }
    });
    return { startDate: startDateSections, endDate: endDateSections };
};
const removeLastSeparator = (dateSections) => dateSections.map((section, sectionIndex) => {
    if (sectionIndex === dateSections.length - 1) {
        return Object.assign(Object.assign({}, section), { separator: null });
    }
    return section;
});

const rangeValueManager = {
    emptyValue: [null, null],
    getTodayValue: (utils) => [utils.date(), utils.date()],
    cleanValue: (utils, value) => value.map((date) => replaceInvalidDateByNull(utils, date)),
    areValuesEqual: (utils, a, b) => utils.isEqual(a[0], b[0]) && utils.isEqual(a[1], b[1]),
    isSameError: (a, b) => b !== null && a[1] === b[1] && a[0] === b[0],
    defaultErrorState: [null, null],
};
const rangeFieldValueManager = {
    updateReferenceValue: (utils, value, prevReferenceValue) => {
        const shouldKeepStartDate = value[0] != null && utils.isValid(value[0]);
        const shouldKeepEndDate = value[1] != null && utils.isValid(value[1]);
        if (!shouldKeepStartDate && !shouldKeepEndDate) {
            return prevReferenceValue;
        }
        if (shouldKeepStartDate && shouldKeepEndDate) {
            return value;
        }
        if (shouldKeepStartDate) {
            return [value[0], prevReferenceValue[0]];
        }
        return [prevReferenceValue[1], value[1]];
    },
    getSectionsFromValue: (utils, localeText, prevSections, [start, end], format) => {
        const prevDateRangeSections = prevSections == null
            ? { startDate: null, endDate: null }
            : splitDateRangeSections(prevSections);
        const getSections = (newDate, prevDateSections, position) => {
            const shouldReUsePrevDateSections = !utils.isValid(newDate) && !!prevDateSections;
            if (shouldReUsePrevDateSections) {
                return prevDateSections;
            }
            const sections = splitFormatIntoSections(utils, localeText, format, newDate);
            return sections.map((section, sectionIndex) => {
                if (sectionIndex === sections.length - 1 && position === 'start') {
                    return Object.assign(Object.assign({}, section), { dateName: position, endSeparator: `${section.endSeparator}\u2069  \u2066` });
                }
                return Object.assign(Object.assign({}, section), { dateName: position });
            });
        };
        return addPositionPropertiesToSections([
            ...getSections(start, prevDateRangeSections.startDate, 'start'),
            ...getSections(end, prevDateRangeSections.endDate, 'end'),
        ]);
    },
    getValueStrFromSections: (sections) => {
        const dateRangeSections = splitDateRangeSections(sections);
        return createDateStrForInputFromSections([
            ...dateRangeSections.startDate,
            ...dateRangeSections.endDate,
        ]);
    },
    getActiveDateSections: (sections, activeSection) => {
        const index = activeSection.dateName === 'start' ? 0 : 1;
        const dateRangeSections = splitDateRangeSections(sections);
        return index === 0
            ? removeLastSeparator(dateRangeSections.startDate)
            : dateRangeSections.endDate;
    },
    parseValueStr: (valueStr, referenceValue, parseDate) => {
        // TODO: Improve because it would not work if the date format has `` as a separator.
        const [startStr, endStr] = valueStr.split('');
        return [startStr, endStr].map((dateStr, index) => {
            if (dateStr == null) {
                return null;
            }
            return parseDate(dateStr.trim(), referenceValue[index]);
        });
    },
    getActiveDateManager: (utils, state, activeSection) => {
        const index = activeSection.dateName === 'start' ? 0 : 1;
        const updateDateInRange = (newDate, prevDateRange) => (index === 0 ? [newDate, prevDateRange[1]] : [prevDateRange[0], newDate]);
        return {
            activeDate: state.value[index],
            referenceActiveDate: state.referenceValue[index],
            getNewValueFromNewActiveDate: (newActiveDate) => ({
                value: updateDateInRange(newActiveDate, state.value),
                referenceValue: newActiveDate == null || !utils.isValid(newActiveDate)
                    ? state.referenceValue
                    : updateDateInRange(newActiveDate, state.referenceValue),
            }),
        };
    },
    hasError: (error) => error[0] != null || error[1] != null,
    getSectionOrder: (utils, localeText, format, isRTL) => {
        const splitedFormat = splitFormatIntoSections(utils, localeText, format, null);
        return getSectionOrder([
            ...splitedFormat.slice(0, splitedFormat.length - 1),
            Object.assign(Object.assign({}, splitedFormat[splitedFormat.length - 1]), { endSeparator: '  ' }),
            ...splitedFormat,
        ], isRTL);
    },
};

const resolveDateFromTarget = (target, utils) => {
    const timestampString = target.dataset.timestamp;
    if (!timestampString) {
        return null;
    }
    const timestamp = +timestampString;
    return utils.date(new Date(timestamp));
};
const isSameAsDraggingDate = (event) => {
    const timestampString = event.target.dataset.timestamp;
    return timestampString === event.dataTransfer.getData('draggingDate');
};
const resolveButtonElement = (element) => {
    if (element) {
        if (element instanceof HTMLButtonElement && !element.disabled) {
            return element;
        }
        if (element.children.length) {
            return resolveButtonElement(element.children[0]);
        }
        return null;
    }
    return element;
};
const resolveElementFromTouch = (event, ignoreTouchTarget) => {
    var _a;
    // don't parse multi-touch result
    if (((_a = event.changedTouches) === null || _a === void 0 ? void 0 : _a.length) === 1 && event.touches.length <= 1) {
        const element = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
        // `elementFromPoint` could have resolved preview div or wrapping div
        // might need to recursively find the nested button
        const buttonElement = resolveButtonElement(element);
        if (ignoreTouchTarget && buttonElement === event.changedTouches[0].target) {
            return null;
        }
        return buttonElement;
    }
    return null;
};
const useDragRangeEvents = ({ utils, setRangeDragDay, setIsDragging, isDragging, onDatePositionChange, onDrop, disableDragEditing, dateRange, }) => {
    const emptyDragImgRef = React__namespace.useRef(null);
    React__namespace.useEffect(() => {
        // Preload the image - required for Safari support: https://stackoverflow.com/a/40923520/3303436
        emptyDragImgRef.current = document.createElement('img');
        emptyDragImgRef.current.src =
            'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    }, []);
    const isElementDraggable = (day) => {
        if (day == null) {
            return false;
        }
        const shouldInitDragging = !disableDragEditing && !!dateRange[0] && !!dateRange[1];
        const isSelectedStartDate = isStartOfRange(utils, day, dateRange);
        const isSelectedEndDate = isEndOfRange(utils, day, dateRange);
        return shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);
    };
    const handleDragStart = _default$2((event) => {
        const newDate = resolveDateFromTarget(event.target, utils);
        if (!isElementDraggable(newDate)) {
            return;
        }
        event.stopPropagation();
        if (emptyDragImgRef.current) {
            event.dataTransfer.setDragImage(emptyDragImgRef.current, 0, 0);
        }
        setRangeDragDay(newDate);
        event.dataTransfer.effectAllowed = 'move';
        setIsDragging(true);
        const buttonDataset = event.target.dataset;
        if (buttonDataset.timestamp) {
            event.dataTransfer.setData('draggingDate', buttonDataset.timestamp);
        }
        if (buttonDataset.position) {
            onDatePositionChange(buttonDataset.position);
        }
    });
    const handleTouchStart = _default$2((event) => {
        const target = resolveElementFromTouch(event);
        if (!target) {
            return;
        }
        const newDate = resolveDateFromTarget(target, utils);
        if (!isElementDraggable(newDate)) {
            return;
        }
        setRangeDragDay(newDate);
        setIsDragging(true);
        const button = event.target;
        const buttonDataset = button.dataset;
        if (buttonDataset.position) {
            onDatePositionChange(buttonDataset.position);
        }
    });
    const handleDragEnter = _default$2((event) => {
        if (!isDragging) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        event.dataTransfer.dropEffect = 'move';
        setRangeDragDay(resolveDateFromTarget(event.target, utils));
    });
    const handleTouchMove = _default$2((event) => {
        const target = resolveElementFromTouch(event);
        if (!isDragging || !target) {
            return;
        }
        const newDate = resolveDateFromTarget(target, utils);
        if (newDate) {
            setRangeDragDay(newDate);
        }
    });
    const handleDragLeave = _default$2((event) => {
        if (!isDragging) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
    });
    const handleDragOver = _default$2((event) => {
        if (!isDragging) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        event.dataTransfer.dropEffect = 'move';
    });
    const handleTouchEnd = _default$2((event) => {
        if (!isDragging) {
            return;
        }
        setRangeDragDay(null);
        setIsDragging(false);
        const target = resolveElementFromTouch(event, true);
        if (!target) {
            return;
        }
        // make sure the focused element is the element where touch ended
        target.focus();
        const newDate = resolveDateFromTarget(target, utils);
        if (newDate) {
            onDrop(newDate);
        }
    });
    const handleDragEnd = _default$2((event) => {
        if (!isDragging) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        setIsDragging(false);
        setRangeDragDay(null);
    });
    const handleDrop = _default$2((event) => {
        if (!isDragging) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        setIsDragging(false);
        setRangeDragDay(null);
        // make sure the focused element is the element where drop ended
        event.currentTarget.focus();
        if (isSameAsDraggingDate(event)) {
            return;
        }
        const newDate = resolveDateFromTarget(event.target, utils);
        if (newDate) {
            onDrop(newDate);
        }
    });
    return {
        onDragStart: handleDragStart,
        onDragEnter: handleDragEnter,
        onDragLeave: handleDragLeave,
        onDragOver: handleDragOver,
        onDragEnd: handleDragEnd,
        onDrop: handleDrop,
        onTouchStart: handleTouchStart,
        onTouchMove: handleTouchMove,
        onTouchEnd: handleTouchEnd,
    };
};
const useDragRange = ({ disableDragEditing, utils, onDatePositionChange, onDrop, dateRange, }) => {
    const [isDragging, setIsDragging] = React__namespace.useState(false);
    const [rangeDragDay, setRangeDragDay] = React__namespace.useState(null);
    const handleRangeDragDayChange = _default$2((val) => {
        if (!utils.isEqual(val, rangeDragDay)) {
            setRangeDragDay(val);
        }
    });
    const draggingDatePosition = React__namespace.useMemo(() => {
        const [start, end] = dateRange;
        if (rangeDragDay) {
            if (start && utils.isBefore(rangeDragDay, start)) {
                return 'start';
            }
            if (end && utils.isAfter(rangeDragDay, end)) {
                return 'end';
            }
        }
        return null;
    }, [dateRange, rangeDragDay, utils]);
    const dragRangeEvents = useDragRangeEvents({
        utils,
        onDatePositionChange,
        onDrop,
        setIsDragging,
        isDragging,
        setRangeDragDay: handleRangeDragDayChange,
        disableDragEditing,
        dateRange,
    });
    return React__namespace.useMemo(() => (Object.assign({ isDragging,
        rangeDragDay,
        draggingDatePosition }, (!disableDragEditing ? dragRangeEvents : {}))), [isDragging, rangeDragDay, draggingDatePosition, disableDragEditing, dragRangeEvents]);
};

const DateRangeCalendarRoot = styled$1('div', {
    name: 'MuiDateRangeCalendar',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})({
    display: 'flex',
    flexDirection: 'row',
});
const DateRangeCalendarMonthContainer = styled$1('div', {
    name: 'MuiDateRangeCalendar',
    slot: 'Container',
    overridesResolver: (_, styles) => styles.monthContainer,
})(({ theme }) => ({
    '&:not(:last-of-type)': {
        borderRight: `2px solid ${(theme.vars || theme).palette.divider}`,
    },
}));
const DateRangeCalendarArrowSwitcher = styled$1(PickersArrowSwitcher)({
    padding: '16px 16px 8px 16px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
});
const DAY_RANGE_SIZE$1 = 40;
const weeksContainerHeight$1 = (DAY_RANGE_SIZE$1 + DAY_MARGIN * 2) * 6;
const DayCalendarForRange = styled$1(DayCalendar)(({ theme }) => ({
    minWidth: 312,
    minHeight: weeksContainerHeight$1,
    [`&.${dateRangeCalendarClasses.dayDragging}`]: {
        [`& .${dateRangePickerDayClasses.day}`]: {
            cursor: 'grabbing',
        },
        [`& .${dateRangePickerDayClasses.root}:not(.${dateRangePickerDayClasses.rangeIntervalDayHighlightStart}):not(.${dateRangePickerDayClasses.rangeIntervalDayHighlightEnd}) .${dateRangePickerDayClasses.day}:not(.${dateRangePickerDayClasses.notSelectedDate})`]: {
            // we can't override `PickersDay` background color here, because it's styles take precedence
            opacity: 0.6,
        },
    },
    [`&:not(.${dateRangeCalendarClasses.dayDragging}) .${dateRangePickerDayClasses.dayOutsideRangeInterval}`]: {
        '@media (pointer: fine)': {
            '&:hover': {
                border: `1px solid ${(theme.vars || theme).palette.grey[500]}`,
            },
        },
    },
}));
function useDateRangeCalendarDefaultizedProps(props, name) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
        props,
        name,
    });
    return Object.assign(Object.assign({ openTo: (_a = props.openTo) !== null && _a !== void 0 ? _a : 'day', views: (_b = props.views) !== null && _b !== void 0 ? _b : ['year', 'day'], reduceAnimations: (_c = themeProps.reduceAnimations) !== null && _c !== void 0 ? _c : defaultReduceAnimations, renderLoading: (_d = themeProps.renderLoading) !== null && _d !== void 0 ? _d : (() => React__namespace.createElement("span", { "data-mui-test": "loading-progress" }, "...")) }, themeProps), { loading: (_e = props.loading) !== null && _e !== void 0 ? _e : false, disablePast: (_f = props.disablePast) !== null && _f !== void 0 ? _f : false, disableFuture: (_g = props.disableFuture) !== null && _g !== void 0 ? _g : false, minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate), calendars: (_h = themeProps.calendars) !== null && _h !== void 0 ? _h : 2, disableDragEditing: (_j = themeProps.disableDragEditing) !== null && _j !== void 0 ? _j : false });
}
const useUtilityClasses$3 = (ownerState) => {
    const { classes, isDragging } = ownerState;
    const slots = {
        root: ['root'],
        monthContainer: ['monthContainer'],
        dayCalendar: [isDragging && 'dayDragging'],
    };
    return composeClasses(slots, getDateRangeCalendarUtilityClass, classes);
};
const DateRangeCalendar = React__namespace.forwardRef(function DateRangeCalendar(inProps, ref) {
    const utils = useUtils();
    const localeText = useLocaleText();
    const now = useNow();
    const props = useDateRangeCalendarDefaultizedProps(inProps, 'MuiDateRangeCalendar');
    const isMobile = React__namespace.useContext(WrapperVariantContext) === 'mobile';
    const { onViewChange, value: valueProp, defaultValue, onChange, className, disableFuture, disablePast, minDate, maxDate, shouldDisableDate, shouldDisableMonth, shouldDisableYear, view: inView, views, openTo, reduceAnimations, onYearChange, onMonthChange, defaultCalendarMonth, rangePosition: rangePositionProps, onRangePositionChange, calendars, components, componentsProps, loading, renderLoading, disableHighlightToday, readOnly, disabled, focusedView: inFocusedView, onFocusedViewChange, showDaysOutsideCurrentMonth, dayOfWeekFormatter, disableAutoMonthSwitching, autoFocus, fixedWeekNumber, disableDragEditing, displayWeekNumber } = props, other = __rest(props, ["onViewChange", "value", "defaultValue", "onChange", "className", "disableFuture", "disablePast", "minDate", "maxDate", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "reduceAnimations", "onYearChange", "onMonthChange", "defaultCalendarMonth", "rangePosition", "onRangePositionChange", "calendars", "components", "componentsProps", "loading", "renderLoading", "disableHighlightToday", "readOnly", "disabled", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "dayOfWeekFormatter", "disableAutoMonthSwitching", "autoFocus", "fixedWeekNumber", "disableDragEditing", "displayWeekNumber"]);
    const [currentView, setCurrentView] = _default({
        name: 'DateRangeCalendar',
        controlled: inView,
        default: inView || 'day'
    });
    const [value, setValue] = _default({
        controlled: valueProp,
        default: defaultValue !== null && defaultValue !== void 0 ? defaultValue : rangeValueManager.emptyValue,
        name: 'DateRangeCalendar',
        state: 'value',
    });
    const [rangePosition, setRangePosition] = _default({
        controlled: rangePositionProps,
        default: 'start',
        name: 'DateRangeCalendar',
        state: 'rangePosition',
    });
    const handleDatePositionChange = _default$2((position) => {
        if (rangePosition !== position) {
            setRangePosition(position);
        }
    });
    const handleSelectedDayChange = _default$2((newDate, selectionState, allowRangeFlip = false) => {
        const isSameRangePosition = currentView !== 'day';
        const forcedRangePosition = isSameRangePosition ? rangePosition : null;
        const { nextSelection, newRange } = calculateRangeChange({
            newDate,
            utils,
            range: value,
            rangePosition: forcedRangePosition ? forcedRangePosition : rangePosition,
            allowRangeFlip,
        });
        setRangePosition(forcedRangePosition ? forcedRangePosition : nextSelection);
        onRangePositionChange === null || onRangePositionChange === void 0 ? void 0 : onRangePositionChange(forcedRangePosition ? forcedRangePosition : nextSelection);
        const isFullRangeSelected = rangePosition === 'end' && isRangeValid(utils, newRange);
        setValue(newRange);
        onChange === null || onChange === void 0 ? void 0 : onChange(newRange, isFullRangeSelected ? 'finish' : 'partial');
    });
    const handleDrop = _default$2((newDate) => {
        handleSelectedDayChange(newDate, undefined, true);
    });
    const shouldDisableDragEditing = disableDragEditing || disabled || readOnly;
    // Range going for the start of the start day to the end of the end day.
    // This makes sure that `isWithinRange` works with any time in the start and end day.
    const valueDayRange = React__namespace.useMemo(() => [
        value[0] == null || !utils.isValid(value[0]) ? value[0] : utils.startOfDay(value[0]),
        value[1] == null || !utils.isValid(value[1]) ? value[1] : utils.endOfDay(value[1]),
    ], [value, utils]);
    const _a = useDragRange({
        disableDragEditing: shouldDisableDragEditing,
        onDrop: handleDrop,
        onDatePositionChange: handleDatePositionChange,
        utils,
        dateRange: valueDayRange,
    }), { isDragging, rangeDragDay, draggingDatePosition } = _a, dragEventHandlers = __rest(_a, ["isDragging", "rangeDragDay", "draggingDatePosition"]);
    const ownerState = Object.assign(Object.assign({}, props), { isDragging });
    const classes = useUtilityClasses$3(ownerState);
    const draggingRange = React__namespace.useMemo(() => {
        if (!valueDayRange[0] || !valueDayRange[1] || !rangeDragDay) {
            return [null, null];
        }
        const newRange = calculateRangeChange({
            utils,
            range: valueDayRange,
            newDate: rangeDragDay,
            rangePosition,
            allowRangeFlip: true,
        }).newRange;
        return newRange[0] !== null && newRange[1] !== null
            ? [utils.startOfDay(newRange[0]), utils.endOfDay(newRange[1])]
            : newRange;
    }, [rangePosition, rangeDragDay, utils, valueDayRange]);
    const wrappedShouldDisableDate = React__namespace.useMemo(() => {
        if (!shouldDisableDate) {
            return undefined;
        }
        return (dayToTest) => shouldDisableDate(dayToTest, draggingDatePosition || rangePosition);
    }, [shouldDisableDate, rangePosition, draggingDatePosition]);
    const { calendarState, changeFocusedDay, changeMonth, handleChangeMonth, onMonthSwitchingAnimationEnd, isDateDisabled } = useCalendarState({
        value: value[0] || value[1],
        defaultCalendarMonth,
        disableFuture,
        disablePast,
        disableSwitchToMonthOnDayFocus: true,
        maxDate,
        minDate,
        onMonthChange,
        reduceAnimations,
        shouldDisableDate: wrappedShouldDisableDate,
    });
    const prevValue = React__namespace.useRef(null);
    React__namespace.useEffect(() => {
        var _a, _b;
        const date = rangePosition === 'start' ? value[0] : value[1];
        if (!date || !utils.isValid(date)) {
            return;
        }
        const prevDate = rangePosition === 'start' ? (_a = prevValue.current) === null || _a === void 0 ? void 0 : _a[0] : (_b = prevValue.current) === null || _b === void 0 ? void 0 : _b[1];
        prevValue.current = value;
        // The current date did not change, this call comes either from a `rangePosition` change or a change in the other date.
        // In both cases, we don't want to change the visible month(s).
        if (disableAutoMonthSwitching && prevDate && utils.isEqual(prevDate, date)) {
            return;
        }
        const displayingMonthRange = calendars - 1;
        const currentMonthNumber = utils.getMonth(calendarState.currentMonth);
        const requestedMonthNumber = utils.getMonth(date);
        if (!utils.isSameYear(calendarState.currentMonth, date) ||
            requestedMonthNumber < currentMonthNumber ||
            requestedMonthNumber > currentMonthNumber + displayingMonthRange) {
            const newMonth = rangePosition === 'start'
                ? date
                : // If need to focus end, scroll to the state when "end" is displaying in the last calendar
                    utils.addMonths(date, -displayingMonthRange);
            changeMonth(newMonth);
        }
    }, [rangePosition, value]); // eslint-disable-line
    const selectNextMonth = React__namespace.useCallback(() => {
        changeMonth(utils.getNextMonth(calendarState.currentMonth));
    }, [changeMonth, calendarState.currentMonth, utils]);
    const selectPreviousMonth = React__namespace.useCallback(() => {
        changeMonth(utils.getPreviousMonth(calendarState.currentMonth));
    }, [changeMonth, calendarState.currentMonth, utils]);
    const isNextMonthDisabled = useNextMonthDisabled(calendarState.currentMonth, {
        disableFuture,
        maxDate,
    });
    const isPreviousMonthDisabled = usePreviousMonthDisabled(calendarState.currentMonth, {
        disablePast,
        minDate,
    });
    const baseDateValidationProps = {
        disablePast,
        disableFuture,
        maxDate,
        minDate,
    };
    const commonViewProps = {
        disableHighlightToday,
        readOnly,
        disabled,
    };
    // When disabled, limit the view to the selected date
    const minDateWithDisabled = (disabled && value[0]) || minDate;
    const maxDateWithDisabled = (disabled && value[1]) || maxDate;
    const [rangePreviewDay, setRangePreviewDay] = React__namespace.useState(null);
    const CalendarTransitionProps = React__namespace.useMemo(() => ({
        onMouseLeave: () => setRangePreviewDay(null),
    }), []);
    const previewingRange = calculateRangePreview({
        utils,
        range: valueDayRange,
        newDate: rangePreviewDay,
        rangePosition,
    });
    const handleDayMouseEnter = _default$2((event, newPreviewRequest) => {
        if (!isWithinRange(utils, newPreviewRequest, valueDayRange)) {
            setRangePreviewDay(newPreviewRequest);
        }
        else {
            setRangePreviewDay(null);
        }
    });
    const componentsForDayCalendar = Object.assign({ Day: DateRangePickerDay }, components);
    const componentsPropsForDayCalendar = Object.assign(Object.assign({}, componentsProps), { day: (dayOwnerState) => {
            var _a;
            const { day } = dayOwnerState;
            const isSelectedStartDate = isStartOfRange(utils, day, valueDayRange);
            const isSelectedEndDate = isEndOfRange(utils, day, valueDayRange);
            const shouldInitDragging = !shouldDisableDragEditing && valueDayRange[0] && valueDayRange[1];
            const isElementDraggable = shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);
            let datePosition;
            if (isSelectedStartDate) {
                datePosition = 'start';
            }
            else if (isSelectedEndDate) {
                datePosition = 'end';
            }
            const isStartOfHighlighting = isDragging
                ? isStartOfRange(utils, day, draggingRange)
                : isSelectedStartDate;
            const isEndOfHighlighting = isDragging
                ? isEndOfRange(utils, day, draggingRange)
                : isSelectedEndDate;
            return Object.assign(Object.assign(Object.assign({ isPreviewing: isMobile ? false : isWithinRange(utils, day, previewingRange), isStartOfPreviewing: isMobile ? false : isStartOfRange(utils, day, previewingRange), isEndOfPreviewing: isMobile ? false : isEndOfRange(utils, day, previewingRange), isHighlighting: isWithinRange(utils, day, isDragging ? draggingRange : valueDayRange), isStartOfHighlighting, isEndOfHighlighting: isDragging
                    ? isEndOfRange(utils, day, draggingRange)
                    : isSelectedEndDate, onMouseEnter: handleDayMouseEnter, 
                // apply selected styling to the dragging start or end day
                isVisuallySelected: dayOwnerState.selected || (isDragging && (isStartOfHighlighting || isEndOfHighlighting)), 'data-position': datePosition }, dragEventHandlers), { draggable: isElementDraggable ? true : undefined }), ((_a = resolveComponentProps(componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.day, dayOwnerState)) !== null && _a !== void 0 ? _a : {}));
        } });
    const visibleMonths = React__namespace.useMemo(() => Array.from({ length: calendars }).map((_, index) => utils.setMonth(calendarState.currentMonth, utils.getMonth(calendarState.currentMonth) + index)), [utils, calendarState.currentMonth, calendars]);
    const focusedMonth = React__namespace.useMemo(() => {
        var _a;
        if (!autoFocus) {
            return null;
        }
        // The focus priority of the "day" view is as follows:
        // 1. Month of the `start` date
        // 2. Month of the `end` date
        // 3. Month of the current date
        // 4. First visible month
        if (value[0] != null) {
            return visibleMonths.find((month) => utils.isSameMonth(month, value[0]));
        }
        if (value[1] != null) {
            return visibleMonths.find((month) => utils.isSameMonth(month, value[1]));
        }
        return (_a = visibleMonths.find((month) => utils.isSameMonth(month, now))) !== null && _a !== void 0 ? _a : visibleMonths[0];
    }, [utils, value, visibleMonths, autoFocus, now]);
    const { view, setView, focusedView, setFocusedView, goToNextView, setValueAndGoToNextView } = useViews({
        view: inView,
        views,
        openTo,
        onChange: handleSelectedDayChange,
        onViewChange,
        autoFocus,
        focusedView: inFocusedView,
        onFocusedViewChange,
    });
    React__namespace.useEffect(() => {
        setCurrentView(view);
    }, [view]);
    const hasFocus = focusedView !== null;
    const handleDateMonthChange = _default$2((newDate) => {
        const startOfMonth = utils.startOfMonth(newDate);
        const endOfMonth = utils.endOfMonth(newDate);
        const closestEnabledDate = isDateDisabled(newDate)
            ? findClosestEnabledDate({
                utils,
                date: newDate,
                minDate: utils.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
                maxDate: utils.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
                disablePast,
                disableFuture,
                isDateDisabled,
            })
            : newDate;
        if (closestEnabledDate) {
            setValueAndGoToNextView(closestEnabledDate, 'finish');
            onMonthChange === null || onMonthChange === void 0 ? void 0 : onMonthChange(startOfMonth);
        }
        else {
            goToNextView();
            changeMonth(startOfMonth);
        }
        changeFocusedDay(closestEnabledDate, true);
    });
    const handleDateYearChange = _default$2((newDate) => {
        const startOfYear = utils.startOfYear(newDate);
        const endOfYear = utils.endOfYear(newDate);
        const closestEnabledDate = isDateDisabled(newDate)
            ? findClosestEnabledDate({
                utils,
                date: newDate,
                minDate: utils.isBefore(minDate, startOfYear) ? startOfYear : minDate,
                maxDate: utils.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
                disablePast,
                disableFuture,
                isDateDisabled,
            })
            : newDate;
        if (closestEnabledDate) {
            setValueAndGoToNextView(closestEnabledDate, 'finish');
            onYearChange === null || onYearChange === void 0 ? void 0 : onYearChange(closestEnabledDate);
        }
        else {
            goToNextView();
            changeMonth(startOfYear);
        }
        changeFocusedDay(closestEnabledDate, true);
    });
    return (React__namespace.createElement(DateRangeCalendarRoot, Object.assign({ ref: ref, className: clsx(className, classes.root), ownerState: ownerState }, other), visibleMonths.map((month, index) => (React__namespace.createElement(DateRangeCalendarMonthContainer, { key: month.toString(), className: classes.monthContainer },
        calendars === 1 ? (React__namespace.createElement(PickersCalendarHeader, { views: views, view: view, currentMonth: calendarState.currentMonth, onViewChange: (newView) => {
                setView(newView);
                setCurrentView(newView);
            }, onMonthChange: (newMonth, direction) => handleChangeMonth({ newMonth, direction }), minDate: minDateWithDisabled, maxDate: maxDateWithDisabled, disabled: disabled, disablePast: disablePast, disableFuture: disableFuture, reduceAnimations: reduceAnimations, components: components, componentsProps: componentsProps })) : (React__namespace.createElement(DateRangeCalendarArrowSwitcher, { onGoToPrevious: selectPreviousMonth, onGoToNext: selectNextMonth, isPreviousHidden: index !== 0, isPreviousDisabled: isPreviousMonthDisabled, previousLabel: localeText.previousMonth, isNextHidden: index !== calendars - 1, isNextDisabled: isNextMonthDisabled, nextLabel: localeText.nextMonth, components: components, componentsProps: componentsProps }, utils.format(month, 'monthAndYear'))),
        view === 'year' && (React__namespace.createElement(YearCalendar, Object.assign({}, baseDateValidationProps, commonViewProps, { value: rangePosition === 'start' ? value[0] : value[1], onChange: handleDateYearChange, shouldDisableYear: shouldDisableYear, hasFocus: hasFocus, onFocusedViewChange: (isViewFocused) => setFocusedView('year', isViewFocused) }))),
        view === 'month' && (React__namespace.createElement(MonthCalendar, Object.assign({}, baseDateValidationProps, commonViewProps, { hasFocus: hasFocus, className: className, value: rangePosition === 'start' ? value[0] : value[1], onChange: handleDateMonthChange, shouldDisableMonth: shouldDisableMonth, onFocusedViewChange: (isViewFocused) => setFocusedView('month', isViewFocused) }))),
        view === 'day' && (React__namespace.createElement(DayCalendarForRange, Object.assign({ key: index, className: classes.dayCalendar }, calendarState, baseDateValidationProps, commonViewProps, { onMonthSwitchingAnimationEnd: onMonthSwitchingAnimationEnd, onFocusedDayChange: changeFocusedDay, reduceAnimations: reduceAnimations, selectedDays: value, onSelectedDaysChange: handleSelectedDayChange, currentMonth: month, TransitionProps: CalendarTransitionProps, shouldDisableDate: wrappedShouldDisableDate, showDaysOutsideCurrentMonth: showDaysOutsideCurrentMonth, dayOfWeekFormatter: dayOfWeekFormatter, loading: loading, renderLoading: renderLoading, components: componentsForDayCalendar, componentsProps: componentsPropsForDayCalendar, autoFocus: month === focusedMonth, fixedWeekNumber: fixedWeekNumber, displayWeekNumber: displayWeekNumber }))))))));
});
DateRangeCalendar.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * The number of calendars to render.
     * @default 2
     */
    calendars: propTypesExports.oneOf([1, 2, 3]),
    classes: propTypesExports.object,
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={[null, null]}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default selected value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
     * @default false
     */
    disableAutoMonthSwitching: propTypesExports.bool,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true`, editing dates by dragging is disabled.
     * @default false
     */
    disableDragEditing: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value changes.
     * @template TDate
     * @param {DateRange<TDate>} value The new value.
     * @param {PickerSelectionState | undefined} selectionState Indicates if the date range selection is complete.
     */
    onChange: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    onRangePositionChange: propTypesExports.func,
    rangePosition: propTypesExports.oneOf(['end', 'start']),
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => "..."
     */
    renderLoading: propTypesExports.func,
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
};

/**
 * @ignore - internal component.
 */
function DateRangePickerViewMobile(props) {
    const { view: inView, views, onFocusedViewChange, onYearChange, onViewChange, reduceAnimations, openTo, autoFocus, focusedView: inFocusedView, isDateDisabled, handleChangeMonth, disableHighlightToday, shouldDisableMonth, shouldDisableYear, changeFocusedDay, onMonthChange, onFocusedViewChangedIn, setCurrentView, changeMonth, components, componentsProps, value, maxDate: maxDateProp, minDate: minDateProp, onSelectedDaysChange, disabled, readOnly, 
    // excluding classes from `other` to avoid passing them down to children
    classes: providedClasses } = props; __rest(props, ["view", "views", "onFocusedViewChange", "onYearChange", "onViewChange", "reduceAnimations", "openTo", "autoFocus", "focusedView", "isDateDisabled", "handleChangeMonth", "disableHighlightToday", "shouldDisableMonth", "shouldDisableYear", "changeFocusedDay", "onMonthChange", "onFocusedViewChangedIn", "setCurrentView", "changeMonth", "components", "componentsProps", "value", "maxDate", "minDate", "onSelectedDaysChange", "disabled", "readOnly", "classes"]);
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement(DateRangeCalendar, Object.assign({}, props, { calendars: 1, onFocusedViewChange: props.onFocusedViewChangedIn, onViewChange: setCurrentView, components: components, componentsProps: componentsProps, views: views, autoFocus: autoFocus }))));
}

function getDateRangePickerInputUtilityClass(slot) {
    return generateUtilityClass('MuiDateRangePickerInput', slot);
}
const dateRangePickerInputClasses = generateUtilityClasses('MuiDateRangePickerInput', ['root']);

const useUtilityClasses$2 = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
    };
    return composeClasses(slots, getDateRangePickerInputUtilityClass, classes);
};
const DateRangePickerInputRoot = styled$1('div', {
    name: 'MuiDateRangePickerInput',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})(({ theme }) => ({
    display: 'flex',
    alignItems: 'baseline',
    [theme.breakpoints.down('xs')]: {
        flexDirection: 'column',
        alignItems: 'center',
    },
}));
/**
 * @ignore - internal component.
 */
const DateRangePickerInput = React__namespace.forwardRef(function DateRangePickerInput(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiDateRangePickerInput' });
    const { rangePosition, onRangePositionChange, disableOpenPicker, onBlur, onChange, open, openPicker, value, value: [start, end], readOnly, renderInput, TextFieldProps, validationError: [startValidationError, endValidationError], className, mobile } = props, other = __rest(props, ["rangePosition", "onRangePositionChange", "disableOpenPicker", "onBlur", "onChange", "open", "openPicker", "value", "value", "readOnly", "renderInput", "TextFieldProps", "validationError", "className", "mobile"]);
    const startRef = React__namespace.useRef(null);
    const endRef = React__namespace.useRef(null);
    const classes = useUtilityClasses$2(props);
    const localeText = useLocaleText();
    React__namespace.useEffect(() => {
        var _a, _b;
        if (!open) {
            return;
        }
        if (rangePosition === 'start') {
            (_a = startRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
        else if (rangePosition === 'end') {
            (_b = endRef.current) === null || _b === void 0 ? void 0 : _b.focus();
        }
    }, [rangePosition, open]);
    // TODO: rethink this approach. We do not need to wait for calendar to be updated to rerender input (looks like freezing)
    // TODO: so simply break 1 react's commit phase in 2 (first for input and second for calendars) by executing onChange in the next tick
    const lazyHandleChangeCallback = React__namespace.useCallback((...args) => executeInTheNextEventLoopTick(() => onChange(...args)), [onChange]);
    const handleStartChange = (date, inputString) => {
        lazyHandleChangeCallback([date, end], inputString);
    };
    const handleEndChange = (date, inputString) => {
        lazyHandleChangeCallback([start, date], inputString);
    };
    const openRangeStartSelection = (event) => {
        event.stopPropagation();
        if (onRangePositionChange) {
            onRangePositionChange('start');
        }
        if (!readOnly && !disableOpenPicker) {
            openPicker();
        }
    };
    const openRangeEndSelection = (event) => {
        event.stopPropagation();
        if (onRangePositionChange) {
            onRangePositionChange('end');
        }
        if (!readOnly && !disableOpenPicker) {
            openPicker();
        }
    };
    const focusOnRangeEnd = () => {
        if (open && onRangePositionChange) {
            onRangePositionChange('end');
        }
    };
    const focusOnRangeStart = () => {
        if (open && onRangePositionChange) {
            onRangePositionChange('start');
        }
    };
    const startInputProps = useMaskedInput(Object.assign(Object.assign({}, other), { readOnly, value: start, onChange: handleStartChange, label: localeText.start, validationError: startValidationError !== null, TextFieldProps: Object.assign(Object.assign(Object.assign({}, TextFieldProps), { inputRef: startRef, focused: open ? rangePosition === 'start' : undefined }), (!readOnly && !other.disabled && { onClick: openRangeStartSelection })), inputProps: {
            onClick: openRangeStartSelection,
            onKeyDown: onSpaceOrEnter(openRangeStartSelection),
            onFocus: focusOnRangeStart,
            readOnly: mobile,
        } }));
    const endInputProps = useMaskedInput(Object.assign(Object.assign({}, other), { readOnly, label: localeText.end, value: end, onChange: handleEndChange, validationError: endValidationError !== null, TextFieldProps: Object.assign(Object.assign(Object.assign({}, TextFieldProps), { inputRef: endRef, focused: open ? rangePosition === 'end' : undefined }), (!readOnly && !other.disabled && { onClick: openRangeEndSelection })), inputProps: {
            onClick: openRangeEndSelection,
            onKeyDown: onSpaceOrEnter(openRangeEndSelection),
            onFocus: focusOnRangeEnd,
            readOnly: mobile,
        } }));
    return (React__namespace.createElement(DateRangePickerInputRoot, { onBlur: onBlur, ref: ref, className: clsx(classes.root, className) }, renderInput(startInputProps, endInputProps)));
});

const doNothing = () => { };

function getDateRangePickerViewDesktopUtilityClass(slot) {
    return generateUtilityClass('MuiDateRangePickerViewDesktop', slot);
}
const dateRangePickerViewDesktopClasses = generateUtilityClasses('MuiDateRangePickerViewDesktop', ['root', 'container']);

const useUtilityClasses$1 = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        container: ['container'],
    };
    return composeClasses(slots, getDateRangePickerViewDesktopUtilityClass, classes);
};
const DateRangePickerViewDesktopRoot = styled$1('div', {
    name: 'MuiDateRangePickerViewDesktop',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})({
    display: 'flex',
    flexDirection: 'row',
});
const DateRangePickerViewDesktopContainer = styled$1('div', {
    name: 'MuiDateRangePickerViewDesktop',
    slot: 'Container',
    overridesResolver: (_, styles) => styles.container,
})(({ theme }) => ({
    '&:not(:last-of-type)': {
        borderRight: `2px solid ${(theme.vars || theme).palette.divider}`,
    },
}));
const DAY_RANGE_SIZE = 40;
const weeksContainerHeight = (DAY_RANGE_SIZE + DAY_MARGIN * 2) * 6;
const DateRangePickerViewDesktopCalendar = styled$1(DayCalendar)({
    minWidth: 312,
    minHeight: weeksContainerHeight,
});
const DateRangePickerViewDesktopArrowSwitcher = styled$1(PickersArrowSwitcher)({
    padding: '16px 16px 8px 16px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
});
function getCalendarsArray(calendars) {
    switch (calendars) {
        case 1:
            return [0];
        case 2:
            return [0, 0];
        case 3:
            return [0, 0, 0];
        // this will not work in IE11, but allows to support any amount of calendars
        default:
            return new Array(calendars).fill(0);
    }
}
/**
 * @ignore - internal component.
 */
function DateRangePickerViewDesktop(inProps) {
    const props = useThemeProps({ props: inProps, name: 'MuiDateRangePickerViewDesktop' });
    const { view: inView, views, onFocusedViewChange, onYearChange, onViewChange, reduceAnimations, disabled, openTo, autoFocus, focusedView: inFocusedView, isDateDisabled, handleChangeMonth, disableHighlightToday, readOnly, shouldDisableMonth, shouldDisableYear, changeFocusedDay, onMonthChange, onFocusedViewChangedIn, setCurrentView, calendars, changeMonth, components, componentsProps, rangePosition, currentMonth, value, disableFuture, disablePast, maxDate: maxDateProp, minDate: minDateProp, onSelectedDaysChange, className, 
    // excluding classes from `other` to avoid passing them down to children
    classes: providedClasses } = props, other = __rest(props, ["view", "views", "onFocusedViewChange", "onYearChange", "onViewChange", "reduceAnimations", "disabled", "openTo", "autoFocus", "focusedView", "isDateDisabled", "handleChangeMonth", "disableHighlightToday", "readOnly", "shouldDisableMonth", "shouldDisableYear", "changeFocusedDay", "onMonthChange", "onFocusedViewChangedIn", "setCurrentView", "calendars", "changeMonth", "components", "componentsProps", "rangePosition", "currentMonth", "value", "disableFuture", "disablePast", "maxDate", "minDate", "onSelectedDaysChange", "className", "classes"]);
    const localeText = useLocaleText();
    const utils = useUtils();
    const classes = useUtilityClasses$1(props);
    const defaultDates = useDefaultDates();
    const minDate = minDateProp !== null && minDateProp !== void 0 ? minDateProp : defaultDates.minDate;
    const maxDate = maxDateProp !== null && maxDateProp !== void 0 ? maxDateProp : defaultDates.maxDate;
    // When disabled, limit the view to the selected date
    const minDateWithDisabled = (disabled && value[0]) || minDate;
    const maxDateWithDisabled = (disabled && value[1]) || maxDate;
    const [rangePreviewDay, setRangePreviewDay] = React__namespace.useState(null);
    const isNextMonthDisabled = useNextMonthDisabled(currentMonth, { disableFuture, maxDate });
    const isPreviousMonthDisabled = usePreviousMonthDisabled(currentMonth, { disablePast, minDate });
    // Range going for the start of the start day to the end of the end day.
    // This makes sure that `isWithinRange` works with any time in the start and end day.
    const valueDayRange = React__namespace.useMemo(() => [
        value[0] == null || !utils.isValid(value[0]) ? value[0] : utils.startOfDay(value[0]),
        value[1] == null || !utils.isValid(value[1]) ? value[1] : utils.endOfDay(value[1]),
    ], [value, utils]);
    const previewingRange = calculateRangePreview({
        utils,
        range: valueDayRange,
        newDate: rangePreviewDay,
        rangePosition,
    });
    const handleSelectedDayChange = React__namespace.useCallback((day) => {
        setRangePreviewDay(null);
        onSelectedDaysChange(day);
    }, [onSelectedDaysChange]);
    const handlePreviewDayChange = (newPreviewRequest) => {
        if (!isWithinRange(utils, newPreviewRequest, valueDayRange)) {
            setRangePreviewDay(newPreviewRequest);
        }
        else {
            setRangePreviewDay(null);
        }
    };
    const CalendarTransitionProps = React__namespace.useMemo(() => ({
        onMouseLeave: () => setRangePreviewDay(null),
    }), []);
    const selectNextMonth = React__namespace.useCallback(() => {
        changeMonth(utils.getNextMonth(currentMonth));
    }, [changeMonth, currentMonth, utils]);
    const selectPreviousMonth = React__namespace.useCallback(() => {
        changeMonth(utils.getPreviousMonth(currentMonth));
    }, [changeMonth, currentMonth, utils]);
    const componentsForDayCalendar = Object.assign({ Day: DateRangePickerDay }, components);
    const componentsPropsForDayCalendar = Object.assign(Object.assign({}, componentsProps), { day: (dayOwnerState) => {
            var _a;
            const { day } = dayOwnerState;
            return Object.assign({ isPreviewing: isWithinRange(utils, day, previewingRange), isStartOfPreviewing: isStartOfRange(utils, day, previewingRange), isEndOfPreviewing: isEndOfRange(utils, day, previewingRange), isHighlighting: isWithinRange(utils, day, valueDayRange), isStartOfHighlighting: isStartOfRange(utils, day, valueDayRange), isEndOfHighlighting: isEndOfRange(utils, day, valueDayRange), onMouseEnter: () => handlePreviewDayChange(day) }, ((_a = resolveComponentProps(componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.day, dayOwnerState)) !== null && _a !== void 0 ? _a : {}));
        } });
    const baseDateValidationProps = {
        disablePast,
        disableFuture,
        maxDate,
        minDate,
    };
    const commonViewProps = {
        disableHighlightToday,
        readOnly,
        disabled,
    };
    const { view, setView, focusedView, setFocusedView, goToNextView, setValueAndGoToNextView } = useViews({
        view: inView,
        views,
        openTo,
        onChange: handleSelectedDayChange,
        onViewChange,
        autoFocus,
        focusedView: inFocusedView,
        onFocusedViewChange: onFocusedViewChangedIn
    });
    React__namespace.useEffect(() => {
        setCurrentView(view);
    }, [view]);
    const hasFocus = focusedView !== null;
    const handleDateMonthChange = _default$2((newDate) => {
        const startOfMonth = utils.startOfMonth(newDate);
        const endOfMonth = utils.endOfMonth(newDate);
        const closestEnabledDate = (isDateDisabled === null || isDateDisabled === void 0 ? void 0 : isDateDisabled(newDate))
            ? findClosestEnabledDate({
                utils,
                date: newDate,
                minDate: utils.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
                maxDate: utils.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
                disablePast,
                disableFuture,
                isDateDisabled,
            })
            : newDate;
        if (closestEnabledDate) {
            setValueAndGoToNextView(closestEnabledDate, 'finish');
            onMonthChange === null || onMonthChange === void 0 ? void 0 : onMonthChange(startOfMonth);
        }
        else {
            goToNextView();
            changeMonth(startOfMonth);
        }
        changeFocusedDay(closestEnabledDate, true);
    });
    const handleDateYearChange = _default$2((newDate) => {
        const startOfYear = utils.startOfYear(newDate);
        const endOfYear = utils.endOfYear(newDate);
        const closestEnabledDate = (isDateDisabled === null || isDateDisabled === void 0 ? void 0 : isDateDisabled(newDate))
            ? findClosestEnabledDate({
                utils,
                date: newDate,
                minDate: utils.isBefore(minDate, startOfYear) ? startOfYear : minDate,
                maxDate: utils.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
                disablePast,
                disableFuture,
                isDateDisabled,
            })
            : newDate;
        if (closestEnabledDate) {
            setValueAndGoToNextView(closestEnabledDate, 'finish');
            onYearChange === null || onYearChange === void 0 ? void 0 : onYearChange(closestEnabledDate);
        }
        else {
            goToNextView();
            changeMonth(startOfYear);
        }
        changeFocusedDay(closestEnabledDate, true);
    });
    return (React__namespace.createElement(DateRangePickerViewDesktopRoot, { className: clsx(className, classes.root) }, getCalendarsArray(calendars).map((_, index) => {
        const monthOnIteration = utils.setMonth(currentMonth, utils.getMonth(currentMonth) + index);
        return (React__namespace.createElement(DateRangePickerViewDesktopContainer, { key: index, className: classes.container },
            calendars === 1 ? (React__namespace.createElement(PickersCalendarHeader, { views: views, view: view, currentMonth: currentMonth, onViewChange: (newView) => {
                    setView(newView);
                    setCurrentView(newView);
                }, onMonthChange: (newMonth, direction) => handleChangeMonth === null || handleChangeMonth === void 0 ? void 0 : handleChangeMonth({ newMonth, direction }), minDate: minDateWithDisabled, maxDate: maxDateWithDisabled, disabled: disabled, disablePast: disablePast, disableFuture: disableFuture, reduceAnimations: reduceAnimations, components: components, componentsProps: componentsProps })) : (React__namespace.createElement(DateRangePickerViewDesktopArrowSwitcher, { onGoToPrevious: selectPreviousMonth, onGoToNext: selectNextMonth, isPreviousHidden: index !== 0, isPreviousDisabled: isPreviousMonthDisabled, previousLabel: localeText.previousMonth, isNextHidden: index !== calendars - 1, isNextDisabled: isNextMonthDisabled, nextLabel: localeText.nextMonth, components: components, componentsProps: componentsProps }, utils.format(monthOnIteration, 'monthAndYear'))),
            view === 'year' && (React__namespace.createElement(YearCalendar, Object.assign({}, baseDateValidationProps, commonViewProps, { value: rangePosition === 'start' ? value[0] : value[1], onChange: handleDateYearChange, shouldDisableYear: shouldDisableYear, hasFocus: hasFocus, onFocusedViewChange: (isViewFocused) => setFocusedView('year', isViewFocused) }))),
            view === 'month' && (React__namespace.createElement(MonthCalendar, Object.assign({}, baseDateValidationProps, commonViewProps, { hasFocus: hasFocus, className: className, value: rangePosition === 'start' ? value[0] : value[1], onChange: handleDateMonthChange, shouldDisableMonth: shouldDisableMonth, onFocusedViewChange: (isViewFocused) => setFocusedView('month', isViewFocused) }))),
            view === 'day' && (React__namespace.createElement(DateRangePickerViewDesktopCalendar, Object.assign({}, other, { reduceAnimations: reduceAnimations, minDate: minDate, maxDate: maxDate, disablePast: disablePast, disableFuture: disableFuture, key: index, selectedDays: value, onFocusedDayChange: doNothing, onSelectedDaysChange: handleSelectedDayChange, currentMonth: monthOnIteration, TransitionProps: CalendarTransitionProps, components: componentsForDayCalendar, componentsProps: componentsPropsForDayCalendar })))));
    })));
}

/**
 * @ignore - internal component.
 */
function DateRangePickerViewRaw(props) {
    const { onYearChange, views, view: inView, openTo, focusedView, readOnly, shouldDisableMonth, shouldDisableYear, calendars, className, value, DateInputProps, defaultCalendarMonth, disableAutoMonthSwitching = false, disableFuture, disableHighlightToday, disablePast, isMobileKeyboardViewOpen, maxDate, minDate, onDateChange, onMonthChange, open, reduceAnimations = defaultReduceAnimations, rangePosition, onRangePositionChange, shouldDisableDate, showToolbar, toggleMobileKeyboardView, components, componentsProps, onFocusedViewChange } = props, other = __rest(props, ["onYearChange", "views", "view", "openTo", "focusedView", "readOnly", "shouldDisableMonth", "shouldDisableYear", "calendars", "className", "value", "DateInputProps", "defaultCalendarMonth", "disableAutoMonthSwitching", "disableFuture", "disableHighlightToday", "disablePast", "isMobileKeyboardViewOpen", "maxDate", "minDate", "onDateChange", "onMonthChange", "open", "reduceAnimations", "rangePosition", "onRangePositionChange", "shouldDisableDate", "showToolbar", "toggleMobileKeyboardView", "components", "componentsProps", "onFocusedViewChange"]);
    const utils = useUtils();
    const wrapperVariant = React__namespace.useContext(WrapperVariantContext);
    const wrappedShouldDisableDate = shouldDisableDate && ((dayToTest) => shouldDisableDate === null || shouldDisableDate === void 0 ? void 0 : shouldDisableDate(dayToTest, rangePosition));
    const [currentView, setCurrentView] = _default({
        name: 'DateRangePickerView',
        controlled: inView,
        default: inView || 'day'
    });
    const [start, end] = value;
    const { calendarState, changeFocusedDay, changeMonth, handleChangeMonth, onMonthSwitchingAnimationEnd, isDateDisabled } = useCalendarState({
        value: start || end,
        defaultCalendarMonth,
        disableFuture,
        disablePast,
        disableSwitchToMonthOnDayFocus: true,
        maxDate,
        minDate,
        onMonthChange,
        reduceAnimations,
        shouldDisableDate: wrappedShouldDisableDate,
    });
    const prevValue = React__namespace.useRef(null);
    React__namespace.useEffect(() => {
        var _a, _b;
        const date = rangePosition === 'start' ? start : end;
        if (!date || !utils.isValid(date)) {
            return;
        }
        const prevDate = rangePosition === 'start' ? (_a = prevValue.current) === null || _a === void 0 ? void 0 : _a[0] : (_b = prevValue.current) === null || _b === void 0 ? void 0 : _b[1];
        prevValue.current = value;
        // The current date did not change, this call comes either from a `rangePosition` change or a change in the other date.
        // In both cases, we don't want to change the visible month(s).
        if (disableAutoMonthSwitching && prevDate && utils.isEqual(prevDate, date)) {
            return;
        }
        const displayingMonthRange = wrapperVariant === 'mobile' ? 0 : calendars - 1;
        const currentMonthNumber = utils.getMonth(calendarState.currentMonth);
        const requestedMonthNumber = utils.getMonth(date);
        if (!utils.isSameYear(calendarState.currentMonth, date) ||
            requestedMonthNumber < currentMonthNumber ||
            requestedMonthNumber > currentMonthNumber + displayingMonthRange) {
            const newMonth = rangePosition === 'start'
                ? date
                : // If need to focus end, scroll to the state when "end" is displaying in the last calendar
                    utils.addMonths(date, -displayingMonthRange);
            changeMonth(newMonth);
        }
    }, [rangePosition, value]); // eslint-disable-line
    const handleSelectedDayChange = React__namespace.useCallback((newDate) => {
        const isSameRangePosition = currentView !== 'day';
        const forcedRangePosition = isSameRangePosition ? rangePosition : null;
        const { nextSelection, newRange } = calculateRangeChange({
            newDate,
            utils,
            range: value,
            rangePosition: forcedRangePosition ? forcedRangePosition : rangePosition,
        });
        onRangePositionChange(forcedRangePosition ? forcedRangePosition : nextSelection);
        const isFullRangeSelected = rangePosition === 'end' && isRangeValid(utils, newRange);
        onDateChange(newRange, wrapperVariant, isFullRangeSelected ? 'finish' : 'partial');
    }, [rangePosition, value, onDateChange, onRangePositionChange, utils, wrapperVariant]);
    const shouldRenderToolbar = showToolbar !== null && showToolbar !== void 0 ? showToolbar : wrapperVariant !== 'desktop';
    const Toolbar = components === null || components === void 0 ? void 0 : components.Toolbar;
    const renderView = () => {
        const sharedCalendarProps = Object.assign(Object.assign(Object.assign({ value,
            onMonthChange,
            views,
            onYearChange,
            isDateDisabled,
            handleChangeMonth,
            changeFocusedDay, onSelectedDaysChange: handleSelectedDayChange, setCurrentView,
            reduceAnimations,
            disableHighlightToday,
            onMonthSwitchingAnimationEnd,
            changeMonth,
            rangePosition,
            disableFuture,
            disablePast,
            minDate,
            maxDate,
            components,
            componentsProps, shouldDisableDate: wrappedShouldDisableDate }, calendarState), { onFocusedViewChange: onFocusedViewChange
                ? (newHasFocus) => onFocusedViewChange('day', newHasFocus)
                : undefined }), other);
        switch (wrapperVariant) {
            case 'desktop': {
                return React__namespace.createElement(DateRangePickerViewDesktop, Object.assign({ calendars: calendars }, sharedCalendarProps));
            }
            default: {
                return React__namespace.createElement(DateRangePickerViewMobile, Object.assign({}, sharedCalendarProps));
            }
        }
    };
    return (React__namespace.createElement("div", { className: className },
        shouldRenderToolbar && !!Toolbar && (React__namespace.createElement(Toolbar, Object.assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.toolbar, { value: value, isMobileKeyboardViewOpen: isMobileKeyboardViewOpen, toggleMobileKeyboardView: toggleMobileKeyboardView, rangePosition: rangePosition, onRangePositionChange: onRangePositionChange }))),
        isMobileKeyboardViewOpen ? (React__namespace.createElement(MobileKeyboardInputView, null,
            React__namespace.createElement(DateRangePickerInput, Object.assign({ disableOpenPicker: true, ignoreInvalidInputs: true }, DateInputProps)))) : (renderView())));
}
const DateRangePickerView = DateRangePickerViewRaw;
DateRangePickerViewRaw.propTypes = {
    calendars: propTypesExports.oneOf([1, 2, 3]),
    disableAutoMonthSwitching: propTypesExports.bool,
};

const validateDateRange = ({ props, value, adapter }) => {
    const [start, end] = value;
    const { shouldDisableDate } = props, otherProps = __rest(props, ["shouldDisableDate"]);
    const dateValidations = [
        validateDate({
            adapter,
            value: start,
            props: Object.assign(Object.assign({}, otherProps), { shouldDisableDate: (day) => !!(shouldDisableDate === null || shouldDisableDate === void 0 ? void 0 : shouldDisableDate(day, 'start')) }),
        }),
        validateDate({
            adapter,
            value: end,
            props: Object.assign(Object.assign({}, otherProps), { shouldDisableDate: (day) => !!(shouldDisableDate === null || shouldDisableDate === void 0 ? void 0 : shouldDisableDate(day, 'end')) }),
        }),
    ];
    if (dateValidations[0] || dateValidations[1]) {
        return dateValidations;
    }
    // for partial input
    if (start === null || end === null) {
        return [null, null];
    }
    if (!isRangeValid(adapter.utils, value)) {
        return ['invalidRange', 'invalidRange'];
    }
    return [null, null];
};
const useDateRangeValidation = (props) => {
    return useValidation(props, validateDateRange, rangeValueManager.isSameError, rangeValueManager.defaultErrorState);
};

function getDateRangePickerToolbarUtilityClass(slot) {
    return generateUtilityClass('MuiDateRangePickerToolbar', slot);
}
const dateRangePickerToolbarClasses = generateUtilityClasses('MuiDateRangePickerToolbar', ['root', 'container']);

const useUtilityClasses = (ownerState) => {
    const { classes } = ownerState;
    const slots = {
        root: ['root'],
        container: ['container'],
    };
    return composeClasses(slots, getDateRangePickerToolbarUtilityClass, classes);
};
const DateRangePickerToolbarRoot = styled$1(PickersToolbar, {
    name: 'MuiDateRangePickerToolbar',
    slot: 'Root',
    overridesResolver: (_, styles) => styles.root,
})({
    [`& .${pickersToolbarClasses.penIconButton}`]: {
        position: 'relative',
        top: 4,
    },
});
const DateRangePickerToolbarContainer = styled$1('div', {
    name: 'MuiDateRangePickerToolbar',
    slot: 'Container',
    overridesResolver: (_, styles) => styles.container,
})({
    display: 'flex',
});
/**
 * @ignore - internal component.
 */
const DateRangePickerToolbar = React__namespace.forwardRef(function DateRangePickerToolbar(inProps, ref) {
    const utils = useUtils();
    const props = useThemeProps({ props: inProps, name: 'MuiDateRangePickerToolbar' });
    const { value: [start, end], isMobileKeyboardViewOpen, toggleMobileKeyboardView, rangePosition, onRangePositionChange, toolbarFormat, className, } = props;
    const localeText = useLocaleText();
    const startDateValue = start
        ? utils.formatByString(start, toolbarFormat || utils.formats.shortDate)
        : localeText.start;
    const endDateValue = end
        ? utils.formatByString(end, toolbarFormat || utils.formats.shortDate)
        : localeText.end;
    const ownerState = props;
    const classes = useUtilityClasses(ownerState);
    return (React__namespace.createElement(DateRangePickerToolbarRoot, { toolbarTitle: localeText.dateRangePickerToolbarTitle, isMobileKeyboardViewOpen: isMobileKeyboardViewOpen, toggleMobileKeyboardView: toggleMobileKeyboardView, isLandscape: false, className: clsx(className, classes.root), ownerState: ownerState, ref: ref },
        React__namespace.createElement(DateRangePickerToolbarContainer, { className: classes.container },
            React__namespace.createElement(PickersToolbarButton, { variant: start !== null ? 'h5' : 'h6', value: startDateValue, selected: rangePosition === 'start', onClick: () => onRangePositionChange('start') }),
            React__namespace.createElement(Typography$1, { variant: "h5" },
                "\u00A0",
                '',
                "\u00A0"),
            React__namespace.createElement(PickersToolbarButton, { variant: end !== null ? 'h5' : 'h6', value: endDateValue, selected: rangePosition === 'end', onClick: () => onRangePositionChange('end') }))));
});

function useDateRangePickerDefaultizedProps(props, name) {
    var _a, _b;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    // This is technically unsound if the type parameters appear in optional props.
    // Optional props can be filled by `useThemeProps` with types that don't match the type parameters.
    const themeProps = useThemeProps({
        props,
        name,
    });
    const localeText = React__namespace.useMemo(() => {
        var _a;
        if (((_a = themeProps.localeText) === null || _a === void 0 ? void 0 : _a.toolbarTitle) == null) {
            return themeProps.localeText;
        }
        return Object.assign(Object.assign({}, themeProps.localeText), { dateRangePickerToolbarTitle: themeProps.localeText.toolbarTitle });
    }, [themeProps.localeText]);
    return Object.assign(Object.assign({ disableFuture: false, disablePast: false, calendars: 2, openTo: (_a = props.openTo) !== null && _a !== void 0 ? _a : 'day', views: (_b = props.views) !== null && _b !== void 0 ? _b : ['year', 'day'], inputFormat: utils.formats.keyboardDate }, themeProps), { minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate), localeText, components: Object.assign({ Toolbar: DateRangePickerToolbar }, themeProps.components) });
}

const KeyboardDateInputComponent = DateRangePickerInput;
/**
 *
 * Demos:
 *
 * - [Date Range Picker](https://mui.com/x/react-date-pickers/date-range-picker/)
 *
 * API:
 *
 * - [DesktopDateRangePicker API](https://mui.com/x/api/date-pickers/desktop-date-range-picker/)
 */
const DesktopDateRangePicker = React__namespace.forwardRef(function DesktopDateRangePicker(inProps, ref) {
    const props = useDateRangePickerDefaultizedProps(inProps, 'MuiDesktopDateRangePicker');
    const [rangePosition, setRangePosition] = React__namespace.useState('start');
    const validationError = useDateRangeValidation(props);
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, rangeValueManager);
    const { value, onChange, components, componentsProps, localeText } = props, other = __rest(props, ["value", "onChange", "components", "componentsProps", "localeText"]);
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { components,
        componentsProps,
        rangePosition, onRangePositionChange: setRangePosition, validationError,
        ref });
    return (React__namespace.createElement(DesktopTooltipWrapper, Object.assign({}, wrapperProps, { DateInputProps: DateInputProps, KeyboardDateInputComponent: KeyboardDateInputComponent, components: components, componentsProps: componentsProps, localeText: localeText }),
        React__namespace.createElement(DateRangePickerView, Object.assign({ open: wrapperProps.open, DateInputProps: DateInputProps, rangePosition: rangePosition, onRangePositionChange: setRangePosition }, pickerProps, { components: components, componentsProps: componentsProps }, other))));
});
DesktopDateRangePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * The number of calendars that render on **desktop**.
     * @default 2
     */
    calendars: propTypesExports.oneOf([1, 2, 3]),
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
     * @default false
     */
    disableAutoMonthSwitching: propTypesExports.bool,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     * @default '__/__/____'
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date range) changes @DateIOType.
     * @template TDate
     * @param {DateRange<TDate>} date The new date range.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `startProps` and `endProps` arguments of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props),
     * that you need to forward to the range start/end inputs respectively.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example
     * ```jsx
     * <DateRangePicker
     *  renderInput={(startProps, endProps) => (
     *   <React.Fragment>
     *     <TextField {...startProps} />
     *     <Box sx={{ mx: 2 }}> to </Box>
     *     <TextField {...endProps} />
     *   </React.Fragment>;
     *  )}
     * />
     * ````
     * @param {MuiTextFieldProps} startProps Props that you need to forward to the range start input.
     * @param {MuiTextFieldProps} endProps Props that you need to forward to the range end input.
     * @returns {React.ReactElement} The range input to render.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The value of the picker.
     */
    value: propTypesExports.arrayOf(propTypesExports.any).isRequired,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
};

const PureDateInputComponent = DateRangePickerInput;
/**
 *
 * Demos:
 *
 * - [Date Range Picker](https://mui.com/x/react-date-pickers/date-range-picker/)
 *
 * API:
 *
 * - [MobileDateRangePicker API](https://mui.com/x/api/date-pickers/mobile-date-range-picker/)
 */
const MobileDateRangePicker = React__namespace.forwardRef(function MobileDateRangePicker(inProps, ref) {
    const props = useDateRangePickerDefaultizedProps(inProps, 'MuiMobileDateRangePicker');
    const { value, onChange, components, componentsProps, localeText } = props, other = __rest(props, ["value", "onChange", "components", "componentsProps", "localeText"]);
    const [rangePosition, setRangePosition] = React__namespace.useState('start');
    const pickerStateProps = Object.assign(Object.assign({}, other), { value,
        onChange });
    const { pickerProps, inputProps, wrapperProps } = usePickerState(pickerStateProps, rangeValueManager);
    const validationError = useDateRangeValidation(props);
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { components,
        componentsProps,
        rangePosition, onRangePositionChange: setRangePosition, validationError,
        ref, mobile: true });
    return (React__namespace.createElement(MobileWrapper, Object.assign({}, other, wrapperProps, { DateInputProps: DateInputProps, PureDateInputComponent: PureDateInputComponent, components: components, componentsProps: componentsProps, localeText: localeText }),
        React__namespace.createElement(DateRangePickerView, Object.assign({ open: wrapperProps.open, DateInputProps: DateInputProps, rangePosition: rangePosition, onRangePositionChange: setRangePosition }, pickerProps, { components: components, componentsProps: componentsProps }, other))));
});
MobileDateRangePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * The number of calendars that render on **desktop**.
     * @default 2
     */
    calendars: propTypesExports.oneOf([1, 2, 3]),
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
     * @default false
     */
    disableAutoMonthSwitching: propTypesExports.bool,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     * @default '__/__/____'
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date range) changes @DateIOType.
     * @template TDate
     * @param {DateRange<TDate>} date The new date range.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `startProps` and `endProps` arguments of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props),
     * that you need to forward to the range start/end inputs respectively.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example
     * ```jsx
     * <DateRangePicker
     *  renderInput={(startProps, endProps) => (
     *   <React.Fragment>
     *     <TextField {...startProps} />
     *     <Box sx={{ mx: 2 }}> to </Box>
     *     <TextField {...endProps} />
     *   </React.Fragment>;
     *  )}
     * />
     * ````
     * @param {MuiTextFieldProps} startProps Props that you need to forward to the range start input.
     * @param {MuiTextFieldProps} endProps Props that you need to forward to the range end input.
     * @returns {React.ReactElement} The range input to render.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The value of the picker.
     */
    value: propTypesExports.arrayOf(propTypesExports.any).isRequired,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
};

/**
 *
 * Demos:
 *
 * - [Date Range Picker](https://mui.com/x/react-date-pickers/date-range-picker/)
 *
 * API:
 *
 * - [DateRangePicker API](https://mui.com/x/api/date-pickers/date-range-picker/)
 */
const DateRangePicker = React__namespace.forwardRef(function DateRangePicker(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiDateRangePicker' });
    const { desktopModeMediaQuery = '@media (pointer: fine)' } = props, other = __rest(props, ["desktopModeMediaQuery"]);
    // defaults to `true` in environments where `window.matchMedia` would not be available (i.e. test/jsdom)
    const isDesktop = useMediaQuery(desktopModeMediaQuery, { defaultMatches: true });
    if (isDesktop) {
        return React__namespace.createElement(DesktopDateRangePicker, Object.assign({ ref: ref }, other));
    }
    return React__namespace.createElement(MobileDateRangePicker, Object.assign({ ref: ref }, other));
});
DateRangePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    /**
     * The number of calendars that render on **desktop**.
     * @default 2
     */
    calendars: propTypesExports.oneOf([1, 2, 3]),
    children: propTypesExports.node,
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * CSS media query when `Mobile` mode will be changed to `Desktop`.
     * @default '@media (pointer: fine)'
     * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
     */
    desktopModeMediaQuery: propTypesExports.string,
    /**
     * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
     * @default false
     */
    disableAutoMonthSwitching: propTypesExports.bool,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     * @default '__/__/____'
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date range) changes @DateIOType.
     * @template TDate
     * @param {DateRange<TDate>} date The new date range.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     */
    open: propTypesExports.bool,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `startProps` and `endProps` arguments of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props),
     * that you need to forward to the range start/end inputs respectively.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example
     * ```jsx
     * <DateRangePicker
     *  renderInput={(startProps, endProps) => (
     *   <React.Fragment>
     *     <TextField {...startProps} />
     *     <Box sx={{ mx: 2 }}> to </Box>
     *     <TextField {...endProps} />
     *   </React.Fragment>;
     *  )}
     * />
     * ````
     * @param {MuiTextFieldProps} startProps Props that you need to forward to the range start input.
     * @param {MuiTextFieldProps} endProps Props that you need to forward to the range end input.
     * @returns {React.ReactElement} The range input to render.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The value of the picker.
     */
    value: propTypesExports.arrayOf(propTypesExports.any).isRequired,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
};

/**
 *
 * Demos:
 *
 * - [Date Range Picker](https://mui.com/x/react-date-pickers/date-range-picker/)
 *
 * API:
 *
 * - [StaticDateRangePicker API](https://mui.com/x/api/date-pickers/static-date-range-picker/)
 */
const StaticDateRangePicker = React__namespace.forwardRef(function StaticDateRangePicker(inProps, ref) {
    const props = useDateRangePickerDefaultizedProps(inProps, 'MuiStaticDateRangePicker');
    const [rangePosition, setRangePosition] = React__namespace.useState('start');
    const validationError = useDateRangeValidation(props);
    const { pickerProps, inputProps, wrapperProps } = usePickerState(props, rangeValueManager);
    const { displayStaticWrapperAs, value, onChange, components, componentsProps, localeText, sx, className } = props, other = __rest(props, ["displayStaticWrapperAs", "value", "onChange", "components", "componentsProps", "localeText", "sx", "className"]);
    const DateInputProps = Object.assign(Object.assign(Object.assign({}, inputProps), other), { rangePosition, onRangePositionChange: setRangePosition, validationError,
        components,
        componentsProps,
        ref });
    return (React__namespace.createElement(PickerStaticWrapper, Object.assign({ displayStaticWrapperAs: displayStaticWrapperAs, components: components, componentsProps: componentsProps, localeText: localeText, sx: sx, className: className }, wrapperProps),
        React__namespace.createElement(DateRangePickerView, Object.assign({ open: wrapperProps.open, DateInputProps: DateInputProps, rangePosition: rangePosition, onRangePositionChange: setRangePosition, components: components, componentsProps: componentsProps }, pickerProps, other))));
});
StaticDateRangePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Regular expression to detect "accepted" symbols.
     * @default /\dap/gi
     */
    acceptRegex: propTypesExports.instanceOf(RegExp),
    autoFocus: propTypesExports.bool,
    /**
     * The number of calendars that render on **desktop**.
     * @default 2
     */
    calendars: propTypesExports.oneOf([1, 2, 3]),
    /**
     * className applied to the root component.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will immediately close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={null}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
     * @default false
     */
    disableAutoMonthSwitching: propTypesExports.bool,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Disable mask on the keyboard, this should be used rarely. Consider passing proper mask for your format.
     * @default false
     */
    disableMaskedInput: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only text field with validation).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Force static wrapper inner components to be rendered in mobile or desktop mode.
     * @default "mobile"
     */
    displayStaticWrapperAs: propTypesExports.oneOf(['desktop', 'mobile']),
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Get aria-label text for control that opens picker dialog. Aria-label text must include selected date. @DateIOType
     * @template TDate
     * @param {TDate | null} date The date from which we want to add an aria-text.
     * @param {MuiPickersAdapter<TDate>} utils The utils to manipulate the date.
     * @returns {string} The aria-text to render inside the dialog.
     * @default (date, utils) => `Choose date, selected date is ${utils.format(date, 'fullDate')}`
     */
    getOpenDialogAriaText: propTypesExports.func,
    ignoreInvalidInputs: propTypesExports.bool,
    /**
     * Props to pass to keyboard input adornment.
     */
    InputAdornmentProps: propTypesExports.object,
    /**
     * Format string.
     */
    inputFormat: propTypesExports.string,
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.object,
        }),
    ]),
    label: propTypesExports.node,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts
     */
    localeText: propTypesExports.object,
    /**
     * Custom mask. Can be used to override generate from format. (e.g. `__/__/____ __:__` or `__/__/____ __:__ _M`).
     * @default '__/__/____'
     */
    mask: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when date is accepted @DateIOType.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value (the selected date range) changes @DateIOType.
     * @template TDate
     * @param {DateRange<TDate>} date The new date range.
     * @param {string} keyboardInputValue The current value of the keyboard input.
     */
    onChange: propTypesExports.func.isRequired,
    /**
     * Callback that fired when input value or new `value` prop validation returns **new** validation error (or value is valid after error).
     * In case of validation error detected `reason` prop return non-null value and `TextField` must be displayed in `error` state.
     * This can be used to render appropriate form error.
     *
     * [Read the guide](https://next.material-ui-pickers.dev/guides/forms) about form integration and error displaying.
     * @DateIOType
     *
     * @template TError, TValue
     * @param {TError} reason The reason why the current value is not valid.
     * @param {TValue} value The invalid value.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Props to pass to keyboard adornment button.
     */
    OpenPickerButtonProps: propTypesExports.object,
    /**
     * Make picker read only.
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * The `renderInput` prop allows you to customize the rendered input.
     * The `startProps` and `endProps` arguments of this render prop contains props of [TextField](https://mui.com/material-ui/api/text-field/#props),
     * that you need to forward to the range start/end inputs respectively.
     * Pay specific attention to the `ref` and `inputProps` keys.
     * @example
     * ```jsx
     * <DateRangePicker
     *  renderInput={(startProps, endProps) => (
     *   <React.Fragment>
     *     <TextField {...startProps} />
     *     <Box sx={{ mx: 2 }}> to </Box>
     *     <TextField {...endProps} />
     *   </React.Fragment>;
     *  )}
     * />
     * ````
     * @param {MuiTextFieldProps} startProps Props that you need to forward to the range start input.
     * @param {MuiTextFieldProps} endProps Props that you need to forward to the range end input.
     * @returns {React.ReactElement} The range input to render.
     */
    renderInput: propTypesExports.func.isRequired,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => <span data-mui-test="loading-progress">...</span>
     */
    renderLoading: propTypesExports.func,
    /**
     * Custom formatter to be passed into Rifm component.
     * @param {string} str The un-formatted string.
     * @returns {string} The formatted string.
     */
    rifmFormatter: propTypesExports.func,
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific month.
     * @template TDate
     * @param {TDate} month The month to test.
     * @returns {boolean} If `true` the month will be disabled.
     */
    shouldDisableMonth: propTypesExports.func,
    /**
     * Disable specific year.
     * @template TDate
     * @param {TDate} year The year to test.
     * @returns {boolean} If `true` the year will be disabled.
     */
    shouldDisableYear: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, show the toolbar even in desktop mode.
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The value of the picker.
     */
    value: propTypesExports.arrayOf(propTypesExports.any).isRequired,
    /**
     * The visible view.
     * Used when the component view is controlled.
     * Must be a valid option from `views` list.
     */
    view: propTypesExports.oneOf(['day', 'month', 'year']),
    /**
     * Available views.
     */
    views: propTypesExports.arrayOf(propTypesExports.oneOf(['day', 'month', 'year']).isRequired),
    /**
     * The default visible view.
     * Used when the component view is not controlled.
     * Must be a valid option from `views` list.
     */
    openTo: propTypesExports.oneOf(['day', 'month', 'year']),
};

const _excluded = ["component", "direction", "spacing", "divider", "children"];
function joinChildren(children, separator) {
  const childrenArray = React__namespace.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output, child, index) => {
    output.push(child);
    if (index < childrenArray.length - 1) {
      output.push( /*#__PURE__*/React__namespace.cloneElement(separator, {
        key: `separator-${index}`
      }));
    }
    return output;
  }, []);
}
const getSideFromDirection = direction => {
  return {
    row: 'Left',
    'row-reverse': 'Right',
    column: 'Top',
    'column-reverse': 'Bottom'
  }[direction];
};
const style = ({
  ownerState,
  theme
}) => {
  let styles = _extends({
    display: 'flex',
    flexDirection: 'column'
  }, handleBreakpoints({
    theme
  }, resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme.breakpoints.values
  }), propValue => ({
    flexDirection: propValue
  })));
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme);
    const base = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === 'object' && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === 'object' && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base
    });
    if (typeof directionValues === 'object') {
      Object.keys(directionValues).forEach((breakpoint, index, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index > 0 ? directionValues[breakpoints[index - 1]] : 'column';
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      return {
        '& > :not(style) + :not(style)': {
          margin: 0,
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
        }
      };
    };
    styles = deepmerge(styles, handleBreakpoints({
      theme
    }, spacingValues, styleFromPropValue));
  }
  styles = mergeBreakpointsInOrder(theme.breakpoints, styles);
  return styles;
};
const StackRoot = styled$1('div', {
  name: 'MuiStack',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    return [styles.root];
  }
})(style);
const Stack = /*#__PURE__*/React__namespace.forwardRef(function Stack(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: 'MuiStack'
  });
  const props = extendSxProp(themeProps);
  const {
      component = 'div',
      direction = 'column',
      spacing = 0,
      divider,
      children
    } = props,
    other = _objectWithoutPropertiesLoose(props, _excluded);
  const ownerState = {
    direction,
    spacing
  };
  return /*#__PURE__*/jsxRuntime.jsx(StackRoot, _extends({
    as: component,
    ownerState: ownerState,
    ref: ref
  }, other, {
    children: divider ? joinChildren(children, divider) : children
  }));
});
process.env.NODE_ENV !== "production" ? Stack.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: propTypesExports.node,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypesExports.elementType,
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'column'
   */
  direction: propTypesExports.oneOfType([propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row']), propTypesExports.arrayOf(propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row'])), propTypesExports.object]),
  /**
   * Add an element between each child.
   */
  divider: propTypesExports.node,
  /**
   * Defines the space between immediate children.
   * @default 0
   */
  spacing: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string])), propTypesExports.number, propTypesExports.object, propTypesExports.string]),
  /**
   * The system prop, which allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypesExports.oneOfType([propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])), propTypesExports.func, propTypesExports.object])
} : void 0;
var Stack$1 = Stack;

const useDefaultizedDateRangeFieldProps = (props) => {
    var _a, _b, _c;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    return Object.assign(Object.assign({}, props), { disablePast: (_a = props.disablePast) !== null && _a !== void 0 ? _a : false, disableFuture: (_b = props.disableFuture) !== null && _b !== void 0 ? _b : false, format: (_c = props.format) !== null && _c !== void 0 ? _c : utils.formats.keyboardDate, minDate: applyDefaultDate(utils, props.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, props.maxDate, defaultDates.maxDate) });
};
const useSingleInputDateRangeField = ({ props, inputRef, }) => {
    const _a = useDefaultizedDateRangeFieldProps(props), { value, defaultValue, format, onChange, readOnly, onError, shouldDisableDate, minDate, maxDate, disableFuture, disablePast, selectedSections, onSelectedSectionsChange } = _a, other = __rest(_a, ["value", "defaultValue", "format", "onChange", "readOnly", "onError", "shouldDisableDate", "minDate", "maxDate", "disableFuture", "disablePast", "selectedSections", "onSelectedSectionsChange"]);
    return useField({
        inputRef,
        forwardedProps: other,
        internalProps: {
            value,
            defaultValue,
            format,
            onChange,
            readOnly,
            onError,
            shouldDisableDate,
            minDate,
            maxDate,
            disableFuture,
            disablePast,
            selectedSections,
            onSelectedSectionsChange,
        },
        valueManager: rangeValueManager,
        fieldValueManager: rangeFieldValueManager,
        validator: validateDateRange,
        supportedDateSections: ['year', 'month', 'day'],
    });
};

const useMultiInputDateRangeField = ({ sharedProps: inSharedProps, startInputProps: inStartInputProps, endInputProps: inEndInputProps, startInputRef, endInputRef, }) => {
    var _a;
    const sharedProps = useDefaultizedDateRangeFieldProps(inSharedProps);
    const adapter = useLocalizationContext();
    const { value: valueProp, defaultValue, format, onChange, disabled, readOnly } = sharedProps;
    const firstDefaultValue = React__namespace.useRef(defaultValue);
    // TODO: Maybe export utility from `useField` instead of copy/pasting the logic
    const buildChangeHandler = (index) => {
        if (!onChange) {
            return () => { };
        }
        return (newDate, rawContext) => {
            var _a;
            const currentDateRange = (_a = valueProp !== null && valueProp !== void 0 ? valueProp : firstDefaultValue.current) !== null && _a !== void 0 ? _a : rangeValueManager.emptyValue;
            const newDateRange = index === 0 ? [newDate, currentDateRange[1]] : [currentDateRange[0], newDate];
            const context = Object.assign(Object.assign({}, rawContext), { validationError: validateDateRange({
                    adapter,
                    value: newDateRange,
                    props: Object.assign(Object.assign({}, sharedProps), { value: newDateRange }),
                }) });
            onChange(newDateRange, context);
        };
    };
    const handleStartDateChange = _default$2(buildChangeHandler(0));
    const handleEndDateChange = _default$2(buildChangeHandler(1));
    const startInputProps = Object.assign(Object.assign({}, inStartInputProps), { disabled,
        readOnly,
        format, value: valueProp === undefined ? undefined : valueProp[0], defaultValue: defaultValue === undefined ? undefined : defaultValue[0], onChange: handleStartDateChange });
    const endInputProps = Object.assign(Object.assign({}, inEndInputProps), { format,
        disabled,
        readOnly, value: valueProp === undefined ? undefined : valueProp[1], defaultValue: defaultValue === undefined ? undefined : defaultValue[1], onChange: handleEndDateChange });
    const rawStartDateResponse = useDateField({
        props: startInputProps,
        inputRef: startInputRef,
    });
    const rawEndDateResponse = useDateField({
        props: endInputProps,
        inputRef: endInputRef,
    });
    const value = (_a = valueProp !== null && valueProp !== void 0 ? valueProp : firstDefaultValue.current) !== null && _a !== void 0 ? _a : rangeValueManager.emptyValue;
    const validationError = useValidation(Object.assign(Object.assign({}, sharedProps), { value }), validateDateRange, rangeValueManager.isSameError, rangeValueManager.defaultErrorState);
    const startDateResponse = Object.assign(Object.assign({}, rawStartDateResponse), { error: !!validationError[0] });
    const endDateResponse = Object.assign(Object.assign({}, rawEndDateResponse), { error: !!validationError[1] });
    return { startDate: startDateResponse, endDate: endDateResponse };
};

const MultiInputDateRangeFieldRoot = styled$1(React__namespace.forwardRef((props, ref) => (React__namespace.createElement(Stack$1, Object.assign({ ref: ref, spacing: 2, direction: "row", alignItems: "baseline" }, props)))), {
    name: 'MuiMultiInputDateRangeField',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({});
const MultiInputDateRangeFieldSeparator = styled$1((props) => { var _a; return React__namespace.createElement(Typography$1, Object.assign({}, props), (_a = props.children) !== null && _a !== void 0 ? _a : '  '); }, {
    name: 'MuiMultiInputDateRangeField',
    slot: 'Separator',
    overridesResolver: (props, styles) => styles.separator,
})({});
const MultiInputDateRangeField = React__namespace.forwardRef(function MultiInputDateRangeField(inProps, ref) {
    var _a, _b, _c;
    const themeProps = useThemeProps({
        props: inProps,
        name: 'MuiMultiInputDateRangeField',
    });
    const { components, componentsProps, value, defaultValue, format, onChange, readOnly, disabled, onError, shouldDisableDate, minDate, maxDate, disableFuture, disablePast, selectedSections, onSelectedSectionsChange, autoFocus } = themeProps, other = __rest(themeProps, ["components", "componentsProps", "value", "defaultValue", "format", "onChange", "readOnly", "disabled", "onError", "shouldDisableDate", "minDate", "maxDate", "disableFuture", "disablePast", "selectedSections", "onSelectedSectionsChange", "autoFocus"]);
    const ownerState = themeProps;
    const Root = (_a = components === null || components === void 0 ? void 0 : components.Root) !== null && _a !== void 0 ? _a : MultiInputDateRangeFieldRoot;
    const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
            ref,
        },
        ownerState,
    });
    const Input = (_b = components === null || components === void 0 ? void 0 : components.Input) !== null && _b !== void 0 ? _b : TextField$1;
    const startInputProps = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        additionalProps: { autoFocus },
        ownerState: Object.assign(Object.assign({}, ownerState), { position: 'start' }),
    });
    const endInputProps = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        ownerState: Object.assign(Object.assign({}, ownerState), { position: 'end' }),
    });
    const Separator = (_c = components === null || components === void 0 ? void 0 : components.Separator) !== null && _c !== void 0 ? _c : MultiInputDateRangeFieldSeparator;
    const separatorProps = useSlotProps({
        elementType: Separator,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.separator,
        ownerState,
    });
    const _d = useMultiInputDateRangeField({
        sharedProps: {
            value,
            defaultValue,
            format,
            onChange,
            readOnly,
            disabled,
            onError,
            shouldDisableDate,
            minDate,
            maxDate,
            disableFuture,
            disablePast,
            selectedSections,
            onSelectedSectionsChange,
        },
        startInputProps,
        endInputProps,
        startInputRef: startInputProps.inputRef,
        endInputRef: endInputProps.inputRef,
    }), _e = _d.startDate, { onKeyDown: onStartInputKeyDown, ref: startInputRef, readOnly: startReadOnly, inputMode: startInputMode } = _e, startDateProps = __rest(_e, ["onKeyDown", "ref", "readOnly", "inputMode"]), _f = _d.endDate, { onKeyDown: onEndInputKeyDown, ref: endInputRef, readOnly: endReadOnly, inputMode: endInputMode } = _f, endDateProps = __rest(_f, ["onKeyDown", "ref", "readOnly", "inputMode"]);
    return (React__namespace.createElement(Root, Object.assign({}, rootProps),
        React__namespace.createElement(Input, Object.assign({}, startDateProps, { inputProps: Object.assign(Object.assign({}, startDateProps.inputProps), { ref: startInputRef, readOnly: startReadOnly, inputMode: startInputMode, onKeyDown: onStartInputKeyDown }) })),
        React__namespace.createElement(Separator, Object.assign({}, separatorProps)),
        React__namespace.createElement(Input, Object.assign({}, endDateProps, { inputProps: Object.assign(Object.assign({}, endDateProps.inputProps), { ref: endInputRef, readOnly: endReadOnly, inputMode: endInputMode, onKeyDown: onEndInputKeyDown }) }))));
});
MultiInputDateRangeField.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    autoFocus: propTypesExports.bool,
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value. Use when the component is not controlled.
     */
    defaultValue: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * Defines the `flex-direction` style property.
     * It is applied for all screen sizes.
     * @default 'column'
     */
    direction: propTypesExports.oneOfType([
        propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row']),
        propTypesExports.arrayOf(propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row'])),
        propTypesExports.object,
    ]),
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Add an element between each child.
     */
    divider: propTypesExports.node,
    /**
     * Format of the date when rendered in the input(s).
     */
    format: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * @template TValue, TError
     * @param {TError} error The new error.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Defines the space between immediate children.
     * @default 0
     */
    spacing: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string])),
        propTypesExports.number,
        propTypesExports.object,
        propTypesExports.string,
    ]),
    style: propTypesExports.object,
    /**
     * The system prop, which allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.arrayOf(propTypesExports.any),
};

const validateTimeRange = ({ props, value, adapter }) => {
    const [start, end] = value;
    const dateTimeValidations = [
        validateTime({
            adapter,
            value: start,
            props,
        }),
        validateTime({
            adapter,
            value: end,
            props,
        }),
    ];
    if (dateTimeValidations[0] || dateTimeValidations[1]) {
        return dateTimeValidations;
    }
    // for partial input
    if (start === null || end === null) {
        return [null, null];
    }
    if (!isRangeValid(adapter.utils, value)) {
        return ['invalidRange', 'invalidRange'];
    }
    return [null, null];
};

const useDefaultizedTimeRangeFieldProps = (props) => {
    var _a, _b, _c, _d;
    const utils = useUtils();
    const ampm = (_a = props.ampm) !== null && _a !== void 0 ? _a : utils.is12HourCycleInCurrentLocale();
    const defaultFormat = ampm ? utils.formats.fullTime12h : utils.formats.fullTime24h;
    return Object.assign(Object.assign({}, props), { disablePast: (_b = props.disablePast) !== null && _b !== void 0 ? _b : false, disableFuture: (_c = props.disableFuture) !== null && _c !== void 0 ? _c : false, format: (_d = props.format) !== null && _d !== void 0 ? _d : defaultFormat, minTime: props.minTime, maxTime: props.maxTime });
};
const useMultiInputTimeRangeField = ({ sharedProps: inSharedProps, startInputProps: inStartInputProps, endInputProps: inEndInputProps, startInputRef, endInputRef, }) => {
    var _a;
    const sharedProps = useDefaultizedTimeRangeFieldProps(inSharedProps);
    const adapter = useLocalizationContext();
    const { value: valueProp, defaultValue, format, onChange, disabled, readOnly } = sharedProps;
    const firstDefaultValue = React__namespace.useRef(defaultValue);
    // TODO: Maybe export utility from `useField` instead of copy/pasting the logic
    const buildChangeHandler = (index) => {
        if (!onChange) {
            return () => { };
        }
        return (newDate, rawContext) => {
            var _a;
            const currentDateRange = (_a = valueProp !== null && valueProp !== void 0 ? valueProp : firstDefaultValue.current) !== null && _a !== void 0 ? _a : rangeValueManager.emptyValue;
            const newDateRange = index === 0 ? [newDate, currentDateRange[1]] : [currentDateRange[0], newDate];
            const context = Object.assign(Object.assign({}, rawContext), { validationError: validateTimeRange({
                    adapter,
                    value: newDateRange,
                    props: Object.assign(Object.assign({}, sharedProps), { value: newDateRange }),
                }) });
            onChange(newDateRange, context);
        };
    };
    const handleStartDateChange = _default$2(buildChangeHandler(0));
    const handleEndDateChange = _default$2(buildChangeHandler(1));
    const startInputProps = Object.assign(Object.assign({}, inStartInputProps), { format,
        disabled,
        readOnly, value: valueProp === undefined ? undefined : valueProp[0], defaultValue: defaultValue === undefined ? undefined : defaultValue[0], onChange: handleStartDateChange });
    const endInputProps = Object.assign(Object.assign({}, inEndInputProps), { format,
        disabled,
        readOnly, value: valueProp === undefined ? undefined : valueProp[1], defaultValue: defaultValue === undefined ? undefined : defaultValue[1], onChange: handleEndDateChange });
    const rawStartDateResponse = useTimeField({
        props: startInputProps,
        inputRef: startInputRef,
    });
    const rawEndDateResponse = useTimeField({
        props: endInputProps,
        inputRef: endInputRef,
    });
    const value = (_a = valueProp !== null && valueProp !== void 0 ? valueProp : firstDefaultValue.current) !== null && _a !== void 0 ? _a : rangeValueManager.emptyValue;
    const validationError = useValidation(Object.assign(Object.assign({}, sharedProps), { value }), validateTimeRange, rangeValueManager.isSameError, rangeValueManager.defaultErrorState);
    const startDateResponse = Object.assign(Object.assign({}, rawStartDateResponse), { error: !!validationError[0] });
    const endDateResponse = Object.assign(Object.assign({}, rawEndDateResponse), { error: !!validationError[1] });
    return { startDate: startDateResponse, endDate: endDateResponse };
};

const MultiInputTimeRangeFieldRoot = styled$1(React__namespace.forwardRef((props, ref) => (React__namespace.createElement(Stack$1, Object.assign({ ref: ref, spacing: 2, direction: "row", alignItems: "baseline" }, props)))), {
    name: 'MuiMultiInputTimeRangeField',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({});
const MultiInputTimeRangeFieldSeparator = styled$1((props) => { var _a; return React__namespace.createElement(Typography$1, Object.assign({}, props), (_a = props.children) !== null && _a !== void 0 ? _a : '  '); }, {
    name: 'MuiMultiInputTimeRangeField',
    slot: 'Separator',
    overridesResolver: (props, styles) => styles.separator,
})({});
const MultiInputTimeRangeField = React__namespace.forwardRef(function MultiInputTimeRangeField(inProps, ref) {
    var _a, _b, _c;
    const themeProps = useThemeProps({
        props: inProps,
        name: 'MuiMultiInputTimeRangeField',
    });
    const { components, componentsProps, value, defaultValue, format, onChange, readOnly, disabled, onError, minTime, maxTime, minutesStep, shouldDisableTime, disableFuture, disablePast, selectedSections, onSelectedSectionsChange } = themeProps, other = __rest(themeProps, ["components", "componentsProps", "value", "defaultValue", "format", "onChange", "readOnly", "disabled", "onError", "minTime", "maxTime", "minutesStep", "shouldDisableTime", "disableFuture", "disablePast", "selectedSections", "onSelectedSectionsChange"]);
    const ownerState = themeProps;
    const Root = (_a = components === null || components === void 0 ? void 0 : components.Root) !== null && _a !== void 0 ? _a : MultiInputTimeRangeFieldRoot;
    const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
            ref,
        },
        ownerState,
    });
    const Input = (_b = components === null || components === void 0 ? void 0 : components.Input) !== null && _b !== void 0 ? _b : TextField$1;
    const startInputProps = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        ownerState: Object.assign(Object.assign({}, ownerState), { position: 'start' }),
    });
    const endInputProps = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        ownerState: Object.assign(Object.assign({}, ownerState), { position: 'end' }),
    });
    const Separator = (_c = components === null || components === void 0 ? void 0 : components.Separator) !== null && _c !== void 0 ? _c : MultiInputTimeRangeFieldSeparator;
    const separatorProps = useSlotProps({
        elementType: Separator,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.separator,
        ownerState,
    });
    const _d = useMultiInputTimeRangeField({
        sharedProps: {
            value,
            defaultValue,
            format,
            onChange,
            readOnly,
            disabled,
            onError,
            minTime,
            maxTime,
            minutesStep,
            shouldDisableTime,
            disableFuture,
            disablePast,
            selectedSections,
            onSelectedSectionsChange,
        },
        startInputProps,
        endInputProps,
        startInputRef: startInputProps.inputRef,
        endInputRef: endInputProps.inputRef,
    }), _e = _d.startDate, { onKeyDown: onStartInputKeyDown, ref: startInputRef, readOnly: startReadOnly, inputMode: startInputMode } = _e, startDateProps = __rest(_e, ["onKeyDown", "ref", "readOnly", "inputMode"]), _f = _d.endDate, { onKeyDown: onEndInputKeyDown, ref: endInputRef, readOnly: endReadOnly, inputMode: endInputMode } = _f, endDateProps = __rest(_f, ["onKeyDown", "ref", "readOnly", "inputMode"]);
    return (React__namespace.createElement(Root, Object.assign({}, rootProps),
        React__namespace.createElement(Input, Object.assign({}, startDateProps, { inputProps: Object.assign(Object.assign({}, startDateProps.inputProps), { ref: startInputRef, readOnly: startReadOnly, inputMode: startInputMode, onKeyDown: onStartInputKeyDown }) })),
        React__namespace.createElement(Separator, Object.assign({}, separatorProps)),
        React__namespace.createElement(Input, Object.assign({}, endDateProps, { inputProps: Object.assign(Object.assign({}, endDateProps.inputProps), { ref: endInputRef, readOnly: endReadOnly, inputMode: endInputMode, onKeyDown: onEndInputKeyDown }) }))));
});
MultiInputTimeRangeField.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value. Use when the component is not controlled.
     */
    defaultValue: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * Defines the `flex-direction` style property.
     * It is applied for all screen sizes.
     * @default 'column'
     */
    direction: propTypesExports.oneOfType([
        propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row']),
        propTypesExports.arrayOf(propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row'])),
        propTypesExports.object,
    ]),
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Add an element between each child.
     */
    divider: propTypesExports.node,
    /**
     * Format of the date when rendered in the input(s).
     */
    format: propTypesExports.string,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * @template TValue, TError
     * @param {TError} error The new error.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Defines the space between immediate children.
     * @default 0
     */
    spacing: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string])),
        propTypesExports.number,
        propTypesExports.object,
        propTypesExports.string,
    ]),
    style: propTypesExports.object,
    /**
     * The system prop, which allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.arrayOf(propTypesExports.any),
};

const validateDateTimeRange = ({ props, value, adapter }) => {
    const [start, end] = value;
    const { shouldDisableDate } = props, otherProps = __rest(props, ["shouldDisableDate"]);
    const dateTimeValidations = [
        validateDateTime({
            adapter,
            value: start,
            props: Object.assign(Object.assign({}, otherProps), { shouldDisableDate: (day) => !!(shouldDisableDate === null || shouldDisableDate === void 0 ? void 0 : shouldDisableDate(day, 'start')) }),
        }),
        validateDateTime({
            adapter,
            value: end,
            props: Object.assign(Object.assign({}, otherProps), { shouldDisableDate: (day) => !!(shouldDisableDate === null || shouldDisableDate === void 0 ? void 0 : shouldDisableDate(day, 'end')) }),
        }),
    ];
    if (dateTimeValidations[0] || dateTimeValidations[1]) {
        return dateTimeValidations;
    }
    // for partial input
    if (start === null || end === null) {
        return [null, null];
    }
    if (!isRangeValid(adapter.utils, value)) {
        return ['invalidRange', 'invalidRange'];
    }
    return [null, null];
};

const useDefaultizedDateTimeRangeFieldProps = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const ampm = (_a = props.ampm) !== null && _a !== void 0 ? _a : utils.is12HourCycleInCurrentLocale();
    const defaultFormat = ampm
        ? utils.formats.keyboardDateTime12h
        : utils.formats.keyboardDateTime24h;
    return Object.assign(Object.assign({}, props), { disablePast: (_b = props.disablePast) !== null && _b !== void 0 ? _b : false, disableFuture: (_c = props.disableFuture) !== null && _c !== void 0 ? _c : false, format: (_d = props.format) !== null && _d !== void 0 ? _d : defaultFormat, minDate: applyDefaultDate(utils, (_e = props.minDateTime) !== null && _e !== void 0 ? _e : props.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, (_f = props.maxDateTime) !== null && _f !== void 0 ? _f : props.maxDate, defaultDates.maxDate), minTime: (_g = props.minDateTime) !== null && _g !== void 0 ? _g : props.minTime, maxTime: (_h = props.maxDateTime) !== null && _h !== void 0 ? _h : props.maxTime, disableIgnoringDatePartForTimeValidation: Boolean(props.minDateTime || props.maxDateTime) });
};
const useMultiInputDateTimeRangeField = ({ sharedProps: inSharedProps, startInputProps: inStartInputProps, endInputProps: inEndInputProps, startInputRef, endInputRef, }) => {
    var _a;
    const sharedProps = useDefaultizedDateTimeRangeFieldProps(inSharedProps);
    const adapter = useLocalizationContext();
    const { value: valueProp, defaultValue, format, onChange, disabled, readOnly } = sharedProps;
    const firstDefaultValue = React__namespace.useRef(defaultValue);
    // TODO: Maybe export utility from `useField` instead of copy/pasting the logic
    const buildChangeHandler = (index) => {
        if (!onChange) {
            return () => { };
        }
        return (newDate, rawContext) => {
            var _a;
            const currentDateRange = (_a = valueProp !== null && valueProp !== void 0 ? valueProp : firstDefaultValue.current) !== null && _a !== void 0 ? _a : rangeValueManager.emptyValue;
            const newDateRange = index === 0 ? [newDate, currentDateRange[1]] : [currentDateRange[0], newDate];
            const context = Object.assign(Object.assign({}, rawContext), { validationError: validateDateTimeRange({
                    adapter,
                    value: newDateRange,
                    props: Object.assign(Object.assign({}, sharedProps), { value: newDateRange }),
                }) });
            onChange(newDateRange, context);
        };
    };
    const handleStartDateChange = _default$2(buildChangeHandler(0));
    const handleEndDateChange = _default$2(buildChangeHandler(1));
    const startInputProps = Object.assign(Object.assign({}, inStartInputProps), { format,
        disabled,
        readOnly, value: valueProp === undefined ? undefined : valueProp[0], defaultValue: defaultValue === undefined ? undefined : defaultValue[0], onChange: handleStartDateChange });
    const endInputProps = Object.assign(Object.assign({}, inEndInputProps), { format,
        disabled,
        readOnly, value: valueProp === undefined ? undefined : valueProp[1], defaultValue: defaultValue === undefined ? undefined : defaultValue[1], onChange: handleEndDateChange });
    const rawStartDateResponse = useDateTimeField({
        props: startInputProps,
        inputRef: startInputRef,
    });
    const rawEndDateResponse = useDateTimeField({
        props: endInputProps,
        inputRef: endInputRef,
    });
    const value = (_a = valueProp !== null && valueProp !== void 0 ? valueProp : firstDefaultValue.current) !== null && _a !== void 0 ? _a : rangeValueManager.emptyValue;
    const validationError = useValidation(Object.assign(Object.assign({}, sharedProps), { value }), validateDateTimeRange, rangeValueManager.isSameError, rangeValueManager.defaultErrorState);
    const startDateResponse = Object.assign(Object.assign({}, rawStartDateResponse), { error: !!validationError[0] });
    const endDateResponse = Object.assign(Object.assign({}, rawEndDateResponse), { error: !!validationError[1] });
    return { startDate: startDateResponse, endDate: endDateResponse };
};

const MultiInputDateTimeRangeFieldRoot = styled$1(React__namespace.forwardRef((props, ref) => (React__namespace.createElement(Stack$1, Object.assign({ ref: ref, spacing: 2, direction: "row", alignItems: "baseline" }, props)))), {
    name: 'MuiMultiInputDateTimeRangeField',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root,
})({});
const MultiInputDateTimeRangeFieldSeparator = styled$1((props) => { var _a; return React__namespace.createElement(Typography$1, Object.assign({}, props), (_a = props.children) !== null && _a !== void 0 ? _a : '  '); }, {
    name: 'MuiMultiInputDateTimeRangeField',
    slot: 'Separator',
    overridesResolver: (props, styles) => styles.separator,
})({});
const MultiInputDateTimeRangeField = React__namespace.forwardRef(function MultiInputDateTimeRangeField(inProps, ref) {
    var _a, _b, _c;
    const themeProps = useThemeProps({
        props: inProps,
        name: 'MuiMultiInputDateTimeRangeField',
    });
    const { components, componentsProps, value, defaultValue, format, onChange, readOnly, disabled, onError, shouldDisableDate, minDate, maxDate, minTime, maxTime, minDateTime, maxDateTime, minutesStep, shouldDisableTime, disableFuture, disablePast, selectedSections, onSelectedSectionsChange } = themeProps, other = __rest(themeProps, ["components", "componentsProps", "value", "defaultValue", "format", "onChange", "readOnly", "disabled", "onError", "shouldDisableDate", "minDate", "maxDate", "minTime", "maxTime", "minDateTime", "maxDateTime", "minutesStep", "shouldDisableTime", "disableFuture", "disablePast", "selectedSections", "onSelectedSectionsChange"]);
    const ownerState = themeProps;
    const Root = (_a = components === null || components === void 0 ? void 0 : components.Root) !== null && _a !== void 0 ? _a : MultiInputDateTimeRangeFieldRoot;
    const rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
            ref,
        },
        ownerState,
    });
    const Input = (_b = components === null || components === void 0 ? void 0 : components.Input) !== null && _b !== void 0 ? _b : TextField$1;
    const startInputProps = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        ownerState: Object.assign(Object.assign({}, ownerState), { position: 'start' }),
    });
    const endInputProps = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        ownerState: Object.assign(Object.assign({}, ownerState), { position: 'end' }),
    });
    const Separator = (_c = components === null || components === void 0 ? void 0 : components.Separator) !== null && _c !== void 0 ? _c : MultiInputDateTimeRangeFieldSeparator;
    const separatorProps = useSlotProps({
        elementType: Separator,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.separator,
        ownerState,
    });
    const _d = useMultiInputDateTimeRangeField({
        sharedProps: {
            value,
            defaultValue,
            format,
            onChange,
            readOnly,
            disabled,
            onError,
            shouldDisableDate,
            minDate,
            maxDate,
            minTime,
            maxTime,
            minDateTime,
            maxDateTime,
            minutesStep,
            shouldDisableTime,
            disableFuture,
            disablePast,
            selectedSections,
            onSelectedSectionsChange,
        },
        startInputProps,
        endInputProps,
        startInputRef: startInputProps.inputRef,
        endInputRef: endInputProps.inputRef,
    }), _e = _d.startDate, { onKeyDown: onStartInputKeyDown, ref: startInputRef, readOnly: startReadOnly, inputMode: startInputMode } = _e, startDateProps = __rest(_e, ["onKeyDown", "ref", "readOnly", "inputMode"]), _f = _d.endDate, { onKeyDown: onEndInputKeyDown, ref: endInputRef, readOnly: endReadOnly, inputMode: endInputMode } = _f, endDateProps = __rest(_f, ["onKeyDown", "ref", "readOnly", "inputMode"]);
    return (React__namespace.createElement(Root, Object.assign({}, rootProps),
        React__namespace.createElement(Input, Object.assign({}, startDateProps, { inputProps: Object.assign(Object.assign({}, startDateProps.inputProps), { ref: startInputRef, readOnly: startReadOnly, inputMode: startInputMode, onKeyDown: onStartInputKeyDown }) })),
        React__namespace.createElement(Separator, Object.assign({}, separatorProps)),
        React__namespace.createElement(Input, Object.assign({}, endDateProps, { inputProps: Object.assign(Object.assign({}, endDateProps.inputProps), { ref: endInputRef, readOnly: endReadOnly, inputMode: endInputMode, onKeyDown: onEndInputKeyDown }) }))));
});
MultiInputDateTimeRangeField.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * 12h/24h view for hour selection clock.
     * @default `utils.is12HourCycleInCurrentLocale()`
     */
    ampm: propTypesExports.bool,
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value. Use when the component is not controlled.
     */
    defaultValue: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * Defines the `flex-direction` style property.
     * It is applied for all screen sizes.
     * @default 'column'
     */
    direction: propTypesExports.oneOfType([
        propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row']),
        propTypesExports.arrayOf(propTypesExports.oneOf(['column-reverse', 'column', 'row-reverse', 'row'])),
        propTypesExports.object,
    ]),
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * Do not ignore date part when validating min/max time.
     * @default false
     */
    disableIgnoringDatePartForTimeValidation: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Add an element between each child.
     */
    divider: propTypesExports.node,
    /**
     * Format of the date when rendered in the input(s).
     */
    format: propTypesExports.string,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
     */
    maxDateTime: propTypesExports.any,
    /**
     * Maximal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    maxTime: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
     */
    minDateTime: propTypesExports.any,
    /**
     * Minimal selectable time.
     * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
     */
    minTime: propTypesExports.any,
    /**
     * Step over minutes.
     * @default 1
     */
    minutesStep: propTypesExports.number,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * @template TValue, TError
     * @param {TError} error The new error.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * Disable specific time.
     * @param {number} timeValue The value to check.
     * @param {TimeView} view The clock type of the timeValue.
     * @returns {boolean} If `true` the time will be disabled.
     */
    shouldDisableTime: propTypesExports.func,
    /**
     * Defines the space between immediate children.
     * @default 0
     */
    spacing: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.number, propTypesExports.string])),
        propTypesExports.number,
        propTypesExports.object,
        propTypesExports.string,
    ]),
    style: propTypesExports.object,
    /**
     * The system prop, which allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.arrayOf(propTypesExports.any),
};

const SingleInputDateRangeField = React__namespace.forwardRef(function SingleInputDateRangeField(inProps, ref) {
    var _a;
    const themeProps = useThemeProps({
        props: inProps,
        name: 'MuiSingleInputDateRangeField',
    });
    const { components, componentsProps } = themeProps, other = __rest(themeProps, ["components", "componentsProps"]);
    const ownerState = themeProps;
    const Input = (_a = components === null || components === void 0 ? void 0 : components.Input) !== null && _a !== void 0 ? _a : TextField$1;
    const inputProps = useSlotProps({
        elementType: Input,
        externalSlotProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.input,
        externalForwardedProps: other,
        ownerState,
    });
    const _b = useSingleInputDateRangeField({
        props: inputProps,
        inputRef: inputProps.inputRef,
    }), { ref: inputRef, onPaste, inputMode, readOnly } = _b, fieldProps = __rest(_b, ["ref", "onPaste", "inputMode", "readOnly"]);
    return (React__namespace.createElement(Input, Object.assign({ ref: ref }, fieldProps, { inputProps: Object.assign(Object.assign({}, fieldProps.inputProps), { ref: inputRef, onPaste, inputMode, readOnly }) })));
});
SingleInputDateRangeField.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the `input` element is focused during the first mount.
     * @default false
     */
    autoFocus: propTypesExports.bool,
    className: propTypesExports.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
     * @default 'primary'
     */
    color: propTypesExports.oneOf(['error', 'info', 'primary', 'secondary', 'success', 'warning']),
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * The default value. Use when the component is not controlled.
     */
    defaultValue: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the component is displayed in focused state.
     */
    focused: propTypesExports.bool,
    /**
     * Format of the date when rendered in the input(s).
     */
    format: propTypesExports.string,
    /**
     * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
     */
    FormHelperTextProps: propTypesExports.object,
    /**
     * If `true`, the input will take up the full width of its container.
     * @default false
     */
    fullWidth: propTypesExports.bool,
    /**
     * The helper text content.
     */
    helperText: propTypesExports.node,
    /**
     * If `true`, the label is hidden.
     * This is used to increase density for a `FilledInput`.
     * Be sure to add `aria-label` to the `input` element.
     * @default false
     */
    hiddenLabel: propTypesExports.bool,
    /**
     * The id of the `input` element.
     * Use this prop to make `label` and `helperText` accessible for screen readers.
     */
    id: propTypesExports.string,
    /**
     * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
     * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
     */
    InputLabelProps: propTypesExports.object,
    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: propTypesExports.object,
    /**
     * Props applied to the Input element.
     * It will be a [`FilledInput`](/material-ui/api/filled-input/),
     * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
     * component depending on the `variant` prop value.
     */
    InputProps: propTypesExports.object,
    /**
     * Pass a ref to the `input` element.
     */
    inputRef: propTypesExports.oneOfType([
        propTypesExports.func,
        propTypesExports.shape({
            current: propTypesExports.any.isRequired,
        }),
    ]),
    /**
     * The label content.
     */
    label: propTypesExports.node,
    /**
     * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
     * @default 'none'
     */
    margin: propTypesExports.oneOf(['dense', 'none', 'normal']),
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Name attribute of the `input` element.
     */
    name: propTypesExports.string,
    onBlur: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * @template TValue, TError
     * @param {TError} error The new error.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    onFocus: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     * @default false
     */
    readOnly: propTypesExports.bool,
    /**
     * If `true`, the label is displayed as required and the `input` element is required.
     * @default false
     */
    required: propTypesExports.bool,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * The size of the component.
     */
    size: propTypesExports.oneOf(['medium', 'small']),
    style: propTypesExports.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * The variant to use.
     * @default 'outlined'
     */
    variant: propTypesExports.oneOf(['filled', 'outlined', 'standard']),
};

function useNextDateRangePickerDefaultizedProps(props, name) {
    var _a, _b;
    const utils = useUtils();
    const defaultDates = useDefaultDates();
    const themeProps = useThemeProps({
        props,
        name,
    });
    const localeText = React__namespace.useMemo(() => {
        var _a;
        if (((_a = themeProps.localeText) === null || _a === void 0 ? void 0 : _a.toolbarTitle) == null) {
            return themeProps.localeText;
        }
        return Object.assign(Object.assign({}, themeProps.localeText), { dateRangePickerToolbarTitle: themeProps.localeText.toolbarTitle });
    }, [themeProps.localeText]);
    return Object.assign(Object.assign(Object.assign(Object.assign({}, themeProps), { localeText }), applyDefaultViewProps({
        views: themeProps.views,
        openTo: themeProps.openTo,
        defaultViews: ['year', 'day'],
        defaultOpenTo: 'day',
    })), { disableFuture: (_a = themeProps.disableFuture) !== null && _a !== void 0 ? _a : false, disablePast: (_b = themeProps.disablePast) !== null && _b !== void 0 ? _b : false, minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate), maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate), components: Object.assign({ Toolbar: DateRangePickerToolbar }, themeProps.components) });
}

const isDatePickerView = (view) => view === 'year' || view === 'month' || view === 'day';
/**
 * We don't pass all the props down to `DateRangeCalendar`,
 * because otherwise some unwanted props would be passed to the HTML element.
 */
const renderDateRangeViewCalendar = ({ views, view, focusedView, value, defaultValue, onChange, className, classes, disableFuture, disablePast, minDate, maxDate, shouldDisableDate, reduceAnimations, onMonthChange, defaultCalendarMonth, rangePosition, onRangePositionChange, calendars, components, componentsProps, loading, renderLoading, disableHighlightToday, readOnly, disabled, showDaysOutsideCurrentMonth, dayOfWeekFormatter, disableAutoMonthSwitching, sx, autoFocus, fixedWeekNumber, disableDragEditing, displayWeekNumber, }) => (React__namespace.createElement(DateRangeCalendar, { view: view, views: views.filter(isDatePickerView), focusedView: focusedView, value: value, defaultValue: defaultValue, onChange: onChange, className: className, classes: classes, disableFuture: disableFuture, disablePast: disablePast, minDate: minDate, maxDate: maxDate, shouldDisableDate: shouldDisableDate, reduceAnimations: reduceAnimations, onMonthChange: onMonthChange, defaultCalendarMonth: defaultCalendarMonth, rangePosition: rangePosition, onRangePositionChange: onRangePositionChange, calendars: calendars, components: components, componentsProps: componentsProps, loading: loading, renderLoading: renderLoading, disableHighlightToday: disableHighlightToday, readOnly: readOnly, disabled: disabled, showDaysOutsideCurrentMonth: showDaysOutsideCurrentMonth, dayOfWeekFormatter: dayOfWeekFormatter, disableAutoMonthSwitching: disableAutoMonthSwitching, sx: sx, autoFocus: autoFocus, fixedWeekNumber: fixedWeekNumber, disableDragEditing: disableDragEditing, displayWeekNumber: displayWeekNumber }));

const useRangePickerInputProps = ({ wrapperVariant, open, actions, readOnly, disabled, disableOpenPicker, onBlur, rangePosition, onRangePositionChange, localeText: inLocaleText, }) => {
    var _a, _b;
    const localeText = useLocaleText();
    const startRef = React__namespace.useRef(null);
    const endRef = React__namespace.useRef(null);
    React__namespace.useEffect(() => {
        var _a, _b;
        if (!open) {
            return;
        }
        if (rangePosition === 'start') {
            (_a = startRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
        else if (rangePosition === 'end') {
            (_b = endRef.current) === null || _b === void 0 ? void 0 : _b.focus();
        }
    }, [rangePosition, open]);
    const openRangeStartSelection = (event) => {
        event.stopPropagation();
        onRangePositionChange('start');
        if (!readOnly && !disableOpenPicker) {
            actions.onOpen();
        }
    };
    const openRangeEndSelection = (event) => {
        event.stopPropagation();
        onRangePositionChange('end');
        if (!readOnly && !disableOpenPicker) {
            actions.onOpen();
        }
    };
    const focusOnRangeStart = () => {
        if (open) {
            onRangePositionChange('start');
        }
    };
    const focusOnRangeEnd = () => {
        if (open) {
            onRangePositionChange('end');
        }
    };
    const readOnlyInput = readOnly !== null && readOnly !== void 0 ? readOnly : wrapperVariant === 'mobile';
    const startInputProps = Object.assign(Object.assign({ inputRef: startRef, label: (_a = inLocaleText === null || inLocaleText === void 0 ? void 0 : inLocaleText.start) !== null && _a !== void 0 ? _a : localeText.start, onKeyDown: onSpaceOrEnter(openRangeStartSelection), onFocus: focusOnRangeStart, focused: open ? rangePosition === 'start' : undefined }, (!readOnly && !disabled && { onClick: openRangeStartSelection })), { readOnly: readOnlyInput, disabled });
    const endInputProps = Object.assign(Object.assign({ inputRef: endRef, label: (_b = inLocaleText === null || inLocaleText === void 0 ? void 0 : inLocaleText.end) !== null && _b !== void 0 ? _b : localeText.end, onKeyDown: onSpaceOrEnter(openRangeEndSelection), onFocus: focusOnRangeEnd, focused: open ? rangePosition === 'end' : undefined }, (!readOnly && !disabled && { onClick: openRangeEndSelection })), { readOnly: readOnlyInput, disabled });
    const rootProps = {
        onBlur,
    };
    return { startInput: startInputProps, endInput: endInputProps, root: rootProps };
};

const useDesktopRangePicker = ({ props, valueManager, validator, }) => {
    var _a;
    const { components, componentsProps = {}, className, format, readOnly, disabled, autoFocus, disableOpenPicker, localeText, } = props;
    const fieldRef = React__namespace.useRef(null);
    const popperRef = React__namespace.useRef(null);
    const [rangePosition, setRangePosition] = React__namespace.useState('start');
    const { open, actions, layoutProps, renderCurrentView, shouldRestoreFocus, fieldProps: pickerFieldProps, } = usePicker({
        props,
        valueManager,
        wrapperVariant: 'desktop',
        validator,
        autoFocusView: true,
        additionalViewProps: {
            rangePosition,
            onRangePositionChange: setRangePosition,
        },
    });
    const handleBlur = () => {
        executeInTheNextEventLoopTick(() => {
            var _a, _b;
            if (((_a = fieldRef.current) === null || _a === void 0 ? void 0 : _a.contains(getActiveElement(document))) ||
                ((_b = popperRef.current) === null || _b === void 0 ? void 0 : _b.contains(getActiveElement(document)))) {
                return;
            }
            actions.onDismiss();
        });
    };
    const fieldSlotsProps = useRangePickerInputProps({
        wrapperVariant: 'desktop',
        open,
        actions,
        readOnly,
        disabled,
        disableOpenPicker,
        localeText,
        onBlur: handleBlur,
        rangePosition,
        onRangePositionChange: setRangePosition,
    });
    const Field = components.Field;
    const fieldProps = useSlotProps({
        elementType: Field,
        externalSlotProps: componentsProps.field,
        additionalProps: Object.assign(Object.assign({}, pickerFieldProps), { readOnly,
            disabled,
            className,
            format, autoFocus: autoFocus && !props.open, ref: fieldRef }),
        ownerState: props,
    });
    const componentsForField = Object.assign(Object.assign({}, fieldProps.components), { Input: components.Input, Root: components.FieldRoot, Separator: components.FieldSeparator });
    const componentsPropsForField = Object.assign(Object.assign({}, fieldProps.componentsProps), { input: (ownerState) => {
            var _a;
            const externalInputProps = resolveComponentProps(componentsProps.input, ownerState);
            const inputPropsPassedByField = resolveComponentProps((_a = fieldProps.componentsProps) === null || _a === void 0 ? void 0 : _a.input, ownerState);
            const inputPropsPassedByPicker = ownerState.position === 'start' ? fieldSlotsProps.startInput : fieldSlotsProps.endInput;
            return Object.assign(Object.assign(Object.assign(Object.assign({}, externalInputProps), inputPropsPassedByField), inputPropsPassedByPicker), { inputProps: Object.assign(Object.assign({}, externalInputProps === null || externalInputProps === void 0 ? void 0 : externalInputProps.inputProps), inputPropsPassedByField === null || inputPropsPassedByField === void 0 ? void 0 : inputPropsPassedByField.inputProps) });
        }, root: (ownerState) => {
            var _a;
            const externalRootProps = resolveComponentProps(componentsProps.fieldRoot, ownerState);
            const rootPropsPassedByField = resolveComponentProps((_a = fieldProps.componentsProps) === null || _a === void 0 ? void 0 : _a.root, ownerState);
            return Object.assign(Object.assign(Object.assign({}, externalRootProps), rootPropsPassedByField), fieldSlotsProps.root);
        }, separator: (ownerState) => {
            var _a;
            const externalSeparatorProps = resolveComponentProps(componentsProps.fieldSeparator, ownerState);
            const separatorPropsPassedByField = resolveComponentProps((_a = fieldProps.componentsProps) === null || _a === void 0 ? void 0 : _a.separator, ownerState);
            return Object.assign(Object.assign(Object.assign({}, externalSeparatorProps), separatorPropsPassedByField), fieldSlotsProps.root);
        } });
    const componentsPropsForLayout = Object.assign(Object.assign({}, componentsProps), { toolbar: Object.assign(Object.assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.toolbar), { rangePosition, onRangePositionChange: setRangePosition }) });
    const Layout = (_a = components === null || components === void 0 ? void 0 : components.Layout) !== null && _a !== void 0 ? _a : PickersLayout;
    const renderPicker = () => (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: "desktop" },
            React__namespace.createElement(Field, Object.assign({}, fieldProps, { components: componentsForField, componentsProps: componentsPropsForField })),
            React__namespace.createElement(PickersPopper, Object.assign({ role: "tooltip", containerRef: popperRef, anchorEl: fieldRef.current, onBlur: handleBlur }, actions, { open: open, components: Object.assign(Object.assign({}, components), { 
                    // Avoids to render 2 action bar, will be removed once `PickersPopper` stop displaying the action bar.
                    ActionBar: () => null }), componentsProps: Object.assign(Object.assign({}, componentsProps), { actionBar: undefined }), shouldRestoreFocus: shouldRestoreFocus }),
                React__namespace.createElement(Layout, Object.assign({}, layoutProps, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.layout, { components: components, componentsProps: componentsPropsForLayout }), renderCurrentView())))));
    return {
        renderPicker,
    };
};

const DesktopNextDateRangePicker = React__namespace.forwardRef(function DesktopNextDateRangePicker(inProps, ref) {
    var _a, _b;
    // Props with the default values common to all date time pickers
    const _c = useNextDateRangePickerDefaultizedProps(inProps, 'MuiDesktopNextDateRangePicker'), { className, sx } = _c, defaultizedProps = __rest(_c, ["className", "sx"]);
    const viewRenderers = Object.assign({ day: renderDateRangeViewCalendar, month: renderDateRangeViewCalendar, year: renderDateRangeViewCalendar }, defaultizedProps.viewRenderers);
    const props = Object.assign(Object.assign({}, defaultizedProps), { view: (defaultizedProps === null || defaultizedProps === void 0 ? void 0 : defaultizedProps.view) ? defaultizedProps.view : 'day', views: (defaultizedProps === null || defaultizedProps === void 0 ? void 0 : defaultizedProps.views) ? defaultizedProps.views : ['year', 'day'], viewRenderers, calendars: (_a = defaultizedProps.calendars) !== null && _a !== void 0 ? _a : 2, showToolbar: (_b = defaultizedProps.showToolbar) !== null && _b !== void 0 ? _b : false, components: Object.assign({ Field: MultiInputDateRangeField }, defaultizedProps.components), componentsProps: Object.assign(Object.assign({}, defaultizedProps.componentsProps), { field: (ownerState) => {
                var _a;
                return (Object.assign(Object.assign(Object.assign({}, resolveComponentProps((_a = defaultizedProps.componentsProps) === null || _a === void 0 ? void 0 : _a.field, ownerState)), extractValidationProps(defaultizedProps)), { className,
                    sx,
                    ref }));
            } }) });
    const { renderPicker } = useDesktopRangePicker({
        props,
        valueManager: rangeValueManager,
        validator: validateDateRange,
    });
    return renderPicker();
});
DesktopNextDateRangePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * The number of calendars to render on **desktop**.
     * @default 2
     */
    calendars: propTypesExports.oneOf([1, 2, 3]),
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={[null, null]}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
     * @default false
     */
    disableAutoMonthSwitching: propTypesExports.bool,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true`, editing dates by dragging is disabled.
     * @default false
     */
    disableDragEditing: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => "..."
     */
    renderLoading: propTypesExports.func,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
    }),
};

const useMobileRangePicker = ({ props, valueManager, validator, }) => {
    var _a;
    const { components, componentsProps = {}, className, format, readOnly, disabled, disableOpenPicker, localeText, } = props;
    const fieldRef = React__namespace.useRef(null);
    const [rangePosition, setRangePosition] = React__namespace.useState('start');
    const { open, actions, layoutProps, renderCurrentView, fieldProps: pickerFieldProps, } = usePicker({
        props,
        valueManager,
        wrapperVariant: 'mobile',
        validator,
        autoFocusView: true,
        additionalViewProps: {
            rangePosition,
            onRangePositionChange: setRangePosition,
        },
    });
    const fieldSlotsProps = useRangePickerInputProps({
        wrapperVariant: 'mobile',
        open,
        actions,
        readOnly,
        disabled,
        disableOpenPicker,
        localeText,
        rangePosition,
        onRangePositionChange: setRangePosition,
    });
    const Field = components.Field;
    const fieldProps = useSlotProps({
        elementType: Field,
        externalSlotProps: componentsProps.field,
        additionalProps: Object.assign(Object.assign({}, pickerFieldProps), { readOnly: readOnly !== null && readOnly !== void 0 ? readOnly : true, disabled,
            className,
            format, ref: fieldRef }),
        ownerState: props,
    });
    const componentsForField = Object.assign(Object.assign({}, fieldProps.components), { Input: components.Input });
    const componentsPropsForField = Object.assign(Object.assign({}, fieldProps.componentsProps), { input: (ownerState) => {
            var _a;
            const externalInputProps = resolveComponentProps(componentsProps.input, ownerState);
            const inputPropsPassedByField = resolveComponentProps((_a = fieldProps.componentsProps) === null || _a === void 0 ? void 0 : _a.input, ownerState);
            const inputPropsPassedByPicker = ownerState.position === 'start' ? fieldSlotsProps.startInput : fieldSlotsProps.endInput;
            return Object.assign(Object.assign(Object.assign(Object.assign({}, externalInputProps), inputPropsPassedByField), inputPropsPassedByPicker), { inputProps: Object.assign(Object.assign({}, externalInputProps === null || externalInputProps === void 0 ? void 0 : externalInputProps.inputProps), inputPropsPassedByField === null || inputPropsPassedByField === void 0 ? void 0 : inputPropsPassedByField.inputProps) });
        }, root: (ownerState) => {
            var _a;
            const externalRootProps = resolveComponentProps(componentsProps.fieldRoot, ownerState);
            const rootPropsPassedByField = resolveComponentProps((_a = fieldProps.componentsProps) === null || _a === void 0 ? void 0 : _a.root, ownerState);
            return Object.assign(Object.assign(Object.assign({}, externalRootProps), rootPropsPassedByField), fieldSlotsProps.root);
        }, separator: (ownerState) => {
            var _a;
            const externalSeparatorProps = resolveComponentProps(componentsProps.fieldSeparator, ownerState);
            const separatorPropsPassedByField = resolveComponentProps((_a = fieldProps.componentsProps) === null || _a === void 0 ? void 0 : _a.separator, ownerState);
            return Object.assign(Object.assign(Object.assign({}, externalSeparatorProps), separatorPropsPassedByField), fieldSlotsProps.root);
        } });
    const componentsPropsForLayout = Object.assign(Object.assign({}, componentsProps), { toolbar: Object.assign(Object.assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.toolbar), { rangePosition, onRangePositionChange: setRangePosition }) });
    const Layout = (_a = components === null || components === void 0 ? void 0 : components.Layout) !== null && _a !== void 0 ? _a : PickersLayout;
    const renderPicker = () => (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: "mobile" },
            React__namespace.createElement(Field, Object.assign({}, fieldProps, { components: componentsForField, componentsProps: componentsPropsForField })),
            React__namespace.createElement(PickersModalDialog, Object.assign({}, actions, { open: open, components: Object.assign(Object.assign({}, components), { 
                    // Avoids to render 2 action bar, will be removed once `PickersModalDialog` stop displaying the action bar.
                    ActionBar: () => null }), componentsProps: Object.assign(Object.assign({}, componentsProps), { actionBar: undefined }) }),
                React__namespace.createElement(Layout, Object.assign({}, layoutProps, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.layout, { components: components, componentsProps: componentsPropsForLayout }), renderCurrentView())))));
    return {
        renderPicker,
    };
};

const MobileNextDateRangePicker = React__namespace.forwardRef(function MobileNextDateRangePicker(inProps, ref) {
    var _a, _b;
    // Props with the default values common to all date time pickers
    const _c = useNextDateRangePickerDefaultizedProps(inProps, 'MuiMobileNextDateRangePicker'), { className, sx } = _c, defaultizedProps = __rest(_c, ["className", "sx"]);
    const viewRenderers = Object.assign({ day: renderDateRangeViewCalendar, month: renderDateRangeViewCalendar, year: renderDateRangeViewCalendar }, defaultizedProps.viewRenderers);
    const props = Object.assign(Object.assign({}, defaultizedProps), { view: (defaultizedProps === null || defaultizedProps === void 0 ? void 0 : defaultizedProps.view) ? defaultizedProps.view : 'day', views: (defaultizedProps === null || defaultizedProps === void 0 ? void 0 : defaultizedProps.views) ? defaultizedProps.views : ['year', 'day'], viewRenderers, calendars: (_a = defaultizedProps.calendars) !== null && _a !== void 0 ? _a : 1, showToolbar: (_b = defaultizedProps.showToolbar) !== null && _b !== void 0 ? _b : true, components: Object.assign({ Field: MultiInputDateRangeField }, defaultizedProps.components), componentsProps: Object.assign(Object.assign({}, defaultizedProps.componentsProps), { field: (ownerState) => {
                var _a;
                return (Object.assign(Object.assign(Object.assign({}, resolveComponentProps((_a = defaultizedProps.componentsProps) === null || _a === void 0 ? void 0 : _a.field, ownerState)), extractValidationProps(defaultizedProps)), { className,
                    sx,
                    ref }));
            } }) });
    const { renderPicker } = useMobileRangePicker({
        props,
        valueManager: rangeValueManager,
        validator: validateDateRange,
    });
    return renderPicker();
});
MobileNextDateRangePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * The number of calendars to render on **desktop**.
     * @default 2
     */
    calendars: propTypesExports.oneOf([1, 2, 3]),
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={[null, null]}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
     * @default false
     */
    disableAutoMonthSwitching: propTypesExports.bool,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true`, editing dates by dragging is disabled.
     * @default false
     */
    disableDragEditing: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => "..."
     */
    renderLoading: propTypesExports.func,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
    }),
};

const NextDateRangePicker = React__namespace.forwardRef(function NextDateRangePicker(inProps, ref) {
    const props = useThemeProps({ props: inProps, name: 'MuiNextDateRangePicker' });
    const { desktopModeMediaQuery = '@media (pointer: fine)' } = props, other = __rest(props, ["desktopModeMediaQuery"]);
    // defaults to `true` in environments where `window.matchMedia` would not be available (i.e. test/jsdom)
    const isDesktop = useMediaQuery(desktopModeMediaQuery, { defaultMatches: true });
    if (isDesktop) {
        return React__namespace.createElement(DesktopNextDateRangePicker, Object.assign({ ref: ref }, other));
    }
    return React__namespace.createElement(MobileNextDateRangePicker, Object.assign({ ref: ref }, other));
});
NextDateRangePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * The number of calendars to render on **desktop**.
     * @default 2
     */
    calendars: propTypesExports.oneOf([1, 2, 3]),
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * If `true` the popup or dialog will close after submitting full date.
     * @default `true` for Desktop, `false` for Mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
     */
    closeOnSelect: propTypesExports.bool,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={[null, null]}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * CSS media query when `Mobile` mode will be changed to `Desktop`.
     * @default '@media (pointer: fine)'
     * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
     */
    desktopModeMediaQuery: propTypesExports.string,
    /**
     * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
     * @default false
     */
    disableAutoMonthSwitching: propTypesExports.bool,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true`, editing dates by dragging is disabled.
     * @default false
     */
    disableDragEditing: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * Do not render open picker button (renders only the field).
     * @default false
     */
    disableOpenPicker: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * Format of the date when rendered in the input(s).
     * Defaults to localized format based on the used `views`.
     */
    format: propTypesExports.string,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     */
    onClose: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     */
    onOpen: propTypesExports.func,
    /**
     * Callback fired when the selected sections change.
     * @param {FieldSelectedSections} newValue The new selected sections.
     */
    onSelectedSectionsChange: propTypesExports.func,
    /**
     * Control the popup or dialog open state.
     * @default false
     */
    open: propTypesExports.bool,
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => "..."
     */
    renderLoading: propTypesExports.func,
    /**
     * The currently selected sections.
     * This prop accept four formats:
     * 1. If a number is provided, the section at this index will be selected.
     * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
     * 3. If a string of type `MuiDateSectionName` is provided, the first section with that name will be selected.
     * 4. If `null` is provided, no section will be selected
     * If not provided, the selected sections will be handled internally.
     */
    selectedSections: propTypesExports.oneOfType([
        propTypesExports.oneOf(['all', 'day', 'hours', 'meridiem', 'minutes', 'month', 'seconds', 'year']),
        propTypesExports.number,
        propTypesExports.shape({
            endIndex: propTypesExports.number.isRequired,
            startIndex: propTypesExports.number.isRequired,
        }),
    ]),
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
    }),
};

const PickerStaticLayout = styled$1(PickersLayout)(({ theme }) => ({
    overflow: 'hidden',
    minWidth: DIALOG_WIDTH,
    backgroundColor: (theme.vars || theme).palette.background.paper,
}));
/**
 * Hook managing all the range static pickers:
 * - StaticDateRangePicker
 */
const useStaticRangePicker = ({ props, valueManager, validator, ref, }) => {
    var _a;
    const { localeText, components, componentsProps, displayStaticWrapperAs, autoFocus } = props;
    const [rangePosition, setRangePosition] = React__namespace.useState('start');
    const { layoutProps, renderCurrentView } = usePicker({
        props,
        valueManager,
        validator,
        autoFocusView: autoFocus !== null && autoFocus !== void 0 ? autoFocus : false,
        additionalViewProps: {},
        wrapperVariant: displayStaticWrapperAs,
    });
    const Layout = (_a = components === null || components === void 0 ? void 0 : components.Layout) !== null && _a !== void 0 ? _a : PickerStaticLayout;
    const componentsPropsForLayout = Object.assign(Object.assign({}, componentsProps), { toolbar: Object.assign(Object.assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.toolbar), { rangePosition, onDateRangePositionRange: setRangePosition }) });
    const renderPicker = () => (React__namespace.createElement(LocalizationProvider, { localeText: localeText },
        React__namespace.createElement(WrapperVariantContext.Provider, { value: displayStaticWrapperAs },
            React__namespace.createElement(Layout, Object.assign({}, layoutProps, { components: components, componentsProps: componentsPropsForLayout, ref: ref }), renderCurrentView()))));
    return { renderPicker };
};

const StaticNextDateRangePicker = React__namespace.forwardRef(function StaticNextDateRangePicker(inProps, ref) {
    var _a, _b, _c;
    const defaultizedProps = useNextDateRangePickerDefaultizedProps(inProps, 'MuiStaticNextDateRangePicker');
    const displayStaticWrapperAs = (_a = defaultizedProps.displayStaticWrapperAs) !== null && _a !== void 0 ? _a : 'mobile';
    const viewRenderers = Object.assign({ day: renderDateRangeViewCalendar, month: renderDateRangeViewCalendar, year: renderDateRangeViewCalendar }, defaultizedProps.viewRenderers);
    // Props with the default values specific to the static variant
    const props = Object.assign(Object.assign({}, defaultizedProps), { view: (defaultizedProps === null || defaultizedProps === void 0 ? void 0 : defaultizedProps.view) ? defaultizedProps.view : 'day', views: (defaultizedProps === null || defaultizedProps === void 0 ? void 0 : defaultizedProps.views) ? defaultizedProps.views : ['year', 'day'], viewRenderers,
        displayStaticWrapperAs, calendars: (_b = defaultizedProps.calendars) !== null && _b !== void 0 ? _b : (displayStaticWrapperAs === 'mobile' ? 1 : 2), showToolbar: (_c = defaultizedProps.showToolbar) !== null && _c !== void 0 ? _c : displayStaticWrapperAs === 'mobile' });
    const { renderPicker } = useStaticRangePicker({
        props,
        valueManager: rangeValueManager,
        validator: validateDateRange,
        ref,
    });
    return renderPicker();
});
StaticNextDateRangePicker.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "yarn proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If `true`, the main element is focused during the first mount.
     * This main element is:
     * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
     * - the `input` element if there is a field rendered.
     */
    autoFocus: propTypesExports.bool,
    /**
     * The number of calendars to render.
     * @default 2
     */
    calendars: propTypesExports.oneOf([1, 2, 3]),
    /**
     * Class name applied to the root element.
     */
    className: propTypesExports.string,
    /**
     * Overrideable components.
     * @default {}
     */
    components: propTypesExports.object,
    /**
     * The props used for each component slot.
     * @default {}
     */
    componentsProps: propTypesExports.object,
    /**
     * Formats the day of week displayed in the calendar header.
     * @param {string} day The day of week provided by the adapter's method `getWeekdays`.
     * @returns {string} The name to display.
     * @default (day) => day.charAt(0).toUpperCase()
     */
    dayOfWeekFormatter: propTypesExports.func,
    /**
     * Default calendar month displayed when `value={[null, null]}`.
     */
    defaultCalendarMonth: propTypesExports.any,
    /**
     * The default value.
     * Used when the component is not controlled.
     */
    defaultValue: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
     * @default false
     */
    disableAutoMonthSwitching: propTypesExports.bool,
    /**
     * If `true`, the picker and text field are disabled.
     * @default false
     */
    disabled: propTypesExports.bool,
    /**
     * If `true`, editing dates by dragging is disabled.
     * @default false
     */
    disableDragEditing: propTypesExports.bool,
    /**
     * If `true` disable values before the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disableFuture: propTypesExports.bool,
    /**
     * If `true`, today's date is rendering without highlighting with circle.
     * @default false
     */
    disableHighlightToday: propTypesExports.bool,
    /**
     * If `true` disable values after the current date for date components, time for time components and both for date time components.
     * @default false
     */
    disablePast: propTypesExports.bool,
    /**
     * Force static wrapper inner components to be rendered in mobile or desktop mode.
     * @default "mobile"
     */
    displayStaticWrapperAs: propTypesExports.oneOf(['desktop', 'mobile']),
    /**
     * If `true`, the week number will be display in the calendar.
     */
    displayWeekNumber: propTypesExports.bool,
    /**
     * Calendar will show more weeks in order to match this value.
     * Put it to 6 for having fix number of week in Gregorian calendars
     * @default undefined
     */
    fixedWeekNumber: propTypesExports.number,
    /**
     * If `true` renders `LoadingComponent` in calendar instead of calendar view.
     * Can be used to preload information and show it in calendar.
     * @default false
     */
    loading: propTypesExports.bool,
    /**
     * Locale for components texts.
     * Allows overriding texts coming from `LocalizationProvider` and `theme`.
     */
    localeText: propTypesExports.object,
    /**
     * Maximal selectable date.
     */
    maxDate: propTypesExports.any,
    /**
     * Minimal selectable date.
     */
    minDate: propTypesExports.any,
    /**
     * Callback fired when the value is accepted.
     * @template TValue
     * @param {TValue} value The value that was just accepted.
     */
    onAccept: propTypesExports.func,
    /**
     * Callback fired when the value changes.
     * @template TValue, TError
     * @param {TValue} value The new value.
     * @param {FieldChangeHandlerContext<TError>} The context containing the validation result of the current value.
     */
    onChange: propTypesExports.func,
    /**
     * Callback fired when the error associated to the current value changes.
     * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
     *
     * @template TValue, TError
     * @param {TError} error The new error describing why the current value is not valid.
     * @param {TValue} value The value associated to the error.
     */
    onError: propTypesExports.func,
    /**
     * Callback firing on month change @DateIOType.
     * @template TDate
     * @param {TDate} month The new month.
     * @returns {void|Promise} -
     */
    onMonthChange: propTypesExports.func,
    readOnly: propTypesExports.bool,
    /**
     * Disable heavy animations.
     * @default typeof navigator !== 'undefined' && /(android)/i.test(navigator.userAgent)
     */
    reduceAnimations: propTypesExports.bool,
    /**
     * Component displaying when passed `loading` true.
     * @returns {React.ReactNode} The node to render when loading.
     * @default () => "..."
     */
    renderLoading: propTypesExports.func,
    /**
     * Disable specific date. @DateIOType
     * @template TDate
     * @param {TDate} day The date to test.
     * @param {string} position The date to test, 'start' or 'end'.
     * @returns {boolean} Returns `true` if the date should be disabled.
     */
    shouldDisableDate: propTypesExports.func,
    /**
     * If `true`, days that have `outsideCurrentMonth={true}` are displayed.
     * @default false
     */
    showDaysOutsideCurrentMonth: propTypesExports.bool,
    /**
     * If `true`, the toolbar will be visible.
     * @default `true` for mobile, `false` for desktop
     */
    showToolbar: propTypesExports.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: propTypesExports.oneOfType([
        propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.func, propTypesExports.object, propTypesExports.bool])),
        propTypesExports.func,
        propTypesExports.object,
    ]),
    /**
     * The selected value.
     * Used when the component is controlled.
     */
    value: propTypesExports.arrayOf(propTypesExports.any),
    /**
     * Define custom view renderers for each section.
     * If `null`, the section will only have field editing.
     * If `undefined`, internally defined view will be the used.
     */
    viewRenderers: propTypesExports.shape({
        day: propTypesExports.func,
    }),
};

exports.AdapterDateFns = AdapterDateFns;
exports.AdapterDateFnsJalali = AdapterDateFnsJalali;
exports.AdapterDayjs = AdapterDayjs;
exports.AdapterLuxon = AdapterLuxon;
exports.AdapterMoment = AdapterMoment;
exports.AdapterMomentHijri = AdapterMomentHijri;
exports.AdapterMomentJalaali = AdapterMomentJalaali;
exports.DEFAULT_LOCALE = DEFAULT_LOCALE;
exports.DateCalendar = DateCalendar;
exports.DatePicker = DatePicker;
exports.DateRangeCalendar = DateRangeCalendar;
exports.DateRangePicker = DateRangePicker;
exports.DateRangePickerDay = DateRangePickerDay;
exports.DateTimePicker = DateTimePicker;
exports.DateTimePickerTabs = DateTimePickerTabs;
exports.DayCalendarSkeleton = DayCalendarSkeleton;
exports.DesktopDatePicker = DesktopDatePicker;
exports.DesktopDateRangePicker = DesktopDateRangePicker;
exports.DesktopDateTimePicker = DesktopDateTimePicker;
exports.DesktopTimePicker = DesktopTimePicker;
exports.LocalizationProvider = LocalizationProvider;
exports.MobileDatePicker = MobileDatePicker;
exports.MobileDateRangePicker = MobileDateRangePicker;
exports.MobileDateTimePicker = MobileDateTimePicker;
exports.MobileTimePicker = MobileTimePicker;
exports.MonthCalendar = MonthCalendar;
exports.MuiPickersAdapterContext = MuiPickersAdapterContext;
exports.PickerStaticWrapper = PickerStaticWrapper;
exports.PickersActionBar = PickersActionBar;
exports.PickersDay = PickersDay;
exports.PickersLayout = PickersLayout;
exports.PickersLayoutContentWrapper = PickersLayoutContentWrapper;
exports.PickersLayoutRoot = PickersLayoutRoot;
exports.StaticDatePicker = StaticDatePicker;
exports.StaticDateRangePicker = StaticDateRangePicker;
exports.StaticDateTimePicker = StaticDateTimePicker;
exports.StaticTimePicker = StaticTimePicker;
exports.TimeClock = TimeClock;
exports.TimePicker = TimePicker;
exports.Unstable_DateField = DateField;
exports.Unstable_DateTimeField = DateTimeField;
exports.Unstable_DesktopNextDatePicker = DesktopNextDatePicker;
exports.Unstable_DesktopNextDateRangePicker = DesktopNextDateRangePicker;
exports.Unstable_DesktopNextDateTimePicker = DesktopNextDateTimePicker;
exports.Unstable_DesktopNextTimePicker = DesktopNextTimePicker;
exports.Unstable_MobileNextDatePicker = MobileNextDatePicker;
exports.Unstable_MobileNextDateRangePicker = MobileNextDateRangePicker;
exports.Unstable_MobileNextDateTimePicker = MobileNextDateTimePicker;
exports.Unstable_MobileNextTimePicker = MobileNextTimePicker;
exports.Unstable_MultiInputDateRangeField = MultiInputDateRangeField;
exports.Unstable_MultiInputDateTimeRangeField = MultiInputDateTimeRangeField;
exports.Unstable_MultiInputTimeRangeField = MultiInputTimeRangeField;
exports.Unstable_NextDatePicker = NextDatePicker;
exports.Unstable_NextDateRangePicker = NextDateRangePicker;
exports.Unstable_NextDateTimePicker = NextDateTimePicker;
exports.Unstable_NextTimePicker = NextTimePicker;
exports.Unstable_SingleInputDateRangeField = SingleInputDateRangeField;
exports.Unstable_StaticNextDatePicker = StaticNextDatePicker;
exports.Unstable_StaticNextDateRangePicker = StaticNextDateRangePicker;
exports.Unstable_StaticNextDateTimePicker = StaticNextDateTimePicker;
exports.Unstable_StaticNextTimePicker = StaticNextTimePicker;
exports.Unstable_TimeField = TimeField;
exports.YearCalendar = YearCalendar;
exports.clockClasses = clockClasses;
exports.clockNumberClasses = clockNumberClasses;
exports.clockPointerClasses = clockPointerClasses;
exports.dateCalendarClasses = dateCalendarClasses;
exports.datePickerToolbarClasses = datePickerToolbarClasses;
exports.dateRangeCalendarClasses = dateRangeCalendarClasses;
exports.dateRangePickerDayClasses = dateRangePickerDayClasses;
exports.dateRangePickerInputClasses = dateRangePickerInputClasses;
exports.dateRangePickerToolbarClasses = dateRangePickerToolbarClasses;
exports.dateRangePickerViewDesktopClasses = dateRangePickerViewDesktopClasses;
exports.dateTimePickerTabsClasses = dateTimePickerTabsClasses;
exports.dateTimePickerToolbarClasses = dateTimePickerToolbarClasses;
exports.dayCalendarSkeletonClasses = dayCalendarSkeletonClasses;
exports.dayPickerClasses = dayPickerClasses;
exports.deDE = deDE;
exports.enUS = enUS;
exports.esES = esES;
exports.faIR = faIR;
exports.fiFI = fiFI;
exports.frFR = frFR;
exports.getDateCalendarUtilityClass = getDateCalendarUtilityClass;
exports.getDateRangeCalendarUtilityClass = getDateRangeCalendarUtilityClass;
exports.getDateRangePickerDayUtilityClass = getDateRangePickerDayUtilityClass;
exports.getDateRangePickerInputUtilityClass = getDateRangePickerInputUtilityClass;
exports.getDateRangePickerToolbarUtilityClass = getDateRangePickerToolbarUtilityClass;
exports.getDateRangePickerViewDesktopUtilityClass = getDateRangePickerViewDesktopUtilityClass;
exports.getDayCalendarSkeletonUtilityClass = getDayCalendarSkeletonUtilityClass;
exports.getMonthCalendarUtilityClass = getMonthCalendarUtilityClass;
exports.getPickersDayUtilityClass = getPickersDayUtilityClass;
exports.getTimeClockUtilityClass = getTimeClockUtilityClass;
exports.getYearCalendarUtilityClass = getYearCalendarUtilityClass;
exports.isIS = isIS;
exports.itIT = itIT;
exports.jaJP = jaJP;
exports.koKR = koKR;
exports.monthCalendarClasses = monthCalendarClasses;
exports.nbNO = nbNO;
exports.nlNL = nlNL;
exports.pickersCalendarHeaderClasses = pickersCalendarHeaderClasses;
exports.pickersDayClasses = pickersDayClasses;
exports.pickersFadeTransitionGroupClasses = pickersFadeTransitionGroupClasses;
exports.pickersLayoutClasses = pickersLayoutClasses;
exports.pickersMonthClasses = pickersMonthClasses;
exports.pickersSlideTransitionClasses = pickersSlideTransitionClasses;
exports.pickersYearClasses = pickersYearClasses;
exports.plPL = plPL;
exports.ptBR = ptBR;
exports.renderDateRangeViewCalendar = renderDateRangeViewCalendar;
exports.renderDateViewCalendar = renderDateViewCalendar;
exports.renderTimeViewClock = renderTimeViewClock;
exports.svSE = svSE;
exports.timeClockClasses = timeClockClasses;
exports.timePickerToolbarClasses = timePickerToolbarClasses;
exports.trTR = trTR;
exports.ukUA = ukUA;
exports.unstable_useDateField = useDateField;
exports.unstable_useDateTimeField = useDateTimeField;
exports.unstable_useMultiInputDateRangeField = useMultiInputDateRangeField;
exports.unstable_useMultiInputDateTimeRangeField = useMultiInputDateTimeRangeField;
exports.unstable_useMultiInputTimeRangeField = useMultiInputTimeRangeField;
exports.unstable_useSingleInputDateRangeField = useSingleInputDateRangeField;
exports.unstable_useTimeField = useTimeField;
exports.urPK = urPK;
exports.usePickerLayout = usePickerLayout;
exports.yearCalendarClasses = yearCalendarClasses;
exports.zhCN = zhCN;
//# sourceMappingURL=index.js.map
